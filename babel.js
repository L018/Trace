(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Babel = {}));
}(this, (function (exports) { 'use strict';

	var babel = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get version () { return version$3; },
		get types () { return t$f; },
		get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
		get OptionManager () { return OptionManager; },
		get Plugin () { return Plugin; },
		get File () { return File; },
		get buildExternalHelpers () { return babelBuildExternalHelpers; },
		get resolvePlugin () { return resolvePlugin; },
		get resolvePreset () { return resolvePreset; },
		get getEnv () { return getEnv; },
		get tokTypes () { return tokTypes; },
		get traverse () { return traverse; },
		get template () { return template$2; },
		get createConfigItem () { return createConfigItem; },
		get createConfigItemSync () { return createConfigItemSync; },
		get createConfigItemAsync () { return createConfigItemAsync; },
		get loadPartialConfig () { return loadPartialConfig; },
		get loadPartialConfigSync () { return loadPartialConfigSync; },
		get loadPartialConfigAsync () { return loadPartialConfigAsync; },
		get loadOptions () { return loadOptions; },
		get loadOptionsSync () { return loadOptionsSync; },
		get loadOptionsAsync () { return loadOptionsAsync; },
		get transform () { return transform$2; },
		get transformSync () { return transformSync; },
		get transformAsync () { return transformAsync; },
		get transformFile () { return transformFile; },
		get transformFileSync () { return transformFileSync; },
		get transformFileAsync () { return transformFileAsync; },
		get transformFromAst () { return transformFromAst$1; },
		get transformFromAstSync () { return transformFromAstSync; },
		get transformFromAstAsync () { return transformFromAstAsync; },
		get parse () { return parse$2; },
		get parseSync () { return parseSync; },
		get parseAsync () { return parseAsync; }
	});

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRegister (path, loader) {
		DYNAMIC_REQUIRE_LOADERS[path] = loader;
	}

	const DYNAMIC_REQUIRE_LOADERS = Object.create(null);
	const DYNAMIC_REQUIRE_CACHE = Object.create(null);
	const DEFAULT_PARENT_MODULE = {
		id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
	};
	const CHECKED_EXTENSIONS = ['', '.js', '.json'];

	function normalize$2 (path) {
		path = path.replace(/\\/g, '/');
		const parts = path.split('/');
		const slashed = parts[0] === '';
		for (let i = 1; i < parts.length; i++) {
			if (parts[i] === '.' || parts[i] === '') {
				parts.splice(i--, 1);
			}
		}
		for (let i = 1; i < parts.length; i++) {
			if (parts[i] !== '..') continue;
			if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
				parts.splice(--i, 2);
				i--;
			}
		}
		path = parts.join('/');
		if (slashed && path[0] !== '/')
		  path = '/' + path;
		else if (path.length === 0)
		  path = '.';
		return path;
	}

	function join$1 () {
		if (arguments.length === 0)
		  return '.';
		let joined;
		for (let i = 0; i < arguments.length; ++i) {
		  let arg = arguments[i];
		  if (arg.length > 0) {
			if (joined === undefined)
			  joined = arg;
			else
			  joined += '/' + arg;
		  }
		}
		if (joined === undefined)
		  return '.';

		return joined;
	}

	function isPossibleNodeModulesPath (modulePath) {
		let c0 = modulePath[0];
		if (c0 === '/' || c0 === '\\') return false;
		let c1 = modulePath[1], c2 = modulePath[2];
		if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
			(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
		if (c1 === ':' && (c2 === '/' || c2 === '\\'))
			return false;
		return true;
	}

	function dirname$1 (path) {
	  if (path.length === 0)
	    return '.';

	  let i = path.length - 1;
	  while (i > 0) {
	    const c = path.charCodeAt(i);
	    if ((c === 47 || c === 92) && i !== path.length - 1)
	      break;
	    i--;
	  }

	  if (i > 0)
	    return path.substr(0, i);

	  if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
	    return path.charAt(0);

	  return '.';
	}

	function commonjsResolveImpl (path, originalModuleDir, testCache) {
		const shouldTryNodeModules = isPossibleNodeModulesPath(path);
		path = normalize$2(path);
		let relPath;
		if (path[0] === '/') {
			originalModuleDir = '/';
		}
		while (true) {
			if (!shouldTryNodeModules) {
				relPath = originalModuleDir ? normalize$2(originalModuleDir + '/' + path) : path;
			} else if (originalModuleDir) {
				relPath = normalize$2(originalModuleDir + '/node_modules/' + path);
			} else {
				relPath = normalize$2(join$1('node_modules', path));
			}

			if (relPath.endsWith('/..')) {
				break; // Travelled too far up, avoid infinite loop
			}

			for (let extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
				const resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
				if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
					return resolvedPath;
				}			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
					return resolvedPath;
				}		}
			if (!shouldTryNodeModules) break;
			const nextDir = normalize$2(originalModuleDir + '/..');
			if (nextDir === originalModuleDir) break;
			originalModuleDir = nextDir;
		}
		return null;
	}

	function commonjsResolve (path, originalModuleDir) {
		const resolvedPath = commonjsResolveImpl(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}

	function commonjsRequire (path, originalModuleDir) {
		const resolvedPath = commonjsResolveImpl(path, originalModuleDir);
		if (resolvedPath !== null) {
	    let cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
	    if (cachedModule) return cachedModule.exports;
	    const loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
	    if (loader) {
	      DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
	        id: resolvedPath,
	        filename: resolvedPath,
	        path: dirname$1(resolvedPath),
	        exports: {},
	        parent: DEFAULT_PARENT_MODULE,
	        loaded: false,
	        children: [],
	        paths: [],
	        require: function (path, base) {
	          return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
	        }
	      };
	      try {
	        loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
	      } catch (error) {
	        delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
	        throw error;
	      }
	      cachedModule.loaded = true;
	      return cachedModule.exports;
	    }	}
		return require(path);
	}

	commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
	commonjsRequire.resolve = commonjsResolve;

	var regenerate = createCommonjsModule(function (module, exports) {

	  (function (root) {
	    var freeExports = exports;
	    var freeModule = module && module.exports == freeExports && module;
	    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

	    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
	      root = freeGlobal;
	    }

	    var ERRORS = {
	      'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
	      'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
	    };
	    var HIGH_SURROGATE_MIN = 0xD800;
	    var HIGH_SURROGATE_MAX = 0xDBFF;
	    var LOW_SURROGATE_MIN = 0xDC00;
	    var LOW_SURROGATE_MAX = 0xDFFF;
	    var regexNull = /\\x00([^0123456789]|$)/g;
	    var object = {};
	    var hasOwnProperty = object.hasOwnProperty;

	    var extend = function extend(destination, source) {
	      var key;

	      for (key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          destination[key] = source[key];
	        }
	      }

	      return destination;
	    };

	    var forEach = function forEach(array, callback) {
	      var index = -1;
	      var length = array.length;

	      while (++index < length) {
	        callback(array[index], index);
	      }
	    };

	    var toString = object.toString;

	    var isArray = function isArray(value) {
	      return toString.call(value) == '[object Array]';
	    };

	    var isNumber = function isNumber(value) {
	      return typeof value == 'number' || toString.call(value) == '[object Number]';
	    };

	    var zeroes = '0000';

	    var pad = function pad(number, totalCharacters) {
	      var string = String(number);
	      return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
	    };

	    var hex = function hex(number) {
	      return Number(number).toString(16).toUpperCase();
	    };

	    var slice = [].slice;

	    var dataFromCodePoints = function dataFromCodePoints(codePoints) {
	      var index = -1;
	      var length = codePoints.length;
	      var max = length - 1;
	      var result = [];
	      var isStart = true;
	      var tmp;
	      var previous = 0;

	      while (++index < length) {
	        tmp = codePoints[index];

	        if (isStart) {
	          result.push(tmp);
	          previous = tmp;
	          isStart = false;
	        } else {
	          if (tmp == previous + 1) {
	            if (index != max) {
	              previous = tmp;
	              continue;
	            } else {
	              isStart = true;
	              result.push(tmp + 1);
	            }
	          } else {
	            result.push(previous + 1, tmp);
	            previous = tmp;
	          }
	        }
	      }

	      if (!isStart) {
	        result.push(tmp + 1);
	      }

	      return result;
	    };

	    var dataRemove = function dataRemove(data, codePoint) {
	      var index = 0;
	      var start;
	      var end;
	      var length = data.length;

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1];

	        if (codePoint >= start && codePoint < end) {
	          if (codePoint == start) {
	            if (end == start + 1) {
	              data.splice(index, 2);
	              return data;
	            } else {
	              data[index] = codePoint + 1;
	              return data;
	            }
	          } else if (codePoint == end - 1) {
	            data[index + 1] = codePoint;
	            return data;
	          } else {
	            data.splice(index, 2, start, codePoint, codePoint + 1, end);
	            return data;
	          }
	        }

	        index += 2;
	      }

	      return data;
	    };

	    var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
	      if (rangeEnd < rangeStart) {
	        throw Error(ERRORS.rangeOrder);
	      }

	      var index = 0;
	      var start;
	      var end;

	      while (index < data.length) {
	        start = data[index];
	        end = data[index + 1] - 1;

	        if (start > rangeEnd) {
	          return data;
	        }

	        if (rangeStart <= start && rangeEnd >= end) {
	          data.splice(index, 2);
	          continue;
	        }

	        if (rangeStart >= start && rangeEnd < end) {
	          if (rangeStart == start) {
	            data[index] = rangeEnd + 1;
	            data[index + 1] = end + 1;
	            return data;
	          }

	          data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
	          return data;
	        }

	        if (rangeStart >= start && rangeStart <= end) {
	          data[index + 1] = rangeStart;
	        } else if (rangeEnd >= start && rangeEnd <= end) {
	          data[index] = rangeEnd + 1;
	          return data;
	        }

	        index += 2;
	      }

	      return data;
	    };

	    var dataAdd = function dataAdd(data, codePoint) {
	      var index = 0;
	      var start;
	      var end;
	      var lastIndex = null;
	      var length = data.length;

	      if (codePoint < 0x0 || codePoint > 0x10FFFF) {
	        throw RangeError(ERRORS.codePointRange);
	      }

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1];

	        if (codePoint >= start && codePoint < end) {
	          return data;
	        }

	        if (codePoint == start - 1) {
	          data[index] = codePoint;
	          return data;
	        }

	        if (start > codePoint) {
	          data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
	          return data;
	        }

	        if (codePoint == end) {
	          if (codePoint + 1 == data[index + 2]) {
	            data.splice(index, 4, start, data[index + 3]);
	            return data;
	          }

	          data[index + 1] = codePoint + 1;
	          return data;
	        }

	        lastIndex = index;
	        index += 2;
	      }

	      data.push(codePoint, codePoint + 1);
	      return data;
	    };

	    var dataAddData = function dataAddData(dataA, dataB) {
	      var index = 0;
	      var start;
	      var end;
	      var data = dataA.slice();
	      var length = dataB.length;

	      while (index < length) {
	        start = dataB[index];
	        end = dataB[index + 1] - 1;

	        if (start == end) {
	          data = dataAdd(data, start);
	        } else {
	          data = dataAddRange(data, start, end);
	        }

	        index += 2;
	      }

	      return data;
	    };

	    var dataRemoveData = function dataRemoveData(dataA, dataB) {
	      var index = 0;
	      var start;
	      var end;
	      var data = dataA.slice();
	      var length = dataB.length;

	      while (index < length) {
	        start = dataB[index];
	        end = dataB[index + 1] - 1;

	        if (start == end) {
	          data = dataRemove(data, start);
	        } else {
	          data = dataRemoveRange(data, start, end);
	        }

	        index += 2;
	      }

	      return data;
	    };

	    var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
	      if (rangeEnd < rangeStart) {
	        throw Error(ERRORS.rangeOrder);
	      }

	      if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
	        throw RangeError(ERRORS.codePointRange);
	      }

	      var index = 0;
	      var start;
	      var end;
	      var added = false;
	      var length = data.length;

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1];

	        if (added) {
	          if (start == rangeEnd + 1) {
	            data.splice(index - 1, 2);
	            return data;
	          }

	          if (start > rangeEnd) {
	            return data;
	          }

	          if (start >= rangeStart && start <= rangeEnd) {
	            if (end > rangeStart && end - 1 <= rangeEnd) {
	              data.splice(index, 2);
	              index -= 2;
	            } else {
	              data.splice(index - 1, 2);
	              index -= 2;
	            }
	          }
	        } else if (start == rangeEnd + 1 || start == rangeEnd) {
	          data[index] = rangeStart;
	          return data;
	        } else if (start > rangeEnd) {
	          data.splice(index, 0, rangeStart, rangeEnd + 1);
	          return data;
	        } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
	          return data;
	        } else if (rangeStart >= start && rangeStart < end || end == rangeStart) {
	          data[index + 1] = rangeEnd + 1;
	          added = true;
	        } else if (rangeStart <= start && rangeEnd + 1 >= end) {
	          data[index] = rangeStart;
	          data[index + 1] = rangeEnd + 1;
	          added = true;
	        }

	        index += 2;
	      }

	      if (!added) {
	        data.push(rangeStart, rangeEnd + 1);
	      }

	      return data;
	    };

	    var dataContains = function dataContains(data, codePoint) {
	      var index = 0;
	      var length = data.length;
	      var start = data[index];
	      var end = data[length - 1];

	      if (length >= 2) {
	        if (codePoint < start || codePoint > end) {
	          return false;
	        }
	      }

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1];

	        if (codePoint >= start && codePoint < end) {
	          return true;
	        }

	        index += 2;
	      }

	      return false;
	    };

	    var dataIntersection = function dataIntersection(data, codePoints) {
	      var index = 0;
	      var length = codePoints.length;
	      var codePoint;
	      var result = [];

	      while (index < length) {
	        codePoint = codePoints[index];

	        if (dataContains(data, codePoint)) {
	          result.push(codePoint);
	        }

	        ++index;
	      }

	      return dataFromCodePoints(result);
	    };

	    var dataIsEmpty = function dataIsEmpty(data) {
	      return !data.length;
	    };

	    var dataIsSingleton = function dataIsSingleton(data) {
	      return data.length == 2 && data[0] + 1 == data[1];
	    };

	    var dataToArray = function dataToArray(data) {
	      var index = 0;
	      var start;
	      var end;
	      var result = [];
	      var length = data.length;

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1];

	        while (start < end) {
	          result.push(start);
	          ++start;
	        }

	        index += 2;
	      }

	      return result;
	    };

	    var floor = Math.floor;

	    var highSurrogate = function highSurrogate(codePoint) {
	      return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
	    };

	    var lowSurrogate = function lowSurrogate(codePoint) {
	      return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
	    };

	    var stringFromCharCode = String.fromCharCode;

	    var codePointToString = function codePointToString(codePoint) {
	      var string;

	      if (codePoint == 0x09) {
	        string = '\\t';
	      } else if (codePoint == 0x0A) {
	        string = '\\n';
	      } else if (codePoint == 0x0C) {
	        string = '\\f';
	      } else if (codePoint == 0x0D) {
	        string = '\\r';
	      } else if (codePoint == 0x2D) {
	        string = '\\x2D';
	      } else if (codePoint == 0x5C) {
	        string = '\\\\';
	      } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
	        string = '\\' + stringFromCharCode(codePoint);
	      } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
	        string = stringFromCharCode(codePoint);
	      } else if (codePoint <= 0xFF) {
	        string = '\\x' + pad(hex(codePoint), 2);
	      } else {
	        string = "\\u" + pad(hex(codePoint), 4);
	      }

	      return string;
	    };

	    var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
	      if (codePoint <= 0xFFFF) {
	        return codePointToString(codePoint);
	      }

	      return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
	    };

	    var symbolToCodePoint = function symbolToCodePoint(symbol) {
	      var length = symbol.length;
	      var first = symbol.charCodeAt(0);
	      var second;

	      if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
	        second = symbol.charCodeAt(1);
	        return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
	      }

	      return first;
	    };

	    var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
	      var result = '';
	      var index = 0;
	      var start;
	      var end;
	      var length = data.length;

	      if (dataIsSingleton(data)) {
	        return codePointToString(data[0]);
	      }

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1] - 1;

	        if (start == end) {
	          result += codePointToString(start);
	        } else if (start + 1 == end) {
	          result += codePointToString(start) + codePointToString(end);
	        } else {
	          result += codePointToString(start) + '-' + codePointToString(end);
	        }

	        index += 2;
	      }

	      return '[' + result + ']';
	    };

	    var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
	      var result = '';
	      var index = 0;
	      var start;
	      var end;
	      var length = data.length;

	      if (dataIsSingleton(data)) {
	        return codePointToStringUnicode(data[0]);
	      }

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1] - 1;

	        if (start == end) {
	          result += codePointToStringUnicode(start);
	        } else if (start + 1 == end) {
	          result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
	        } else {
	          result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
	        }

	        index += 2;
	      }

	      return '[' + result + ']';
	    };

	    var splitAtBMP = function splitAtBMP(data) {
	      var loneHighSurrogates = [];
	      var loneLowSurrogates = [];
	      var bmp = [];
	      var astral = [];
	      var index = 0;
	      var start;
	      var end;
	      var length = data.length;

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1] - 1;

	        if (start < HIGH_SURROGATE_MIN) {
	          if (end < HIGH_SURROGATE_MIN) {
	            bmp.push(start, end + 1);
	          }

	          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
	            bmp.push(start, HIGH_SURROGATE_MIN);
	            loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
	          }

	          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
	            bmp.push(start, HIGH_SURROGATE_MIN);
	            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
	            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
	          }

	          if (end > LOW_SURROGATE_MAX) {
	            bmp.push(start, HIGH_SURROGATE_MIN);
	            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
	            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

	            if (end <= 0xFFFF) {
	              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
	            } else {
	              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
	              astral.push(0xFFFF + 1, end + 1);
	            }
	          }
	        } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
	          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
	            loneHighSurrogates.push(start, end + 1);
	          }

	          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
	            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
	            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
	          }

	          if (end > LOW_SURROGATE_MAX) {
	            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
	            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

	            if (end <= 0xFFFF) {
	              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
	            } else {
	              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
	              astral.push(0xFFFF + 1, end + 1);
	            }
	          }
	        } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
	          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
	            loneLowSurrogates.push(start, end + 1);
	          }

	          if (end > LOW_SURROGATE_MAX) {
	            loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

	            if (end <= 0xFFFF) {
	              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
	            } else {
	              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
	              astral.push(0xFFFF + 1, end + 1);
	            }
	          }
	        } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
	          if (end <= 0xFFFF) {
	            bmp.push(start, end + 1);
	          } else {
	            bmp.push(start, 0xFFFF + 1);
	            astral.push(0xFFFF + 1, end + 1);
	          }
	        } else {
	          astral.push(start, end + 1);
	        }

	        index += 2;
	      }

	      return {
	        'loneHighSurrogates': loneHighSurrogates,
	        'loneLowSurrogates': loneLowSurrogates,
	        'bmp': bmp,
	        'astral': astral
	      };
	    };

	    var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
	      var result = [];
	      var tmpLow = [];
	      var addLow = false;
	      var mapping;
	      var nextMapping;
	      var highSurrogates;
	      var lowSurrogates;
	      var nextHighSurrogates;
	      var nextLowSurrogates;
	      var index = -1;
	      var length = surrogateMappings.length;

	      while (++index < length) {
	        mapping = surrogateMappings[index];
	        nextMapping = surrogateMappings[index + 1];

	        if (!nextMapping) {
	          result.push(mapping);
	          continue;
	        }

	        highSurrogates = mapping[0];
	        lowSurrogates = mapping[1];
	        nextHighSurrogates = nextMapping[0];
	        nextLowSurrogates = nextMapping[1];
	        tmpLow = lowSurrogates;

	        while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
	          if (dataIsSingleton(nextLowSurrogates)) {
	            tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
	          } else {
	            tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
	          }

	          ++index;
	          mapping = surrogateMappings[index];
	          highSurrogates = mapping[0];
	          lowSurrogates = mapping[1];
	          nextMapping = surrogateMappings[index + 1];
	          nextHighSurrogates = nextMapping && nextMapping[0];
	          nextLowSurrogates = nextMapping && nextMapping[1];
	          addLow = true;
	        }

	        result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
	        addLow = false;
	      }

	      return optimizeByLowSurrogates(result);
	    };

	    var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
	      if (surrogateMappings.length == 1) {
	        return surrogateMappings;
	      }

	      var index = -1;
	      var innerIndex = -1;

	      while (++index < surrogateMappings.length) {
	        var mapping = surrogateMappings[index];
	        var lowSurrogates = mapping[1];
	        var lowSurrogateStart = lowSurrogates[0];
	        var lowSurrogateEnd = lowSurrogates[1];
	        innerIndex = index;

	        while (++innerIndex < surrogateMappings.length) {
	          var otherMapping = surrogateMappings[innerIndex];
	          var otherLowSurrogates = otherMapping[1];
	          var otherLowSurrogateStart = otherLowSurrogates[0];
	          var otherLowSurrogateEnd = otherLowSurrogates[1];

	          if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd && otherLowSurrogates.length === 2) {
	            if (dataIsSingleton(otherMapping[0])) {
	              mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
	            } else {
	              mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
	            }

	            surrogateMappings.splice(innerIndex, 1);
	            --innerIndex;
	          }
	        }
	      }

	      return surrogateMappings;
	    };

	    var surrogateSet = function surrogateSet(data) {
	      if (!data.length) {
	        return [];
	      }

	      var index = 0;
	      var start;
	      var end;
	      var startHigh;
	      var startLow;
	      var endHigh;
	      var endLow;
	      var surrogateMappings = [];
	      var length = data.length;

	      while (index < length) {
	        start = data[index];
	        end = data[index + 1] - 1;
	        startHigh = highSurrogate(start);
	        startLow = lowSurrogate(start);
	        endHigh = highSurrogate(end);
	        endLow = lowSurrogate(end);
	        var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
	        var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
	        var complete = false;

	        if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
	          surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
	          complete = true;
	        } else {
	          surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
	        }

	        if (!complete && startHigh + 1 < endHigh) {
	          if (endsWithHighestLowSurrogate) {
	            surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
	            complete = true;
	          } else {
	            surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
	          }
	        }

	        if (!complete) {
	          surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
	        }

	        index += 2;
	      }

	      return optimizeSurrogateMappings(surrogateMappings);
	    };

	    var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
	      var result = [];
	      forEach(surrogateMappings, function (surrogateMapping) {
	        var highSurrogates = surrogateMapping[0];
	        var lowSurrogates = surrogateMapping[1];
	        result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
	      });
	      return result.join('|');
	    };

	    var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
	      if (hasUnicodeFlag) {
	        return createUnicodeCharacterClasses(data);
	      }

	      var result = [];
	      var parts = splitAtBMP(data);
	      var loneHighSurrogates = parts.loneHighSurrogates;
	      var loneLowSurrogates = parts.loneLowSurrogates;
	      var bmp = parts.bmp;
	      var astral = parts.astral;
	      var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
	      var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
	      var surrogateMappings = surrogateSet(astral);

	      if (bmpOnly) {
	        bmp = dataAddData(bmp, loneHighSurrogates);
	        hasLoneHighSurrogates = false;
	        bmp = dataAddData(bmp, loneLowSurrogates);
	        hasLoneLowSurrogates = false;
	      }

	      if (!dataIsEmpty(bmp)) {
	        result.push(createBMPCharacterClasses(bmp));
	      }

	      if (surrogateMappings.length) {
	        result.push(createSurrogateCharacterClasses(surrogateMappings));
	      }

	      if (hasLoneHighSurrogates) {
	        result.push(createBMPCharacterClasses(loneHighSurrogates) + "(?![\\uDC00-\\uDFFF])");
	      }

	      if (hasLoneLowSurrogates) {
	        result.push("(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
	      }

	      return result.join('|');
	    };

	    var regenerate = function regenerate(value) {
	      if (arguments.length > 1) {
	        value = slice.call(arguments);
	      }

	      if (this instanceof regenerate) {
	        this.data = [];
	        return value ? this.add(value) : this;
	      }

	      return new regenerate().add(value);
	    };

	    regenerate.version = '1.4.2';
	    var proto = regenerate.prototype;
	    extend(proto, {
	      'add': function add(value) {
	        var $this = this;

	        if (value == null) {
	          return $this;
	        }

	        if (value instanceof regenerate) {
	          $this.data = dataAddData($this.data, value.data);
	          return $this;
	        }

	        if (arguments.length > 1) {
	          value = slice.call(arguments);
	        }

	        if (isArray(value)) {
	          forEach(value, function (item) {
	            $this.add(item);
	          });
	          return $this;
	        }

	        $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
	        return $this;
	      },
	      'remove': function remove(value) {
	        var $this = this;

	        if (value == null) {
	          return $this;
	        }

	        if (value instanceof regenerate) {
	          $this.data = dataRemoveData($this.data, value.data);
	          return $this;
	        }

	        if (arguments.length > 1) {
	          value = slice.call(arguments);
	        }

	        if (isArray(value)) {
	          forEach(value, function (item) {
	            $this.remove(item);
	          });
	          return $this;
	        }

	        $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
	        return $this;
	      },
	      'addRange': function addRange(start, end) {
	        var $this = this;
	        $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
	        return $this;
	      },
	      'removeRange': function removeRange(start, end) {
	        var $this = this;
	        var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
	        var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
	        $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
	        return $this;
	      },
	      'intersection': function intersection(argument) {
	        var $this = this;
	        var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
	        $this.data = dataIntersection($this.data, array);
	        return $this;
	      },
	      'contains': function contains(codePoint) {
	        return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
	      },
	      'clone': function clone() {
	        var set = new regenerate();
	        set.data = this.data.slice(0);
	        return set;
	      },
	      'toString': function toString(options) {
	        var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

	        if (!result) {
	          return '[]';
	        }

	        return result.replace(regexNull, '\\0$1');
	      },
	      'toRegExp': function toRegExp(flags) {
	        var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
	          'hasUnicodeFlag': true
	        } : null);
	        return RegExp(pattern, flags || '');
	      },
	      'valueOf': function valueOf() {
	        return dataToArray(this.data);
	      }
	    });
	    proto.toArray = proto.valueOf;

	    if (freeExports && !freeExports.nodeType) {
	      if (freeModule) {
	        freeModule.exports = regenerate;
	      } else {
	        freeExports.regenerate = regenerate;
	      }
	    } else {
	      root.regenerate = regenerate;
	    }
	  })(commonjsGlobal);
	}, "/$$rollup_base$$/node_modules/regenerate");

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Alphabetic.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x2EC, 0x2EE, 0x345, 0x37F, 0x386, 0x38C, 0x559, 0x5BF, 0x5C7, 0x6FF, 0x7FA, 0x9B2, 0x9CE, 0x9D7, 0x9FC, 0xA51, 0xA5E, 0xAD0, 0xB71, 0xB9C, 0xBD0, 0xBD7, 0xC5D, 0xD4E, 0xDBD, 0xDD6, 0xE4D, 0xE84, 0xEA5, 0xEC6, 0xECD, 0xF00, 0x1038, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x17DC, 0x1AA7, 0x1CFA, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2071, 0x207F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0x2E2F, 0xA7D3, 0xA8C5, 0xA8FB, 0xA9CF, 0xAAC0, 0xAAC2, 0xFB3E, 0x10808, 0x1083C, 0x10F27, 0x110C2, 0x11176, 0x111DA, 0x111DC, 0x11237, 0x1123E, 0x11288, 0x11350, 0x11357, 0x114C7, 0x11640, 0x11644, 0x116B8, 0x11909, 0x119E1, 0x11A9D, 0x11C40, 0x11D3A, 0x11D43, 0x11D98, 0x11FB0, 0x16FE3, 0x1BC9E, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E14E, 0x1E947, 0x1E94B, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x370, 0x374).addRange(0x376, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x5B0, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x610, 0x61A).addRange(0x620, 0x657).addRange(0x659, 0x65F).addRange(0x66E, 0x6D3).addRange(0x6D5, 0x6DC).addRange(0x6E1, 0x6E8).addRange(0x6ED, 0x6EF).addRange(0x6FA, 0x6FC).addRange(0x710, 0x73F).addRange(0x74D, 0x7B1).addRange(0x7CA, 0x7EA).addRange(0x7F4, 0x7F5).addRange(0x800, 0x817).addRange(0x81A, 0x82C).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x8A0, 0x8C9).addRange(0x8D4, 0x8DF).addRange(0x8E3, 0x8E9).addRange(0x8F0, 0x93B).addRange(0x93D, 0x94C).addRange(0x94E, 0x950).addRange(0x955, 0x963).addRange(0x971, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8);
	set.addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BD, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CC).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E3).addRange(0x9F0, 0x9F1).addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4C).addRange(0xA59, 0xA5C).addRange(0xA70, 0xA75).addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABD, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACC).addRange(0xAE0, 0xAE3).addRange(0xAF9, 0xAFC).addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3D, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4C).addRange(0xB56, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A);
	set.addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCC).addRange(0xC00, 0xC03).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3D, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4C).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC80, 0xC83).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBD, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCC).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCF1, 0xCF2).addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD3D, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4C).addRange(0xD54, 0xD57).addRange(0xD5F, 0xD63).addRange(0xD7A, 0xD7F).addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDF2, 0xDF3).addRange(0xE01, 0xE3A).addRange(0xE40, 0xE46).addRange(0xE81, 0xE82);
	set.addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB9).addRange(0xEBB, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEDC, 0xEDF).addRange(0xF40, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF81).addRange(0xF88, 0xF97).addRange(0xF99, 0xFBC).addRange(0x1000, 0x1036).addRange(0x103B, 0x103F).addRange(0x1050, 0x108F).addRange(0x109A, 0x109D).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8).addRange(0x1700, 0x1713).addRange(0x171F, 0x1733).addRange(0x1740, 0x1753).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773).addRange(0x1780, 0x17B3).addRange(0x17B6, 0x17C8).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E);
	set.addRange(0x1920, 0x192B).addRange(0x1930, 0x1938).addRange(0x1950, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x1A00, 0x1A1B).addRange(0x1A20, 0x1A5E).addRange(0x1A61, 0x1A74).addRange(0x1ABF, 0x1AC0).addRange(0x1ACC, 0x1ACE).addRange(0x1B00, 0x1B33).addRange(0x1B35, 0x1B43).addRange(0x1B45, 0x1B4C).addRange(0x1B80, 0x1BA9).addRange(0x1BAC, 0x1BAF).addRange(0x1BBA, 0x1BE5).addRange(0x1BE7, 0x1BF1).addRange(0x1C00, 0x1C36).addRange(0x1C4D, 0x1C4F).addRange(0x1C5A, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF6).addRange(0x1D00, 0x1DBF).addRange(0x1DE7, 0x1DF4).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x2090, 0x209C).addRange(0x210A, 0x2113).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x212F, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149);
	set.addRange(0x2160, 0x2188).addRange(0x24B6, 0x24E9).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x2DE0, 0x2DFF).addRange(0x3005, 0x3007).addRange(0x3021, 0x3029).addRange(0x3031, 0x3035).addRange(0x3038, 0x303C).addRange(0x3041, 0x3096).addRange(0x309D, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA61F).addRange(0xA62A, 0xA62B).addRange(0xA640, 0xA66E).addRange(0xA674, 0xA67B).addRange(0xA67F, 0xA6EF).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA805).addRange(0xA807, 0xA827).addRange(0xA840, 0xA873).addRange(0xA880, 0xA8C3).addRange(0xA8F2, 0xA8F7).addRange(0xA8FD, 0xA8FF).addRange(0xA90A, 0xA92A).addRange(0xA930, 0xA952);
	set.addRange(0xA960, 0xA97C).addRange(0xA980, 0xA9B2).addRange(0xA9B4, 0xA9BF).addRange(0xA9E0, 0xA9EF).addRange(0xA9FA, 0xA9FE).addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA60, 0xAA76).addRange(0xAA7A, 0xAABE).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEF).addRange(0xAAF2, 0xAAF5).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABEA).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1D, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFB).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D);
	set.addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10140, 0x10174).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x1037A).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x103D1, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A00, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7);
	set.addRange(0x10AC9, 0x10AE4).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D27).addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAC).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F45).addRange(0x10F70, 0x10F81).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11000, 0x11045).addRange(0x11071, 0x11075).addRange(0x11082, 0x110B8).addRange(0x110D0, 0x110E8).addRange(0x11100, 0x11132).addRange(0x11144, 0x11147).addRange(0x11150, 0x11172).addRange(0x11180, 0x111BF).addRange(0x111C1, 0x111C4).addRange(0x111CE, 0x111CF).addRange(0x11200, 0x11211).addRange(0x11213, 0x11234).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112E8).addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133D, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134C).addRange(0x1135D, 0x11363).addRange(0x11400, 0x11441).addRange(0x11443, 0x11445).addRange(0x11447, 0x1144A).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114C1).addRange(0x114C4, 0x114C5);
	set.addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115BE).addRange(0x115D8, 0x115DD).addRange(0x11600, 0x1163E).addRange(0x11680, 0x116B5).addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172A).addRange(0x11740, 0x11746).addRange(0x11800, 0x11838).addRange(0x118A0, 0x118DF).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x1193C).addRange(0x1193F, 0x11942).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119DF).addRange(0x119E3, 0x119E4).addRange(0x11A00, 0x11A32).addRange(0x11A35, 0x11A3E).addRange(0x11A50, 0x11A97).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C3E).addRange(0x11C72, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D41).addRange(0x11D46, 0x11D47).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D96).addRange(0x11EE0, 0x11EF6).addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E);
	set.addRange(0x16A70, 0x16ABE).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B40, 0x16B43).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x16FF0, 0x16FF1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8);
	set.addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF1E).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E100, 0x1E12C).addRange(0x1E137, 0x1E13D).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E900, 0x1E943).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1F130, 0x1F149).addRange(0x1F150, 0x1F169).addRange(0x1F170, 0x1F189).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Any.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x0, 0x10FFFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/ASCII_Hex_Digit.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x30, 0x39).addRange(0x41, 0x46).addRange(0x61, 0x66);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/ASCII.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x0, 0x7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Assigned.js", function (module, exports) {
	  const set = regenerate(0x38C, 0x85E, 0x9B2, 0x9D7, 0xA3C, 0xA51, 0xA5E, 0xAD0, 0xB9C, 0xBD0, 0xBD7, 0xC5D, 0xDBD, 0xDCA, 0xDD6, 0xE84, 0xEA5, 0xEC6, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x1940, 0x1F59, 0x1F5B, 0x1F5D, 0x2D27, 0x2D2D, 0xA7D3, 0xFB3E, 0xFDCF, 0xFEFF, 0x101A0, 0x10808, 0x1083C, 0x1093F, 0x110CD, 0x11288, 0x11350, 0x11357, 0x11909, 0x11D3A, 0x11FB0, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E2FF, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E, 0x1F7F0, 0xE0001);
	set.addRange(0x0, 0x377).addRange(0x37A, 0x37F).addRange(0x384, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x52F).addRange(0x531, 0x556).addRange(0x559, 0x58A).addRange(0x58D, 0x58F).addRange(0x591, 0x5C7).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F4).addRange(0x600, 0x70D).addRange(0x70F, 0x74A).addRange(0x74D, 0x7B1).addRange(0x7C0, 0x7FA).addRange(0x7FD, 0x82D).addRange(0x830, 0x83E).addRange(0x840, 0x85B).addRange(0x860, 0x86A).addRange(0x870, 0x88E).addRange(0x890, 0x891).addRange(0x898, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BC, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CE).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E3).addRange(0x9E6, 0x9FE).addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA76).addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0);
	set.addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABC, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE0, 0xAE3).addRange(0xAE6, 0xAF1).addRange(0xAF9, 0xAFF).addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3C, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB66, 0xB77).addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD).addRange(0xBE6, 0xBFA).addRange(0xC00, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3C, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC66, 0xC6F).addRange(0xC77, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9);
	set.addRange(0xCBC, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2).addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4F).addRange(0xD54, 0xD63).addRange(0xD66, 0xD7F).addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF4).addRange(0xE01, 0xE3A).addRange(0xE3F, 0xE5B).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEC8, 0xECD).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF).addRange(0xF00, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF97).addRange(0xF99, 0xFBC).addRange(0xFBE, 0xFCC).addRange(0xFCE, 0xFDA).addRange(0x1000, 0x10C5).addRange(0x10D0, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5);
	set.addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x135D, 0x137C).addRange(0x1380, 0x1399).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1400, 0x169C).addRange(0x16A0, 0x16F8).addRange(0x1700, 0x1715).addRange(0x171F, 0x1736).addRange(0x1740, 0x1753).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773).addRange(0x1780, 0x17DD).addRange(0x17E0, 0x17E9).addRange(0x17F0, 0x17F9).addRange(0x1800, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1944, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x19DE, 0x1A1B).addRange(0x1A1E, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1A7F, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AA0, 0x1AAD).addRange(0x1AB0, 0x1ACE).addRange(0x1B00, 0x1B4C).addRange(0x1B50, 0x1B7E).addRange(0x1B80, 0x1BF3).addRange(0x1BFC, 0x1C37).addRange(0x1C3B, 0x1C49).addRange(0x1C4D, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CC7).addRange(0x1CD0, 0x1CFA).addRange(0x1D00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D);
	set.addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FC4).addRange(0x1FC6, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FDD, 0x1FEF).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFE).addRange(0x2000, 0x2064).addRange(0x2066, 0x2071).addRange(0x2074, 0x208E).addRange(0x2090, 0x209C).addRange(0x20A0, 0x20C0).addRange(0x20D0, 0x20F0).addRange(0x2100, 0x218B).addRange(0x2190, 0x2426).addRange(0x2440, 0x244A).addRange(0x2460, 0x2B73).addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2CF3).addRange(0x2CF9, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D6F, 0x2D70).addRange(0x2D7F, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x2DE0, 0x2E5D).addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x2FF0, 0x2FFB).addRange(0x3000, 0x303F).addRange(0x3041, 0x3096).addRange(0x3099, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x3190, 0x31E3).addRange(0x31F0, 0x321E).addRange(0x3220, 0xA48C).addRange(0xA490, 0xA4C6).addRange(0xA4D0, 0xA62B).addRange(0xA640, 0xA6F7).addRange(0xA700, 0xA7CA).addRange(0xA7D0, 0xA7D1);
	set.addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA82C).addRange(0xA830, 0xA839).addRange(0xA840, 0xA877).addRange(0xA880, 0xA8C5).addRange(0xA8CE, 0xA8D9).addRange(0xA8E0, 0xA953).addRange(0xA95F, 0xA97C).addRange(0xA980, 0xA9CD).addRange(0xA9CF, 0xA9D9).addRange(0xA9DE, 0xA9FE).addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA50, 0xAA59).addRange(0xAA5C, 0xAAC2).addRange(0xAADB, 0xAAF6).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB6B).addRange(0xAB70, 0xABED).addRange(0xABF0, 0xABF9).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xD800, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1D, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBC2).addRange(0xFBD3, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFE19).addRange(0xFE20, 0xFE52).addRange(0xFE54, 0xFE66).addRange(0xFE68, 0xFE6B).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF01, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE);
	set.addRange(0xFFF9, 0xFFFD).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10100, 0x10102).addRange(0x10107, 0x10133).addRange(0x10137, 0x1018E).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FD).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x102E0, 0x102FB).addRange(0x10300, 0x10323).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x1037A).addRange(0x10380, 0x1039D).addRange(0x1039F, 0x103C3).addRange(0x103C8, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104A0, 0x104A9).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x1056F, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10857, 0x1089E).addRange(0x108A7, 0x108AF).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x108FB, 0x1091B);
	set.addRange(0x1091F, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BC, 0x109CF).addRange(0x109D2, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A38, 0x10A3A).addRange(0x10A3F, 0x10A48).addRange(0x10A50, 0x10A58).addRange(0x10A60, 0x10A9F).addRange(0x10AC0, 0x10AE6).addRange(0x10AEB, 0x10AF6).addRange(0x10B00, 0x10B35).addRange(0x10B39, 0x10B55).addRange(0x10B58, 0x10B72).addRange(0x10B78, 0x10B91).addRange(0x10B99, 0x10B9C).addRange(0x10BA9, 0x10BAF).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10CFA, 0x10D27).addRange(0x10D30, 0x10D39).addRange(0x10E60, 0x10E7E).addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAD).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F27).addRange(0x10F30, 0x10F59).addRange(0x10F70, 0x10F89).addRange(0x10FB0, 0x10FCB).addRange(0x10FE0, 0x10FF6).addRange(0x11000, 0x1104D).addRange(0x11052, 0x11075).addRange(0x1107F, 0x110C2).addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9).addRange(0x11100, 0x11134).addRange(0x11136, 0x11147).addRange(0x11150, 0x11176).addRange(0x11180, 0x111DF).addRange(0x111E1, 0x111F4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1123E).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A9).addRange(0x112B0, 0x112EA);
	set.addRange(0x112F0, 0x112F9).addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133B, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11400, 0x1145B).addRange(0x1145D, 0x11461).addRange(0x11480, 0x114C7).addRange(0x114D0, 0x114D9).addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115DD).addRange(0x11600, 0x11644).addRange(0x11650, 0x11659).addRange(0x11660, 0x1166C).addRange(0x11680, 0x116B9).addRange(0x116C0, 0x116C9).addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172B).addRange(0x11730, 0x11746).addRange(0x11800, 0x1183B).addRange(0x118A0, 0x118F2).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x11946).addRange(0x11950, 0x11959).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119E4).addRange(0x11A00, 0x11A47).addRange(0x11A50, 0x11AA2).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C45).addRange(0x11C50, 0x11C6C).addRange(0x11C70, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6).addRange(0x11D00, 0x11D06);
	set.addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D47).addRange(0x11D50, 0x11D59).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D98).addRange(0x11DA0, 0x11DA9).addRange(0x11EE0, 0x11EF8).addRange(0x11FC0, 0x11FF1).addRange(0x11FFF, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12470, 0x12474).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF2).addRange(0x13000, 0x1342E).addRange(0x13430, 0x13438).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A6E, 0x16ABE).addRange(0x16AC0, 0x16AC9).addRange(0x16AD0, 0x16AED).addRange(0x16AF0, 0x16AF5).addRange(0x16B00, 0x16B45).addRange(0x16B50, 0x16B59).addRange(0x16B5B, 0x16B61).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E9A).addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F).addRange(0x16FE0, 0x16FE4).addRange(0x16FF0, 0x16FF1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C);
	set.addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1BC9C, 0x1BCA3).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D1EA).addRange(0x1D200, 0x1D245).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D300, 0x1D356).addRange(0x1D360, 0x1D378).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1DA8B).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1DF00, 0x1DF1E).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E100, 0x1E12C).addRange(0x1E130, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E14E, 0x1E14F).addRange(0x1E290, 0x1E2AE).addRange(0x1E2C0, 0x1E2F9).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E8C7, 0x1E8D6);
	set.addRange(0x1E900, 0x1E94B).addRange(0x1E950, 0x1E959).addRange(0x1E95E, 0x1E95F).addRange(0x1EC71, 0x1ECB4).addRange(0x1ED01, 0x1ED3D).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1EEF0, 0x1EEF1).addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F100, 0x1F1AD).addRange(0x1F1E6, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C);
	set.addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA).addRange(0x1FBF0, 0x1FBF9).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A).addRange(0xE0020, 0xE007F).addRange(0xE0100, 0xE01EF).addRange(0xF0000, 0xFFFFD).addRange(0x100000, 0x10FFFD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Bidi_Control.js", function (module, exports) {
	  const set = regenerate(0x61C);
	set.addRange(0x200E, 0x200F).addRange(0x202A, 0x202E).addRange(0x2066, 0x2069);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Bidi_Mirrored.js", function (module, exports) {
	  const set = regenerate(0x3C, 0x3E, 0x5B, 0x5D, 0x7B, 0x7D, 0xAB, 0xBB, 0x2140, 0x2211, 0x2224, 0x2226, 0x2239, 0x2262, 0x2298, 0x27C0, 0x29B8, 0x29C9, 0x29E1, 0x2A24, 0x2A26, 0x2A29, 0x2ADC, 0x2ADE, 0x2AF3, 0x2AFD, 0x2BFE, 0xFF1C, 0xFF1E, 0xFF3B, 0xFF3D, 0xFF5B, 0xFF5D, 0x1D6DB, 0x1D715, 0x1D74F, 0x1D789, 0x1D7C3);
	set.addRange(0x28, 0x29).addRange(0xF3A, 0xF3D).addRange(0x169B, 0x169C).addRange(0x2039, 0x203A).addRange(0x2045, 0x2046).addRange(0x207D, 0x207E).addRange(0x208D, 0x208E).addRange(0x2201, 0x2204).addRange(0x2208, 0x220D).addRange(0x2215, 0x2216).addRange(0x221A, 0x221D).addRange(0x221F, 0x2222).addRange(0x222B, 0x2233).addRange(0x223B, 0x224C).addRange(0x2252, 0x2255).addRange(0x225F, 0x2260).addRange(0x2264, 0x226B).addRange(0x226E, 0x228C).addRange(0x228F, 0x2292).addRange(0x22A2, 0x22A3).addRange(0x22A6, 0x22B8).addRange(0x22BE, 0x22BF).addRange(0x22C9, 0x22CD).addRange(0x22D0, 0x22D1).addRange(0x22D6, 0x22ED).addRange(0x22F0, 0x22FF).addRange(0x2308, 0x230B).addRange(0x2320, 0x2321).addRange(0x2329, 0x232A).addRange(0x2768, 0x2775).addRange(0x27C3, 0x27C6).addRange(0x27C8, 0x27C9).addRange(0x27CB, 0x27CD).addRange(0x27D3, 0x27D6).addRange(0x27DC, 0x27DE).addRange(0x27E2, 0x27EF).addRange(0x2983, 0x2998).addRange(0x299B, 0x29A0).addRange(0x29A2, 0x29AF).addRange(0x29C0, 0x29C5).addRange(0x29CE, 0x29D2).addRange(0x29D4, 0x29D5).addRange(0x29D8, 0x29DC).addRange(0x29E3, 0x29E5).addRange(0x29E8, 0x29E9).addRange(0x29F4, 0x29F9).addRange(0x29FC, 0x29FD).addRange(0x2A0A, 0x2A1C).addRange(0x2A1E, 0x2A21).addRange(0x2A2B, 0x2A2E).addRange(0x2A34, 0x2A35);
	set.addRange(0x2A3C, 0x2A3E).addRange(0x2A57, 0x2A58).addRange(0x2A64, 0x2A65).addRange(0x2A6A, 0x2A6D).addRange(0x2A6F, 0x2A70).addRange(0x2A73, 0x2A74).addRange(0x2A79, 0x2AA3).addRange(0x2AA6, 0x2AAD).addRange(0x2AAF, 0x2AD6).addRange(0x2AE2, 0x2AE6).addRange(0x2AEC, 0x2AEE).addRange(0x2AF7, 0x2AFB).addRange(0x2E02, 0x2E05).addRange(0x2E09, 0x2E0A).addRange(0x2E0C, 0x2E0D).addRange(0x2E1C, 0x2E1D).addRange(0x2E20, 0x2E29).addRange(0x2E55, 0x2E5C).addRange(0x3008, 0x3011).addRange(0x3014, 0x301B).addRange(0xFE59, 0xFE5E).addRange(0xFE64, 0xFE65).addRange(0xFF08, 0xFF09).addRange(0xFF5F, 0xFF60).addRange(0xFF62, 0xFF63);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Case_Ignorable.js", function (module, exports) {
	  const set = regenerate(0x27, 0x2E, 0x3A, 0x5E, 0x60, 0xA8, 0xAD, 0xAF, 0xB4, 0x37A, 0x387, 0x559, 0x55F, 0x5BF, 0x5C7, 0x5F4, 0x61C, 0x640, 0x670, 0x70F, 0x711, 0x7FA, 0x7FD, 0x888, 0x93A, 0x93C, 0x94D, 0x971, 0x981, 0x9BC, 0x9CD, 0x9FE, 0xA3C, 0xA51, 0xA75, 0xABC, 0xACD, 0xB01, 0xB3C, 0xB3F, 0xB4D, 0xB82, 0xBC0, 0xBCD, 0xC00, 0xC04, 0xC3C, 0xC81, 0xCBC, 0xCBF, 0xCC6, 0xD4D, 0xD81, 0xDCA, 0xDD6, 0xE31, 0xEB1, 0xEC6, 0xF35, 0xF37, 0xF39, 0xFC6, 0x1082, 0x108D, 0x109D, 0x10FC, 0x17C6, 0x17D7, 0x17DD, 0x1843, 0x18A9, 0x1932, 0x1A1B, 0x1A56, 0x1A60, 0x1A62, 0x1A7F, 0x1AA7, 0x1B34, 0x1B3C, 0x1B42, 0x1BE6, 0x1BED, 0x1CED, 0x1CF4, 0x1D78, 0x1FBD, 0x2024, 0x2027, 0x2071, 0x207F, 0x2D6F, 0x2D7F, 0x2E2F, 0x3005, 0x303B, 0xA015, 0xA60C, 0xA67F, 0xA770, 0xA802, 0xA806, 0xA80B, 0xA82C, 0xA8FF, 0xA9B3, 0xA9CF, 0xAA43, 0xAA4C, 0xAA70, 0xAA7C, 0xAAB0, 0xAAC1, 0xAADD, 0xAAF6, 0xABE5, 0xABE8, 0xABED, 0xFB1E, 0xFE13, 0xFE52, 0xFE55, 0xFEFF, 0xFF07, 0xFF0E, 0xFF1A, 0xFF3E, 0xFF40, 0xFF70, 0xFFE3, 0x101FD, 0x102E0, 0x10A3F, 0x11001, 0x11070, 0x110BD, 0x110C2, 0x110CD, 0x11173, 0x111CF, 0x11234, 0x1123E, 0x112DF, 0x11340, 0x11446, 0x1145E, 0x114BA, 0x1163D, 0x116AB, 0x116AD, 0x116B7, 0x1193E, 0x11943, 0x119E0, 0x11A47, 0x11C3F, 0x11D3A, 0x11D47, 0x11D95, 0x11D97, 0x16F4F, 0x1DA75, 0x1DA84, 0x1E2AE, 0xE0001);
	set.addRange(0xB7, 0xB8).addRange(0x2B0, 0x36F).addRange(0x374, 0x375).addRange(0x384, 0x385).addRange(0x483, 0x489).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x600, 0x605).addRange(0x610, 0x61A).addRange(0x64B, 0x65F).addRange(0x6D6, 0x6DD).addRange(0x6DF, 0x6E8).addRange(0x6EA, 0x6ED).addRange(0x730, 0x74A).addRange(0x7A6, 0x7B0).addRange(0x7EB, 0x7F5).addRange(0x816, 0x82D).addRange(0x859, 0x85B).addRange(0x890, 0x891).addRange(0x898, 0x89F).addRange(0x8C9, 0x902).addRange(0x941, 0x948).addRange(0x951, 0x957).addRange(0x962, 0x963).addRange(0x9C1, 0x9C4).addRange(0x9E2, 0x9E3).addRange(0xA01, 0xA02).addRange(0xA41, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA70, 0xA71).addRange(0xA81, 0xA82).addRange(0xAC1, 0xAC5).addRange(0xAC7, 0xAC8).addRange(0xAE2, 0xAE3).addRange(0xAFA, 0xAFF).addRange(0xB41, 0xB44).addRange(0xB55, 0xB56).addRange(0xB62, 0xB63).addRange(0xC3E, 0xC40).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC62, 0xC63).addRange(0xCCC, 0xCCD).addRange(0xCE2, 0xCE3).addRange(0xD00, 0xD01).addRange(0xD3B, 0xD3C).addRange(0xD41, 0xD44).addRange(0xD62, 0xD63);
	set.addRange(0xDD2, 0xDD4).addRange(0xE34, 0xE3A).addRange(0xE46, 0xE4E).addRange(0xEB4, 0xEBC).addRange(0xEC8, 0xECD).addRange(0xF18, 0xF19).addRange(0xF71, 0xF7E).addRange(0xF80, 0xF84).addRange(0xF86, 0xF87).addRange(0xF8D, 0xF97).addRange(0xF99, 0xFBC).addRange(0x102D, 0x1030).addRange(0x1032, 0x1037).addRange(0x1039, 0x103A).addRange(0x103D, 0x103E).addRange(0x1058, 0x1059).addRange(0x105E, 0x1060).addRange(0x1071, 0x1074).addRange(0x1085, 0x1086).addRange(0x135D, 0x135F).addRange(0x1712, 0x1714).addRange(0x1732, 0x1733).addRange(0x1752, 0x1753).addRange(0x1772, 0x1773).addRange(0x17B4, 0x17B5).addRange(0x17B7, 0x17BD).addRange(0x17C9, 0x17D3).addRange(0x180B, 0x180F).addRange(0x1885, 0x1886).addRange(0x1920, 0x1922).addRange(0x1927, 0x1928).addRange(0x1939, 0x193B).addRange(0x1A17, 0x1A18).addRange(0x1A58, 0x1A5E).addRange(0x1A65, 0x1A6C).addRange(0x1A73, 0x1A7C).addRange(0x1AB0, 0x1ACE).addRange(0x1B00, 0x1B03).addRange(0x1B36, 0x1B3A).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1B81).addRange(0x1BA2, 0x1BA5).addRange(0x1BA8, 0x1BA9).addRange(0x1BAB, 0x1BAD).addRange(0x1BE8, 0x1BE9).addRange(0x1BEF, 0x1BF1).addRange(0x1C2C, 0x1C33).addRange(0x1C36, 0x1C37).addRange(0x1C78, 0x1C7D).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CE0);
	set.addRange(0x1CE2, 0x1CE8).addRange(0x1CF8, 0x1CF9).addRange(0x1D2C, 0x1D6A).addRange(0x1D9B, 0x1DFF).addRange(0x1FBF, 0x1FC1).addRange(0x1FCD, 0x1FCF).addRange(0x1FDD, 0x1FDF).addRange(0x1FED, 0x1FEF).addRange(0x1FFD, 0x1FFE).addRange(0x200B, 0x200F).addRange(0x2018, 0x2019).addRange(0x202A, 0x202E).addRange(0x2060, 0x2064).addRange(0x2066, 0x206F).addRange(0x2090, 0x209C).addRange(0x20D0, 0x20F0).addRange(0x2C7C, 0x2C7D).addRange(0x2CEF, 0x2CF1).addRange(0x2DE0, 0x2DFF).addRange(0x302A, 0x302D).addRange(0x3031, 0x3035).addRange(0x3099, 0x309E).addRange(0x30FC, 0x30FE).addRange(0xA4F8, 0xA4FD).addRange(0xA66F, 0xA672).addRange(0xA674, 0xA67D).addRange(0xA69C, 0xA69F).addRange(0xA6F0, 0xA6F1).addRange(0xA700, 0xA721).addRange(0xA788, 0xA78A).addRange(0xA7F2, 0xA7F4).addRange(0xA7F8, 0xA7F9).addRange(0xA825, 0xA826).addRange(0xA8C4, 0xA8C5).addRange(0xA8E0, 0xA8F1).addRange(0xA926, 0xA92D).addRange(0xA947, 0xA951).addRange(0xA980, 0xA982).addRange(0xA9B6, 0xA9B9).addRange(0xA9BC, 0xA9BD).addRange(0xA9E5, 0xA9E6).addRange(0xAA29, 0xAA2E).addRange(0xAA31, 0xAA32).addRange(0xAA35, 0xAA36).addRange(0xAAB2, 0xAAB4).addRange(0xAAB7, 0xAAB8).addRange(0xAABE, 0xAABF).addRange(0xAAEC, 0xAAED).addRange(0xAAF3, 0xAAF4).addRange(0xAB5B, 0xAB5F).addRange(0xAB69, 0xAB6B);
	set.addRange(0xFBB2, 0xFBC2).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0xFF9E, 0xFF9F).addRange(0xFFF9, 0xFFFB).addRange(0x10376, 0x1037A).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10A01, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A0F).addRange(0x10A38, 0x10A3A).addRange(0x10AE5, 0x10AE6).addRange(0x10D24, 0x10D27).addRange(0x10EAB, 0x10EAC).addRange(0x10F46, 0x10F50).addRange(0x10F82, 0x10F85).addRange(0x11038, 0x11046).addRange(0x11073, 0x11074).addRange(0x1107F, 0x11081).addRange(0x110B3, 0x110B6).addRange(0x110B9, 0x110BA).addRange(0x11100, 0x11102).addRange(0x11127, 0x1112B).addRange(0x1112D, 0x11134).addRange(0x11180, 0x11181).addRange(0x111B6, 0x111BE).addRange(0x111C9, 0x111CC).addRange(0x1122F, 0x11231).addRange(0x11236, 0x11237).addRange(0x112E3, 0x112EA).addRange(0x11300, 0x11301).addRange(0x1133B, 0x1133C).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11438, 0x1143F).addRange(0x11442, 0x11444).addRange(0x114B3, 0x114B8).addRange(0x114BF, 0x114C0).addRange(0x114C2, 0x114C3).addRange(0x115B2, 0x115B5).addRange(0x115BC, 0x115BD).addRange(0x115BF, 0x115C0).addRange(0x115DC, 0x115DD).addRange(0x11633, 0x1163A).addRange(0x1163F, 0x11640).addRange(0x116B0, 0x116B5).addRange(0x1171D, 0x1171F).addRange(0x11722, 0x11725).addRange(0x11727, 0x1172B);
	set.addRange(0x1182F, 0x11837).addRange(0x11839, 0x1183A).addRange(0x1193B, 0x1193C).addRange(0x119D4, 0x119D7).addRange(0x119DA, 0x119DB).addRange(0x11A01, 0x11A0A).addRange(0x11A33, 0x11A38).addRange(0x11A3B, 0x11A3E).addRange(0x11A51, 0x11A56).addRange(0x11A59, 0x11A5B).addRange(0x11A8A, 0x11A96).addRange(0x11A98, 0x11A99).addRange(0x11C30, 0x11C36).addRange(0x11C38, 0x11C3D).addRange(0x11C92, 0x11CA7).addRange(0x11CAA, 0x11CB0).addRange(0x11CB2, 0x11CB3).addRange(0x11CB5, 0x11CB6).addRange(0x11D31, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D45).addRange(0x11D90, 0x11D91).addRange(0x11EF3, 0x11EF4).addRange(0x13430, 0x13438).addRange(0x16AF0, 0x16AF4).addRange(0x16B30, 0x16B36).addRange(0x16B40, 0x16B43).addRange(0x16F8F, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x16FE3, 0x16FE4).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1BC9D, 0x1BC9E).addRange(0x1BCA0, 0x1BCA3).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169).addRange(0x1D173, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A);
	set.addRange(0x1E130, 0x1E13D).addRange(0x1E2EC, 0x1E2EF).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E944, 0x1E94B).addRange(0x1F3FB, 0x1F3FF).addRange(0xE0020, 0xE007F).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Cased.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x345, 0x37F, 0x386, 0x38C, 0x10C7, 0x10CD, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2071, 0x207F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x2139, 0x214E, 0x2D27, 0x2D2D, 0xA7D3, 0x10780, 0x1D4A2, 0x1D4BB, 0x1D546);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x1BA).addRange(0x1BC, 0x1BF).addRange(0x1C4, 0x293).addRange(0x295, 0x2B8).addRange(0x2C0, 0x2C1).addRange(0x2E0, 0x2E4).addRange(0x370, 0x373).addRange(0x376, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1D00, 0x1DBF).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x2090, 0x209C).addRange(0x210A, 0x2113).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x212F, 0x2134).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149);
	set.addRange(0x2160, 0x217F).addRange(0x2183, 0x2184).addRange(0x24B6, 0x24E9).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0xA640, 0xA66D).addRange(0xA680, 0xA69D).addRange(0xA722, 0xA787).addRange(0xA78B, 0xA78E).addRange(0xA790, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F5, 0xA7F6).addRange(0xA7F8, 0xA7FA).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB68).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0x10400, 0x1044F).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10783, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x118A0, 0x118DF).addRange(0x16E40, 0x16E7F).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514);
	set.addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF09).addRange(0x1DF0B, 0x1DF1E).addRange(0x1E900, 0x1E943).addRange(0x1F130, 0x1F149).addRange(0x1F150, 0x1F169).addRange(0x1F170, 0x1F189);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_Casefolded.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x17B, 0x17D, 0x17F, 0x184, 0x1A2, 0x1A4, 0x1A9, 0x1AC, 0x1B5, 0x1BC, 0x1CD, 0x1CF, 0x1D1, 0x1D3, 0x1D5, 0x1D7, 0x1D9, 0x1DB, 0x1DE, 0x1E0, 0x1E2, 0x1E4, 0x1E6, 0x1E8, 0x1EA, 0x1EC, 0x1EE, 0x1F4, 0x1FA, 0x1FC, 0x1FE, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20A, 0x20C, 0x20E, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21A, 0x21C, 0x21E, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22A, 0x22C, 0x22E, 0x230, 0x232, 0x241, 0x248, 0x24A, 0x24C, 0x24E, 0x345, 0x370, 0x372, 0x376, 0x37F, 0x386, 0x38C, 0x3C2, 0x3D8, 0x3DA, 0x3DC, 0x3DE, 0x3E0, 0x3E2, 0x3E4, 0x3E6, 0x3E8, 0x3EA, 0x3EC, 0x3EE, 0x3F7, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46A, 0x46C, 0x46E, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47A, 0x47C, 0x47E, 0x480, 0x48A, 0x48C, 0x48E, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49A, 0x49C, 0x49E, 0x4A0, 0x4A2, 0x4A4, 0x4A6, 0x4A8, 0x4AA, 0x4AC, 0x4AE, 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4BC, 0x4BE, 0x4C3, 0x4C5, 0x4C7, 0x4C9, 0x4CB, 0x4CD, 0x4D0, 0x4D2, 0x4D4, 0x4D6, 0x4D8, 0x4DA, 0x4DC, 0x4DE, 0x4E0, 0x4E2, 0x4E4, 0x4E6, 0x4E8, 0x4EA, 0x4EC, 0x4EE, 0x4F0, 0x4F2, 0x4F4, 0x4F6, 0x4F8, 0x4FA, 0x4FC, 0x4FE, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50A, 0x50C, 0x50E, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51A, 0x51C, 0x51E, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52A, 0x52C, 0x52E, 0x587, 0x10C7, 0x10CD, 0x1E00, 0x1E02, 0x1E04, 0x1E06, 0x1E08, 0x1E0A, 0x1E0C, 0x1E0E, 0x1E10, 0x1E12, 0x1E14, 0x1E16, 0x1E18, 0x1E1A, 0x1E1C, 0x1E1E, 0x1E20, 0x1E22, 0x1E24, 0x1E26, 0x1E28, 0x1E2A, 0x1E2C, 0x1E2E, 0x1E30, 0x1E32, 0x1E34, 0x1E36, 0x1E38, 0x1E3A, 0x1E3C, 0x1E3E, 0x1E40, 0x1E42, 0x1E44, 0x1E46, 0x1E48, 0x1E4A, 0x1E4C, 0x1E4E, 0x1E50, 0x1E52, 0x1E54, 0x1E56, 0x1E58, 0x1E5A, 0x1E5C, 0x1E5E, 0x1E60, 0x1E62, 0x1E64, 0x1E66, 0x1E68, 0x1E6A, 0x1E6C, 0x1E6E, 0x1E70, 0x1E72, 0x1E74, 0x1E76, 0x1E78, 0x1E7A, 0x1E7C, 0x1E7E, 0x1E80, 0x1E82, 0x1E84, 0x1E86, 0x1E88, 0x1E8A, 0x1E8C, 0x1E8E, 0x1E90, 0x1E92, 0x1E94, 0x1E9E, 0x1EA0, 0x1EA2, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAA, 0x1EAC, 0x1EAE, 0x1EB0, 0x1EB2, 0x1EB4, 0x1EB6, 0x1EB8, 0x1EBA, 0x1EBC, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1EC8, 0x1ECA, 0x1ECC, 0x1ECE, 0x1ED0, 0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EDA, 0x1EDC, 0x1EDE, 0x1EE0, 0x1EE2, 0x1EE4, 0x1EE6, 0x1EE8, 0x1EEA, 0x1EEC, 0x1EEE, 0x1EF0, 0x1EF2, 0x1EF4, 0x1EF6, 0x1EF8, 0x1EFA, 0x1EFC, 0x1EFE, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F, 0x2126, 0x2132, 0x2183, 0x2C60, 0x2C67, 0x2C69, 0x2C6B, 0x2C72, 0x2C75, 0x2C82, 0x2C84, 0x2C86, 0x2C88, 0x2C8A, 0x2C8C, 0x2C8E, 0x2C90, 0x2C92, 0x2C94, 0x2C96, 0x2C98, 0x2C9A, 0x2C9C, 0x2C9E, 0x2CA0, 0x2CA2, 0x2CA4, 0x2CA6, 0x2CA8, 0x2CAA, 0x2CAC, 0x2CAE, 0x2CB0, 0x2CB2, 0x2CB4, 0x2CB6, 0x2CB8, 0x2CBA, 0x2CBC, 0x2CBE, 0x2CC0, 0x2CC2, 0x2CC4, 0x2CC6, 0x2CC8, 0x2CCA, 0x2CCC, 0x2CCE, 0x2CD0, 0x2CD2, 0x2CD4, 0x2CD6, 0x2CD8, 0x2CDA, 0x2CDC, 0x2CDE, 0x2CE0, 0x2CE2, 0x2CEB, 0x2CED, 0x2CF2, 0xA640, 0xA642, 0xA644, 0xA646, 0xA648, 0xA64A, 0xA64C, 0xA64E, 0xA650, 0xA652, 0xA654, 0xA656, 0xA658, 0xA65A, 0xA65C, 0xA65E, 0xA660, 0xA662, 0xA664, 0xA666, 0xA668, 0xA66A, 0xA66C, 0xA680, 0xA682, 0xA684, 0xA686, 0xA688, 0xA68A, 0xA68C, 0xA68E, 0xA690, 0xA692, 0xA694, 0xA696, 0xA698, 0xA69A, 0xA722, 0xA724, 0xA726, 0xA728, 0xA72A, 0xA72C, 0xA72E, 0xA732, 0xA734, 0xA736, 0xA738, 0xA73A, 0xA73C, 0xA73E, 0xA740, 0xA742, 0xA744, 0xA746, 0xA748, 0xA74A, 0xA74C, 0xA74E, 0xA750, 0xA752, 0xA754, 0xA756, 0xA758, 0xA75A, 0xA75C, 0xA75E, 0xA760, 0xA762, 0xA764, 0xA766, 0xA768, 0xA76A, 0xA76C, 0xA76E, 0xA779, 0xA77B, 0xA780, 0xA782, 0xA784, 0xA786, 0xA78B, 0xA78D, 0xA790, 0xA792, 0xA796, 0xA798, 0xA79A, 0xA79C, 0xA79E, 0xA7A0, 0xA7A2, 0xA7A4, 0xA7A6, 0xA7A8, 0xA7B6, 0xA7B8, 0xA7BA, 0xA7BC, 0xA7BE, 0xA7C0, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D6, 0xA7D8, 0xA7F5);
	set.addRange(0x41, 0x5A).addRange(0xC0, 0xD6).addRange(0xD8, 0xDF).addRange(0x149, 0x14A).addRange(0x178, 0x179).addRange(0x181, 0x182).addRange(0x186, 0x187).addRange(0x189, 0x18B).addRange(0x18E, 0x191).addRange(0x193, 0x194).addRange(0x196, 0x198).addRange(0x19C, 0x19D).addRange(0x19F, 0x1A0).addRange(0x1A6, 0x1A7).addRange(0x1AE, 0x1AF).addRange(0x1B1, 0x1B3).addRange(0x1B7, 0x1B8).addRange(0x1C4, 0x1C5).addRange(0x1C7, 0x1C8).addRange(0x1CA, 0x1CB).addRange(0x1F1, 0x1F2).addRange(0x1F6, 0x1F8).addRange(0x23A, 0x23B).addRange(0x23D, 0x23E).addRange(0x243, 0x246).addRange(0x388, 0x38A).addRange(0x38E, 0x38F).addRange(0x391, 0x3A1).addRange(0x3A3, 0x3AB).addRange(0x3CF, 0x3D1).addRange(0x3D5, 0x3D6).addRange(0x3F0, 0x3F1).addRange(0x3F4, 0x3F5).addRange(0x3F9, 0x3FA).addRange(0x3FD, 0x42F).addRange(0x4C0, 0x4C1).addRange(0x531, 0x556).addRange(0x10A0, 0x10C5).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1E9A, 0x1E9B).addRange(0x1F08, 0x1F0F).addRange(0x1F18, 0x1F1D).addRange(0x1F28, 0x1F2F).addRange(0x1F38, 0x1F3F).addRange(0x1F48, 0x1F4D).addRange(0x1F68, 0x1F6F).addRange(0x1F80, 0x1FAF).addRange(0x1FB2, 0x1FB4);
	set.addRange(0x1FB7, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC7, 0x1FCC).addRange(0x1FD8, 0x1FDB).addRange(0x1FE8, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF7, 0x1FFC).addRange(0x212A, 0x212B).addRange(0x2160, 0x216F).addRange(0x24B6, 0x24CF).addRange(0x2C00, 0x2C2F).addRange(0x2C62, 0x2C64).addRange(0x2C6D, 0x2C70).addRange(0x2C7E, 0x2C80).addRange(0xA77D, 0xA77E).addRange(0xA7AA, 0xA7AE).addRange(0xA7B0, 0xA7B4).addRange(0xA7C4, 0xA7C7).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF21, 0xFF3A).addRange(0x10400, 0x10427).addRange(0x104B0, 0x104D3).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10C80, 0x10CB2).addRange(0x118A0, 0x118BF).addRange(0x16E40, 0x16E5F).addRange(0x1E900, 0x1E921);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_Casemapped.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x1BF, 0x259, 0x263, 0x26F, 0x275, 0x27D, 0x280, 0x292, 0x345, 0x37F, 0x386, 0x38C, 0x10C7, 0x10CD, 0x1D79, 0x1D7D, 0x1D8E, 0x1E9E, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2126, 0x2132, 0x214E, 0x2D27, 0x2D2D, 0xAB53);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x137).addRange(0x139, 0x18C).addRange(0x18E, 0x19A).addRange(0x19C, 0x1A9).addRange(0x1AC, 0x1B9).addRange(0x1BC, 0x1BD).addRange(0x1C4, 0x220).addRange(0x222, 0x233).addRange(0x23A, 0x254).addRange(0x256, 0x257).addRange(0x25B, 0x25C).addRange(0x260, 0x261).addRange(0x265, 0x266).addRange(0x268, 0x26C).addRange(0x271, 0x272).addRange(0x282, 0x283).addRange(0x287, 0x28C).addRange(0x29D, 0x29E).addRange(0x370, 0x373).addRange(0x376, 0x377).addRange(0x37B, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3D1).addRange(0x3D5, 0x3F5).addRange(0x3F7, 0x3FB).addRange(0x3FD, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x561, 0x587).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1E00, 0x1E9B).addRange(0x1EA0, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC);
	set.addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x212A, 0x212B).addRange(0x2160, 0x217F).addRange(0x2183, 0x2184).addRange(0x24B6, 0x24E9).addRange(0x2C00, 0x2C70).addRange(0x2C72, 0x2C73).addRange(0x2C75, 0x2C76).addRange(0x2C7E, 0x2CE3).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0xA640, 0xA66D).addRange(0xA680, 0xA69B).addRange(0xA722, 0xA72F).addRange(0xA732, 0xA76F).addRange(0xA779, 0xA787).addRange(0xA78B, 0xA78D).addRange(0xA790, 0xA794).addRange(0xA796, 0xA7AE).addRange(0xA7B0, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D6, 0xA7D9).addRange(0xA7F5, 0xA7F6).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0x10400, 0x1044F).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x118A0, 0x118DF).addRange(0x16E40, 0x16E7F).addRange(0x1E900, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_Lowercased.js", function (module, exports) {
	  const set = regenerate(0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x17B, 0x17D, 0x184, 0x1A2, 0x1A4, 0x1A9, 0x1AC, 0x1B5, 0x1BC, 0x1CD, 0x1CF, 0x1D1, 0x1D3, 0x1D5, 0x1D7, 0x1D9, 0x1DB, 0x1DE, 0x1E0, 0x1E2, 0x1E4, 0x1E6, 0x1E8, 0x1EA, 0x1EC, 0x1EE, 0x1F4, 0x1FA, 0x1FC, 0x1FE, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20A, 0x20C, 0x20E, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21A, 0x21C, 0x21E, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22A, 0x22C, 0x22E, 0x230, 0x232, 0x241, 0x248, 0x24A, 0x24C, 0x24E, 0x370, 0x372, 0x376, 0x37F, 0x386, 0x38C, 0x3CF, 0x3D8, 0x3DA, 0x3DC, 0x3DE, 0x3E0, 0x3E2, 0x3E4, 0x3E6, 0x3E8, 0x3EA, 0x3EC, 0x3EE, 0x3F4, 0x3F7, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46A, 0x46C, 0x46E, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47A, 0x47C, 0x47E, 0x480, 0x48A, 0x48C, 0x48E, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49A, 0x49C, 0x49E, 0x4A0, 0x4A2, 0x4A4, 0x4A6, 0x4A8, 0x4AA, 0x4AC, 0x4AE, 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4BC, 0x4BE, 0x4C3, 0x4C5, 0x4C7, 0x4C9, 0x4CB, 0x4CD, 0x4D0, 0x4D2, 0x4D4, 0x4D6, 0x4D8, 0x4DA, 0x4DC, 0x4DE, 0x4E0, 0x4E2, 0x4E4, 0x4E6, 0x4E8, 0x4EA, 0x4EC, 0x4EE, 0x4F0, 0x4F2, 0x4F4, 0x4F6, 0x4F8, 0x4FA, 0x4FC, 0x4FE, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50A, 0x50C, 0x50E, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51A, 0x51C, 0x51E, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52A, 0x52C, 0x52E, 0x10C7, 0x10CD, 0x1E00, 0x1E02, 0x1E04, 0x1E06, 0x1E08, 0x1E0A, 0x1E0C, 0x1E0E, 0x1E10, 0x1E12, 0x1E14, 0x1E16, 0x1E18, 0x1E1A, 0x1E1C, 0x1E1E, 0x1E20, 0x1E22, 0x1E24, 0x1E26, 0x1E28, 0x1E2A, 0x1E2C, 0x1E2E, 0x1E30, 0x1E32, 0x1E34, 0x1E36, 0x1E38, 0x1E3A, 0x1E3C, 0x1E3E, 0x1E40, 0x1E42, 0x1E44, 0x1E46, 0x1E48, 0x1E4A, 0x1E4C, 0x1E4E, 0x1E50, 0x1E52, 0x1E54, 0x1E56, 0x1E58, 0x1E5A, 0x1E5C, 0x1E5E, 0x1E60, 0x1E62, 0x1E64, 0x1E66, 0x1E68, 0x1E6A, 0x1E6C, 0x1E6E, 0x1E70, 0x1E72, 0x1E74, 0x1E76, 0x1E78, 0x1E7A, 0x1E7C, 0x1E7E, 0x1E80, 0x1E82, 0x1E84, 0x1E86, 0x1E88, 0x1E8A, 0x1E8C, 0x1E8E, 0x1E90, 0x1E92, 0x1E94, 0x1E9E, 0x1EA0, 0x1EA2, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAA, 0x1EAC, 0x1EAE, 0x1EB0, 0x1EB2, 0x1EB4, 0x1EB6, 0x1EB8, 0x1EBA, 0x1EBC, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1EC8, 0x1ECA, 0x1ECC, 0x1ECE, 0x1ED0, 0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EDA, 0x1EDC, 0x1EDE, 0x1EE0, 0x1EE2, 0x1EE4, 0x1EE6, 0x1EE8, 0x1EEA, 0x1EEC, 0x1EEE, 0x1EF0, 0x1EF2, 0x1EF4, 0x1EF6, 0x1EF8, 0x1EFA, 0x1EFC, 0x1EFE, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F, 0x2126, 0x2132, 0x2183, 0x2C60, 0x2C67, 0x2C69, 0x2C6B, 0x2C72, 0x2C75, 0x2C82, 0x2C84, 0x2C86, 0x2C88, 0x2C8A, 0x2C8C, 0x2C8E, 0x2C90, 0x2C92, 0x2C94, 0x2C96, 0x2C98, 0x2C9A, 0x2C9C, 0x2C9E, 0x2CA0, 0x2CA2, 0x2CA4, 0x2CA6, 0x2CA8, 0x2CAA, 0x2CAC, 0x2CAE, 0x2CB0, 0x2CB2, 0x2CB4, 0x2CB6, 0x2CB8, 0x2CBA, 0x2CBC, 0x2CBE, 0x2CC0, 0x2CC2, 0x2CC4, 0x2CC6, 0x2CC8, 0x2CCA, 0x2CCC, 0x2CCE, 0x2CD0, 0x2CD2, 0x2CD4, 0x2CD6, 0x2CD8, 0x2CDA, 0x2CDC, 0x2CDE, 0x2CE0, 0x2CE2, 0x2CEB, 0x2CED, 0x2CF2, 0xA640, 0xA642, 0xA644, 0xA646, 0xA648, 0xA64A, 0xA64C, 0xA64E, 0xA650, 0xA652, 0xA654, 0xA656, 0xA658, 0xA65A, 0xA65C, 0xA65E, 0xA660, 0xA662, 0xA664, 0xA666, 0xA668, 0xA66A, 0xA66C, 0xA680, 0xA682, 0xA684, 0xA686, 0xA688, 0xA68A, 0xA68C, 0xA68E, 0xA690, 0xA692, 0xA694, 0xA696, 0xA698, 0xA69A, 0xA722, 0xA724, 0xA726, 0xA728, 0xA72A, 0xA72C, 0xA72E, 0xA732, 0xA734, 0xA736, 0xA738, 0xA73A, 0xA73C, 0xA73E, 0xA740, 0xA742, 0xA744, 0xA746, 0xA748, 0xA74A, 0xA74C, 0xA74E, 0xA750, 0xA752, 0xA754, 0xA756, 0xA758, 0xA75A, 0xA75C, 0xA75E, 0xA760, 0xA762, 0xA764, 0xA766, 0xA768, 0xA76A, 0xA76C, 0xA76E, 0xA779, 0xA77B, 0xA780, 0xA782, 0xA784, 0xA786, 0xA78B, 0xA78D, 0xA790, 0xA792, 0xA796, 0xA798, 0xA79A, 0xA79C, 0xA79E, 0xA7A0, 0xA7A2, 0xA7A4, 0xA7A6, 0xA7A8, 0xA7B6, 0xA7B8, 0xA7BA, 0xA7BC, 0xA7BE, 0xA7C0, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D6, 0xA7D8, 0xA7F5);
	set.addRange(0x41, 0x5A).addRange(0xC0, 0xD6).addRange(0xD8, 0xDE).addRange(0x178, 0x179).addRange(0x181, 0x182).addRange(0x186, 0x187).addRange(0x189, 0x18B).addRange(0x18E, 0x191).addRange(0x193, 0x194).addRange(0x196, 0x198).addRange(0x19C, 0x19D).addRange(0x19F, 0x1A0).addRange(0x1A6, 0x1A7).addRange(0x1AE, 0x1AF).addRange(0x1B1, 0x1B3).addRange(0x1B7, 0x1B8).addRange(0x1C4, 0x1C5).addRange(0x1C7, 0x1C8).addRange(0x1CA, 0x1CB).addRange(0x1F1, 0x1F2).addRange(0x1F6, 0x1F8).addRange(0x23A, 0x23B).addRange(0x23D, 0x23E).addRange(0x243, 0x246).addRange(0x388, 0x38A).addRange(0x38E, 0x38F).addRange(0x391, 0x3A1).addRange(0x3A3, 0x3AB).addRange(0x3F9, 0x3FA).addRange(0x3FD, 0x42F).addRange(0x4C0, 0x4C1).addRange(0x531, 0x556).addRange(0x10A0, 0x10C5).addRange(0x13A0, 0x13F5).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1F08, 0x1F0F).addRange(0x1F18, 0x1F1D).addRange(0x1F28, 0x1F2F).addRange(0x1F38, 0x1F3F).addRange(0x1F48, 0x1F4D).addRange(0x1F68, 0x1F6F).addRange(0x1F88, 0x1F8F).addRange(0x1F98, 0x1F9F).addRange(0x1FA8, 0x1FAF).addRange(0x1FB8, 0x1FBC).addRange(0x1FC8, 0x1FCC).addRange(0x1FD8, 0x1FDB).addRange(0x1FE8, 0x1FEC).addRange(0x1FF8, 0x1FFC).addRange(0x212A, 0x212B);
	set.addRange(0x2160, 0x216F).addRange(0x24B6, 0x24CF).addRange(0x2C00, 0x2C2F).addRange(0x2C62, 0x2C64).addRange(0x2C6D, 0x2C70).addRange(0x2C7E, 0x2C80).addRange(0xA77D, 0xA77E).addRange(0xA7AA, 0xA7AE).addRange(0xA7B0, 0xA7B4).addRange(0xA7C4, 0xA7C7).addRange(0xFF21, 0xFF3A).addRange(0x10400, 0x10427).addRange(0x104B0, 0x104D3).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10C80, 0x10CB2).addRange(0x118A0, 0x118BF).addRange(0x16E40, 0x16E5F).addRange(0x1E900, 0x1E921);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_NFKC_Casefolded.js", function (module, exports) {
	  const set = regenerate(0xA0, 0xA8, 0xAA, 0xAD, 0xAF, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x136, 0x139, 0x13B, 0x13D, 0x143, 0x145, 0x147, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x17B, 0x17D, 0x17F, 0x184, 0x1A2, 0x1A4, 0x1A9, 0x1AC, 0x1B5, 0x1BC, 0x1CF, 0x1D1, 0x1D3, 0x1D5, 0x1D7, 0x1D9, 0x1DB, 0x1DE, 0x1E0, 0x1E2, 0x1E4, 0x1E6, 0x1E8, 0x1EA, 0x1EC, 0x1EE, 0x1FA, 0x1FC, 0x1FE, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20A, 0x20C, 0x20E, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21A, 0x21C, 0x21E, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22A, 0x22C, 0x22E, 0x230, 0x232, 0x241, 0x248, 0x24A, 0x24C, 0x24E, 0x34F, 0x370, 0x372, 0x374, 0x376, 0x37A, 0x38C, 0x3C2, 0x3D8, 0x3DA, 0x3DC, 0x3DE, 0x3E0, 0x3E2, 0x3E4, 0x3E6, 0x3E8, 0x3EA, 0x3EC, 0x3EE, 0x3F7, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46A, 0x46C, 0x46E, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47A, 0x47C, 0x47E, 0x480, 0x48A, 0x48C, 0x48E, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49A, 0x49C, 0x49E, 0x4A0, 0x4A2, 0x4A4, 0x4A6, 0x4A8, 0x4AA, 0x4AC, 0x4AE, 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4BC, 0x4BE, 0x4C3, 0x4C5, 0x4C7, 0x4C9, 0x4CB, 0x4CD, 0x4D0, 0x4D2, 0x4D4, 0x4D6, 0x4D8, 0x4DA, 0x4DC, 0x4DE, 0x4E0, 0x4E2, 0x4E4, 0x4E6, 0x4E8, 0x4EA, 0x4EC, 0x4EE, 0x4F0, 0x4F2, 0x4F4, 0x4F6, 0x4F8, 0x4FA, 0x4FC, 0x4FE, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50A, 0x50C, 0x50E, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51A, 0x51C, 0x51E, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52A, 0x52C, 0x52E, 0x587, 0x61C, 0x9DF, 0xA33, 0xA36, 0xA5E, 0xE33, 0xEB3, 0xF0C, 0xF43, 0xF4D, 0xF52, 0xF57, 0xF5C, 0xF69, 0xF73, 0xF81, 0xF93, 0xF9D, 0xFA2, 0xFA7, 0xFAC, 0xFB9, 0x10C7, 0x10CD, 0x10FC, 0x1D78, 0x1E00, 0x1E02, 0x1E04, 0x1E06, 0x1E08, 0x1E0A, 0x1E0C, 0x1E0E, 0x1E10, 0x1E12, 0x1E14, 0x1E16, 0x1E18, 0x1E1A, 0x1E1C, 0x1E1E, 0x1E20, 0x1E22, 0x1E24, 0x1E26, 0x1E28, 0x1E2A, 0x1E2C, 0x1E2E, 0x1E30, 0x1E32, 0x1E34, 0x1E36, 0x1E38, 0x1E3A, 0x1E3C, 0x1E3E, 0x1E40, 0x1E42, 0x1E44, 0x1E46, 0x1E48, 0x1E4A, 0x1E4C, 0x1E4E, 0x1E50, 0x1E52, 0x1E54, 0x1E56, 0x1E58, 0x1E5A, 0x1E5C, 0x1E5E, 0x1E60, 0x1E62, 0x1E64, 0x1E66, 0x1E68, 0x1E6A, 0x1E6C, 0x1E6E, 0x1E70, 0x1E72, 0x1E74, 0x1E76, 0x1E78, 0x1E7A, 0x1E7C, 0x1E7E, 0x1E80, 0x1E82, 0x1E84, 0x1E86, 0x1E88, 0x1E8A, 0x1E8C, 0x1E8E, 0x1E90, 0x1E92, 0x1E94, 0x1E9E, 0x1EA0, 0x1EA2, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAA, 0x1EAC, 0x1EAE, 0x1EB0, 0x1EB2, 0x1EB4, 0x1EB6, 0x1EB8, 0x1EBA, 0x1EBC, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1EC8, 0x1ECA, 0x1ECC, 0x1ECE, 0x1ED0, 0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EDA, 0x1EDC, 0x1EDE, 0x1EE0, 0x1EE2, 0x1EE4, 0x1EE6, 0x1EE8, 0x1EEA, 0x1EEC, 0x1EEE, 0x1EF0, 0x1EF2, 0x1EF4, 0x1EF6, 0x1EF8, 0x1EFA, 0x1EFC, 0x1EFE, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F, 0x1F71, 0x1F73, 0x1F75, 0x1F77, 0x1F79, 0x1F7B, 0x1F7D, 0x1FD3, 0x1FE3, 0x2011, 0x2017, 0x203C, 0x203E, 0x2057, 0x20A8, 0x2124, 0x2126, 0x2128, 0x2183, 0x2189, 0x2A0C, 0x2ADC, 0x2C60, 0x2C67, 0x2C69, 0x2C6B, 0x2C72, 0x2C75, 0x2C82, 0x2C84, 0x2C86, 0x2C88, 0x2C8A, 0x2C8C, 0x2C8E, 0x2C90, 0x2C92, 0x2C94, 0x2C96, 0x2C98, 0x2C9A, 0x2C9C, 0x2C9E, 0x2CA0, 0x2CA2, 0x2CA4, 0x2CA6, 0x2CA8, 0x2CAA, 0x2CAC, 0x2CAE, 0x2CB0, 0x2CB2, 0x2CB4, 0x2CB6, 0x2CB8, 0x2CBA, 0x2CBC, 0x2CBE, 0x2CC0, 0x2CC2, 0x2CC4, 0x2CC6, 0x2CC8, 0x2CCA, 0x2CCC, 0x2CCE, 0x2CD0, 0x2CD2, 0x2CD4, 0x2CD6, 0x2CD8, 0x2CDA, 0x2CDC, 0x2CDE, 0x2CE0, 0x2CE2, 0x2CEB, 0x2CED, 0x2CF2, 0x2D6F, 0x2E9F, 0x2EF3, 0x3000, 0x3036, 0x309F, 0x30FF, 0xA640, 0xA642, 0xA644, 0xA646, 0xA648, 0xA64A, 0xA64C, 0xA64E, 0xA650, 0xA652, 0xA654, 0xA656, 0xA658, 0xA65A, 0xA65C, 0xA65E, 0xA660, 0xA662, 0xA664, 0xA666, 0xA668, 0xA66A, 0xA66C, 0xA680, 0xA682, 0xA684, 0xA686, 0xA688, 0xA68A, 0xA68C, 0xA68E, 0xA690, 0xA692, 0xA694, 0xA696, 0xA698, 0xA69A, 0xA722, 0xA724, 0xA726, 0xA728, 0xA72A, 0xA72C, 0xA72E, 0xA732, 0xA734, 0xA736, 0xA738, 0xA73A, 0xA73C, 0xA73E, 0xA740, 0xA742, 0xA744, 0xA746, 0xA748, 0xA74A, 0xA74C, 0xA74E, 0xA750, 0xA752, 0xA754, 0xA756, 0xA758, 0xA75A, 0xA75C, 0xA75E, 0xA760, 0xA762, 0xA764, 0xA766, 0xA768, 0xA76A, 0xA76C, 0xA76E, 0xA770, 0xA779, 0xA77B, 0xA780, 0xA782, 0xA784, 0xA786, 0xA78B, 0xA78D, 0xA790, 0xA792, 0xA796, 0xA798, 0xA79A, 0xA79C, 0xA79E, 0xA7A0, 0xA7A2, 0xA7A4, 0xA7A6, 0xA7A8, 0xA7B6, 0xA7B8, 0xA7BA, 0xA7BC, 0xA7BE, 0xA7C0, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D6, 0xA7D8, 0xAB69, 0xFA10, 0xFA12, 0xFA20, 0xFA22, 0xFB1D, 0xFB3E, 0xFE74, 0xFEFF, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E, 0x1F190);
	set.addRange(0x41, 0x5A).addRange(0xB2, 0xB5).addRange(0xB8, 0xBA).addRange(0xBC, 0xBE).addRange(0xC0, 0xD6).addRange(0xD8, 0xDF).addRange(0x132, 0x134).addRange(0x13F, 0x141).addRange(0x149, 0x14A).addRange(0x178, 0x179).addRange(0x181, 0x182).addRange(0x186, 0x187).addRange(0x189, 0x18B).addRange(0x18E, 0x191).addRange(0x193, 0x194).addRange(0x196, 0x198).addRange(0x19C, 0x19D).addRange(0x19F, 0x1A0).addRange(0x1A6, 0x1A7).addRange(0x1AE, 0x1AF).addRange(0x1B1, 0x1B3).addRange(0x1B7, 0x1B8).addRange(0x1C4, 0x1CD).addRange(0x1F1, 0x1F4).addRange(0x1F6, 0x1F8).addRange(0x23A, 0x23B).addRange(0x23D, 0x23E).addRange(0x243, 0x246).addRange(0x2B0, 0x2B8).addRange(0x2D8, 0x2DD).addRange(0x2E0, 0x2E4).addRange(0x340, 0x341).addRange(0x343, 0x345).addRange(0x37E, 0x37F).addRange(0x384, 0x38A).addRange(0x38E, 0x38F).addRange(0x391, 0x3A1).addRange(0x3A3, 0x3AB).addRange(0x3CF, 0x3D6).addRange(0x3F0, 0x3F2).addRange(0x3F4, 0x3F5).addRange(0x3F9, 0x3FA).addRange(0x3FD, 0x42F).addRange(0x4C0, 0x4C1).addRange(0x531, 0x556).addRange(0x675, 0x678).addRange(0x958, 0x95F).addRange(0x9DC, 0x9DD).addRange(0xA59, 0xA5B).addRange(0xB5C, 0xB5D).addRange(0xEDC, 0xEDD);
	set.addRange(0xF75, 0xF79).addRange(0x10A0, 0x10C5).addRange(0x115F, 0x1160).addRange(0x13F8, 0x13FD).addRange(0x17B4, 0x17B5).addRange(0x180B, 0x180F).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1D2C, 0x1D2E).addRange(0x1D30, 0x1D3A).addRange(0x1D3C, 0x1D4D).addRange(0x1D4F, 0x1D6A).addRange(0x1D9B, 0x1DBF).addRange(0x1E9A, 0x1E9B).addRange(0x1F08, 0x1F0F).addRange(0x1F18, 0x1F1D).addRange(0x1F28, 0x1F2F).addRange(0x1F38, 0x1F3F).addRange(0x1F48, 0x1F4D).addRange(0x1F68, 0x1F6F).addRange(0x1F80, 0x1FAF).addRange(0x1FB2, 0x1FB4).addRange(0x1FB7, 0x1FC4).addRange(0x1FC7, 0x1FCF).addRange(0x1FD8, 0x1FDB).addRange(0x1FDD, 0x1FDF).addRange(0x1FE8, 0x1FEF).addRange(0x1FF2, 0x1FF4).addRange(0x1FF7, 0x1FFE).addRange(0x2000, 0x200F).addRange(0x2024, 0x2026).addRange(0x202A, 0x202F).addRange(0x2033, 0x2034).addRange(0x2036, 0x2037).addRange(0x2047, 0x2049).addRange(0x205F, 0x2071).addRange(0x2074, 0x208E).addRange(0x2090, 0x209C).addRange(0x2100, 0x2103).addRange(0x2105, 0x2107).addRange(0x2109, 0x2113).addRange(0x2115, 0x2116).addRange(0x2119, 0x211D).addRange(0x2120, 0x2122).addRange(0x212A, 0x212D).addRange(0x212F, 0x2139).addRange(0x213B, 0x2140).addRange(0x2145, 0x2149).addRange(0x2150, 0x217F).addRange(0x222C, 0x222D);
	set.addRange(0x222F, 0x2230).addRange(0x2329, 0x232A).addRange(0x2460, 0x24EA).addRange(0x2A74, 0x2A76).addRange(0x2C00, 0x2C2F).addRange(0x2C62, 0x2C64).addRange(0x2C6D, 0x2C70).addRange(0x2C7C, 0x2C80).addRange(0x2F00, 0x2FD5).addRange(0x3038, 0x303A).addRange(0x309B, 0x309C).addRange(0x3131, 0x318E).addRange(0x3192, 0x319F).addRange(0x3200, 0x321E).addRange(0x3220, 0x3247).addRange(0x3250, 0x327E).addRange(0x3280, 0x33FF).addRange(0xA69C, 0xA69D).addRange(0xA77D, 0xA77E).addRange(0xA7AA, 0xA7AE).addRange(0xA7B0, 0xA7B4).addRange(0xA7C4, 0xA7C7).addRange(0xA7F2, 0xA7F5).addRange(0xA7F8, 0xA7F9).addRange(0xAB5C, 0xAB5F).addRange(0xAB70, 0xABBF).addRange(0xF900, 0xFA0D).addRange(0xFA15, 0xFA1E).addRange(0xFA25, 0xFA26).addRange(0xFA2A, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1F, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFC).addRange(0xFE00, 0xFE19).addRange(0xFE30, 0xFE44).addRange(0xFE47, 0xFE52).addRange(0xFE54, 0xFE66).addRange(0xFE68, 0xFE6B).addRange(0xFE70, 0xFE72).addRange(0xFE76, 0xFEFC).addRange(0xFF01, 0xFFBE).addRange(0xFFC2, 0xFFC7);
	set.addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE).addRange(0xFFF0, 0xFFF8).addRange(0x10400, 0x10427).addRange(0x104B0, 0x104D3).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10781, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10C80, 0x10CB2).addRange(0x118A0, 0x118BF).addRange(0x16E40, 0x16E5F).addRange(0x1BCA0, 0x1BCA3).addRange(0x1D15E, 0x1D164).addRange(0x1D173, 0x1D17A).addRange(0x1D1BB, 0x1D1C0).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1E900, 0x1E921).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72);
	set.addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1F100, 0x1F10A).addRange(0x1F110, 0x1F12E).addRange(0x1F130, 0x1F14F).addRange(0x1F16A, 0x1F16C).addRange(0x1F200, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1FBF0, 0x1FBF9).addRange(0x2F800, 0x2FA1D).addRange(0xE0000, 0xE0FFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_Titlecased.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x183, 0x185, 0x188, 0x18C, 0x192, 0x195, 0x19E, 0x1A1, 0x1A3, 0x1A5, 0x1A8, 0x1AD, 0x1B0, 0x1B4, 0x1B6, 0x1B9, 0x1BD, 0x1BF, 0x1C4, 0x1CC, 0x1CE, 0x1D0, 0x1D2, 0x1D4, 0x1D6, 0x1D8, 0x1DA, 0x1DF, 0x1E1, 0x1E3, 0x1E5, 0x1E7, 0x1E9, 0x1EB, 0x1ED, 0x1F3, 0x1F5, 0x1F9, 0x1FB, 0x1FD, 0x1FF, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20B, 0x20D, 0x20F, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21B, 0x21D, 0x21F, 0x223, 0x225, 0x227, 0x229, 0x22B, 0x22D, 0x22F, 0x231, 0x233, 0x23C, 0x242, 0x247, 0x249, 0x24B, 0x24D, 0x259, 0x263, 0x26F, 0x275, 0x27D, 0x280, 0x292, 0x345, 0x371, 0x373, 0x377, 0x390, 0x3D9, 0x3DB, 0x3DD, 0x3DF, 0x3E1, 0x3E3, 0x3E5, 0x3E7, 0x3E9, 0x3EB, 0x3ED, 0x3F5, 0x3F8, 0x3FB, 0x461, 0x463, 0x465, 0x467, 0x469, 0x46B, 0x46D, 0x46F, 0x471, 0x473, 0x475, 0x477, 0x479, 0x47B, 0x47D, 0x47F, 0x481, 0x48B, 0x48D, 0x48F, 0x491, 0x493, 0x495, 0x497, 0x499, 0x49B, 0x49D, 0x49F, 0x4A1, 0x4A3, 0x4A5, 0x4A7, 0x4A9, 0x4AB, 0x4AD, 0x4AF, 0x4B1, 0x4B3, 0x4B5, 0x4B7, 0x4B9, 0x4BB, 0x4BD, 0x4BF, 0x4C2, 0x4C4, 0x4C6, 0x4C8, 0x4CA, 0x4CC, 0x4D1, 0x4D3, 0x4D5, 0x4D7, 0x4D9, 0x4DB, 0x4DD, 0x4DF, 0x4E1, 0x4E3, 0x4E5, 0x4E7, 0x4E9, 0x4EB, 0x4ED, 0x4EF, 0x4F1, 0x4F3, 0x4F5, 0x4F7, 0x4F9, 0x4FB, 0x4FD, 0x4FF, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50B, 0x50D, 0x50F, 0x511, 0x513, 0x515, 0x517, 0x519, 0x51B, 0x51D, 0x51F, 0x521, 0x523, 0x525, 0x527, 0x529, 0x52B, 0x52D, 0x52F, 0x1D79, 0x1D7D, 0x1D8E, 0x1E01, 0x1E03, 0x1E05, 0x1E07, 0x1E09, 0x1E0B, 0x1E0D, 0x1E0F, 0x1E11, 0x1E13, 0x1E15, 0x1E17, 0x1E19, 0x1E1B, 0x1E1D, 0x1E1F, 0x1E21, 0x1E23, 0x1E25, 0x1E27, 0x1E29, 0x1E2B, 0x1E2D, 0x1E2F, 0x1E31, 0x1E33, 0x1E35, 0x1E37, 0x1E39, 0x1E3B, 0x1E3D, 0x1E3F, 0x1E41, 0x1E43, 0x1E45, 0x1E47, 0x1E49, 0x1E4B, 0x1E4D, 0x1E4F, 0x1E51, 0x1E53, 0x1E55, 0x1E57, 0x1E59, 0x1E5B, 0x1E5D, 0x1E5F, 0x1E61, 0x1E63, 0x1E65, 0x1E67, 0x1E69, 0x1E6B, 0x1E6D, 0x1E6F, 0x1E71, 0x1E73, 0x1E75, 0x1E77, 0x1E79, 0x1E7B, 0x1E7D, 0x1E7F, 0x1E81, 0x1E83, 0x1E85, 0x1E87, 0x1E89, 0x1E8B, 0x1E8D, 0x1E8F, 0x1E91, 0x1E93, 0x1EA1, 0x1EA3, 0x1EA5, 0x1EA7, 0x1EA9, 0x1EAB, 0x1EAD, 0x1EAF, 0x1EB1, 0x1EB3, 0x1EB5, 0x1EB7, 0x1EB9, 0x1EBB, 0x1EBD, 0x1EBF, 0x1EC1, 0x1EC3, 0x1EC5, 0x1EC7, 0x1EC9, 0x1ECB, 0x1ECD, 0x1ECF, 0x1ED1, 0x1ED3, 0x1ED5, 0x1ED7, 0x1ED9, 0x1EDB, 0x1EDD, 0x1EDF, 0x1EE1, 0x1EE3, 0x1EE5, 0x1EE7, 0x1EE9, 0x1EEB, 0x1EED, 0x1EEF, 0x1EF1, 0x1EF3, 0x1EF5, 0x1EF7, 0x1EF9, 0x1EFB, 0x1EFD, 0x1FBE, 0x214E, 0x2184, 0x2C61, 0x2C68, 0x2C6A, 0x2C6C, 0x2C73, 0x2C76, 0x2C81, 0x2C83, 0x2C85, 0x2C87, 0x2C89, 0x2C8B, 0x2C8D, 0x2C8F, 0x2C91, 0x2C93, 0x2C95, 0x2C97, 0x2C99, 0x2C9B, 0x2C9D, 0x2C9F, 0x2CA1, 0x2CA3, 0x2CA5, 0x2CA7, 0x2CA9, 0x2CAB, 0x2CAD, 0x2CAF, 0x2CB1, 0x2CB3, 0x2CB5, 0x2CB7, 0x2CB9, 0x2CBB, 0x2CBD, 0x2CBF, 0x2CC1, 0x2CC3, 0x2CC5, 0x2CC7, 0x2CC9, 0x2CCB, 0x2CCD, 0x2CCF, 0x2CD1, 0x2CD3, 0x2CD5, 0x2CD7, 0x2CD9, 0x2CDB, 0x2CDD, 0x2CDF, 0x2CE1, 0x2CE3, 0x2CEC, 0x2CEE, 0x2CF3, 0x2D27, 0x2D2D, 0xA641, 0xA643, 0xA645, 0xA647, 0xA649, 0xA64B, 0xA64D, 0xA64F, 0xA651, 0xA653, 0xA655, 0xA657, 0xA659, 0xA65B, 0xA65D, 0xA65F, 0xA661, 0xA663, 0xA665, 0xA667, 0xA669, 0xA66B, 0xA66D, 0xA681, 0xA683, 0xA685, 0xA687, 0xA689, 0xA68B, 0xA68D, 0xA68F, 0xA691, 0xA693, 0xA695, 0xA697, 0xA699, 0xA69B, 0xA723, 0xA725, 0xA727, 0xA729, 0xA72B, 0xA72D, 0xA72F, 0xA733, 0xA735, 0xA737, 0xA739, 0xA73B, 0xA73D, 0xA73F, 0xA741, 0xA743, 0xA745, 0xA747, 0xA749, 0xA74B, 0xA74D, 0xA74F, 0xA751, 0xA753, 0xA755, 0xA757, 0xA759, 0xA75B, 0xA75D, 0xA75F, 0xA761, 0xA763, 0xA765, 0xA767, 0xA769, 0xA76B, 0xA76D, 0xA76F, 0xA77A, 0xA77C, 0xA77F, 0xA781, 0xA783, 0xA785, 0xA787, 0xA78C, 0xA791, 0xA797, 0xA799, 0xA79B, 0xA79D, 0xA79F, 0xA7A1, 0xA7A3, 0xA7A5, 0xA7A7, 0xA7A9, 0xA7B5, 0xA7B7, 0xA7B9, 0xA7BB, 0xA7BD, 0xA7BF, 0xA7C1, 0xA7C3, 0xA7C8, 0xA7CA, 0xA7D1, 0xA7D7, 0xA7D9, 0xA7F6, 0xAB53);
	set.addRange(0x61, 0x7A).addRange(0xDF, 0xF6).addRange(0xF8, 0xFF).addRange(0x148, 0x149).addRange(0x17E, 0x180).addRange(0x199, 0x19A).addRange(0x1C6, 0x1C7).addRange(0x1C9, 0x1CA).addRange(0x1DC, 0x1DD).addRange(0x1EF, 0x1F1).addRange(0x23F, 0x240).addRange(0x24F, 0x254).addRange(0x256, 0x257).addRange(0x25B, 0x25C).addRange(0x260, 0x261).addRange(0x265, 0x266).addRange(0x268, 0x26C).addRange(0x271, 0x272).addRange(0x282, 0x283).addRange(0x287, 0x28C).addRange(0x29D, 0x29E).addRange(0x37B, 0x37D).addRange(0x3AC, 0x3CE).addRange(0x3D0, 0x3D1).addRange(0x3D5, 0x3D7).addRange(0x3EF, 0x3F3).addRange(0x430, 0x45F).addRange(0x4CE, 0x4CF).addRange(0x561, 0x587).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1E95, 0x1E9B).addRange(0x1EFF, 0x1F07).addRange(0x1F10, 0x1F15).addRange(0x1F20, 0x1F27).addRange(0x1F30, 0x1F37).addRange(0x1F40, 0x1F45).addRange(0x1F50, 0x1F57).addRange(0x1F60, 0x1F67).addRange(0x1F70, 0x1F7D).addRange(0x1F80, 0x1F87).addRange(0x1F90, 0x1F97).addRange(0x1FA0, 0x1FA7).addRange(0x1FB0, 0x1FB4).addRange(0x1FB6, 0x1FB7).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FC7).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FD7).addRange(0x1FE0, 0x1FE7).addRange(0x1FF2, 0x1FF4);
	set.addRange(0x1FF6, 0x1FF7).addRange(0x2170, 0x217F).addRange(0x24D0, 0x24E9).addRange(0x2C30, 0x2C5F).addRange(0x2C65, 0x2C66).addRange(0x2D00, 0x2D25).addRange(0xA793, 0xA794).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF41, 0xFF5A).addRange(0x10428, 0x1044F).addRange(0x104D8, 0x104FB).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10CC0, 0x10CF2).addRange(0x118C0, 0x118DF).addRange(0x16E60, 0x16E7F).addRange(0x1E922, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Changes_When_Uppercased.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x183, 0x185, 0x188, 0x18C, 0x192, 0x195, 0x19E, 0x1A1, 0x1A3, 0x1A5, 0x1A8, 0x1AD, 0x1B0, 0x1B4, 0x1B6, 0x1B9, 0x1BD, 0x1BF, 0x1CE, 0x1D0, 0x1D2, 0x1D4, 0x1D6, 0x1D8, 0x1DA, 0x1DF, 0x1E1, 0x1E3, 0x1E5, 0x1E7, 0x1E9, 0x1EB, 0x1ED, 0x1F5, 0x1F9, 0x1FB, 0x1FD, 0x1FF, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20B, 0x20D, 0x20F, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21B, 0x21D, 0x21F, 0x223, 0x225, 0x227, 0x229, 0x22B, 0x22D, 0x22F, 0x231, 0x233, 0x23C, 0x242, 0x247, 0x249, 0x24B, 0x24D, 0x259, 0x263, 0x26F, 0x275, 0x27D, 0x280, 0x292, 0x345, 0x371, 0x373, 0x377, 0x390, 0x3D9, 0x3DB, 0x3DD, 0x3DF, 0x3E1, 0x3E3, 0x3E5, 0x3E7, 0x3E9, 0x3EB, 0x3ED, 0x3F5, 0x3F8, 0x3FB, 0x461, 0x463, 0x465, 0x467, 0x469, 0x46B, 0x46D, 0x46F, 0x471, 0x473, 0x475, 0x477, 0x479, 0x47B, 0x47D, 0x47F, 0x481, 0x48B, 0x48D, 0x48F, 0x491, 0x493, 0x495, 0x497, 0x499, 0x49B, 0x49D, 0x49F, 0x4A1, 0x4A3, 0x4A5, 0x4A7, 0x4A9, 0x4AB, 0x4AD, 0x4AF, 0x4B1, 0x4B3, 0x4B5, 0x4B7, 0x4B9, 0x4BB, 0x4BD, 0x4BF, 0x4C2, 0x4C4, 0x4C6, 0x4C8, 0x4CA, 0x4CC, 0x4D1, 0x4D3, 0x4D5, 0x4D7, 0x4D9, 0x4DB, 0x4DD, 0x4DF, 0x4E1, 0x4E3, 0x4E5, 0x4E7, 0x4E9, 0x4EB, 0x4ED, 0x4EF, 0x4F1, 0x4F3, 0x4F5, 0x4F7, 0x4F9, 0x4FB, 0x4FD, 0x4FF, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50B, 0x50D, 0x50F, 0x511, 0x513, 0x515, 0x517, 0x519, 0x51B, 0x51D, 0x51F, 0x521, 0x523, 0x525, 0x527, 0x529, 0x52B, 0x52D, 0x52F, 0x1D79, 0x1D7D, 0x1D8E, 0x1E01, 0x1E03, 0x1E05, 0x1E07, 0x1E09, 0x1E0B, 0x1E0D, 0x1E0F, 0x1E11, 0x1E13, 0x1E15, 0x1E17, 0x1E19, 0x1E1B, 0x1E1D, 0x1E1F, 0x1E21, 0x1E23, 0x1E25, 0x1E27, 0x1E29, 0x1E2B, 0x1E2D, 0x1E2F, 0x1E31, 0x1E33, 0x1E35, 0x1E37, 0x1E39, 0x1E3B, 0x1E3D, 0x1E3F, 0x1E41, 0x1E43, 0x1E45, 0x1E47, 0x1E49, 0x1E4B, 0x1E4D, 0x1E4F, 0x1E51, 0x1E53, 0x1E55, 0x1E57, 0x1E59, 0x1E5B, 0x1E5D, 0x1E5F, 0x1E61, 0x1E63, 0x1E65, 0x1E67, 0x1E69, 0x1E6B, 0x1E6D, 0x1E6F, 0x1E71, 0x1E73, 0x1E75, 0x1E77, 0x1E79, 0x1E7B, 0x1E7D, 0x1E7F, 0x1E81, 0x1E83, 0x1E85, 0x1E87, 0x1E89, 0x1E8B, 0x1E8D, 0x1E8F, 0x1E91, 0x1E93, 0x1EA1, 0x1EA3, 0x1EA5, 0x1EA7, 0x1EA9, 0x1EAB, 0x1EAD, 0x1EAF, 0x1EB1, 0x1EB3, 0x1EB5, 0x1EB7, 0x1EB9, 0x1EBB, 0x1EBD, 0x1EBF, 0x1EC1, 0x1EC3, 0x1EC5, 0x1EC7, 0x1EC9, 0x1ECB, 0x1ECD, 0x1ECF, 0x1ED1, 0x1ED3, 0x1ED5, 0x1ED7, 0x1ED9, 0x1EDB, 0x1EDD, 0x1EDF, 0x1EE1, 0x1EE3, 0x1EE5, 0x1EE7, 0x1EE9, 0x1EEB, 0x1EED, 0x1EEF, 0x1EF1, 0x1EF3, 0x1EF5, 0x1EF7, 0x1EF9, 0x1EFB, 0x1EFD, 0x1FBC, 0x1FBE, 0x1FCC, 0x1FFC, 0x214E, 0x2184, 0x2C61, 0x2C68, 0x2C6A, 0x2C6C, 0x2C73, 0x2C76, 0x2C81, 0x2C83, 0x2C85, 0x2C87, 0x2C89, 0x2C8B, 0x2C8D, 0x2C8F, 0x2C91, 0x2C93, 0x2C95, 0x2C97, 0x2C99, 0x2C9B, 0x2C9D, 0x2C9F, 0x2CA1, 0x2CA3, 0x2CA5, 0x2CA7, 0x2CA9, 0x2CAB, 0x2CAD, 0x2CAF, 0x2CB1, 0x2CB3, 0x2CB5, 0x2CB7, 0x2CB9, 0x2CBB, 0x2CBD, 0x2CBF, 0x2CC1, 0x2CC3, 0x2CC5, 0x2CC7, 0x2CC9, 0x2CCB, 0x2CCD, 0x2CCF, 0x2CD1, 0x2CD3, 0x2CD5, 0x2CD7, 0x2CD9, 0x2CDB, 0x2CDD, 0x2CDF, 0x2CE1, 0x2CE3, 0x2CEC, 0x2CEE, 0x2CF3, 0x2D27, 0x2D2D, 0xA641, 0xA643, 0xA645, 0xA647, 0xA649, 0xA64B, 0xA64D, 0xA64F, 0xA651, 0xA653, 0xA655, 0xA657, 0xA659, 0xA65B, 0xA65D, 0xA65F, 0xA661, 0xA663, 0xA665, 0xA667, 0xA669, 0xA66B, 0xA66D, 0xA681, 0xA683, 0xA685, 0xA687, 0xA689, 0xA68B, 0xA68D, 0xA68F, 0xA691, 0xA693, 0xA695, 0xA697, 0xA699, 0xA69B, 0xA723, 0xA725, 0xA727, 0xA729, 0xA72B, 0xA72D, 0xA72F, 0xA733, 0xA735, 0xA737, 0xA739, 0xA73B, 0xA73D, 0xA73F, 0xA741, 0xA743, 0xA745, 0xA747, 0xA749, 0xA74B, 0xA74D, 0xA74F, 0xA751, 0xA753, 0xA755, 0xA757, 0xA759, 0xA75B, 0xA75D, 0xA75F, 0xA761, 0xA763, 0xA765, 0xA767, 0xA769, 0xA76B, 0xA76D, 0xA76F, 0xA77A, 0xA77C, 0xA77F, 0xA781, 0xA783, 0xA785, 0xA787, 0xA78C, 0xA791, 0xA797, 0xA799, 0xA79B, 0xA79D, 0xA79F, 0xA7A1, 0xA7A3, 0xA7A5, 0xA7A7, 0xA7A9, 0xA7B5, 0xA7B7, 0xA7B9, 0xA7BB, 0xA7BD, 0xA7BF, 0xA7C1, 0xA7C3, 0xA7C8, 0xA7CA, 0xA7D1, 0xA7D7, 0xA7D9, 0xA7F6, 0xAB53);
	set.addRange(0x61, 0x7A).addRange(0xDF, 0xF6).addRange(0xF8, 0xFF).addRange(0x148, 0x149).addRange(0x17E, 0x180).addRange(0x199, 0x19A).addRange(0x1C5, 0x1C6).addRange(0x1C8, 0x1C9).addRange(0x1CB, 0x1CC).addRange(0x1DC, 0x1DD).addRange(0x1EF, 0x1F0).addRange(0x1F2, 0x1F3).addRange(0x23F, 0x240).addRange(0x24F, 0x254).addRange(0x256, 0x257).addRange(0x25B, 0x25C).addRange(0x260, 0x261).addRange(0x265, 0x266).addRange(0x268, 0x26C).addRange(0x271, 0x272).addRange(0x282, 0x283).addRange(0x287, 0x28C).addRange(0x29D, 0x29E).addRange(0x37B, 0x37D).addRange(0x3AC, 0x3CE).addRange(0x3D0, 0x3D1).addRange(0x3D5, 0x3D7).addRange(0x3EF, 0x3F3).addRange(0x430, 0x45F).addRange(0x4CE, 0x4CF).addRange(0x561, 0x587).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1E95, 0x1E9B).addRange(0x1EFF, 0x1F07).addRange(0x1F10, 0x1F15).addRange(0x1F20, 0x1F27).addRange(0x1F30, 0x1F37).addRange(0x1F40, 0x1F45).addRange(0x1F50, 0x1F57).addRange(0x1F60, 0x1F67).addRange(0x1F70, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FB7).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FC7).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FD7).addRange(0x1FE0, 0x1FE7);
	set.addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FF7).addRange(0x2170, 0x217F).addRange(0x24D0, 0x24E9).addRange(0x2C30, 0x2C5F).addRange(0x2C65, 0x2C66).addRange(0x2D00, 0x2D25).addRange(0xA793, 0xA794).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF41, 0xFF5A).addRange(0x10428, 0x1044F).addRange(0x104D8, 0x104FB).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10CC0, 0x10CF2).addRange(0x118C0, 0x118DF).addRange(0x16E60, 0x16E7F).addRange(0x1E922, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Dash.js", function (module, exports) {
	  const set = regenerate(0x2D, 0x58A, 0x5BE, 0x1400, 0x1806, 0x2053, 0x207B, 0x208B, 0x2212, 0x2E17, 0x2E1A, 0x2E40, 0x2E5D, 0x301C, 0x3030, 0x30A0, 0xFE58, 0xFE63, 0xFF0D, 0x10EAD);
	set.addRange(0x2010, 0x2015).addRange(0x2E3A, 0x2E3B).addRange(0xFE31, 0xFE32);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Default_Ignorable_Code_Point.js", function (module, exports) {
	  const set = regenerate(0xAD, 0x34F, 0x61C, 0x3164, 0xFEFF, 0xFFA0);
	set.addRange(0x115F, 0x1160).addRange(0x17B4, 0x17B5).addRange(0x180B, 0x180F).addRange(0x200B, 0x200F).addRange(0x202A, 0x202E).addRange(0x2060, 0x206F).addRange(0xFE00, 0xFE0F).addRange(0xFFF0, 0xFFF8).addRange(0x1BCA0, 0x1BCA3).addRange(0x1D173, 0x1D17A).addRange(0xE0000, 0xE0FFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Deprecated.js", function (module, exports) {
	  const set = regenerate(0x149, 0x673, 0xF77, 0xF79, 0xE0001);
	set.addRange(0x17A3, 0x17A4).addRange(0x206A, 0x206F).addRange(0x2329, 0x232A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Diacritic.js", function (module, exports) {
	  const set = regenerate(0x5E, 0x60, 0xA8, 0xAF, 0xB4, 0x37A, 0x559, 0x5BF, 0x5C4, 0x93C, 0x94D, 0x971, 0x9BC, 0x9CD, 0xA3C, 0xA4D, 0xABC, 0xACD, 0xB3C, 0xB4D, 0xB55, 0xBCD, 0xC3C, 0xC4D, 0xCBC, 0xCCD, 0xD4D, 0xDCA, 0xE4E, 0xEBA, 0xF35, 0xF37, 0xF39, 0xFC6, 0x1037, 0x108F, 0x17DD, 0x1A7F, 0x1B34, 0x1B44, 0x1CED, 0x1CF4, 0x1FBD, 0x2E2F, 0x30FC, 0xA66F, 0xA67F, 0xA8C4, 0xA953, 0xA9B3, 0xA9C0, 0xA9E5, 0xAAF6, 0xFB1E, 0xFF3E, 0xFF40, 0xFF70, 0xFFE3, 0x102E0, 0x11046, 0x11070, 0x11173, 0x111C0, 0x1133C, 0x1134D, 0x11442, 0x11446, 0x1163F, 0x1172B, 0x11943, 0x119E0, 0x11A34, 0x11A47, 0x11A99, 0x11C3F, 0x11D42, 0x11D97, 0x1E2AE);
	set.addRange(0xB7, 0xB8).addRange(0x2B0, 0x34E).addRange(0x350, 0x357).addRange(0x35D, 0x362).addRange(0x374, 0x375).addRange(0x384, 0x385).addRange(0x483, 0x487).addRange(0x591, 0x5A1).addRange(0x5A3, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x64B, 0x652).addRange(0x657, 0x658).addRange(0x6DF, 0x6E0).addRange(0x6E5, 0x6E6).addRange(0x6EA, 0x6EC).addRange(0x730, 0x74A).addRange(0x7A6, 0x7B0).addRange(0x7EB, 0x7F5).addRange(0x818, 0x819).addRange(0x898, 0x89F).addRange(0x8C9, 0x8D2).addRange(0x8E3, 0x8FE).addRange(0x951, 0x954).addRange(0xAFD, 0xAFF).addRange(0xD3B, 0xD3C).addRange(0xE47, 0xE4C).addRange(0xEC8, 0xECC).addRange(0xF18, 0xF19).addRange(0xF3E, 0xF3F).addRange(0xF82, 0xF84).addRange(0xF86, 0xF87).addRange(0x1039, 0x103A).addRange(0x1063, 0x1064).addRange(0x1069, 0x106D).addRange(0x1087, 0x108D).addRange(0x109A, 0x109B).addRange(0x135D, 0x135F).addRange(0x1714, 0x1715).addRange(0x17C9, 0x17D3).addRange(0x1939, 0x193B).addRange(0x1A75, 0x1A7C).addRange(0x1AB0, 0x1ABE).addRange(0x1AC1, 0x1ACB).addRange(0x1B6B, 0x1B73).addRange(0x1BAA, 0x1BAB).addRange(0x1C36, 0x1C37).addRange(0x1C78, 0x1C7D).addRange(0x1CD0, 0x1CE8).addRange(0x1CF7, 0x1CF9).addRange(0x1D2C, 0x1D6A).addRange(0x1DC4, 0x1DCF);
	set.addRange(0x1DF5, 0x1DFF).addRange(0x1FBF, 0x1FC1).addRange(0x1FCD, 0x1FCF).addRange(0x1FDD, 0x1FDF).addRange(0x1FED, 0x1FEF).addRange(0x1FFD, 0x1FFE).addRange(0x2CEF, 0x2CF1).addRange(0x302A, 0x302F).addRange(0x3099, 0x309C).addRange(0xA67C, 0xA67D).addRange(0xA69C, 0xA69D).addRange(0xA6F0, 0xA6F1).addRange(0xA700, 0xA721).addRange(0xA788, 0xA78A).addRange(0xA7F8, 0xA7F9).addRange(0xA8E0, 0xA8F1).addRange(0xA92B, 0xA92E).addRange(0xAA7B, 0xAA7D).addRange(0xAABF, 0xAAC2).addRange(0xAB5B, 0xAB5F).addRange(0xAB69, 0xAB6B).addRange(0xABEC, 0xABED).addRange(0xFE20, 0xFE2F).addRange(0xFF9E, 0xFF9F).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10AE5, 0x10AE6).addRange(0x10D22, 0x10D27).addRange(0x10F46, 0x10F50).addRange(0x10F82, 0x10F85).addRange(0x110B9, 0x110BA).addRange(0x11133, 0x11134).addRange(0x111CA, 0x111CC).addRange(0x11235, 0x11236).addRange(0x112E9, 0x112EA).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x114C2, 0x114C3).addRange(0x115BF, 0x115C0).addRange(0x116B6, 0x116B7).addRange(0x11839, 0x1183A).addRange(0x1193D, 0x1193E).addRange(0x11D44, 0x11D45).addRange(0x16AF0, 0x16AF4).addRange(0x16B30, 0x16B36).addRange(0x16F8F, 0x16F9F).addRange(0x16FF0, 0x16FF1).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE);
	set.addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169).addRange(0x1D16D, 0x1D172).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1E130, 0x1E136).addRange(0x1E2EC, 0x1E2EF).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E944, 0x1E946).addRange(0x1E948, 0x1E94A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Emoji_Component.js", function (module, exports) {
	  const set = regenerate(0x23, 0x2A, 0x200D, 0x20E3, 0xFE0F);
	set.addRange(0x30, 0x39).addRange(0x1F1E6, 0x1F1FF).addRange(0x1F3FB, 0x1F3FF).addRange(0x1F9B0, 0x1F9B3).addRange(0xE0020, 0xE007F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Emoji_Modifier_Base.js", function (module, exports) {
	  const set = regenerate(0x261D, 0x26F9, 0x1F385, 0x1F3C7, 0x1F47C, 0x1F48F, 0x1F491, 0x1F4AA, 0x1F57A, 0x1F590, 0x1F6A3, 0x1F6C0, 0x1F6CC, 0x1F90C, 0x1F90F, 0x1F926, 0x1F977, 0x1F9BB);
	set.addRange(0x270A, 0x270D).addRange(0x1F3C2, 0x1F3C4).addRange(0x1F3CA, 0x1F3CC).addRange(0x1F442, 0x1F443).addRange(0x1F446, 0x1F450).addRange(0x1F466, 0x1F478).addRange(0x1F481, 0x1F483).addRange(0x1F485, 0x1F487).addRange(0x1F574, 0x1F575).addRange(0x1F595, 0x1F596).addRange(0x1F645, 0x1F647).addRange(0x1F64B, 0x1F64F).addRange(0x1F6B4, 0x1F6B6).addRange(0x1F918, 0x1F91F).addRange(0x1F930, 0x1F939).addRange(0x1F93C, 0x1F93E).addRange(0x1F9B5, 0x1F9B6).addRange(0x1F9B8, 0x1F9B9).addRange(0x1F9CD, 0x1F9CF).addRange(0x1F9D1, 0x1F9DD).addRange(0x1FAC3, 0x1FAC5).addRange(0x1FAF0, 0x1FAF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Emoji_Modifier.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1F3FB, 0x1F3FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Emoji_Presentation.js", function (module, exports) {
	  const set = regenerate(0x23F0, 0x23F3, 0x267F, 0x2693, 0x26A1, 0x26CE, 0x26D4, 0x26EA, 0x26F5, 0x26FA, 0x26FD, 0x2705, 0x2728, 0x274C, 0x274E, 0x2757, 0x27B0, 0x27BF, 0x2B50, 0x2B55, 0x1F004, 0x1F0CF, 0x1F18E, 0x1F201, 0x1F21A, 0x1F22F, 0x1F3F4, 0x1F440, 0x1F57A, 0x1F5A4, 0x1F6CC, 0x1F7F0);
	set.addRange(0x231A, 0x231B).addRange(0x23E9, 0x23EC).addRange(0x25FD, 0x25FE).addRange(0x2614, 0x2615).addRange(0x2648, 0x2653).addRange(0x26AA, 0x26AB).addRange(0x26BD, 0x26BE).addRange(0x26C4, 0x26C5).addRange(0x26F2, 0x26F3).addRange(0x270A, 0x270B).addRange(0x2753, 0x2755).addRange(0x2795, 0x2797).addRange(0x2B1B, 0x2B1C).addRange(0x1F191, 0x1F19A).addRange(0x1F1E6, 0x1F1FF).addRange(0x1F232, 0x1F236).addRange(0x1F238, 0x1F23A).addRange(0x1F250, 0x1F251).addRange(0x1F300, 0x1F320).addRange(0x1F32D, 0x1F335).addRange(0x1F337, 0x1F37C).addRange(0x1F37E, 0x1F393).addRange(0x1F3A0, 0x1F3CA).addRange(0x1F3CF, 0x1F3D3).addRange(0x1F3E0, 0x1F3F0).addRange(0x1F3F8, 0x1F43E).addRange(0x1F442, 0x1F4FC).addRange(0x1F4FF, 0x1F53D).addRange(0x1F54B, 0x1F54E).addRange(0x1F550, 0x1F567).addRange(0x1F595, 0x1F596).addRange(0x1F5FB, 0x1F64F).addRange(0x1F680, 0x1F6C5).addRange(0x1F6D0, 0x1F6D2).addRange(0x1F6D5, 0x1F6D7).addRange(0x1F6DD, 0x1F6DF).addRange(0x1F6EB, 0x1F6EC).addRange(0x1F6F4, 0x1F6FC).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F90C, 0x1F93A).addRange(0x1F93C, 0x1F945).addRange(0x1F947, 0x1F9FF).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Emoji.js", function (module, exports) {
	  const set = regenerate(0x23, 0x2A, 0xA9, 0xAE, 0x203C, 0x2049, 0x2122, 0x2139, 0x2328, 0x23CF, 0x24C2, 0x25B6, 0x25C0, 0x260E, 0x2611, 0x2618, 0x261D, 0x2620, 0x2626, 0x262A, 0x2640, 0x2642, 0x2663, 0x2668, 0x267B, 0x2699, 0x26A7, 0x26C8, 0x26D1, 0x26FD, 0x2702, 0x2705, 0x270F, 0x2712, 0x2714, 0x2716, 0x271D, 0x2721, 0x2728, 0x2744, 0x2747, 0x274C, 0x274E, 0x2757, 0x27A1, 0x27B0, 0x27BF, 0x2B50, 0x2B55, 0x3030, 0x303D, 0x3297, 0x3299, 0x1F004, 0x1F0CF, 0x1F18E, 0x1F21A, 0x1F22F, 0x1F587, 0x1F590, 0x1F5A8, 0x1F5BC, 0x1F5E1, 0x1F5E3, 0x1F5E8, 0x1F5EF, 0x1F5F3, 0x1F6E9, 0x1F6F0, 0x1F7F0);
	set.addRange(0x30, 0x39).addRange(0x2194, 0x2199).addRange(0x21A9, 0x21AA).addRange(0x231A, 0x231B).addRange(0x23E9, 0x23F3).addRange(0x23F8, 0x23FA).addRange(0x25AA, 0x25AB).addRange(0x25FB, 0x25FE).addRange(0x2600, 0x2604).addRange(0x2614, 0x2615).addRange(0x2622, 0x2623).addRange(0x262E, 0x262F).addRange(0x2638, 0x263A).addRange(0x2648, 0x2653).addRange(0x265F, 0x2660).addRange(0x2665, 0x2666).addRange(0x267E, 0x267F).addRange(0x2692, 0x2697).addRange(0x269B, 0x269C).addRange(0x26A0, 0x26A1).addRange(0x26AA, 0x26AB).addRange(0x26B0, 0x26B1).addRange(0x26BD, 0x26BE).addRange(0x26C4, 0x26C5).addRange(0x26CE, 0x26CF).addRange(0x26D3, 0x26D4).addRange(0x26E9, 0x26EA).addRange(0x26F0, 0x26F5).addRange(0x26F7, 0x26FA).addRange(0x2708, 0x270D).addRange(0x2733, 0x2734).addRange(0x2753, 0x2755).addRange(0x2763, 0x2764).addRange(0x2795, 0x2797).addRange(0x2934, 0x2935).addRange(0x2B05, 0x2B07).addRange(0x2B1B, 0x2B1C).addRange(0x1F170, 0x1F171).addRange(0x1F17E, 0x1F17F).addRange(0x1F191, 0x1F19A).addRange(0x1F1E6, 0x1F1FF).addRange(0x1F201, 0x1F202).addRange(0x1F232, 0x1F23A).addRange(0x1F250, 0x1F251).addRange(0x1F300, 0x1F321).addRange(0x1F324, 0x1F393).addRange(0x1F396, 0x1F397).addRange(0x1F399, 0x1F39B).addRange(0x1F39E, 0x1F3F0).addRange(0x1F3F3, 0x1F3F5).addRange(0x1F3F7, 0x1F4FD);
	set.addRange(0x1F4FF, 0x1F53D).addRange(0x1F549, 0x1F54E).addRange(0x1F550, 0x1F567).addRange(0x1F56F, 0x1F570).addRange(0x1F573, 0x1F57A).addRange(0x1F58A, 0x1F58D).addRange(0x1F595, 0x1F596).addRange(0x1F5A4, 0x1F5A5).addRange(0x1F5B1, 0x1F5B2).addRange(0x1F5C2, 0x1F5C4).addRange(0x1F5D1, 0x1F5D3).addRange(0x1F5DC, 0x1F5DE).addRange(0x1F5FA, 0x1F64F).addRange(0x1F680, 0x1F6C5).addRange(0x1F6CB, 0x1F6D2).addRange(0x1F6D5, 0x1F6D7).addRange(0x1F6DD, 0x1F6E5).addRange(0x1F6EB, 0x1F6EC).addRange(0x1F6F3, 0x1F6FC).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F90C, 0x1F93A).addRange(0x1F93C, 0x1F945).addRange(0x1F947, 0x1F9FF).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Extended_Pictographic.js", function (module, exports) {
	  const set = regenerate(0xA9, 0xAE, 0x203C, 0x2049, 0x2122, 0x2139, 0x2328, 0x2388, 0x23CF, 0x24C2, 0x25B6, 0x25C0, 0x2714, 0x2716, 0x271D, 0x2721, 0x2728, 0x2744, 0x2747, 0x274C, 0x274E, 0x2757, 0x27A1, 0x27B0, 0x27BF, 0x2B50, 0x2B55, 0x3030, 0x303D, 0x3297, 0x3299, 0x1F12F, 0x1F18E, 0x1F21A, 0x1F22F);
	set.addRange(0x2194, 0x2199).addRange(0x21A9, 0x21AA).addRange(0x231A, 0x231B).addRange(0x23E9, 0x23F3).addRange(0x23F8, 0x23FA).addRange(0x25AA, 0x25AB).addRange(0x25FB, 0x25FE).addRange(0x2600, 0x2605).addRange(0x2607, 0x2612).addRange(0x2614, 0x2685).addRange(0x2690, 0x2705).addRange(0x2708, 0x2712).addRange(0x2733, 0x2734).addRange(0x2753, 0x2755).addRange(0x2763, 0x2767).addRange(0x2795, 0x2797).addRange(0x2934, 0x2935).addRange(0x2B05, 0x2B07).addRange(0x2B1B, 0x2B1C).addRange(0x1F000, 0x1F0FF).addRange(0x1F10D, 0x1F10F).addRange(0x1F16C, 0x1F171).addRange(0x1F17E, 0x1F17F).addRange(0x1F191, 0x1F19A).addRange(0x1F1AD, 0x1F1E5).addRange(0x1F201, 0x1F20F).addRange(0x1F232, 0x1F23A).addRange(0x1F23C, 0x1F23F).addRange(0x1F249, 0x1F3FA).addRange(0x1F400, 0x1F53D).addRange(0x1F546, 0x1F64F).addRange(0x1F680, 0x1F6FF).addRange(0x1F774, 0x1F77F).addRange(0x1F7D5, 0x1F7FF).addRange(0x1F80C, 0x1F80F).addRange(0x1F848, 0x1F84F).addRange(0x1F85A, 0x1F85F).addRange(0x1F888, 0x1F88F).addRange(0x1F8AE, 0x1F8FF).addRange(0x1F90C, 0x1F93A).addRange(0x1F93C, 0x1F945).addRange(0x1F947, 0x1FAFF).addRange(0x1FC00, 0x1FFFD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Extender.js", function (module, exports) {
	  const set = regenerate(0xB7, 0x640, 0x7FA, 0xB55, 0xE46, 0xEC6, 0x180A, 0x1843, 0x1AA7, 0x1C36, 0x1C7B, 0x3005, 0xA015, 0xA60C, 0xA9CF, 0xA9E6, 0xAA70, 0xAADD, 0xFF70, 0x1135D, 0x11A98, 0x16FE3);
	set.addRange(0x2D0, 0x2D1).addRange(0x3031, 0x3035).addRange(0x309D, 0x309E).addRange(0x30FC, 0x30FE).addRange(0xAAF3, 0xAAF4).addRange(0x10781, 0x10782).addRange(0x115C6, 0x115C8).addRange(0x16B42, 0x16B43).addRange(0x16FE0, 0x16FE1).addRange(0x1E13C, 0x1E13D).addRange(0x1E944, 0x1E946);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Grapheme_Base.js", function (module, exports) {
	  const set = regenerate(0x38C, 0x5BE, 0x5C0, 0x5C3, 0x5C6, 0x61B, 0x6DE, 0x6E9, 0x710, 0x7B1, 0x81A, 0x824, 0x828, 0x85E, 0x93B, 0x9B2, 0x9BD, 0x9CE, 0xA03, 0xA5E, 0xA76, 0xA83, 0xAC9, 0xAD0, 0xAF9, 0xB3D, 0xB40, 0xB83, 0xB9C, 0xBBF, 0xBD0, 0xC3D, 0xC5D, 0xD3D, 0xDBD, 0xE84, 0xEA5, 0xEBD, 0xEC6, 0xF36, 0xF38, 0xF7F, 0xF85, 0x1031, 0x1038, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x1715, 0x17B6, 0x18AA, 0x1940, 0x1A57, 0x1A61, 0x1B3B, 0x1BAA, 0x1BE7, 0x1BEE, 0x1CD3, 0x1CE1, 0x1CFA, 0x1F59, 0x1F5B, 0x1F5D, 0x2D27, 0x2D2D, 0xA673, 0xA7D3, 0xAA4D, 0xAAB1, 0xAAC0, 0xAAC2, 0xFB1D, 0xFB3E, 0xFDCF, 0x101A0, 0x10808, 0x1083C, 0x1093F, 0x10EAD, 0x11000, 0x11075, 0x1112C, 0x11235, 0x11288, 0x1133D, 0x1133F, 0x11350, 0x11445, 0x1145D, 0x114B9, 0x114BE, 0x114C1, 0x115BE, 0x1163E, 0x116AC, 0x116B6, 0x11726, 0x11838, 0x1183B, 0x11909, 0x1193D, 0x11A00, 0x11A50, 0x11A97, 0x11C3E, 0x11CA9, 0x11CB1, 0x11CB4, 0x11D46, 0x11D96, 0x11D98, 0x11FB0, 0x16AF5, 0x1BC9C, 0x1BC9F, 0x1D166, 0x1D245, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E2FF, 0x1E94B, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E, 0x1F7F0);
	set.addRange(0x20, 0x7E).addRange(0xA0, 0xAC).addRange(0xAE, 0x2FF).addRange(0x370, 0x377).addRange(0x37A, 0x37F).addRange(0x384, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x482).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x559, 0x58A).addRange(0x58D, 0x58F).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F4).addRange(0x606, 0x60F).addRange(0x61D, 0x64A).addRange(0x660, 0x66F).addRange(0x671, 0x6D5).addRange(0x6E5, 0x6E6).addRange(0x6EE, 0x70D).addRange(0x712, 0x72F).addRange(0x74D, 0x7A5).addRange(0x7C0, 0x7EA).addRange(0x7F4, 0x7FA).addRange(0x7FE, 0x815).addRange(0x830, 0x83E).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x88E).addRange(0x8A0, 0x8C9).addRange(0x903, 0x939).addRange(0x93D, 0x940).addRange(0x949, 0x94C).addRange(0x94E, 0x950).addRange(0x958, 0x961).addRange(0x964, 0x980).addRange(0x982, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BF, 0x9C0).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CC).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E1).addRange(0x9E6, 0x9FD).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28);
	set.addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA40).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA6F).addRange(0xA72, 0xA74).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABD, 0xAC0).addRange(0xACB, 0xACC).addRange(0xAE0, 0xAE1).addRange(0xAE6, 0xAF1).addRange(0xB02, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4C).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB61).addRange(0xB66, 0xB77).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xBC1, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCC).addRange(0xBE6, 0xBFA).addRange(0xC01, 0xC03).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC41, 0xC44).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC61).addRange(0xC66, 0xC6F);
	set.addRange(0xC77, 0xC80).addRange(0xC82, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBD, 0xCBE).addRange(0xCC0, 0xCC1).addRange(0xCC3, 0xCC4).addRange(0xCC7, 0xCC8).addRange(0xCCA, 0xCCB).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE1).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2).addRange(0xD02, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD3F, 0xD40).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4C).addRange(0xD4E, 0xD4F).addRange(0xD54, 0xD56).addRange(0xD58, 0xD61).addRange(0xD66, 0xD7F).addRange(0xD82, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDD0, 0xDD1).addRange(0xDD8, 0xDDE).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF4).addRange(0xE01, 0xE30).addRange(0xE32, 0xE33).addRange(0xE3F, 0xE46).addRange(0xE4F, 0xE5B).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB0).addRange(0xEB2, 0xEB3).addRange(0xEC0, 0xEC4).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF).addRange(0xF00, 0xF17).addRange(0xF1A, 0xF34).addRange(0xF3A, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF88, 0xF8C);
	set.addRange(0xFBE, 0xFC5).addRange(0xFC7, 0xFCC).addRange(0xFCE, 0xFDA).addRange(0x1000, 0x102C).addRange(0x103B, 0x103C).addRange(0x103F, 0x1057).addRange(0x105A, 0x105D).addRange(0x1061, 0x1070).addRange(0x1075, 0x1081).addRange(0x1083, 0x1084).addRange(0x1087, 0x108C).addRange(0x108E, 0x109C).addRange(0x109E, 0x10C5).addRange(0x10D0, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1360, 0x137C).addRange(0x1380, 0x1399).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1400, 0x169C).addRange(0x16A0, 0x16F8).addRange(0x1700, 0x1711).addRange(0x171F, 0x1731).addRange(0x1734, 0x1736).addRange(0x1740, 0x1751).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1780, 0x17B3).addRange(0x17BE, 0x17C5).addRange(0x17C7, 0x17C8).addRange(0x17D4, 0x17DC).addRange(0x17E0, 0x17E9).addRange(0x17F0, 0x17F9).addRange(0x1800, 0x180A).addRange(0x1810, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x1884).addRange(0x1887, 0x18A8).addRange(0x18B0, 0x18F5);
	set.addRange(0x1900, 0x191E).addRange(0x1923, 0x1926).addRange(0x1929, 0x192B).addRange(0x1930, 0x1931).addRange(0x1933, 0x1938).addRange(0x1944, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x19DE, 0x1A16).addRange(0x1A19, 0x1A1A).addRange(0x1A1E, 0x1A55).addRange(0x1A63, 0x1A64).addRange(0x1A6D, 0x1A72).addRange(0x1A80, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AA0, 0x1AAD).addRange(0x1B04, 0x1B33).addRange(0x1B3D, 0x1B41).addRange(0x1B43, 0x1B4C).addRange(0x1B50, 0x1B6A).addRange(0x1B74, 0x1B7E).addRange(0x1B82, 0x1BA1).addRange(0x1BA6, 0x1BA7).addRange(0x1BAE, 0x1BE5).addRange(0x1BEA, 0x1BEC).addRange(0x1BF2, 0x1BF3).addRange(0x1BFC, 0x1C2B).addRange(0x1C34, 0x1C35).addRange(0x1C3B, 0x1C49).addRange(0x1C4D, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CC7).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF7).addRange(0x1D00, 0x1DBF).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FC4).addRange(0x1FC6, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FDD, 0x1FEF).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFE);
	set.addRange(0x2000, 0x200A).addRange(0x2010, 0x2027).addRange(0x202F, 0x205F).addRange(0x2070, 0x2071).addRange(0x2074, 0x208E).addRange(0x2090, 0x209C).addRange(0x20A0, 0x20C0).addRange(0x2100, 0x218B).addRange(0x2190, 0x2426).addRange(0x2440, 0x244A).addRange(0x2460, 0x2B73).addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2CF9, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D6F, 0x2D70).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x2E00, 0x2E5D).addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x2FF0, 0x2FFB).addRange(0x3000, 0x3029).addRange(0x3030, 0x303F).addRange(0x3041, 0x3096).addRange(0x309B, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x3190, 0x31E3).addRange(0x31F0, 0x321E).addRange(0x3220, 0xA48C).addRange(0xA490, 0xA4C6).addRange(0xA4D0, 0xA62B).addRange(0xA640, 0xA66E).addRange(0xA67E, 0xA69D).addRange(0xA6A0, 0xA6EF).addRange(0xA6F2, 0xA6F7).addRange(0xA700, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA801).addRange(0xA803, 0xA805);
	set.addRange(0xA807, 0xA80A).addRange(0xA80C, 0xA824).addRange(0xA827, 0xA82B).addRange(0xA830, 0xA839).addRange(0xA840, 0xA877).addRange(0xA880, 0xA8C3).addRange(0xA8CE, 0xA8D9).addRange(0xA8F2, 0xA8FE).addRange(0xA900, 0xA925).addRange(0xA92E, 0xA946).addRange(0xA952, 0xA953).addRange(0xA95F, 0xA97C).addRange(0xA983, 0xA9B2).addRange(0xA9B4, 0xA9B5).addRange(0xA9BA, 0xA9BB).addRange(0xA9BE, 0xA9CD).addRange(0xA9CF, 0xA9D9).addRange(0xA9DE, 0xA9E4).addRange(0xA9E6, 0xA9FE).addRange(0xAA00, 0xAA28).addRange(0xAA2F, 0xAA30).addRange(0xAA33, 0xAA34).addRange(0xAA40, 0xAA42).addRange(0xAA44, 0xAA4B).addRange(0xAA50, 0xAA59).addRange(0xAA5C, 0xAA7B).addRange(0xAA7D, 0xAAAF).addRange(0xAAB5, 0xAAB6).addRange(0xAAB9, 0xAABD).addRange(0xAADB, 0xAAEB).addRange(0xAAEE, 0xAAF5).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB6B).addRange(0xAB70, 0xABE4).addRange(0xABE6, 0xABE7).addRange(0xABE9, 0xABEC).addRange(0xABF0, 0xABF9).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1F, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41);
	set.addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBC2).addRange(0xFBD3, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFF).addRange(0xFE10, 0xFE19).addRange(0xFE30, 0xFE52).addRange(0xFE54, 0xFE66).addRange(0xFE68, 0xFE6B).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF01, 0xFF9D).addRange(0xFFA0, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE).addRange(0xFFFC, 0xFFFD).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10100, 0x10102).addRange(0x10107, 0x10133).addRange(0x10137, 0x1018E).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FC).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x102E1, 0x102FB).addRange(0x10300, 0x10323).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x10375).addRange(0x10380, 0x1039D).addRange(0x1039F, 0x103C3).addRange(0x103C8, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104A0, 0x104A9).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x1056F, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595);
	set.addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10857, 0x1089E).addRange(0x108A7, 0x108AF).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x108FB, 0x1091B).addRange(0x1091F, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BC, 0x109CF).addRange(0x109D2, 0x10A00).addRange(0x10A10, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A40, 0x10A48).addRange(0x10A50, 0x10A58).addRange(0x10A60, 0x10A9F).addRange(0x10AC0, 0x10AE4).addRange(0x10AEB, 0x10AF6).addRange(0x10B00, 0x10B35).addRange(0x10B39, 0x10B55).addRange(0x10B58, 0x10B72).addRange(0x10B78, 0x10B91).addRange(0x10B99, 0x10B9C).addRange(0x10BA9, 0x10BAF).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10CFA, 0x10D23).addRange(0x10D30, 0x10D39).addRange(0x10E60, 0x10E7E).addRange(0x10E80, 0x10EA9).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F27).addRange(0x10F30, 0x10F45).addRange(0x10F51, 0x10F59).addRange(0x10F70, 0x10F81).addRange(0x10F86, 0x10F89).addRange(0x10FB0, 0x10FCB);
	set.addRange(0x10FE0, 0x10FF6).addRange(0x11002, 0x11037).addRange(0x11047, 0x1104D).addRange(0x11052, 0x1106F).addRange(0x11071, 0x11072).addRange(0x11082, 0x110B2).addRange(0x110B7, 0x110B8).addRange(0x110BB, 0x110BC).addRange(0x110BE, 0x110C1).addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9).addRange(0x11103, 0x11126).addRange(0x11136, 0x11147).addRange(0x11150, 0x11172).addRange(0x11174, 0x11176).addRange(0x11182, 0x111B5).addRange(0x111BF, 0x111C8).addRange(0x111CD, 0x111CE).addRange(0x111D0, 0x111DF).addRange(0x111E1, 0x111F4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1122E).addRange(0x11232, 0x11233).addRange(0x11238, 0x1123D).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A9).addRange(0x112B0, 0x112DE).addRange(0x112E0, 0x112E2).addRange(0x112F0, 0x112F9).addRange(0x11302, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x11341, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11400, 0x11437).addRange(0x11440, 0x11441).addRange(0x11447, 0x1145B).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114AF).addRange(0x114B1, 0x114B2).addRange(0x114BB, 0x114BC).addRange(0x114C4, 0x114C7).addRange(0x114D0, 0x114D9);
	set.addRange(0x11580, 0x115AE).addRange(0x115B0, 0x115B1).addRange(0x115B8, 0x115BB).addRange(0x115C1, 0x115DB).addRange(0x11600, 0x11632).addRange(0x1163B, 0x1163C).addRange(0x11641, 0x11644).addRange(0x11650, 0x11659).addRange(0x11660, 0x1166C).addRange(0x11680, 0x116AA).addRange(0x116AE, 0x116AF).addRange(0x116B8, 0x116B9).addRange(0x116C0, 0x116C9).addRange(0x11700, 0x1171A).addRange(0x11720, 0x11721).addRange(0x11730, 0x11746).addRange(0x11800, 0x1182E).addRange(0x118A0, 0x118F2).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x1192F).addRange(0x11931, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193F, 0x11942).addRange(0x11944, 0x11946).addRange(0x11950, 0x11959).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D3).addRange(0x119DC, 0x119DF).addRange(0x119E1, 0x119E4).addRange(0x11A0B, 0x11A32).addRange(0x11A39, 0x11A3A).addRange(0x11A3F, 0x11A46).addRange(0x11A57, 0x11A58).addRange(0x11A5C, 0x11A89).addRange(0x11A9A, 0x11AA2).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C2F).addRange(0x11C40, 0x11C45).addRange(0x11C50, 0x11C6C).addRange(0x11C70, 0x11C8F).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D30).addRange(0x11D50, 0x11D59).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D93, 0x11D94);
	set.addRange(0x11DA0, 0x11DA9).addRange(0x11EE0, 0x11EF2).addRange(0x11EF5, 0x11EF8).addRange(0x11FC0, 0x11FF1).addRange(0x11FFF, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12470, 0x12474).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF2).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A6E, 0x16ABE).addRange(0x16AC0, 0x16AC9).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B37, 0x16B45).addRange(0x16B50, 0x16B59).addRange(0x16B5B, 0x16B61).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E9A).addRange(0x16F00, 0x16F4A).addRange(0x16F50, 0x16F87).addRange(0x16F93, 0x16F9F).addRange(0x16FE0, 0x16FE3).addRange(0x16FF0, 0x16FF1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D164).addRange(0x1D16A, 0x1D16D).addRange(0x1D183, 0x1D184).addRange(0x1D18C, 0x1D1A9).addRange(0x1D1AE, 0x1D1EA);
	set.addRange(0x1D200, 0x1D241).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D300, 0x1D356).addRange(0x1D360, 0x1D378).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1D9FF).addRange(0x1DA37, 0x1DA3A).addRange(0x1DA6D, 0x1DA74).addRange(0x1DA76, 0x1DA83).addRange(0x1DA85, 0x1DA8B).addRange(0x1DF00, 0x1DF1E).addRange(0x1E100, 0x1E12C).addRange(0x1E137, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E14E, 0x1E14F).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E2F0, 0x1E2F9).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E8C7, 0x1E8CF).addRange(0x1E900, 0x1E943).addRange(0x1E950, 0x1E959).addRange(0x1E95E, 0x1E95F).addRange(0x1EC71, 0x1ECB4).addRange(0x1ED01, 0x1ED3D).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F);
	set.addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1EEF0, 0x1EEF1).addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F100, 0x1F1AD).addRange(0x1F1E6, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA).addRange(0x1FBF0, 0x1FBF9).addRange(0x20000, 0x2A6DF);
	set.addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Grapheme_Extend.js", function (module, exports) {
	  const set = regenerate(0x5BF, 0x5C7, 0x670, 0x711, 0x7FD, 0x93A, 0x93C, 0x94D, 0x981, 0x9BC, 0x9BE, 0x9CD, 0x9D7, 0x9FE, 0xA3C, 0xA51, 0xA75, 0xABC, 0xACD, 0xB01, 0xB3C, 0xB4D, 0xB82, 0xBBE, 0xBC0, 0xBCD, 0xBD7, 0xC00, 0xC04, 0xC3C, 0xC81, 0xCBC, 0xCBF, 0xCC2, 0xCC6, 0xD3E, 0xD4D, 0xD57, 0xD81, 0xDCA, 0xDCF, 0xDD6, 0xDDF, 0xE31, 0xEB1, 0xF35, 0xF37, 0xF39, 0xFC6, 0x1082, 0x108D, 0x109D, 0x17C6, 0x17DD, 0x180F, 0x18A9, 0x1932, 0x1A1B, 0x1A56, 0x1A60, 0x1A62, 0x1A7F, 0x1B3C, 0x1B42, 0x1BE6, 0x1BED, 0x1CED, 0x1CF4, 0x200C, 0x2D7F, 0xA802, 0xA806, 0xA80B, 0xA82C, 0xA8FF, 0xA9B3, 0xA9E5, 0xAA43, 0xAA4C, 0xAA7C, 0xAAB0, 0xAAC1, 0xAAF6, 0xABE5, 0xABE8, 0xABED, 0xFB1E, 0x101FD, 0x102E0, 0x10A3F, 0x11001, 0x11070, 0x110C2, 0x11173, 0x111CF, 0x11234, 0x1123E, 0x112DF, 0x1133E, 0x11340, 0x11357, 0x11446, 0x1145E, 0x114B0, 0x114BA, 0x114BD, 0x115AF, 0x1163D, 0x116AB, 0x116AD, 0x116B7, 0x11930, 0x1193E, 0x11943, 0x119E0, 0x11A47, 0x11C3F, 0x11D3A, 0x11D47, 0x11D95, 0x11D97, 0x16F4F, 0x16FE4, 0x1D165, 0x1DA75, 0x1DA84, 0x1E2AE);
	set.addRange(0x300, 0x36F).addRange(0x483, 0x489).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x610, 0x61A).addRange(0x64B, 0x65F).addRange(0x6D6, 0x6DC).addRange(0x6DF, 0x6E4).addRange(0x6E7, 0x6E8).addRange(0x6EA, 0x6ED).addRange(0x730, 0x74A).addRange(0x7A6, 0x7B0).addRange(0x7EB, 0x7F3).addRange(0x816, 0x819).addRange(0x81B, 0x823).addRange(0x825, 0x827).addRange(0x829, 0x82D).addRange(0x859, 0x85B).addRange(0x898, 0x89F).addRange(0x8CA, 0x8E1).addRange(0x8E3, 0x902).addRange(0x941, 0x948).addRange(0x951, 0x957).addRange(0x962, 0x963).addRange(0x9C1, 0x9C4).addRange(0x9E2, 0x9E3).addRange(0xA01, 0xA02).addRange(0xA41, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA70, 0xA71).addRange(0xA81, 0xA82).addRange(0xAC1, 0xAC5).addRange(0xAC7, 0xAC8).addRange(0xAE2, 0xAE3).addRange(0xAFA, 0xAFF).addRange(0xB3E, 0xB3F).addRange(0xB41, 0xB44).addRange(0xB55, 0xB57).addRange(0xB62, 0xB63).addRange(0xC3E, 0xC40).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC62, 0xC63).addRange(0xCCC, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCE2, 0xCE3).addRange(0xD00, 0xD01).addRange(0xD3B, 0xD3C);
	set.addRange(0xD41, 0xD44).addRange(0xD62, 0xD63).addRange(0xDD2, 0xDD4).addRange(0xE34, 0xE3A).addRange(0xE47, 0xE4E).addRange(0xEB4, 0xEBC).addRange(0xEC8, 0xECD).addRange(0xF18, 0xF19).addRange(0xF71, 0xF7E).addRange(0xF80, 0xF84).addRange(0xF86, 0xF87).addRange(0xF8D, 0xF97).addRange(0xF99, 0xFBC).addRange(0x102D, 0x1030).addRange(0x1032, 0x1037).addRange(0x1039, 0x103A).addRange(0x103D, 0x103E).addRange(0x1058, 0x1059).addRange(0x105E, 0x1060).addRange(0x1071, 0x1074).addRange(0x1085, 0x1086).addRange(0x135D, 0x135F).addRange(0x1712, 0x1714).addRange(0x1732, 0x1733).addRange(0x1752, 0x1753).addRange(0x1772, 0x1773).addRange(0x17B4, 0x17B5).addRange(0x17B7, 0x17BD).addRange(0x17C9, 0x17D3).addRange(0x180B, 0x180D).addRange(0x1885, 0x1886).addRange(0x1920, 0x1922).addRange(0x1927, 0x1928).addRange(0x1939, 0x193B).addRange(0x1A17, 0x1A18).addRange(0x1A58, 0x1A5E).addRange(0x1A65, 0x1A6C).addRange(0x1A73, 0x1A7C).addRange(0x1AB0, 0x1ACE).addRange(0x1B00, 0x1B03).addRange(0x1B34, 0x1B3A).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1B81).addRange(0x1BA2, 0x1BA5).addRange(0x1BA8, 0x1BA9).addRange(0x1BAB, 0x1BAD).addRange(0x1BE8, 0x1BE9).addRange(0x1BEF, 0x1BF1).addRange(0x1C2C, 0x1C33).addRange(0x1C36, 0x1C37).addRange(0x1CD0, 0x1CD2);
	set.addRange(0x1CD4, 0x1CE0).addRange(0x1CE2, 0x1CE8).addRange(0x1CF8, 0x1CF9).addRange(0x1DC0, 0x1DFF).addRange(0x20D0, 0x20F0).addRange(0x2CEF, 0x2CF1).addRange(0x2DE0, 0x2DFF).addRange(0x302A, 0x302F).addRange(0x3099, 0x309A).addRange(0xA66F, 0xA672).addRange(0xA674, 0xA67D).addRange(0xA69E, 0xA69F).addRange(0xA6F0, 0xA6F1).addRange(0xA825, 0xA826).addRange(0xA8C4, 0xA8C5).addRange(0xA8E0, 0xA8F1).addRange(0xA926, 0xA92D).addRange(0xA947, 0xA951).addRange(0xA980, 0xA982).addRange(0xA9B6, 0xA9B9).addRange(0xA9BC, 0xA9BD).addRange(0xAA29, 0xAA2E).addRange(0xAA31, 0xAA32).addRange(0xAA35, 0xAA36).addRange(0xAAB2, 0xAAB4).addRange(0xAAB7, 0xAAB8).addRange(0xAABE, 0xAABF).addRange(0xAAEC, 0xAAED).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0xFF9E, 0xFF9F).addRange(0x10376, 0x1037A).addRange(0x10A01, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A0F).addRange(0x10A38, 0x10A3A).addRange(0x10AE5, 0x10AE6).addRange(0x10D24, 0x10D27).addRange(0x10EAB, 0x10EAC).addRange(0x10F46, 0x10F50).addRange(0x10F82, 0x10F85).addRange(0x11038, 0x11046).addRange(0x11073, 0x11074).addRange(0x1107F, 0x11081).addRange(0x110B3, 0x110B6).addRange(0x110B9, 0x110BA).addRange(0x11100, 0x11102).addRange(0x11127, 0x1112B).addRange(0x1112D, 0x11134).addRange(0x11180, 0x11181).addRange(0x111B6, 0x111BE);
	set.addRange(0x111C9, 0x111CC).addRange(0x1122F, 0x11231).addRange(0x11236, 0x11237).addRange(0x112E3, 0x112EA).addRange(0x11300, 0x11301).addRange(0x1133B, 0x1133C).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11438, 0x1143F).addRange(0x11442, 0x11444).addRange(0x114B3, 0x114B8).addRange(0x114BF, 0x114C0).addRange(0x114C2, 0x114C3).addRange(0x115B2, 0x115B5).addRange(0x115BC, 0x115BD).addRange(0x115BF, 0x115C0).addRange(0x115DC, 0x115DD).addRange(0x11633, 0x1163A).addRange(0x1163F, 0x11640).addRange(0x116B0, 0x116B5).addRange(0x1171D, 0x1171F).addRange(0x11722, 0x11725).addRange(0x11727, 0x1172B).addRange(0x1182F, 0x11837).addRange(0x11839, 0x1183A).addRange(0x1193B, 0x1193C).addRange(0x119D4, 0x119D7).addRange(0x119DA, 0x119DB).addRange(0x11A01, 0x11A0A).addRange(0x11A33, 0x11A38).addRange(0x11A3B, 0x11A3E).addRange(0x11A51, 0x11A56).addRange(0x11A59, 0x11A5B).addRange(0x11A8A, 0x11A96).addRange(0x11A98, 0x11A99).addRange(0x11C30, 0x11C36).addRange(0x11C38, 0x11C3D).addRange(0x11C92, 0x11CA7).addRange(0x11CAA, 0x11CB0).addRange(0x11CB2, 0x11CB3).addRange(0x11CB5, 0x11CB6).addRange(0x11D31, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D45).addRange(0x11D90, 0x11D91).addRange(0x11EF3, 0x11EF4).addRange(0x16AF0, 0x16AF4).addRange(0x16B30, 0x16B36).addRange(0x16F8F, 0x16F92).addRange(0x1BC9D, 0x1BC9E).addRange(0x1CF00, 0x1CF2D);
	set.addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169).addRange(0x1D16E, 0x1D172).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E130, 0x1E136).addRange(0x1E2EC, 0x1E2EF).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E944, 0x1E94A).addRange(0xE0020, 0xE007F).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Hex_Digit.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x30, 0x39).addRange(0x41, 0x46).addRange(0x61, 0x66).addRange(0xFF10, 0xFF19).addRange(0xFF21, 0xFF26).addRange(0xFF41, 0xFF46);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/ID_Continue.js", function (module, exports) {
	  const set = regenerate(0x5F, 0xAA, 0xB5, 0xB7, 0xBA, 0x2EC, 0x2EE, 0x37F, 0x38C, 0x559, 0x5BF, 0x5C7, 0x6FF, 0x7FA, 0x7FD, 0x9B2, 0x9D7, 0x9FC, 0x9FE, 0xA3C, 0xA51, 0xA5E, 0xAD0, 0xB71, 0xB9C, 0xBD0, 0xBD7, 0xC5D, 0xDBD, 0xDCA, 0xDD6, 0xE84, 0xEA5, 0xEC6, 0xF00, 0xF35, 0xF37, 0xF39, 0xFC6, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x1AA7, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2054, 0x2071, 0x207F, 0x20E1, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0xA7D3, 0xA82C, 0xA8FB, 0xFB3E, 0xFF3F, 0x101FD, 0x102E0, 0x10808, 0x1083C, 0x10A3F, 0x10F27, 0x110C2, 0x11176, 0x111DC, 0x1123E, 0x11288, 0x11350, 0x11357, 0x114C7, 0x11644, 0x11909, 0x11A47, 0x11A9D, 0x11D3A, 0x11FB0, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1DA75, 0x1DA84, 0x1E14E, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x300, 0x374).addRange(0x376, 0x377).addRange(0x37A, 0x37D).addRange(0x386, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x483, 0x487).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x610, 0x61A).addRange(0x620, 0x669).addRange(0x66E, 0x6D3).addRange(0x6D5, 0x6DC).addRange(0x6DF, 0x6E8).addRange(0x6EA, 0x6FC).addRange(0x710, 0x74A).addRange(0x74D, 0x7B1).addRange(0x7C0, 0x7F5).addRange(0x800, 0x82D).addRange(0x840, 0x85B).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x898, 0x8E1).addRange(0x8E3, 0x963).addRange(0x966, 0x96F).addRange(0x971, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BC, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CE).addRange(0x9DC, 0x9DD);
	set.addRange(0x9DF, 0x9E3).addRange(0x9E6, 0x9F1).addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA75).addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABC, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE0, 0xAE3).addRange(0xAE6, 0xAEF).addRange(0xAF9, 0xAFF).addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3C, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB66, 0xB6F).addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9);
	set.addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD).addRange(0xBE6, 0xBEF).addRange(0xC00, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3C, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC66, 0xC6F).addRange(0xC80, 0xC83).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBC, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2).addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4E).addRange(0xD54, 0xD57).addRange(0xD5F, 0xD63).addRange(0xD66, 0xD6F).addRange(0xD7A, 0xD7F).addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF3).addRange(0xE01, 0xE3A).addRange(0xE40, 0xE4E).addRange(0xE50, 0xE59).addRange(0xE81, 0xE82);
	set.addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEC8, 0xECD).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF).addRange(0xF18, 0xF19).addRange(0xF20, 0xF29).addRange(0xF3E, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF84).addRange(0xF86, 0xF97).addRange(0xF99, 0xFBC).addRange(0x1000, 0x1049).addRange(0x1050, 0x109D).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x135D, 0x135F).addRange(0x1369, 0x1371).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8).addRange(0x1700, 0x1715).addRange(0x171F, 0x1734).addRange(0x1740, 0x1753).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773).addRange(0x1780, 0x17D3).addRange(0x17DC, 0x17DD).addRange(0x17E0, 0x17E9);
	set.addRange(0x180B, 0x180D).addRange(0x180F, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1946, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x1A00, 0x1A1B).addRange(0x1A20, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1A7F, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AB0, 0x1ABD).addRange(0x1ABF, 0x1ACE).addRange(0x1B00, 0x1B4C).addRange(0x1B50, 0x1B59).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1BF3).addRange(0x1C00, 0x1C37).addRange(0x1C40, 0x1C49).addRange(0x1C4D, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CFA).addRange(0x1D00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x203F, 0x2040).addRange(0x2090, 0x209C).addRange(0x20D0, 0x20DC).addRange(0x20E5, 0x20F0);
	set.addRange(0x210A, 0x2113).addRange(0x2118, 0x211D).addRange(0x212A, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2160, 0x2188).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D7F, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x2DE0, 0x2DFF).addRange(0x3005, 0x3007).addRange(0x3021, 0x302F).addRange(0x3031, 0x3035).addRange(0x3038, 0x303C).addRange(0x3041, 0x3096).addRange(0x3099, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA62B).addRange(0xA640, 0xA66F).addRange(0xA674, 0xA67D).addRange(0xA67F, 0xA6F1).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA827).addRange(0xA840, 0xA873).addRange(0xA880, 0xA8C5).addRange(0xA8D0, 0xA8D9).addRange(0xA8E0, 0xA8F7).addRange(0xA8FD, 0xA92D);
	set.addRange(0xA930, 0xA953).addRange(0xA960, 0xA97C).addRange(0xA980, 0xA9C0).addRange(0xA9CF, 0xA9D9).addRange(0xA9E0, 0xA9FE).addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA50, 0xAA59).addRange(0xAA60, 0xAA76).addRange(0xAA7A, 0xAAC2).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEF).addRange(0xAAF2, 0xAAF6).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABEA).addRange(0xABEC, 0xABED).addRange(0xABF0, 0xABF9).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1D, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFB).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0xFE33, 0xFE34).addRange(0xFE4D, 0xFE4F).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF10, 0xFF19).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFFBE).addRange(0xFFC2, 0xFFC7);
	set.addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10140, 0x10174).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x1037A).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x103D1, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104A0, 0x104A9).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7);
	set.addRange(0x109BE, 0x109BF).addRange(0x10A00, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A38, 0x10A3A).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE6).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D27).addRange(0x10D30, 0x10D39).addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAC).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F50).addRange(0x10F70, 0x10F85).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11000, 0x11046).addRange(0x11066, 0x11075).addRange(0x1107F, 0x110BA).addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9).addRange(0x11100, 0x11134).addRange(0x11136, 0x1113F).addRange(0x11144, 0x11147).addRange(0x11150, 0x11173).addRange(0x11180, 0x111C4).addRange(0x111C9, 0x111CC).addRange(0x111CE, 0x111DA).addRange(0x11200, 0x11211).addRange(0x11213, 0x11237).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112EA).addRange(0x112F0, 0x112F9).addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310);
	set.addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133B, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11400, 0x1144A).addRange(0x11450, 0x11459).addRange(0x1145E, 0x11461).addRange(0x11480, 0x114C5).addRange(0x114D0, 0x114D9).addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115C0).addRange(0x115D8, 0x115DD).addRange(0x11600, 0x11640).addRange(0x11650, 0x11659).addRange(0x11680, 0x116B8).addRange(0x116C0, 0x116C9).addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172B).addRange(0x11730, 0x11739).addRange(0x11740, 0x11746).addRange(0x11800, 0x1183A).addRange(0x118A0, 0x118E9).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x11943).addRange(0x11950, 0x11959).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119E1).addRange(0x119E3, 0x119E4).addRange(0x11A00, 0x11A3E).addRange(0x11A50, 0x11A99).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C40).addRange(0x11C50, 0x11C59).addRange(0x11C72, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09);
	set.addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D47).addRange(0x11D50, 0x11D59).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D98).addRange(0x11DA0, 0x11DA9).addRange(0x11EE0, 0x11EF6).addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A70, 0x16ABE).addRange(0x16AC0, 0x16AC9).addRange(0x16AD0, 0x16AED).addRange(0x16AF0, 0x16AF4).addRange(0x16B00, 0x16B36).addRange(0x16B40, 0x16B43).addRange(0x16B50, 0x16B59).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x16FE3, 0x16FE4).addRange(0x16FF0, 0x16FF1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1BC9D, 0x1BC9E);
	set.addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D165, 0x1D169).addRange(0x1D16D, 0x1D172).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1DF00, 0x1DF1E).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E100, 0x1E12C).addRange(0x1E130, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E290, 0x1E2AE).addRange(0x1E2C0, 0x1E2F9);
	set.addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E900, 0x1E94B).addRange(0x1E950, 0x1E959).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1FBF0, 0x1FBF9).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/ID_Start.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x2EC, 0x2EE, 0x37F, 0x386, 0x38C, 0x559, 0x6D5, 0x6FF, 0x710, 0x7B1, 0x7FA, 0x81A, 0x824, 0x828, 0x93D, 0x950, 0x9B2, 0x9BD, 0x9CE, 0x9FC, 0xA5E, 0xABD, 0xAD0, 0xAF9, 0xB3D, 0xB71, 0xB83, 0xB9C, 0xBD0, 0xC3D, 0xC5D, 0xC80, 0xCBD, 0xD3D, 0xD4E, 0xDBD, 0xE84, 0xEA5, 0xEBD, 0xEC6, 0xF00, 0x103F, 0x1061, 0x108E, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x17DC, 0x18AA, 0x1AA7, 0x1CFA, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2071, 0x207F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0xA7D3, 0xA8FB, 0xA9CF, 0xAA7A, 0xAAB1, 0xAAC0, 0xAAC2, 0xFB1D, 0xFB3E, 0x10808, 0x1083C, 0x10A00, 0x10F27, 0x11075, 0x11144, 0x11147, 0x11176, 0x111DA, 0x111DC, 0x11288, 0x1133D, 0x11350, 0x114C7, 0x11644, 0x116B8, 0x11909, 0x1193F, 0x11941, 0x119E1, 0x119E3, 0x11A00, 0x11A3A, 0x11A50, 0x11A9D, 0x11C40, 0x11D46, 0x11D98, 0x11FB0, 0x16F50, 0x16FE3, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E14E, 0x1E94B, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x370, 0x374).addRange(0x376, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x620, 0x64A).addRange(0x66E, 0x66F).addRange(0x671, 0x6D3).addRange(0x6E5, 0x6E6).addRange(0x6EE, 0x6EF).addRange(0x6FA, 0x6FC).addRange(0x712, 0x72F).addRange(0x74D, 0x7A5).addRange(0x7CA, 0x7EA).addRange(0x7F4, 0x7F5).addRange(0x800, 0x815).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x8A0, 0x8C9).addRange(0x904, 0x939).addRange(0x958, 0x961).addRange(0x971, 0x980).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E1).addRange(0x9F0, 0x9F1).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33);
	set.addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA59, 0xA5C).addRange(0xA72, 0xA74).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xAE0, 0xAE1).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB61).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC61).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE1).addRange(0xCF1, 0xCF2).addRange(0xD04, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD54, 0xD56).addRange(0xD5F, 0xD61).addRange(0xD7A, 0xD7F).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6);
	set.addRange(0xE01, 0xE30).addRange(0xE32, 0xE33).addRange(0xE40, 0xE46).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB0).addRange(0xEB2, 0xEB3).addRange(0xEC0, 0xEC4).addRange(0xEDC, 0xEDF).addRange(0xF40, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF88, 0xF8C).addRange(0x1000, 0x102A).addRange(0x1050, 0x1055).addRange(0x105A, 0x105D).addRange(0x1065, 0x1066).addRange(0x106E, 0x1070).addRange(0x1075, 0x1081).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8).addRange(0x1700, 0x1711).addRange(0x171F, 0x1731).addRange(0x1740, 0x1751).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1780, 0x17B3).addRange(0x1820, 0x1878).addRange(0x1880, 0x18A8);
	set.addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1950, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x1A00, 0x1A16).addRange(0x1A20, 0x1A54).addRange(0x1B05, 0x1B33).addRange(0x1B45, 0x1B4C).addRange(0x1B83, 0x1BA0).addRange(0x1BAE, 0x1BAF).addRange(0x1BBA, 0x1BE5).addRange(0x1C00, 0x1C23).addRange(0x1C4D, 0x1C4F).addRange(0x1C5A, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF6).addRange(0x1D00, 0x1DBF).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x2090, 0x209C).addRange(0x210A, 0x2113).addRange(0x2118, 0x211D).addRange(0x212A, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2160, 0x2188).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D80, 0x2D96);
	set.addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x3005, 0x3007).addRange(0x3021, 0x3029).addRange(0x3031, 0x3035).addRange(0x3038, 0x303C).addRange(0x3041, 0x3096).addRange(0x309B, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA61F).addRange(0xA62A, 0xA62B).addRange(0xA640, 0xA66E).addRange(0xA67F, 0xA69D).addRange(0xA6A0, 0xA6EF).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA801).addRange(0xA803, 0xA805).addRange(0xA807, 0xA80A).addRange(0xA80C, 0xA822).addRange(0xA840, 0xA873).addRange(0xA882, 0xA8B3).addRange(0xA8F2, 0xA8F7).addRange(0xA8FD, 0xA8FE).addRange(0xA90A, 0xA925).addRange(0xA930, 0xA946).addRange(0xA960, 0xA97C).addRange(0xA984, 0xA9B2).addRange(0xA9E0, 0xA9E4).addRange(0xA9E6, 0xA9EF).addRange(0xA9FA, 0xA9FE).addRange(0xAA00, 0xAA28).addRange(0xAA40, 0xAA42);
	set.addRange(0xAA44, 0xAA4B).addRange(0xAA60, 0xAA76).addRange(0xAA7E, 0xAAAF).addRange(0xAAB5, 0xAAB6).addRange(0xAAB9, 0xAABD).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEA).addRange(0xAAF2, 0xAAF4).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABE2).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1F, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFB).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10140, 0x10174).addRange(0x10280, 0x1029C);
	set.addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x10375).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x103D1, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A10, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE4).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48);
	set.addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D23).addRange(0x10E80, 0x10EA9).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F45).addRange(0x10F70, 0x10F81).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11003, 0x11037).addRange(0x11071, 0x11072).addRange(0x11083, 0x110AF).addRange(0x110D0, 0x110E8).addRange(0x11103, 0x11126).addRange(0x11150, 0x11172).addRange(0x11183, 0x111B2).addRange(0x111C1, 0x111C4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1122B).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112DE).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1135D, 0x11361).addRange(0x11400, 0x11434).addRange(0x11447, 0x1144A).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114AF).addRange(0x114C4, 0x114C5).addRange(0x11580, 0x115AE).addRange(0x115D8, 0x115DB).addRange(0x11600, 0x1162F).addRange(0x11680, 0x116AA).addRange(0x11700, 0x1171A).addRange(0x11740, 0x11746).addRange(0x11800, 0x1182B).addRange(0x118A0, 0x118DF).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x1192F).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D0);
	set.addRange(0x11A0B, 0x11A32).addRange(0x11A5C, 0x11A89).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C2E).addRange(0x11C72, 0x11C8F).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D30).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D89).addRange(0x11EE0, 0x11EF2).addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A70, 0x16ABE).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B40, 0x16B43).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F93, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9);
	set.addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF1E).addRange(0x1E100, 0x1E12C).addRange(0x1E137, 0x1E13D).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E900, 0x1E943).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738);
	set.addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Ideographic.js", function (module, exports) {
	  const set = regenerate(0x16FE4);
	set.addRange(0x3006, 0x3007).addRange(0x3021, 0x3029).addRange(0x3038, 0x303A).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0x9FFF).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1B170, 0x1B2FB).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/IDS_Binary_Operator.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2FF0, 0x2FF1).addRange(0x2FF4, 0x2FFB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/IDS_Trinary_Operator.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2FF2, 0x2FF3);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Join_Control.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x200C, 0x200D);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Logical_Order_Exception.js", function (module, exports) {
	  const set = regenerate(0x19BA, 0xAAB9);
	set.addRange(0xE40, 0xE44).addRange(0xEC0, 0xEC4).addRange(0x19B5, 0x19B7).addRange(0xAAB5, 0xAAB6).addRange(0xAABB, 0xAABC);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Lowercase.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x183, 0x185, 0x188, 0x192, 0x195, 0x19E, 0x1A1, 0x1A3, 0x1A5, 0x1A8, 0x1AD, 0x1B0, 0x1B4, 0x1B6, 0x1C6, 0x1C9, 0x1CC, 0x1CE, 0x1D0, 0x1D2, 0x1D4, 0x1D6, 0x1D8, 0x1DA, 0x1DF, 0x1E1, 0x1E3, 0x1E5, 0x1E7, 0x1E9, 0x1EB, 0x1ED, 0x1F3, 0x1F5, 0x1F9, 0x1FB, 0x1FD, 0x1FF, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20B, 0x20D, 0x20F, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21B, 0x21D, 0x21F, 0x221, 0x223, 0x225, 0x227, 0x229, 0x22B, 0x22D, 0x22F, 0x231, 0x23C, 0x242, 0x247, 0x249, 0x24B, 0x24D, 0x345, 0x371, 0x373, 0x377, 0x390, 0x3D9, 0x3DB, 0x3DD, 0x3DF, 0x3E1, 0x3E3, 0x3E5, 0x3E7, 0x3E9, 0x3EB, 0x3ED, 0x3F5, 0x3F8, 0x461, 0x463, 0x465, 0x467, 0x469, 0x46B, 0x46D, 0x46F, 0x471, 0x473, 0x475, 0x477, 0x479, 0x47B, 0x47D, 0x47F, 0x481, 0x48B, 0x48D, 0x48F, 0x491, 0x493, 0x495, 0x497, 0x499, 0x49B, 0x49D, 0x49F, 0x4A1, 0x4A3, 0x4A5, 0x4A7, 0x4A9, 0x4AB, 0x4AD, 0x4AF, 0x4B1, 0x4B3, 0x4B5, 0x4B7, 0x4B9, 0x4BB, 0x4BD, 0x4BF, 0x4C2, 0x4C4, 0x4C6, 0x4C8, 0x4CA, 0x4CC, 0x4D1, 0x4D3, 0x4D5, 0x4D7, 0x4D9, 0x4DB, 0x4DD, 0x4DF, 0x4E1, 0x4E3, 0x4E5, 0x4E7, 0x4E9, 0x4EB, 0x4ED, 0x4EF, 0x4F1, 0x4F3, 0x4F5, 0x4F7, 0x4F9, 0x4FB, 0x4FD, 0x4FF, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50B, 0x50D, 0x50F, 0x511, 0x513, 0x515, 0x517, 0x519, 0x51B, 0x51D, 0x51F, 0x521, 0x523, 0x525, 0x527, 0x529, 0x52B, 0x52D, 0x52F, 0x1E01, 0x1E03, 0x1E05, 0x1E07, 0x1E09, 0x1E0B, 0x1E0D, 0x1E0F, 0x1E11, 0x1E13, 0x1E15, 0x1E17, 0x1E19, 0x1E1B, 0x1E1D, 0x1E1F, 0x1E21, 0x1E23, 0x1E25, 0x1E27, 0x1E29, 0x1E2B, 0x1E2D, 0x1E2F, 0x1E31, 0x1E33, 0x1E35, 0x1E37, 0x1E39, 0x1E3B, 0x1E3D, 0x1E3F, 0x1E41, 0x1E43, 0x1E45, 0x1E47, 0x1E49, 0x1E4B, 0x1E4D, 0x1E4F, 0x1E51, 0x1E53, 0x1E55, 0x1E57, 0x1E59, 0x1E5B, 0x1E5D, 0x1E5F, 0x1E61, 0x1E63, 0x1E65, 0x1E67, 0x1E69, 0x1E6B, 0x1E6D, 0x1E6F, 0x1E71, 0x1E73, 0x1E75, 0x1E77, 0x1E79, 0x1E7B, 0x1E7D, 0x1E7F, 0x1E81, 0x1E83, 0x1E85, 0x1E87, 0x1E89, 0x1E8B, 0x1E8D, 0x1E8F, 0x1E91, 0x1E93, 0x1E9F, 0x1EA1, 0x1EA3, 0x1EA5, 0x1EA7, 0x1EA9, 0x1EAB, 0x1EAD, 0x1EAF, 0x1EB1, 0x1EB3, 0x1EB5, 0x1EB7, 0x1EB9, 0x1EBB, 0x1EBD, 0x1EBF, 0x1EC1, 0x1EC3, 0x1EC5, 0x1EC7, 0x1EC9, 0x1ECB, 0x1ECD, 0x1ECF, 0x1ED1, 0x1ED3, 0x1ED5, 0x1ED7, 0x1ED9, 0x1EDB, 0x1EDD, 0x1EDF, 0x1EE1, 0x1EE3, 0x1EE5, 0x1EE7, 0x1EE9, 0x1EEB, 0x1EED, 0x1EEF, 0x1EF1, 0x1EF3, 0x1EF5, 0x1EF7, 0x1EF9, 0x1EFB, 0x1EFD, 0x1FBE, 0x2071, 0x207F, 0x210A, 0x2113, 0x212F, 0x2134, 0x2139, 0x214E, 0x2184, 0x2C61, 0x2C68, 0x2C6A, 0x2C6C, 0x2C71, 0x2C81, 0x2C83, 0x2C85, 0x2C87, 0x2C89, 0x2C8B, 0x2C8D, 0x2C8F, 0x2C91, 0x2C93, 0x2C95, 0x2C97, 0x2C99, 0x2C9B, 0x2C9D, 0x2C9F, 0x2CA1, 0x2CA3, 0x2CA5, 0x2CA7, 0x2CA9, 0x2CAB, 0x2CAD, 0x2CAF, 0x2CB1, 0x2CB3, 0x2CB5, 0x2CB7, 0x2CB9, 0x2CBB, 0x2CBD, 0x2CBF, 0x2CC1, 0x2CC3, 0x2CC5, 0x2CC7, 0x2CC9, 0x2CCB, 0x2CCD, 0x2CCF, 0x2CD1, 0x2CD3, 0x2CD5, 0x2CD7, 0x2CD9, 0x2CDB, 0x2CDD, 0x2CDF, 0x2CE1, 0x2CEC, 0x2CEE, 0x2CF3, 0x2D27, 0x2D2D, 0xA641, 0xA643, 0xA645, 0xA647, 0xA649, 0xA64B, 0xA64D, 0xA64F, 0xA651, 0xA653, 0xA655, 0xA657, 0xA659, 0xA65B, 0xA65D, 0xA65F, 0xA661, 0xA663, 0xA665, 0xA667, 0xA669, 0xA66B, 0xA66D, 0xA681, 0xA683, 0xA685, 0xA687, 0xA689, 0xA68B, 0xA68D, 0xA68F, 0xA691, 0xA693, 0xA695, 0xA697, 0xA699, 0xA723, 0xA725, 0xA727, 0xA729, 0xA72B, 0xA72D, 0xA733, 0xA735, 0xA737, 0xA739, 0xA73B, 0xA73D, 0xA73F, 0xA741, 0xA743, 0xA745, 0xA747, 0xA749, 0xA74B, 0xA74D, 0xA74F, 0xA751, 0xA753, 0xA755, 0xA757, 0xA759, 0xA75B, 0xA75D, 0xA75F, 0xA761, 0xA763, 0xA765, 0xA767, 0xA769, 0xA76B, 0xA76D, 0xA77A, 0xA77C, 0xA77F, 0xA781, 0xA783, 0xA785, 0xA787, 0xA78C, 0xA78E, 0xA791, 0xA797, 0xA799, 0xA79B, 0xA79D, 0xA79F, 0xA7A1, 0xA7A3, 0xA7A5, 0xA7A7, 0xA7A9, 0xA7AF, 0xA7B5, 0xA7B7, 0xA7B9, 0xA7BB, 0xA7BD, 0xA7BF, 0xA7C1, 0xA7C3, 0xA7C8, 0xA7CA, 0xA7D1, 0xA7D3, 0xA7D5, 0xA7D7, 0xA7D9, 0xA7F6, 0x10780, 0x1D4BB, 0x1D7CB);
	set.addRange(0x61, 0x7A).addRange(0xDF, 0xF6).addRange(0xF8, 0xFF).addRange(0x137, 0x138).addRange(0x148, 0x149).addRange(0x17E, 0x180).addRange(0x18C, 0x18D).addRange(0x199, 0x19B).addRange(0x1AA, 0x1AB).addRange(0x1B9, 0x1BA).addRange(0x1BD, 0x1BF).addRange(0x1DC, 0x1DD).addRange(0x1EF, 0x1F0).addRange(0x233, 0x239).addRange(0x23F, 0x240).addRange(0x24F, 0x293).addRange(0x295, 0x2B8).addRange(0x2C0, 0x2C1).addRange(0x2E0, 0x2E4).addRange(0x37A, 0x37D).addRange(0x3AC, 0x3CE).addRange(0x3D0, 0x3D1).addRange(0x3D5, 0x3D7).addRange(0x3EF, 0x3F3).addRange(0x3FB, 0x3FC).addRange(0x430, 0x45F).addRange(0x4CE, 0x4CF).addRange(0x560, 0x588).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1D00, 0x1DBF).addRange(0x1E95, 0x1E9D).addRange(0x1EFF, 0x1F07).addRange(0x1F10, 0x1F15).addRange(0x1F20, 0x1F27).addRange(0x1F30, 0x1F37).addRange(0x1F40, 0x1F45).addRange(0x1F50, 0x1F57).addRange(0x1F60, 0x1F67).addRange(0x1F70, 0x1F7D).addRange(0x1F80, 0x1F87).addRange(0x1F90, 0x1F97).addRange(0x1FA0, 0x1FA7).addRange(0x1FB0, 0x1FB4).addRange(0x1FB6, 0x1FB7).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FC7).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FD7);
	set.addRange(0x1FE0, 0x1FE7).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FF7).addRange(0x2090, 0x209C).addRange(0x210E, 0x210F).addRange(0x213C, 0x213D).addRange(0x2146, 0x2149).addRange(0x2170, 0x217F).addRange(0x24D0, 0x24E9).addRange(0x2C30, 0x2C5F).addRange(0x2C65, 0x2C66).addRange(0x2C73, 0x2C74).addRange(0x2C76, 0x2C7D).addRange(0x2CE3, 0x2CE4).addRange(0x2D00, 0x2D25).addRange(0xA69B, 0xA69D).addRange(0xA72F, 0xA731).addRange(0xA76F, 0xA778).addRange(0xA793, 0xA795).addRange(0xA7F8, 0xA7FA).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB68).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF41, 0xFF5A).addRange(0x10428, 0x1044F).addRange(0x104D8, 0x104FB).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10783, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10CC0, 0x10CF2).addRange(0x118C0, 0x118DF).addRange(0x16E60, 0x16E7F).addRange(0x1D41A, 0x1D433).addRange(0x1D44E, 0x1D454).addRange(0x1D456, 0x1D467).addRange(0x1D482, 0x1D49B).addRange(0x1D4B6, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D4CF).addRange(0x1D4EA, 0x1D503).addRange(0x1D51E, 0x1D537).addRange(0x1D552, 0x1D56B).addRange(0x1D586, 0x1D59F).addRange(0x1D5BA, 0x1D5D3).addRange(0x1D5EE, 0x1D607);
	set.addRange(0x1D622, 0x1D63B).addRange(0x1D656, 0x1D66F).addRange(0x1D68A, 0x1D6A5).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6E1).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D71B).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D755).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D78F).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7C9).addRange(0x1DF00, 0x1DF09).addRange(0x1DF0B, 0x1DF1E).addRange(0x1E922, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Math.js", function (module, exports) {
	  const set = regenerate(0x2B, 0x5E, 0x7C, 0x7E, 0xAC, 0xB1, 0xD7, 0xF7, 0x3D5, 0x2016, 0x2040, 0x2044, 0x2052, 0x20E1, 0x2102, 0x2107, 0x2115, 0x2124, 0x214B, 0x21DD, 0x237C, 0x23B7, 0x23D0, 0x25E2, 0x25E4, 0x2640, 0x2642, 0xFB29, 0xFE68, 0xFF0B, 0xFF3C, 0xFF3E, 0xFF5C, 0xFF5E, 0xFFE2, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x3C, 0x3E).addRange(0x3D0, 0x3D2).addRange(0x3F0, 0x3F1).addRange(0x3F4, 0x3F6).addRange(0x606, 0x608).addRange(0x2032, 0x2034).addRange(0x2061, 0x2064).addRange(0x207A, 0x207E).addRange(0x208A, 0x208E).addRange(0x20D0, 0x20DC).addRange(0x20E5, 0x20E6).addRange(0x20EB, 0x20EF).addRange(0x210A, 0x2113).addRange(0x2118, 0x211D).addRange(0x2128, 0x2129).addRange(0x212C, 0x212D).addRange(0x212F, 0x2131).addRange(0x2133, 0x2138).addRange(0x213C, 0x2149).addRange(0x2190, 0x21A7).addRange(0x21A9, 0x21AE).addRange(0x21B0, 0x21B1).addRange(0x21B6, 0x21B7).addRange(0x21BC, 0x21DB).addRange(0x21E4, 0x21E5).addRange(0x21F4, 0x22FF).addRange(0x2308, 0x230B).addRange(0x2320, 0x2321).addRange(0x239B, 0x23B5).addRange(0x23DC, 0x23E2).addRange(0x25A0, 0x25A1).addRange(0x25AE, 0x25B7).addRange(0x25BC, 0x25C1).addRange(0x25C6, 0x25C7).addRange(0x25CA, 0x25CB).addRange(0x25CF, 0x25D3).addRange(0x25E7, 0x25EC).addRange(0x25F8, 0x25FF).addRange(0x2605, 0x2606).addRange(0x2660, 0x2663).addRange(0x266D, 0x266F).addRange(0x27C0, 0x27FF).addRange(0x2900, 0x2AFF).addRange(0x2B30, 0x2B44).addRange(0x2B47, 0x2B4C).addRange(0xFE61, 0xFE66).addRange(0xFF1C, 0xFF1E).addRange(0xFFE9, 0xFFEC).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F);
	set.addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1EEF0, 0x1EEF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Noncharacter_Code_Point.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xFDD0, 0xFDEF).addRange(0xFFFE, 0xFFFF).addRange(0x1FFFE, 0x1FFFF).addRange(0x2FFFE, 0x2FFFF).addRange(0x3FFFE, 0x3FFFF).addRange(0x4FFFE, 0x4FFFF).addRange(0x5FFFE, 0x5FFFF).addRange(0x6FFFE, 0x6FFFF).addRange(0x7FFFE, 0x7FFFF).addRange(0x8FFFE, 0x8FFFF).addRange(0x9FFFE, 0x9FFFF).addRange(0xAFFFE, 0xAFFFF).addRange(0xBFFFE, 0xBFFFF).addRange(0xCFFFE, 0xCFFFF).addRange(0xDFFFE, 0xDFFFF).addRange(0xEFFFE, 0xEFFFF).addRange(0xFFFFE, 0xFFFFF).addRange(0x10FFFE, 0x10FFFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Pattern_Syntax.js", function (module, exports) {
	  const set = regenerate(0x60, 0xA9, 0xAE, 0xB6, 0xBB, 0xBF, 0xD7, 0xF7, 0x3030);
	set.addRange(0x21, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x7E).addRange(0xA1, 0xA7).addRange(0xAB, 0xAC).addRange(0xB0, 0xB1).addRange(0x2010, 0x2027).addRange(0x2030, 0x203E).addRange(0x2041, 0x2053).addRange(0x2055, 0x205E).addRange(0x2190, 0x245F).addRange(0x2500, 0x2775).addRange(0x2794, 0x2BFF).addRange(0x2E00, 0x2E7F).addRange(0x3001, 0x3003).addRange(0x3008, 0x3020).addRange(0xFD3E, 0xFD3F).addRange(0xFE45, 0xFE46);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Pattern_White_Space.js", function (module, exports) {
	  const set = regenerate(0x20, 0x85);
	set.addRange(0x9, 0xD).addRange(0x200E, 0x200F).addRange(0x2028, 0x2029);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Quotation_Mark.js", function (module, exports) {
	  const set = regenerate(0x22, 0x27, 0xAB, 0xBB, 0x2E42, 0xFF02, 0xFF07);
	set.addRange(0x2018, 0x201F).addRange(0x2039, 0x203A).addRange(0x300C, 0x300F).addRange(0x301D, 0x301F).addRange(0xFE41, 0xFE44).addRange(0xFF62, 0xFF63);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Radical.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Regional_Indicator.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1F1E6, 0x1F1FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Sentence_Terminal.js", function (module, exports) {
	  const set = regenerate(0x21, 0x2E, 0x3F, 0x589, 0x6D4, 0x7F9, 0x837, 0x839, 0x1362, 0x166E, 0x1803, 0x1809, 0x2E2E, 0x2E3C, 0x3002, 0xA4FF, 0xA6F3, 0xA6F7, 0xA92F, 0xABEB, 0xFE52, 0xFF01, 0xFF0E, 0xFF1F, 0xFF61, 0x111CD, 0x112A9, 0x11944, 0x11946, 0x16AF5, 0x16B44, 0x16E98, 0x1BC9F, 0x1DA88);
	set.addRange(0x61D, 0x61F).addRange(0x700, 0x702).addRange(0x83D, 0x83E).addRange(0x964, 0x965).addRange(0x104A, 0x104B).addRange(0x1367, 0x1368).addRange(0x1735, 0x1736).addRange(0x1944, 0x1945).addRange(0x1AA8, 0x1AAB).addRange(0x1B5A, 0x1B5B).addRange(0x1B5E, 0x1B5F).addRange(0x1B7D, 0x1B7E).addRange(0x1C3B, 0x1C3C).addRange(0x1C7E, 0x1C7F).addRange(0x203C, 0x203D).addRange(0x2047, 0x2049).addRange(0x2E53, 0x2E54).addRange(0xA60E, 0xA60F).addRange(0xA876, 0xA877).addRange(0xA8CE, 0xA8CF).addRange(0xA9C8, 0xA9C9).addRange(0xAA5D, 0xAA5F).addRange(0xAAF0, 0xAAF1).addRange(0xFE56, 0xFE57).addRange(0x10A56, 0x10A57).addRange(0x10F55, 0x10F59).addRange(0x10F86, 0x10F89).addRange(0x11047, 0x11048).addRange(0x110BE, 0x110C1).addRange(0x11141, 0x11143).addRange(0x111C5, 0x111C6).addRange(0x111DE, 0x111DF).addRange(0x11238, 0x11239).addRange(0x1123B, 0x1123C).addRange(0x1144B, 0x1144C).addRange(0x115C2, 0x115C3).addRange(0x115C9, 0x115D7).addRange(0x11641, 0x11642).addRange(0x1173C, 0x1173E).addRange(0x11A42, 0x11A43).addRange(0x11A9B, 0x11A9C).addRange(0x11C41, 0x11C42).addRange(0x11EF7, 0x11EF8).addRange(0x16A6E, 0x16A6F).addRange(0x16B37, 0x16B38);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Soft_Dotted.js", function (module, exports) {
	  const set = regenerate(0x12F, 0x249, 0x268, 0x29D, 0x2B2, 0x3F3, 0x456, 0x458, 0x1D62, 0x1D96, 0x1DA4, 0x1DA8, 0x1E2D, 0x1ECB, 0x2071, 0x2C7C, 0x1DF1A);
	set.addRange(0x69, 0x6A).addRange(0x2148, 0x2149).addRange(0x1D422, 0x1D423).addRange(0x1D456, 0x1D457).addRange(0x1D48A, 0x1D48B).addRange(0x1D4BE, 0x1D4BF).addRange(0x1D4F2, 0x1D4F3).addRange(0x1D526, 0x1D527).addRange(0x1D55A, 0x1D55B).addRange(0x1D58E, 0x1D58F).addRange(0x1D5C2, 0x1D5C3).addRange(0x1D5F6, 0x1D5F7).addRange(0x1D62A, 0x1D62B).addRange(0x1D65E, 0x1D65F).addRange(0x1D692, 0x1D693);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Terminal_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x21, 0x2C, 0x2E, 0x3F, 0x37E, 0x387, 0x589, 0x5C3, 0x60C, 0x61B, 0x6D4, 0x70C, 0x85E, 0xF08, 0x166E, 0x17DA, 0x2E2E, 0x2E3C, 0x2E41, 0x2E4C, 0xA92F, 0xAADF, 0xABEB, 0xFF01, 0xFF0C, 0xFF0E, 0xFF1F, 0xFF61, 0xFF64, 0x1039F, 0x103D0, 0x10857, 0x1091F, 0x111CD, 0x112A9, 0x11944, 0x11946, 0x11C71, 0x16AF5, 0x16B44, 0x1BC9F);
	set.addRange(0x3A, 0x3B).addRange(0x61D, 0x61F).addRange(0x700, 0x70A).addRange(0x7F8, 0x7F9).addRange(0x830, 0x83E).addRange(0x964, 0x965).addRange(0xE5A, 0xE5B).addRange(0xF0D, 0xF12).addRange(0x104A, 0x104B).addRange(0x1361, 0x1368).addRange(0x16EB, 0x16ED).addRange(0x1735, 0x1736).addRange(0x17D4, 0x17D6).addRange(0x1802, 0x1805).addRange(0x1808, 0x1809).addRange(0x1944, 0x1945).addRange(0x1AA8, 0x1AAB).addRange(0x1B5A, 0x1B5B).addRange(0x1B5D, 0x1B5F).addRange(0x1B7D, 0x1B7E).addRange(0x1C3B, 0x1C3F).addRange(0x1C7E, 0x1C7F).addRange(0x203C, 0x203D).addRange(0x2047, 0x2049).addRange(0x2E4E, 0x2E4F).addRange(0x2E53, 0x2E54).addRange(0x3001, 0x3002).addRange(0xA4FE, 0xA4FF).addRange(0xA60D, 0xA60F).addRange(0xA6F3, 0xA6F7).addRange(0xA876, 0xA877).addRange(0xA8CE, 0xA8CF).addRange(0xA9C7, 0xA9C9).addRange(0xAA5D, 0xAA5F).addRange(0xAAF0, 0xAAF1).addRange(0xFE50, 0xFE52).addRange(0xFE54, 0xFE57).addRange(0xFF1A, 0xFF1B).addRange(0x10A56, 0x10A57).addRange(0x10AF0, 0x10AF5).addRange(0x10B3A, 0x10B3F).addRange(0x10B99, 0x10B9C).addRange(0x10F55, 0x10F59).addRange(0x10F86, 0x10F89).addRange(0x11047, 0x1104D).addRange(0x110BE, 0x110C1).addRange(0x11141, 0x11143).addRange(0x111C5, 0x111C6).addRange(0x111DE, 0x111DF).addRange(0x11238, 0x1123C).addRange(0x1144B, 0x1144D);
	set.addRange(0x1145A, 0x1145B).addRange(0x115C2, 0x115C5).addRange(0x115C9, 0x115D7).addRange(0x11641, 0x11642).addRange(0x1173C, 0x1173E).addRange(0x11A42, 0x11A43).addRange(0x11A9B, 0x11A9C).addRange(0x11AA1, 0x11AA2).addRange(0x11C41, 0x11C43).addRange(0x11EF7, 0x11EF8).addRange(0x12470, 0x12474).addRange(0x16A6E, 0x16A6F).addRange(0x16B37, 0x16B39).addRange(0x16E97, 0x16E98).addRange(0x1DA87, 0x1DA8A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Unified_Ideograph.js", function (module, exports) {
	  const set = regenerate(0xFA11, 0xFA1F, 0xFA21);
	set.addRange(0x3400, 0x4DBF).addRange(0x4E00, 0x9FFF).addRange(0xFA0E, 0xFA0F).addRange(0xFA13, 0xFA14).addRange(0xFA23, 0xFA24).addRange(0xFA27, 0xFA29).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Uppercase.js", function (module, exports) {
	  const set = regenerate(0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x17B, 0x17D, 0x184, 0x1A2, 0x1A4, 0x1A9, 0x1AC, 0x1B5, 0x1BC, 0x1C4, 0x1C7, 0x1CA, 0x1CD, 0x1CF, 0x1D1, 0x1D3, 0x1D5, 0x1D7, 0x1D9, 0x1DB, 0x1DE, 0x1E0, 0x1E2, 0x1E4, 0x1E6, 0x1E8, 0x1EA, 0x1EC, 0x1EE, 0x1F1, 0x1F4, 0x1FA, 0x1FC, 0x1FE, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20A, 0x20C, 0x20E, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21A, 0x21C, 0x21E, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22A, 0x22C, 0x22E, 0x230, 0x232, 0x241, 0x248, 0x24A, 0x24C, 0x24E, 0x370, 0x372, 0x376, 0x37F, 0x386, 0x38C, 0x3CF, 0x3D8, 0x3DA, 0x3DC, 0x3DE, 0x3E0, 0x3E2, 0x3E4, 0x3E6, 0x3E8, 0x3EA, 0x3EC, 0x3EE, 0x3F4, 0x3F7, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46A, 0x46C, 0x46E, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47A, 0x47C, 0x47E, 0x480, 0x48A, 0x48C, 0x48E, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49A, 0x49C, 0x49E, 0x4A0, 0x4A2, 0x4A4, 0x4A6, 0x4A8, 0x4AA, 0x4AC, 0x4AE, 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4BC, 0x4BE, 0x4C3, 0x4C5, 0x4C7, 0x4C9, 0x4CB, 0x4CD, 0x4D0, 0x4D2, 0x4D4, 0x4D6, 0x4D8, 0x4DA, 0x4DC, 0x4DE, 0x4E0, 0x4E2, 0x4E4, 0x4E6, 0x4E8, 0x4EA, 0x4EC, 0x4EE, 0x4F0, 0x4F2, 0x4F4, 0x4F6, 0x4F8, 0x4FA, 0x4FC, 0x4FE, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50A, 0x50C, 0x50E, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51A, 0x51C, 0x51E, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52A, 0x52C, 0x52E, 0x10C7, 0x10CD, 0x1E00, 0x1E02, 0x1E04, 0x1E06, 0x1E08, 0x1E0A, 0x1E0C, 0x1E0E, 0x1E10, 0x1E12, 0x1E14, 0x1E16, 0x1E18, 0x1E1A, 0x1E1C, 0x1E1E, 0x1E20, 0x1E22, 0x1E24, 0x1E26, 0x1E28, 0x1E2A, 0x1E2C, 0x1E2E, 0x1E30, 0x1E32, 0x1E34, 0x1E36, 0x1E38, 0x1E3A, 0x1E3C, 0x1E3E, 0x1E40, 0x1E42, 0x1E44, 0x1E46, 0x1E48, 0x1E4A, 0x1E4C, 0x1E4E, 0x1E50, 0x1E52, 0x1E54, 0x1E56, 0x1E58, 0x1E5A, 0x1E5C, 0x1E5E, 0x1E60, 0x1E62, 0x1E64, 0x1E66, 0x1E68, 0x1E6A, 0x1E6C, 0x1E6E, 0x1E70, 0x1E72, 0x1E74, 0x1E76, 0x1E78, 0x1E7A, 0x1E7C, 0x1E7E, 0x1E80, 0x1E82, 0x1E84, 0x1E86, 0x1E88, 0x1E8A, 0x1E8C, 0x1E8E, 0x1E90, 0x1E92, 0x1E94, 0x1E9E, 0x1EA0, 0x1EA2, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAA, 0x1EAC, 0x1EAE, 0x1EB0, 0x1EB2, 0x1EB4, 0x1EB6, 0x1EB8, 0x1EBA, 0x1EBC, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1EC8, 0x1ECA, 0x1ECC, 0x1ECE, 0x1ED0, 0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EDA, 0x1EDC, 0x1EDE, 0x1EE0, 0x1EE2, 0x1EE4, 0x1EE6, 0x1EE8, 0x1EEA, 0x1EEC, 0x1EEE, 0x1EF0, 0x1EF2, 0x1EF4, 0x1EF6, 0x1EF8, 0x1EFA, 0x1EFC, 0x1EFE, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x2145, 0x2183, 0x2C60, 0x2C67, 0x2C69, 0x2C6B, 0x2C72, 0x2C75, 0x2C82, 0x2C84, 0x2C86, 0x2C88, 0x2C8A, 0x2C8C, 0x2C8E, 0x2C90, 0x2C92, 0x2C94, 0x2C96, 0x2C98, 0x2C9A, 0x2C9C, 0x2C9E, 0x2CA0, 0x2CA2, 0x2CA4, 0x2CA6, 0x2CA8, 0x2CAA, 0x2CAC, 0x2CAE, 0x2CB0, 0x2CB2, 0x2CB4, 0x2CB6, 0x2CB8, 0x2CBA, 0x2CBC, 0x2CBE, 0x2CC0, 0x2CC2, 0x2CC4, 0x2CC6, 0x2CC8, 0x2CCA, 0x2CCC, 0x2CCE, 0x2CD0, 0x2CD2, 0x2CD4, 0x2CD6, 0x2CD8, 0x2CDA, 0x2CDC, 0x2CDE, 0x2CE0, 0x2CE2, 0x2CEB, 0x2CED, 0x2CF2, 0xA640, 0xA642, 0xA644, 0xA646, 0xA648, 0xA64A, 0xA64C, 0xA64E, 0xA650, 0xA652, 0xA654, 0xA656, 0xA658, 0xA65A, 0xA65C, 0xA65E, 0xA660, 0xA662, 0xA664, 0xA666, 0xA668, 0xA66A, 0xA66C, 0xA680, 0xA682, 0xA684, 0xA686, 0xA688, 0xA68A, 0xA68C, 0xA68E, 0xA690, 0xA692, 0xA694, 0xA696, 0xA698, 0xA69A, 0xA722, 0xA724, 0xA726, 0xA728, 0xA72A, 0xA72C, 0xA72E, 0xA732, 0xA734, 0xA736, 0xA738, 0xA73A, 0xA73C, 0xA73E, 0xA740, 0xA742, 0xA744, 0xA746, 0xA748, 0xA74A, 0xA74C, 0xA74E, 0xA750, 0xA752, 0xA754, 0xA756, 0xA758, 0xA75A, 0xA75C, 0xA75E, 0xA760, 0xA762, 0xA764, 0xA766, 0xA768, 0xA76A, 0xA76C, 0xA76E, 0xA779, 0xA77B, 0xA780, 0xA782, 0xA784, 0xA786, 0xA78B, 0xA78D, 0xA790, 0xA792, 0xA796, 0xA798, 0xA79A, 0xA79C, 0xA79E, 0xA7A0, 0xA7A2, 0xA7A4, 0xA7A6, 0xA7A8, 0xA7B6, 0xA7B8, 0xA7BA, 0xA7BC, 0xA7BE, 0xA7C0, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D6, 0xA7D8, 0xA7F5, 0x1D49C, 0x1D4A2, 0x1D546, 0x1D7CA);
	set.addRange(0x41, 0x5A).addRange(0xC0, 0xD6).addRange(0xD8, 0xDE).addRange(0x178, 0x179).addRange(0x181, 0x182).addRange(0x186, 0x187).addRange(0x189, 0x18B).addRange(0x18E, 0x191).addRange(0x193, 0x194).addRange(0x196, 0x198).addRange(0x19C, 0x19D).addRange(0x19F, 0x1A0).addRange(0x1A6, 0x1A7).addRange(0x1AE, 0x1AF).addRange(0x1B1, 0x1B3).addRange(0x1B7, 0x1B8).addRange(0x1F6, 0x1F8).addRange(0x23A, 0x23B).addRange(0x23D, 0x23E).addRange(0x243, 0x246).addRange(0x388, 0x38A).addRange(0x38E, 0x38F).addRange(0x391, 0x3A1).addRange(0x3A3, 0x3AB).addRange(0x3D2, 0x3D4).addRange(0x3F9, 0x3FA).addRange(0x3FD, 0x42F).addRange(0x4C0, 0x4C1).addRange(0x531, 0x556).addRange(0x10A0, 0x10C5).addRange(0x13A0, 0x13F5).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1F08, 0x1F0F).addRange(0x1F18, 0x1F1D).addRange(0x1F28, 0x1F2F).addRange(0x1F38, 0x1F3F).addRange(0x1F48, 0x1F4D).addRange(0x1F68, 0x1F6F).addRange(0x1FB8, 0x1FBB).addRange(0x1FC8, 0x1FCB).addRange(0x1FD8, 0x1FDB).addRange(0x1FE8, 0x1FEC).addRange(0x1FF8, 0x1FFB).addRange(0x210B, 0x210D).addRange(0x2110, 0x2112).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x2130, 0x2133).addRange(0x213E, 0x213F).addRange(0x2160, 0x216F);
	set.addRange(0x24B6, 0x24CF).addRange(0x2C00, 0x2C2F).addRange(0x2C62, 0x2C64).addRange(0x2C6D, 0x2C70).addRange(0x2C7E, 0x2C80).addRange(0xA77D, 0xA77E).addRange(0xA7AA, 0xA7AE).addRange(0xA7B0, 0xA7B4).addRange(0xA7C4, 0xA7C7).addRange(0xFF21, 0xFF3A).addRange(0x10400, 0x10427).addRange(0x104B0, 0x104D3).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10C80, 0x10CB2).addRange(0x118A0, 0x118BF).addRange(0x16E40, 0x16E5F).addRange(0x1D400, 0x1D419).addRange(0x1D434, 0x1D44D).addRange(0x1D468, 0x1D481).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B5).addRange(0x1D4D0, 0x1D4E9).addRange(0x1D504, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D538, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D56C, 0x1D585).addRange(0x1D5A0, 0x1D5B9).addRange(0x1D5D4, 0x1D5ED).addRange(0x1D608, 0x1D621).addRange(0x1D63C, 0x1D655).addRange(0x1D670, 0x1D689).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6E2, 0x1D6FA).addRange(0x1D71C, 0x1D734).addRange(0x1D756, 0x1D76E).addRange(0x1D790, 0x1D7A8).addRange(0x1E900, 0x1E921).addRange(0x1F130, 0x1F149).addRange(0x1F150, 0x1F169).addRange(0x1F170, 0x1F189);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/Variation_Selector.js", function (module, exports) {
	  const set = regenerate(0x180F);
	set.addRange(0x180B, 0x180D).addRange(0xFE00, 0xFE0F).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/White_Space.js", function (module, exports) {
	  const set = regenerate(0x20, 0x85, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000);
	set.addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/XID_Continue.js", function (module, exports) {
	  const set = regenerate(0x5F, 0xAA, 0xB5, 0xB7, 0xBA, 0x2EC, 0x2EE, 0x37F, 0x38C, 0x559, 0x5BF, 0x5C7, 0x6FF, 0x7FA, 0x7FD, 0x9B2, 0x9D7, 0x9FC, 0x9FE, 0xA3C, 0xA51, 0xA5E, 0xAD0, 0xB71, 0xB9C, 0xBD0, 0xBD7, 0xC5D, 0xDBD, 0xDCA, 0xDD6, 0xE84, 0xEA5, 0xEC6, 0xF00, 0xF35, 0xF37, 0xF39, 0xFC6, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x1AA7, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2054, 0x2071, 0x207F, 0x20E1, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0xA7D3, 0xA82C, 0xA8FB, 0xFB3E, 0xFE71, 0xFE73, 0xFE77, 0xFE79, 0xFE7B, 0xFE7D, 0xFF3F, 0x101FD, 0x102E0, 0x10808, 0x1083C, 0x10A3F, 0x10F27, 0x110C2, 0x11176, 0x111DC, 0x1123E, 0x11288, 0x11350, 0x11357, 0x114C7, 0x11644, 0x11909, 0x11A47, 0x11A9D, 0x11D3A, 0x11FB0, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1DA75, 0x1DA84, 0x1E14E, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x300, 0x374).addRange(0x376, 0x377).addRange(0x37B, 0x37D).addRange(0x386, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x483, 0x487).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x610, 0x61A).addRange(0x620, 0x669).addRange(0x66E, 0x6D3).addRange(0x6D5, 0x6DC).addRange(0x6DF, 0x6E8).addRange(0x6EA, 0x6FC).addRange(0x710, 0x74A).addRange(0x74D, 0x7B1).addRange(0x7C0, 0x7F5).addRange(0x800, 0x82D).addRange(0x840, 0x85B).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x898, 0x8E1).addRange(0x8E3, 0x963).addRange(0x966, 0x96F).addRange(0x971, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BC, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CE).addRange(0x9DC, 0x9DD);
	set.addRange(0x9DF, 0x9E3).addRange(0x9E6, 0x9F1).addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA75).addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABC, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE0, 0xAE3).addRange(0xAE6, 0xAEF).addRange(0xAF9, 0xAFF).addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3C, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB66, 0xB6F).addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9);
	set.addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD).addRange(0xBE6, 0xBEF).addRange(0xC00, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3C, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC66, 0xC6F).addRange(0xC80, 0xC83).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBC, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2).addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4E).addRange(0xD54, 0xD57).addRange(0xD5F, 0xD63).addRange(0xD66, 0xD6F).addRange(0xD7A, 0xD7F).addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF3).addRange(0xE01, 0xE3A).addRange(0xE40, 0xE4E).addRange(0xE50, 0xE59).addRange(0xE81, 0xE82);
	set.addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEC8, 0xECD).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF).addRange(0xF18, 0xF19).addRange(0xF20, 0xF29).addRange(0xF3E, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF84).addRange(0xF86, 0xF97).addRange(0xF99, 0xFBC).addRange(0x1000, 0x1049).addRange(0x1050, 0x109D).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x135D, 0x135F).addRange(0x1369, 0x1371).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8).addRange(0x1700, 0x1715).addRange(0x171F, 0x1734).addRange(0x1740, 0x1753).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773).addRange(0x1780, 0x17D3).addRange(0x17DC, 0x17DD).addRange(0x17E0, 0x17E9);
	set.addRange(0x180B, 0x180D).addRange(0x180F, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1946, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x1A00, 0x1A1B).addRange(0x1A20, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1A7F, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AB0, 0x1ABD).addRange(0x1ABF, 0x1ACE).addRange(0x1B00, 0x1B4C).addRange(0x1B50, 0x1B59).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1BF3).addRange(0x1C00, 0x1C37).addRange(0x1C40, 0x1C49).addRange(0x1C4D, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CFA).addRange(0x1D00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x203F, 0x2040).addRange(0x2090, 0x209C).addRange(0x20D0, 0x20DC).addRange(0x20E5, 0x20F0);
	set.addRange(0x210A, 0x2113).addRange(0x2118, 0x211D).addRange(0x212A, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2160, 0x2188).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D7F, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x2DE0, 0x2DFF).addRange(0x3005, 0x3007).addRange(0x3021, 0x302F).addRange(0x3031, 0x3035).addRange(0x3038, 0x303C).addRange(0x3041, 0x3096).addRange(0x3099, 0x309A).addRange(0x309D, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA62B).addRange(0xA640, 0xA66F).addRange(0xA674, 0xA67D).addRange(0xA67F, 0xA6F1).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA827).addRange(0xA840, 0xA873).addRange(0xA880, 0xA8C5).addRange(0xA8D0, 0xA8D9).addRange(0xA8E0, 0xA8F7);
	set.addRange(0xA8FD, 0xA92D).addRange(0xA930, 0xA953).addRange(0xA960, 0xA97C).addRange(0xA980, 0xA9C0).addRange(0xA9CF, 0xA9D9).addRange(0xA9E0, 0xA9FE).addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA50, 0xAA59).addRange(0xAA60, 0xAA76).addRange(0xAA7A, 0xAAC2).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEF).addRange(0xAAF2, 0xAAF6).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABEA).addRange(0xABEC, 0xABED).addRange(0xABF0, 0xABF9).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1D, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFC5D).addRange(0xFC64, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDF9).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0xFE33, 0xFE34).addRange(0xFE4D, 0xFE4F).addRange(0xFE7F, 0xFEFC).addRange(0xFF10, 0xFF19).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFFBE);
	set.addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10140, 0x10174).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x1037A).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x103D1, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104A0, 0x104A9).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939);
	set.addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A00, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A38, 0x10A3A).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE6).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D27).addRange(0x10D30, 0x10D39).addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAC).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F50).addRange(0x10F70, 0x10F85).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11000, 0x11046).addRange(0x11066, 0x11075).addRange(0x1107F, 0x110BA).addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9).addRange(0x11100, 0x11134).addRange(0x11136, 0x1113F).addRange(0x11144, 0x11147).addRange(0x11150, 0x11173).addRange(0x11180, 0x111C4).addRange(0x111C9, 0x111CC).addRange(0x111CE, 0x111DA).addRange(0x11200, 0x11211).addRange(0x11213, 0x11237).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112EA).addRange(0x112F0, 0x112F9).addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C);
	set.addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133B, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11400, 0x1144A).addRange(0x11450, 0x11459).addRange(0x1145E, 0x11461).addRange(0x11480, 0x114C5).addRange(0x114D0, 0x114D9).addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115C0).addRange(0x115D8, 0x115DD).addRange(0x11600, 0x11640).addRange(0x11650, 0x11659).addRange(0x11680, 0x116B8).addRange(0x116C0, 0x116C9).addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172B).addRange(0x11730, 0x11739).addRange(0x11740, 0x11746).addRange(0x11800, 0x1183A).addRange(0x118A0, 0x118E9).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x11943).addRange(0x11950, 0x11959).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119E1).addRange(0x119E3, 0x119E4).addRange(0x11A00, 0x11A3E).addRange(0x11A50, 0x11A99).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C40).addRange(0x11C50, 0x11C59).addRange(0x11C72, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6).addRange(0x11D00, 0x11D06);
	set.addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D47).addRange(0x11D50, 0x11D59).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D98).addRange(0x11DA0, 0x11DA9).addRange(0x11EE0, 0x11EF6).addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A70, 0x16ABE).addRange(0x16AC0, 0x16AC9).addRange(0x16AD0, 0x16AED).addRange(0x16AF0, 0x16AF4).addRange(0x16B00, 0x16B36).addRange(0x16B40, 0x16B43).addRange(0x16B50, 0x16B59).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x16FE3, 0x16FE4).addRange(0x16FF0, 0x16FF1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99);
	set.addRange(0x1BC9D, 0x1BC9E).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D165, 0x1D169).addRange(0x1D16D, 0x1D172).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1DF00, 0x1DF1E).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E100, 0x1E12C).addRange(0x1E130, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E290, 0x1E2AE);
	set.addRange(0x1E2C0, 0x1E2F9).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E900, 0x1E94B).addRange(0x1E950, 0x1E959).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1FBF0, 0x1FBF9).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Binary_Property/XID_Start.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x2EC, 0x2EE, 0x37F, 0x386, 0x38C, 0x559, 0x6D5, 0x6FF, 0x710, 0x7B1, 0x7FA, 0x81A, 0x824, 0x828, 0x93D, 0x950, 0x9B2, 0x9BD, 0x9CE, 0x9FC, 0xA5E, 0xABD, 0xAD0, 0xAF9, 0xB3D, 0xB71, 0xB83, 0xB9C, 0xBD0, 0xC3D, 0xC5D, 0xC80, 0xCBD, 0xD3D, 0xD4E, 0xDBD, 0xE32, 0xE84, 0xEA5, 0xEB2, 0xEBD, 0xEC6, 0xF00, 0x103F, 0x1061, 0x108E, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x17DC, 0x18AA, 0x1AA7, 0x1CFA, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2071, 0x207F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0xA7D3, 0xA8FB, 0xA9CF, 0xAA7A, 0xAAB1, 0xAAC0, 0xAAC2, 0xFB1D, 0xFB3E, 0xFE71, 0xFE73, 0xFE77, 0xFE79, 0xFE7B, 0xFE7D, 0x10808, 0x1083C, 0x10A00, 0x10F27, 0x11075, 0x11144, 0x11147, 0x11176, 0x111DA, 0x111DC, 0x11288, 0x1133D, 0x11350, 0x114C7, 0x11644, 0x116B8, 0x11909, 0x1193F, 0x11941, 0x119E1, 0x119E3, 0x11A00, 0x11A3A, 0x11A50, 0x11A9D, 0x11C40, 0x11D46, 0x11D98, 0x11FB0, 0x16F50, 0x16FE3, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E14E, 0x1E94B, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x370, 0x374).addRange(0x376, 0x377).addRange(0x37B, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x620, 0x64A).addRange(0x66E, 0x66F).addRange(0x671, 0x6D3).addRange(0x6E5, 0x6E6).addRange(0x6EE, 0x6EF).addRange(0x6FA, 0x6FC).addRange(0x712, 0x72F).addRange(0x74D, 0x7A5).addRange(0x7CA, 0x7EA).addRange(0x7F4, 0x7F5).addRange(0x800, 0x815).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x8A0, 0x8C9).addRange(0x904, 0x939).addRange(0x958, 0x961).addRange(0x971, 0x980).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E1).addRange(0x9F0, 0x9F1).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33);
	set.addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA59, 0xA5C).addRange(0xA72, 0xA74).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xAE0, 0xAE1).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB61).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC61).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE1).addRange(0xCF1, 0xCF2).addRange(0xD04, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD54, 0xD56).addRange(0xD5F, 0xD61).addRange(0xD7A, 0xD7F).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6);
	set.addRange(0xE01, 0xE30).addRange(0xE40, 0xE46).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB0).addRange(0xEC0, 0xEC4).addRange(0xEDC, 0xEDF).addRange(0xF40, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF88, 0xF8C).addRange(0x1000, 0x102A).addRange(0x1050, 0x1055).addRange(0x105A, 0x105D).addRange(0x1065, 0x1066).addRange(0x106E, 0x1070).addRange(0x1075, 0x1081).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8).addRange(0x1700, 0x1711).addRange(0x171F, 0x1731).addRange(0x1740, 0x1751).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1780, 0x17B3).addRange(0x1820, 0x1878).addRange(0x1880, 0x18A8).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E);
	set.addRange(0x1950, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x1A00, 0x1A16).addRange(0x1A20, 0x1A54).addRange(0x1B05, 0x1B33).addRange(0x1B45, 0x1B4C).addRange(0x1B83, 0x1BA0).addRange(0x1BAE, 0x1BAF).addRange(0x1BBA, 0x1BE5).addRange(0x1C00, 0x1C23).addRange(0x1C4D, 0x1C4F).addRange(0x1C5A, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF6).addRange(0x1D00, 0x1DBF).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x2090, 0x209C).addRange(0x210A, 0x2113).addRange(0x2118, 0x211D).addRange(0x212A, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2160, 0x2188).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0x2D30, 0x2D67).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE);
	set.addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x3005, 0x3007).addRange(0x3021, 0x3029).addRange(0x3031, 0x3035).addRange(0x3038, 0x303C).addRange(0x3041, 0x3096).addRange(0x309D, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA61F).addRange(0xA62A, 0xA62B).addRange(0xA640, 0xA66E).addRange(0xA67F, 0xA69D).addRange(0xA6A0, 0xA6EF).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA801).addRange(0xA803, 0xA805).addRange(0xA807, 0xA80A).addRange(0xA80C, 0xA822).addRange(0xA840, 0xA873).addRange(0xA882, 0xA8B3).addRange(0xA8F2, 0xA8F7).addRange(0xA8FD, 0xA8FE).addRange(0xA90A, 0xA925).addRange(0xA930, 0xA946).addRange(0xA960, 0xA97C).addRange(0xA984, 0xA9B2).addRange(0xA9E0, 0xA9E4).addRange(0xA9E6, 0xA9EF).addRange(0xA9FA, 0xA9FE).addRange(0xAA00, 0xAA28).addRange(0xAA40, 0xAA42).addRange(0xAA44, 0xAA4B).addRange(0xAA60, 0xAA76);
	set.addRange(0xAA7E, 0xAAAF).addRange(0xAAB5, 0xAAB6).addRange(0xAAB9, 0xAABD).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEA).addRange(0xAAF2, 0xAAF4).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABE2).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1F, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFC5D).addRange(0xFC64, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDF9).addRange(0xFE7F, 0xFEFC).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFF9D).addRange(0xFFA0, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10140, 0x10174).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0);
	set.addRange(0x10300, 0x1031F).addRange(0x1032D, 0x1034A).addRange(0x10350, 0x10375).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x103D1, 0x103D5).addRange(0x10400, 0x1049D).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A10, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE4).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48).addRange(0x10C80, 0x10CB2);
	set.addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D23).addRange(0x10E80, 0x10EA9).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F45).addRange(0x10F70, 0x10F81).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11003, 0x11037).addRange(0x11071, 0x11072).addRange(0x11083, 0x110AF).addRange(0x110D0, 0x110E8).addRange(0x11103, 0x11126).addRange(0x11150, 0x11172).addRange(0x11183, 0x111B2).addRange(0x111C1, 0x111C4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1122B).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112DE).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1135D, 0x11361).addRange(0x11400, 0x11434).addRange(0x11447, 0x1144A).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114AF).addRange(0x114C4, 0x114C5).addRange(0x11580, 0x115AE).addRange(0x115D8, 0x115DB).addRange(0x11600, 0x1162F).addRange(0x11680, 0x116AA).addRange(0x11700, 0x1171A).addRange(0x11740, 0x11746).addRange(0x11800, 0x1182B).addRange(0x118A0, 0x118DF).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x1192F).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D0).addRange(0x11A0B, 0x11A32);
	set.addRange(0x11A5C, 0x11A89).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C2E).addRange(0x11C72, 0x11C8F).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D30).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D89).addRange(0x11EE0, 0x11EF2).addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A70, 0x16ABE).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B40, 0x16B43).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F93, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3);
	set.addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF1E).addRange(0x1E100, 0x1E12C).addRange(0x1E137, 0x1E13D).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E900, 0x1E943).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D);
	set.addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Cased_Letter.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x37F, 0x386, 0x38C, 0x10C7, 0x10CD, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x2139, 0x214E, 0x2D27, 0x2D2D, 0xA7D3, 0xA7FA, 0x1D4A2, 0x1D4BB, 0x1D546);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x1BA).addRange(0x1BC, 0x1BF).addRange(0x1C4, 0x293).addRange(0x295, 0x2AF).addRange(0x370, 0x373).addRange(0x376, 0x377).addRange(0x37B, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1D00, 0x1D2B).addRange(0x1D6B, 0x1D77).addRange(0x1D79, 0x1D9A).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x210A, 0x2113).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x212F, 0x2134).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2183, 0x2184);
	set.addRange(0x2C00, 0x2C7B).addRange(0x2C7E, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25).addRange(0xA640, 0xA66D).addRange(0xA680, 0xA69B).addRange(0xA722, 0xA76F).addRange(0xA771, 0xA787).addRange(0xA78B, 0xA78E).addRange(0xA790, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F5, 0xA7F6).addRange(0xAB30, 0xAB5A).addRange(0xAB60, 0xAB68).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0x10400, 0x1044F).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x118A0, 0x118DF).addRange(0x16E40, 0x16E7F).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550);
	set.addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF09).addRange(0x1DF0B, 0x1DF1E).addRange(0x1E900, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Close_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x29, 0x5D, 0x7D, 0xF3B, 0xF3D, 0x169C, 0x2046, 0x207E, 0x208E, 0x2309, 0x230B, 0x232A, 0x2769, 0x276B, 0x276D, 0x276F, 0x2771, 0x2773, 0x2775, 0x27C6, 0x27E7, 0x27E9, 0x27EB, 0x27ED, 0x27EF, 0x2984, 0x2986, 0x2988, 0x298A, 0x298C, 0x298E, 0x2990, 0x2992, 0x2994, 0x2996, 0x2998, 0x29D9, 0x29DB, 0x29FD, 0x2E23, 0x2E25, 0x2E27, 0x2E29, 0x2E56, 0x2E58, 0x2E5A, 0x2E5C, 0x3009, 0x300B, 0x300D, 0x300F, 0x3011, 0x3015, 0x3017, 0x3019, 0x301B, 0xFD3E, 0xFE18, 0xFE36, 0xFE38, 0xFE3A, 0xFE3C, 0xFE3E, 0xFE40, 0xFE42, 0xFE44, 0xFE48, 0xFE5A, 0xFE5C, 0xFE5E, 0xFF09, 0xFF3D, 0xFF5D, 0xFF60, 0xFF63);
	set.addRange(0x301E, 0x301F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Connector_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x5F, 0x2054, 0xFF3F);
	set.addRange(0x203F, 0x2040).addRange(0xFE33, 0xFE34).addRange(0xFE4D, 0xFE4F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Control.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x0, 0x1F).addRange(0x7F, 0x9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Currency_Symbol.js", function (module, exports) {
	  const set = regenerate(0x24, 0x58F, 0x60B, 0x9FB, 0xAF1, 0xBF9, 0xE3F, 0x17DB, 0xA838, 0xFDFC, 0xFE69, 0xFF04, 0x1E2FF, 0x1ECB0);
	set.addRange(0xA2, 0xA5).addRange(0x7FE, 0x7FF).addRange(0x9F2, 0x9F3).addRange(0x20A0, 0x20C0).addRange(0xFFE0, 0xFFE1).addRange(0xFFE5, 0xFFE6).addRange(0x11FDD, 0x11FE0);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Dash_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x2D, 0x58A, 0x5BE, 0x1400, 0x1806, 0x2E17, 0x2E1A, 0x2E40, 0x2E5D, 0x301C, 0x3030, 0x30A0, 0xFE58, 0xFE63, 0xFF0D, 0x10EAD);
	set.addRange(0x2010, 0x2015).addRange(0x2E3A, 0x2E3B).addRange(0xFE31, 0xFE32);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Decimal_Number.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x30, 0x39).addRange(0x660, 0x669).addRange(0x6F0, 0x6F9).addRange(0x7C0, 0x7C9).addRange(0x966, 0x96F).addRange(0x9E6, 0x9EF).addRange(0xA66, 0xA6F).addRange(0xAE6, 0xAEF).addRange(0xB66, 0xB6F).addRange(0xBE6, 0xBEF).addRange(0xC66, 0xC6F).addRange(0xCE6, 0xCEF).addRange(0xD66, 0xD6F).addRange(0xDE6, 0xDEF).addRange(0xE50, 0xE59).addRange(0xED0, 0xED9).addRange(0xF20, 0xF29).addRange(0x1040, 0x1049).addRange(0x1090, 0x1099).addRange(0x17E0, 0x17E9).addRange(0x1810, 0x1819).addRange(0x1946, 0x194F).addRange(0x19D0, 0x19D9).addRange(0x1A80, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1B50, 0x1B59).addRange(0x1BB0, 0x1BB9).addRange(0x1C40, 0x1C49).addRange(0x1C50, 0x1C59).addRange(0xA620, 0xA629).addRange(0xA8D0, 0xA8D9).addRange(0xA900, 0xA909).addRange(0xA9D0, 0xA9D9).addRange(0xA9F0, 0xA9F9).addRange(0xAA50, 0xAA59).addRange(0xABF0, 0xABF9).addRange(0xFF10, 0xFF19).addRange(0x104A0, 0x104A9).addRange(0x10D30, 0x10D39).addRange(0x11066, 0x1106F).addRange(0x110F0, 0x110F9).addRange(0x11136, 0x1113F).addRange(0x111D0, 0x111D9).addRange(0x112F0, 0x112F9).addRange(0x11450, 0x11459).addRange(0x114D0, 0x114D9).addRange(0x11650, 0x11659).addRange(0x116C0, 0x116C9).addRange(0x11730, 0x11739).addRange(0x118E0, 0x118E9).addRange(0x11950, 0x11959);
	set.addRange(0x11C50, 0x11C59).addRange(0x11D50, 0x11D59).addRange(0x11DA0, 0x11DA9).addRange(0x16A60, 0x16A69).addRange(0x16AC0, 0x16AC9).addRange(0x16B50, 0x16B59).addRange(0x1D7CE, 0x1D7FF).addRange(0x1E140, 0x1E149).addRange(0x1E2F0, 0x1E2F9).addRange(0x1E950, 0x1E959).addRange(0x1FBF0, 0x1FBF9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Enclosing_Mark.js", function (module, exports) {
	  const set = regenerate(0x1ABE);
	set.addRange(0x488, 0x489).addRange(0x20DD, 0x20E0).addRange(0x20E2, 0x20E4).addRange(0xA670, 0xA672);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Final_Punctuation.js", function (module, exports) {
	  const set = regenerate(0xBB, 0x2019, 0x201D, 0x203A, 0x2E03, 0x2E05, 0x2E0A, 0x2E0D, 0x2E1D, 0x2E21);

	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Format.js", function (module, exports) {
	  const set = regenerate(0xAD, 0x61C, 0x6DD, 0x70F, 0x8E2, 0x180E, 0xFEFF, 0x110BD, 0x110CD, 0xE0001);
	set.addRange(0x600, 0x605).addRange(0x890, 0x891).addRange(0x200B, 0x200F).addRange(0x202A, 0x202E).addRange(0x2060, 0x2064).addRange(0x2066, 0x206F).addRange(0xFFF9, 0xFFFB).addRange(0x13430, 0x13438).addRange(0x1BCA0, 0x1BCA3).addRange(0x1D173, 0x1D17A).addRange(0xE0020, 0xE007F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Initial_Punctuation.js", function (module, exports) {
	  const set = regenerate(0xAB, 0x2018, 0x201F, 0x2039, 0x2E02, 0x2E04, 0x2E09, 0x2E0C, 0x2E1C, 0x2E20);
	set.addRange(0x201B, 0x201C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Letter_Number.js", function (module, exports) {
	  const set = regenerate(0x3007, 0x10341, 0x1034A);
	set.addRange(0x16EE, 0x16F0).addRange(0x2160, 0x2182).addRange(0x2185, 0x2188).addRange(0x3021, 0x3029).addRange(0x3038, 0x303A).addRange(0xA6E6, 0xA6EF).addRange(0x10140, 0x10174).addRange(0x103D1, 0x103D5).addRange(0x12400, 0x1246E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Letter.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xB5, 0xBA, 0x2EC, 0x2EE, 0x37F, 0x386, 0x38C, 0x559, 0x6D5, 0x6FF, 0x710, 0x7B1, 0x7FA, 0x81A, 0x824, 0x828, 0x93D, 0x950, 0x9B2, 0x9BD, 0x9CE, 0x9FC, 0xA5E, 0xABD, 0xAD0, 0xAF9, 0xB3D, 0xB71, 0xB83, 0xB9C, 0xBD0, 0xC3D, 0xC5D, 0xC80, 0xCBD, 0xD3D, 0xD4E, 0xDBD, 0xE84, 0xEA5, 0xEBD, 0xEC6, 0xF00, 0x103F, 0x1061, 0x108E, 0x10C7, 0x10CD, 0x1258, 0x12C0, 0x17D7, 0x17DC, 0x18AA, 0x1AA7, 0x1CFA, 0x1F59, 0x1F5B, 0x1F5D, 0x1FBE, 0x2071, 0x207F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x214E, 0x2D27, 0x2D2D, 0x2D6F, 0x2E2F, 0xA7D3, 0xA8FB, 0xA9CF, 0xAA7A, 0xAAB1, 0xAAC0, 0xAAC2, 0xFB1D, 0xFB3E, 0x10808, 0x1083C, 0x10A00, 0x10F27, 0x11075, 0x11144, 0x11147, 0x11176, 0x111DA, 0x111DC, 0x11288, 0x1133D, 0x11350, 0x114C7, 0x11644, 0x116B8, 0x11909, 0x1193F, 0x11941, 0x119E1, 0x119E3, 0x11A00, 0x11A3A, 0x11A50, 0x11A9D, 0x11C40, 0x11D46, 0x11D98, 0x11FB0, 0x16F50, 0x16FE3, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1E14E, 0x1E94B, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x370, 0x374).addRange(0x376, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3F5).addRange(0x3F7, 0x481).addRange(0x48A, 0x52F).addRange(0x531, 0x556).addRange(0x560, 0x588).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x620, 0x64A).addRange(0x66E, 0x66F).addRange(0x671, 0x6D3).addRange(0x6E5, 0x6E6).addRange(0x6EE, 0x6EF).addRange(0x6FA, 0x6FC).addRange(0x712, 0x72F).addRange(0x74D, 0x7A5).addRange(0x7CA, 0x7EA).addRange(0x7F4, 0x7F5).addRange(0x800, 0x815).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x8A0, 0x8C9).addRange(0x904, 0x939).addRange(0x958, 0x961).addRange(0x971, 0x980).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E1).addRange(0x9F0, 0x9F1).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33);
	set.addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA59, 0xA5C).addRange(0xA72, 0xA74).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xAE0, 0xAE1).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB61).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC61).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE1).addRange(0xCF1, 0xCF2).addRange(0xD04, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD54, 0xD56).addRange(0xD5F, 0xD61).addRange(0xD7A, 0xD7F).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6);
	set.addRange(0xE01, 0xE30).addRange(0xE32, 0xE33).addRange(0xE40, 0xE46).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB0).addRange(0xEB2, 0xEB3).addRange(0xEC0, 0xEC4).addRange(0xEDC, 0xEDF).addRange(0xF40, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF88, 0xF8C).addRange(0x1000, 0x102A).addRange(0x1050, 0x1055).addRange(0x105A, 0x105D).addRange(0x1065, 0x1066).addRange(0x106E, 0x1070).addRange(0x1075, 0x1081).addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1380, 0x138F).addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16F1, 0x16F8).addRange(0x1700, 0x1711).addRange(0x171F, 0x1731).addRange(0x1740, 0x1751).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1780, 0x17B3).addRange(0x1820, 0x1878).addRange(0x1880, 0x1884);
	set.addRange(0x1887, 0x18A8).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1950, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x1A00, 0x1A16).addRange(0x1A20, 0x1A54).addRange(0x1B05, 0x1B33).addRange(0x1B45, 0x1B4C).addRange(0x1B83, 0x1BA0).addRange(0x1BAE, 0x1BAF).addRange(0x1BBA, 0x1BE5).addRange(0x1C00, 0x1C23).addRange(0x1C4D, 0x1C4F).addRange(0x1C5A, 0x1C7D).addRange(0x1C80, 0x1C88).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF6).addRange(0x1D00, 0x1DBF).addRange(0x1E00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FBC).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FCC).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FE0, 0x1FEC).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFC).addRange(0x2090, 0x209C).addRange(0x210A, 0x2113).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x212F, 0x2139).addRange(0x213C, 0x213F).addRange(0x2145, 0x2149).addRange(0x2183, 0x2184).addRange(0x2C00, 0x2CE4).addRange(0x2CEB, 0x2CEE).addRange(0x2CF2, 0x2CF3).addRange(0x2D00, 0x2D25);
	set.addRange(0x2D30, 0x2D67).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x3005, 0x3006).addRange(0x3031, 0x3035).addRange(0x303B, 0x303C).addRange(0x3041, 0x3096).addRange(0x309D, 0x309F).addRange(0x30A1, 0x30FA).addRange(0x30FC, 0x30FF).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA48C).addRange(0xA4D0, 0xA4FD).addRange(0xA500, 0xA60C).addRange(0xA610, 0xA61F).addRange(0xA62A, 0xA62B).addRange(0xA640, 0xA66E).addRange(0xA67F, 0xA69D).addRange(0xA6A0, 0xA6E5).addRange(0xA717, 0xA71F).addRange(0xA722, 0xA788).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA801).addRange(0xA803, 0xA805).addRange(0xA807, 0xA80A).addRange(0xA80C, 0xA822).addRange(0xA840, 0xA873).addRange(0xA882, 0xA8B3).addRange(0xA8F2, 0xA8F7).addRange(0xA8FD, 0xA8FE).addRange(0xA90A, 0xA925).addRange(0xA930, 0xA946).addRange(0xA960, 0xA97C).addRange(0xA984, 0xA9B2).addRange(0xA9E0, 0xA9E4).addRange(0xA9E6, 0xA9EF).addRange(0xA9FA, 0xA9FE).addRange(0xAA00, 0xAA28);
	set.addRange(0xAA40, 0xAA42).addRange(0xAA44, 0xAA4B).addRange(0xAA60, 0xAA76).addRange(0xAA7E, 0xAAAF).addRange(0xAAB5, 0xAAB6).addRange(0xAAB9, 0xAABD).addRange(0xAADB, 0xAADD).addRange(0xAAE0, 0xAAEA).addRange(0xAAF2, 0xAAF4).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB69).addRange(0xAB70, 0xABE2).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFB1F, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFB).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0xFF66, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10280, 0x1029C);
	set.addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x10340).addRange(0x10342, 0x10349).addRange(0x10350, 0x10375).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x10400, 0x1049D).addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A10, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE4).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48);
	set.addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10D00, 0x10D23).addRange(0x10E80, 0x10EA9).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F45).addRange(0x10F70, 0x10F81).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11003, 0x11037).addRange(0x11071, 0x11072).addRange(0x11083, 0x110AF).addRange(0x110D0, 0x110E8).addRange(0x11103, 0x11126).addRange(0x11150, 0x11172).addRange(0x11183, 0x111B2).addRange(0x111C1, 0x111C4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1122B).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112DE).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1135D, 0x11361).addRange(0x11400, 0x11434).addRange(0x11447, 0x1144A).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114AF).addRange(0x114C4, 0x114C5).addRange(0x11580, 0x115AE).addRange(0x115D8, 0x115DB).addRange(0x11600, 0x1162F).addRange(0x11680, 0x116AA).addRange(0x11700, 0x1171A).addRange(0x11740, 0x11746).addRange(0x11800, 0x1182B).addRange(0x118A0, 0x118DF).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x1192F).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D0);
	set.addRange(0x11A0B, 0x11A32).addRange(0x11A5C, 0x11A89).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C2E).addRange(0x11C72, 0x11C8F).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D30).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D89).addRange(0x11EE0, 0x11EF2).addRange(0x12000, 0x12399).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A70, 0x16ABE).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B40, 0x16B43).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16E40, 0x16E7F).addRange(0x16F00, 0x16F4A).addRange(0x16F93, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B000, 0x1B122).addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3);
	set.addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6FA).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D734).addRange(0x1D736, 0x1D74E).addRange(0x1D750, 0x1D76E).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D7A8).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7CB).addRange(0x1DF00, 0x1DF1E).addRange(0x1E100, 0x1E12C).addRange(0x1E137, 0x1E13D).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1E900, 0x1E943).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D);
	set.addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Line_Separator.js", function (module, exports) {
	  const set = regenerate(0x2028);

	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Lowercase_Letter.js", function (module, exports) {
	  const set = regenerate(0xB5, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x183, 0x185, 0x188, 0x192, 0x195, 0x19E, 0x1A1, 0x1A3, 0x1A5, 0x1A8, 0x1AD, 0x1B0, 0x1B4, 0x1B6, 0x1C6, 0x1C9, 0x1CC, 0x1CE, 0x1D0, 0x1D2, 0x1D4, 0x1D6, 0x1D8, 0x1DA, 0x1DF, 0x1E1, 0x1E3, 0x1E5, 0x1E7, 0x1E9, 0x1EB, 0x1ED, 0x1F3, 0x1F5, 0x1F9, 0x1FB, 0x1FD, 0x1FF, 0x201, 0x203, 0x205, 0x207, 0x209, 0x20B, 0x20D, 0x20F, 0x211, 0x213, 0x215, 0x217, 0x219, 0x21B, 0x21D, 0x21F, 0x221, 0x223, 0x225, 0x227, 0x229, 0x22B, 0x22D, 0x22F, 0x231, 0x23C, 0x242, 0x247, 0x249, 0x24B, 0x24D, 0x371, 0x373, 0x377, 0x390, 0x3D9, 0x3DB, 0x3DD, 0x3DF, 0x3E1, 0x3E3, 0x3E5, 0x3E7, 0x3E9, 0x3EB, 0x3ED, 0x3F5, 0x3F8, 0x461, 0x463, 0x465, 0x467, 0x469, 0x46B, 0x46D, 0x46F, 0x471, 0x473, 0x475, 0x477, 0x479, 0x47B, 0x47D, 0x47F, 0x481, 0x48B, 0x48D, 0x48F, 0x491, 0x493, 0x495, 0x497, 0x499, 0x49B, 0x49D, 0x49F, 0x4A1, 0x4A3, 0x4A5, 0x4A7, 0x4A9, 0x4AB, 0x4AD, 0x4AF, 0x4B1, 0x4B3, 0x4B5, 0x4B7, 0x4B9, 0x4BB, 0x4BD, 0x4BF, 0x4C2, 0x4C4, 0x4C6, 0x4C8, 0x4CA, 0x4CC, 0x4D1, 0x4D3, 0x4D5, 0x4D7, 0x4D9, 0x4DB, 0x4DD, 0x4DF, 0x4E1, 0x4E3, 0x4E5, 0x4E7, 0x4E9, 0x4EB, 0x4ED, 0x4EF, 0x4F1, 0x4F3, 0x4F5, 0x4F7, 0x4F9, 0x4FB, 0x4FD, 0x4FF, 0x501, 0x503, 0x505, 0x507, 0x509, 0x50B, 0x50D, 0x50F, 0x511, 0x513, 0x515, 0x517, 0x519, 0x51B, 0x51D, 0x51F, 0x521, 0x523, 0x525, 0x527, 0x529, 0x52B, 0x52D, 0x52F, 0x1E01, 0x1E03, 0x1E05, 0x1E07, 0x1E09, 0x1E0B, 0x1E0D, 0x1E0F, 0x1E11, 0x1E13, 0x1E15, 0x1E17, 0x1E19, 0x1E1B, 0x1E1D, 0x1E1F, 0x1E21, 0x1E23, 0x1E25, 0x1E27, 0x1E29, 0x1E2B, 0x1E2D, 0x1E2F, 0x1E31, 0x1E33, 0x1E35, 0x1E37, 0x1E39, 0x1E3B, 0x1E3D, 0x1E3F, 0x1E41, 0x1E43, 0x1E45, 0x1E47, 0x1E49, 0x1E4B, 0x1E4D, 0x1E4F, 0x1E51, 0x1E53, 0x1E55, 0x1E57, 0x1E59, 0x1E5B, 0x1E5D, 0x1E5F, 0x1E61, 0x1E63, 0x1E65, 0x1E67, 0x1E69, 0x1E6B, 0x1E6D, 0x1E6F, 0x1E71, 0x1E73, 0x1E75, 0x1E77, 0x1E79, 0x1E7B, 0x1E7D, 0x1E7F, 0x1E81, 0x1E83, 0x1E85, 0x1E87, 0x1E89, 0x1E8B, 0x1E8D, 0x1E8F, 0x1E91, 0x1E93, 0x1E9F, 0x1EA1, 0x1EA3, 0x1EA5, 0x1EA7, 0x1EA9, 0x1EAB, 0x1EAD, 0x1EAF, 0x1EB1, 0x1EB3, 0x1EB5, 0x1EB7, 0x1EB9, 0x1EBB, 0x1EBD, 0x1EBF, 0x1EC1, 0x1EC3, 0x1EC5, 0x1EC7, 0x1EC9, 0x1ECB, 0x1ECD, 0x1ECF, 0x1ED1, 0x1ED3, 0x1ED5, 0x1ED7, 0x1ED9, 0x1EDB, 0x1EDD, 0x1EDF, 0x1EE1, 0x1EE3, 0x1EE5, 0x1EE7, 0x1EE9, 0x1EEB, 0x1EED, 0x1EEF, 0x1EF1, 0x1EF3, 0x1EF5, 0x1EF7, 0x1EF9, 0x1EFB, 0x1EFD, 0x1FBE, 0x210A, 0x2113, 0x212F, 0x2134, 0x2139, 0x214E, 0x2184, 0x2C61, 0x2C68, 0x2C6A, 0x2C6C, 0x2C71, 0x2C81, 0x2C83, 0x2C85, 0x2C87, 0x2C89, 0x2C8B, 0x2C8D, 0x2C8F, 0x2C91, 0x2C93, 0x2C95, 0x2C97, 0x2C99, 0x2C9B, 0x2C9D, 0x2C9F, 0x2CA1, 0x2CA3, 0x2CA5, 0x2CA7, 0x2CA9, 0x2CAB, 0x2CAD, 0x2CAF, 0x2CB1, 0x2CB3, 0x2CB5, 0x2CB7, 0x2CB9, 0x2CBB, 0x2CBD, 0x2CBF, 0x2CC1, 0x2CC3, 0x2CC5, 0x2CC7, 0x2CC9, 0x2CCB, 0x2CCD, 0x2CCF, 0x2CD1, 0x2CD3, 0x2CD5, 0x2CD7, 0x2CD9, 0x2CDB, 0x2CDD, 0x2CDF, 0x2CE1, 0x2CEC, 0x2CEE, 0x2CF3, 0x2D27, 0x2D2D, 0xA641, 0xA643, 0xA645, 0xA647, 0xA649, 0xA64B, 0xA64D, 0xA64F, 0xA651, 0xA653, 0xA655, 0xA657, 0xA659, 0xA65B, 0xA65D, 0xA65F, 0xA661, 0xA663, 0xA665, 0xA667, 0xA669, 0xA66B, 0xA66D, 0xA681, 0xA683, 0xA685, 0xA687, 0xA689, 0xA68B, 0xA68D, 0xA68F, 0xA691, 0xA693, 0xA695, 0xA697, 0xA699, 0xA69B, 0xA723, 0xA725, 0xA727, 0xA729, 0xA72B, 0xA72D, 0xA733, 0xA735, 0xA737, 0xA739, 0xA73B, 0xA73D, 0xA73F, 0xA741, 0xA743, 0xA745, 0xA747, 0xA749, 0xA74B, 0xA74D, 0xA74F, 0xA751, 0xA753, 0xA755, 0xA757, 0xA759, 0xA75B, 0xA75D, 0xA75F, 0xA761, 0xA763, 0xA765, 0xA767, 0xA769, 0xA76B, 0xA76D, 0xA76F, 0xA77A, 0xA77C, 0xA77F, 0xA781, 0xA783, 0xA785, 0xA787, 0xA78C, 0xA78E, 0xA791, 0xA797, 0xA799, 0xA79B, 0xA79D, 0xA79F, 0xA7A1, 0xA7A3, 0xA7A5, 0xA7A7, 0xA7A9, 0xA7AF, 0xA7B5, 0xA7B7, 0xA7B9, 0xA7BB, 0xA7BD, 0xA7BF, 0xA7C1, 0xA7C3, 0xA7C8, 0xA7CA, 0xA7D1, 0xA7D3, 0xA7D5, 0xA7D7, 0xA7D9, 0xA7F6, 0xA7FA, 0x1D4BB, 0x1D7CB);
	set.addRange(0x61, 0x7A).addRange(0xDF, 0xF6).addRange(0xF8, 0xFF).addRange(0x137, 0x138).addRange(0x148, 0x149).addRange(0x17E, 0x180).addRange(0x18C, 0x18D).addRange(0x199, 0x19B).addRange(0x1AA, 0x1AB).addRange(0x1B9, 0x1BA).addRange(0x1BD, 0x1BF).addRange(0x1DC, 0x1DD).addRange(0x1EF, 0x1F0).addRange(0x233, 0x239).addRange(0x23F, 0x240).addRange(0x24F, 0x293).addRange(0x295, 0x2AF).addRange(0x37B, 0x37D).addRange(0x3AC, 0x3CE).addRange(0x3D0, 0x3D1).addRange(0x3D5, 0x3D7).addRange(0x3EF, 0x3F3).addRange(0x3FB, 0x3FC).addRange(0x430, 0x45F).addRange(0x4CE, 0x4CF).addRange(0x560, 0x588).addRange(0x10D0, 0x10FA).addRange(0x10FD, 0x10FF).addRange(0x13F8, 0x13FD).addRange(0x1C80, 0x1C88).addRange(0x1D00, 0x1D2B).addRange(0x1D6B, 0x1D77).addRange(0x1D79, 0x1D9A).addRange(0x1E95, 0x1E9D).addRange(0x1EFF, 0x1F07).addRange(0x1F10, 0x1F15).addRange(0x1F20, 0x1F27).addRange(0x1F30, 0x1F37).addRange(0x1F40, 0x1F45).addRange(0x1F50, 0x1F57).addRange(0x1F60, 0x1F67).addRange(0x1F70, 0x1F7D).addRange(0x1F80, 0x1F87).addRange(0x1F90, 0x1F97).addRange(0x1FA0, 0x1FA7).addRange(0x1FB0, 0x1FB4).addRange(0x1FB6, 0x1FB7).addRange(0x1FC2, 0x1FC4).addRange(0x1FC6, 0x1FC7).addRange(0x1FD0, 0x1FD3).addRange(0x1FD6, 0x1FD7);
	set.addRange(0x1FE0, 0x1FE7).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FF7).addRange(0x210E, 0x210F).addRange(0x213C, 0x213D).addRange(0x2146, 0x2149).addRange(0x2C30, 0x2C5F).addRange(0x2C65, 0x2C66).addRange(0x2C73, 0x2C74).addRange(0x2C76, 0x2C7B).addRange(0x2CE3, 0x2CE4).addRange(0x2D00, 0x2D25).addRange(0xA72F, 0xA731).addRange(0xA771, 0xA778).addRange(0xA793, 0xA795).addRange(0xAB30, 0xAB5A).addRange(0xAB60, 0xAB68).addRange(0xAB70, 0xABBF).addRange(0xFB00, 0xFB06).addRange(0xFB13, 0xFB17).addRange(0xFF41, 0xFF5A).addRange(0x10428, 0x1044F).addRange(0x104D8, 0x104FB).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC).addRange(0x10CC0, 0x10CF2).addRange(0x118C0, 0x118DF).addRange(0x16E60, 0x16E7F).addRange(0x1D41A, 0x1D433).addRange(0x1D44E, 0x1D454).addRange(0x1D456, 0x1D467).addRange(0x1D482, 0x1D49B).addRange(0x1D4B6, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D4CF).addRange(0x1D4EA, 0x1D503).addRange(0x1D51E, 0x1D537).addRange(0x1D552, 0x1D56B).addRange(0x1D586, 0x1D59F).addRange(0x1D5BA, 0x1D5D3).addRange(0x1D5EE, 0x1D607).addRange(0x1D622, 0x1D63B).addRange(0x1D656, 0x1D66F).addRange(0x1D68A, 0x1D6A5).addRange(0x1D6C2, 0x1D6DA).addRange(0x1D6DC, 0x1D6E1).addRange(0x1D6FC, 0x1D714).addRange(0x1D716, 0x1D71B).addRange(0x1D736, 0x1D74E);
	set.addRange(0x1D750, 0x1D755).addRange(0x1D770, 0x1D788).addRange(0x1D78A, 0x1D78F).addRange(0x1D7AA, 0x1D7C2).addRange(0x1D7C4, 0x1D7C9).addRange(0x1DF00, 0x1DF09).addRange(0x1DF0B, 0x1DF1E).addRange(0x1E922, 0x1E943);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Mark.js", function (module, exports) {
	  const set = regenerate(0x5BF, 0x5C7, 0x670, 0x711, 0x7FD, 0x9BC, 0x9D7, 0x9FE, 0xA3C, 0xA51, 0xA75, 0xABC, 0xB3C, 0xB82, 0xBD7, 0xC3C, 0xCBC, 0xD57, 0xDCA, 0xDD6, 0xE31, 0xEB1, 0xF35, 0xF37, 0xF39, 0xFC6, 0x108F, 0x17DD, 0x180F, 0x18A9, 0x1A7F, 0x1CED, 0x1CF4, 0x2D7F, 0xA802, 0xA806, 0xA80B, 0xA82C, 0xA8FF, 0xA9E5, 0xAA43, 0xAAB0, 0xAAC1, 0xFB1E, 0x101FD, 0x102E0, 0x10A3F, 0x11070, 0x110C2, 0x11173, 0x1123E, 0x11357, 0x1145E, 0x11940, 0x119E4, 0x11A47, 0x11D3A, 0x11D47, 0x16F4F, 0x16FE4, 0x1DA75, 0x1DA84, 0x1E2AE);
	set.addRange(0x300, 0x36F).addRange(0x483, 0x489).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x610, 0x61A).addRange(0x64B, 0x65F).addRange(0x6D6, 0x6DC).addRange(0x6DF, 0x6E4).addRange(0x6E7, 0x6E8).addRange(0x6EA, 0x6ED).addRange(0x730, 0x74A).addRange(0x7A6, 0x7B0).addRange(0x7EB, 0x7F3).addRange(0x816, 0x819).addRange(0x81B, 0x823).addRange(0x825, 0x827).addRange(0x829, 0x82D).addRange(0x859, 0x85B).addRange(0x898, 0x89F).addRange(0x8CA, 0x8E1).addRange(0x8E3, 0x903).addRange(0x93A, 0x93C).addRange(0x93E, 0x94F).addRange(0x951, 0x957).addRange(0x962, 0x963).addRange(0x981, 0x983).addRange(0x9BE, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CD).addRange(0x9E2, 0x9E3).addRange(0xA01, 0xA03).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA70, 0xA71).addRange(0xA81, 0xA83).addRange(0xABE, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE2, 0xAE3).addRange(0xAFA, 0xAFF).addRange(0xB01, 0xB03).addRange(0xB3E, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB62, 0xB63).addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD);
	set.addRange(0xC00, 0xC04).addRange(0xC3E, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC62, 0xC63).addRange(0xC81, 0xC83).addRange(0xCBE, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCE2, 0xCE3).addRange(0xD00, 0xD03).addRange(0xD3B, 0xD3C).addRange(0xD3E, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4D).addRange(0xD62, 0xD63).addRange(0xD81, 0xD83).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDF2, 0xDF3).addRange(0xE34, 0xE3A).addRange(0xE47, 0xE4E).addRange(0xEB4, 0xEBC).addRange(0xEC8, 0xECD).addRange(0xF18, 0xF19).addRange(0xF3E, 0xF3F).addRange(0xF71, 0xF84).addRange(0xF86, 0xF87).addRange(0xF8D, 0xF97).addRange(0xF99, 0xFBC).addRange(0x102B, 0x103E).addRange(0x1056, 0x1059).addRange(0x105E, 0x1060).addRange(0x1062, 0x1064).addRange(0x1067, 0x106D).addRange(0x1071, 0x1074).addRange(0x1082, 0x108D).addRange(0x109A, 0x109D).addRange(0x135D, 0x135F).addRange(0x1712, 0x1715).addRange(0x1732, 0x1734).addRange(0x1752, 0x1753).addRange(0x1772, 0x1773).addRange(0x17B4, 0x17D3).addRange(0x180B, 0x180D).addRange(0x1885, 0x1886).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1A17, 0x1A1B);
	set.addRange(0x1A55, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1AB0, 0x1ACE).addRange(0x1B00, 0x1B04).addRange(0x1B34, 0x1B44).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1B82).addRange(0x1BA1, 0x1BAD).addRange(0x1BE6, 0x1BF3).addRange(0x1C24, 0x1C37).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CE8).addRange(0x1CF7, 0x1CF9).addRange(0x1DC0, 0x1DFF).addRange(0x20D0, 0x20F0).addRange(0x2CEF, 0x2CF1).addRange(0x2DE0, 0x2DFF).addRange(0x302A, 0x302F).addRange(0x3099, 0x309A).addRange(0xA66F, 0xA672).addRange(0xA674, 0xA67D).addRange(0xA69E, 0xA69F).addRange(0xA6F0, 0xA6F1).addRange(0xA823, 0xA827).addRange(0xA880, 0xA881).addRange(0xA8B4, 0xA8C5).addRange(0xA8E0, 0xA8F1).addRange(0xA926, 0xA92D).addRange(0xA947, 0xA953).addRange(0xA980, 0xA983).addRange(0xA9B3, 0xA9C0).addRange(0xAA29, 0xAA36).addRange(0xAA4C, 0xAA4D).addRange(0xAA7B, 0xAA7D).addRange(0xAAB2, 0xAAB4).addRange(0xAAB7, 0xAAB8).addRange(0xAABE, 0xAABF).addRange(0xAAEB, 0xAAEF).addRange(0xAAF5, 0xAAF6).addRange(0xABE3, 0xABEA).addRange(0xABEC, 0xABED).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0x10376, 0x1037A).addRange(0x10A01, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A0F).addRange(0x10A38, 0x10A3A).addRange(0x10AE5, 0x10AE6).addRange(0x10D24, 0x10D27).addRange(0x10EAB, 0x10EAC);
	set.addRange(0x10F46, 0x10F50).addRange(0x10F82, 0x10F85).addRange(0x11000, 0x11002).addRange(0x11038, 0x11046).addRange(0x11073, 0x11074).addRange(0x1107F, 0x11082).addRange(0x110B0, 0x110BA).addRange(0x11100, 0x11102).addRange(0x11127, 0x11134).addRange(0x11145, 0x11146).addRange(0x11180, 0x11182).addRange(0x111B3, 0x111C0).addRange(0x111C9, 0x111CC).addRange(0x111CE, 0x111CF).addRange(0x1122C, 0x11237).addRange(0x112DF, 0x112EA).addRange(0x11300, 0x11303).addRange(0x1133B, 0x1133C).addRange(0x1133E, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x11362, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11435, 0x11446).addRange(0x114B0, 0x114C3).addRange(0x115AF, 0x115B5).addRange(0x115B8, 0x115C0).addRange(0x115DC, 0x115DD).addRange(0x11630, 0x11640).addRange(0x116AB, 0x116B7).addRange(0x1171D, 0x1172B).addRange(0x1182C, 0x1183A).addRange(0x11930, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x1193E).addRange(0x11942, 0x11943).addRange(0x119D1, 0x119D7).addRange(0x119DA, 0x119E0).addRange(0x11A01, 0x11A0A).addRange(0x11A33, 0x11A39).addRange(0x11A3B, 0x11A3E).addRange(0x11A51, 0x11A5B).addRange(0x11A8A, 0x11A99).addRange(0x11C2F, 0x11C36).addRange(0x11C38, 0x11C3F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6).addRange(0x11D31, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D45);
	set.addRange(0x11D8A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D97).addRange(0x11EF3, 0x11EF6).addRange(0x16AF0, 0x16AF4).addRange(0x16B30, 0x16B36).addRange(0x16F51, 0x16F87).addRange(0x16F8F, 0x16F92).addRange(0x16FF0, 0x16FF1).addRange(0x1BC9D, 0x1BC9E).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D165, 0x1D169).addRange(0x1D16D, 0x1D172).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E130, 0x1E136).addRange(0x1E2EC, 0x1E2EF).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E944, 0x1E94A).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Math_Symbol.js", function (module, exports) {
	  const set = regenerate(0x2B, 0x7C, 0x7E, 0xAC, 0xB1, 0xD7, 0xF7, 0x3F6, 0x2044, 0x2052, 0x2118, 0x214B, 0x21A0, 0x21A3, 0x21A6, 0x21AE, 0x21D2, 0x21D4, 0x237C, 0x25B7, 0x25C1, 0x266F, 0xFB29, 0xFE62, 0xFF0B, 0xFF5C, 0xFF5E, 0xFFE2, 0x1D6C1, 0x1D6DB, 0x1D6FB, 0x1D715, 0x1D735, 0x1D74F, 0x1D76F, 0x1D789, 0x1D7A9, 0x1D7C3);
	set.addRange(0x3C, 0x3E).addRange(0x606, 0x608).addRange(0x207A, 0x207C).addRange(0x208A, 0x208C).addRange(0x2140, 0x2144).addRange(0x2190, 0x2194).addRange(0x219A, 0x219B).addRange(0x21CE, 0x21CF).addRange(0x21F4, 0x22FF).addRange(0x2320, 0x2321).addRange(0x239B, 0x23B3).addRange(0x23DC, 0x23E1).addRange(0x25F8, 0x25FF).addRange(0x27C0, 0x27C4).addRange(0x27C7, 0x27E5).addRange(0x27F0, 0x27FF).addRange(0x2900, 0x2982).addRange(0x2999, 0x29D7).addRange(0x29DC, 0x29FB).addRange(0x29FE, 0x2AFF).addRange(0x2B30, 0x2B44).addRange(0x2B47, 0x2B4C).addRange(0xFE64, 0xFE66).addRange(0xFF1C, 0xFF1E).addRange(0xFFE9, 0xFFEC).addRange(0x1EEF0, 0x1EEF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Modifier_Letter.js", function (module, exports) {
	  const set = regenerate(0x2EC, 0x2EE, 0x374, 0x37A, 0x559, 0x640, 0x7FA, 0x81A, 0x824, 0x828, 0x8C9, 0x971, 0xE46, 0xEC6, 0x10FC, 0x17D7, 0x1843, 0x1AA7, 0x1D78, 0x2071, 0x207F, 0x2D6F, 0x2E2F, 0x3005, 0x303B, 0xA015, 0xA60C, 0xA67F, 0xA770, 0xA788, 0xA9CF, 0xA9E6, 0xAA70, 0xAADD, 0xAB69, 0xFF70, 0x16FE3, 0x1E94B);
	set.addRange(0x2B0, 0x2C1).addRange(0x2C6, 0x2D1).addRange(0x2E0, 0x2E4).addRange(0x6E5, 0x6E6).addRange(0x7F4, 0x7F5).addRange(0x1C78, 0x1C7D).addRange(0x1D2C, 0x1D6A).addRange(0x1D9B, 0x1DBF).addRange(0x2090, 0x209C).addRange(0x2C7C, 0x2C7D).addRange(0x3031, 0x3035).addRange(0x309D, 0x309E).addRange(0x30FC, 0x30FE).addRange(0xA4F8, 0xA4FD).addRange(0xA69C, 0xA69D).addRange(0xA717, 0xA71F).addRange(0xA7F2, 0xA7F4).addRange(0xA7F8, 0xA7F9).addRange(0xAAF3, 0xAAF4).addRange(0xAB5C, 0xAB5F).addRange(0xFF9E, 0xFF9F).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x16B40, 0x16B43).addRange(0x16F93, 0x16F9F).addRange(0x16FE0, 0x16FE1).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1E137, 0x1E13D);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Modifier_Symbol.js", function (module, exports) {
	  const set = regenerate(0x5E, 0x60, 0xA8, 0xAF, 0xB4, 0xB8, 0x2ED, 0x375, 0x888, 0x1FBD, 0xAB5B, 0xFF3E, 0xFF40, 0xFFE3);
	set.addRange(0x2C2, 0x2C5).addRange(0x2D2, 0x2DF).addRange(0x2E5, 0x2EB).addRange(0x2EF, 0x2FF).addRange(0x384, 0x385).addRange(0x1FBF, 0x1FC1).addRange(0x1FCD, 0x1FCF).addRange(0x1FDD, 0x1FDF).addRange(0x1FED, 0x1FEF).addRange(0x1FFD, 0x1FFE).addRange(0x309B, 0x309C).addRange(0xA700, 0xA716).addRange(0xA720, 0xA721).addRange(0xA789, 0xA78A).addRange(0xAB6A, 0xAB6B).addRange(0xFBB2, 0xFBC2).addRange(0x1F3FB, 0x1F3FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Nonspacing_Mark.js", function (module, exports) {
	  const set = regenerate(0x5BF, 0x5C7, 0x670, 0x711, 0x7FD, 0x93A, 0x93C, 0x94D, 0x981, 0x9BC, 0x9CD, 0x9FE, 0xA3C, 0xA51, 0xA75, 0xABC, 0xACD, 0xB01, 0xB3C, 0xB3F, 0xB4D, 0xB82, 0xBC0, 0xBCD, 0xC00, 0xC04, 0xC3C, 0xC81, 0xCBC, 0xCBF, 0xCC6, 0xD4D, 0xD81, 0xDCA, 0xDD6, 0xE31, 0xEB1, 0xF35, 0xF37, 0xF39, 0xFC6, 0x1082, 0x108D, 0x109D, 0x17C6, 0x17DD, 0x180F, 0x18A9, 0x1932, 0x1A1B, 0x1A56, 0x1A60, 0x1A62, 0x1A7F, 0x1B34, 0x1B3C, 0x1B42, 0x1BE6, 0x1BED, 0x1CED, 0x1CF4, 0x20E1, 0x2D7F, 0xA66F, 0xA802, 0xA806, 0xA80B, 0xA82C, 0xA8FF, 0xA9B3, 0xA9E5, 0xAA43, 0xAA4C, 0xAA7C, 0xAAB0, 0xAAC1, 0xAAF6, 0xABE5, 0xABE8, 0xABED, 0xFB1E, 0x101FD, 0x102E0, 0x10A3F, 0x11001, 0x11070, 0x110C2, 0x11173, 0x111CF, 0x11234, 0x1123E, 0x112DF, 0x11340, 0x11446, 0x1145E, 0x114BA, 0x1163D, 0x116AB, 0x116AD, 0x116B7, 0x1193E, 0x11943, 0x119E0, 0x11A47, 0x11C3F, 0x11D3A, 0x11D47, 0x11D95, 0x11D97, 0x16F4F, 0x16FE4, 0x1DA75, 0x1DA84, 0x1E2AE);
	set.addRange(0x300, 0x36F).addRange(0x483, 0x487).addRange(0x591, 0x5BD).addRange(0x5C1, 0x5C2).addRange(0x5C4, 0x5C5).addRange(0x610, 0x61A).addRange(0x64B, 0x65F).addRange(0x6D6, 0x6DC).addRange(0x6DF, 0x6E4).addRange(0x6E7, 0x6E8).addRange(0x6EA, 0x6ED).addRange(0x730, 0x74A).addRange(0x7A6, 0x7B0).addRange(0x7EB, 0x7F3).addRange(0x816, 0x819).addRange(0x81B, 0x823).addRange(0x825, 0x827).addRange(0x829, 0x82D).addRange(0x859, 0x85B).addRange(0x898, 0x89F).addRange(0x8CA, 0x8E1).addRange(0x8E3, 0x902).addRange(0x941, 0x948).addRange(0x951, 0x957).addRange(0x962, 0x963).addRange(0x9C1, 0x9C4).addRange(0x9E2, 0x9E3).addRange(0xA01, 0xA02).addRange(0xA41, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA70, 0xA71).addRange(0xA81, 0xA82).addRange(0xAC1, 0xAC5).addRange(0xAC7, 0xAC8).addRange(0xAE2, 0xAE3).addRange(0xAFA, 0xAFF).addRange(0xB41, 0xB44).addRange(0xB55, 0xB56).addRange(0xB62, 0xB63).addRange(0xC3E, 0xC40).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC62, 0xC63).addRange(0xCCC, 0xCCD).addRange(0xCE2, 0xCE3).addRange(0xD00, 0xD01).addRange(0xD3B, 0xD3C).addRange(0xD41, 0xD44).addRange(0xD62, 0xD63);
	set.addRange(0xDD2, 0xDD4).addRange(0xE34, 0xE3A).addRange(0xE47, 0xE4E).addRange(0xEB4, 0xEBC).addRange(0xEC8, 0xECD).addRange(0xF18, 0xF19).addRange(0xF71, 0xF7E).addRange(0xF80, 0xF84).addRange(0xF86, 0xF87).addRange(0xF8D, 0xF97).addRange(0xF99, 0xFBC).addRange(0x102D, 0x1030).addRange(0x1032, 0x1037).addRange(0x1039, 0x103A).addRange(0x103D, 0x103E).addRange(0x1058, 0x1059).addRange(0x105E, 0x1060).addRange(0x1071, 0x1074).addRange(0x1085, 0x1086).addRange(0x135D, 0x135F).addRange(0x1712, 0x1714).addRange(0x1732, 0x1733).addRange(0x1752, 0x1753).addRange(0x1772, 0x1773).addRange(0x17B4, 0x17B5).addRange(0x17B7, 0x17BD).addRange(0x17C9, 0x17D3).addRange(0x180B, 0x180D).addRange(0x1885, 0x1886).addRange(0x1920, 0x1922).addRange(0x1927, 0x1928).addRange(0x1939, 0x193B).addRange(0x1A17, 0x1A18).addRange(0x1A58, 0x1A5E).addRange(0x1A65, 0x1A6C).addRange(0x1A73, 0x1A7C).addRange(0x1AB0, 0x1ABD).addRange(0x1ABF, 0x1ACE).addRange(0x1B00, 0x1B03).addRange(0x1B36, 0x1B3A).addRange(0x1B6B, 0x1B73).addRange(0x1B80, 0x1B81).addRange(0x1BA2, 0x1BA5).addRange(0x1BA8, 0x1BA9).addRange(0x1BAB, 0x1BAD).addRange(0x1BE8, 0x1BE9).addRange(0x1BEF, 0x1BF1).addRange(0x1C2C, 0x1C33).addRange(0x1C36, 0x1C37).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CE0);
	set.addRange(0x1CE2, 0x1CE8).addRange(0x1CF8, 0x1CF9).addRange(0x1DC0, 0x1DFF).addRange(0x20D0, 0x20DC).addRange(0x20E5, 0x20F0).addRange(0x2CEF, 0x2CF1).addRange(0x2DE0, 0x2DFF).addRange(0x302A, 0x302D).addRange(0x3099, 0x309A).addRange(0xA674, 0xA67D).addRange(0xA69E, 0xA69F).addRange(0xA6F0, 0xA6F1).addRange(0xA825, 0xA826).addRange(0xA8C4, 0xA8C5).addRange(0xA8E0, 0xA8F1).addRange(0xA926, 0xA92D).addRange(0xA947, 0xA951).addRange(0xA980, 0xA982).addRange(0xA9B6, 0xA9B9).addRange(0xA9BC, 0xA9BD).addRange(0xAA29, 0xAA2E).addRange(0xAA31, 0xAA32).addRange(0xAA35, 0xAA36).addRange(0xAAB2, 0xAAB4).addRange(0xAAB7, 0xAAB8).addRange(0xAABE, 0xAABF).addRange(0xAAEC, 0xAAED).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2F).addRange(0x10376, 0x1037A).addRange(0x10A01, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A0F).addRange(0x10A38, 0x10A3A).addRange(0x10AE5, 0x10AE6).addRange(0x10D24, 0x10D27).addRange(0x10EAB, 0x10EAC).addRange(0x10F46, 0x10F50).addRange(0x10F82, 0x10F85).addRange(0x11038, 0x11046).addRange(0x11073, 0x11074).addRange(0x1107F, 0x11081).addRange(0x110B3, 0x110B6).addRange(0x110B9, 0x110BA).addRange(0x11100, 0x11102).addRange(0x11127, 0x1112B).addRange(0x1112D, 0x11134).addRange(0x11180, 0x11181).addRange(0x111B6, 0x111BE).addRange(0x111C9, 0x111CC).addRange(0x1122F, 0x11231);
	set.addRange(0x11236, 0x11237).addRange(0x112E3, 0x112EA).addRange(0x11300, 0x11301).addRange(0x1133B, 0x1133C).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11438, 0x1143F).addRange(0x11442, 0x11444).addRange(0x114B3, 0x114B8).addRange(0x114BF, 0x114C0).addRange(0x114C2, 0x114C3).addRange(0x115B2, 0x115B5).addRange(0x115BC, 0x115BD).addRange(0x115BF, 0x115C0).addRange(0x115DC, 0x115DD).addRange(0x11633, 0x1163A).addRange(0x1163F, 0x11640).addRange(0x116B0, 0x116B5).addRange(0x1171D, 0x1171F).addRange(0x11722, 0x11725).addRange(0x11727, 0x1172B).addRange(0x1182F, 0x11837).addRange(0x11839, 0x1183A).addRange(0x1193B, 0x1193C).addRange(0x119D4, 0x119D7).addRange(0x119DA, 0x119DB).addRange(0x11A01, 0x11A0A).addRange(0x11A33, 0x11A38).addRange(0x11A3B, 0x11A3E).addRange(0x11A51, 0x11A56).addRange(0x11A59, 0x11A5B).addRange(0x11A8A, 0x11A96).addRange(0x11A98, 0x11A99).addRange(0x11C30, 0x11C36).addRange(0x11C38, 0x11C3D).addRange(0x11C92, 0x11CA7).addRange(0x11CAA, 0x11CB0).addRange(0x11CB2, 0x11CB3).addRange(0x11CB5, 0x11CB6).addRange(0x11D31, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D45).addRange(0x11D90, 0x11D91).addRange(0x11EF3, 0x11EF4).addRange(0x16AF0, 0x16AF4).addRange(0x16B30, 0x16B36).addRange(0x16F8F, 0x16F92).addRange(0x1BC9D, 0x1BC9E).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169);
	set.addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0x1D242, 0x1D244).addRange(0x1DA00, 0x1DA36).addRange(0x1DA3B, 0x1DA6C).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A).addRange(0x1E130, 0x1E136).addRange(0x1E2EC, 0x1E2EF).addRange(0x1E8D0, 0x1E8D6).addRange(0x1E944, 0x1E94A).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Number.js", function (module, exports) {
	  const set = regenerate(0xB9, 0x2070, 0x2CFD, 0x3007, 0x10341, 0x1034A);
	set.addRange(0x30, 0x39).addRange(0xB2, 0xB3).addRange(0xBC, 0xBE).addRange(0x660, 0x669).addRange(0x6F0, 0x6F9).addRange(0x7C0, 0x7C9).addRange(0x966, 0x96F).addRange(0x9E6, 0x9EF).addRange(0x9F4, 0x9F9).addRange(0xA66, 0xA6F).addRange(0xAE6, 0xAEF).addRange(0xB66, 0xB6F).addRange(0xB72, 0xB77).addRange(0xBE6, 0xBF2).addRange(0xC66, 0xC6F).addRange(0xC78, 0xC7E).addRange(0xCE6, 0xCEF).addRange(0xD58, 0xD5E).addRange(0xD66, 0xD78).addRange(0xDE6, 0xDEF).addRange(0xE50, 0xE59).addRange(0xED0, 0xED9).addRange(0xF20, 0xF33).addRange(0x1040, 0x1049).addRange(0x1090, 0x1099).addRange(0x1369, 0x137C).addRange(0x16EE, 0x16F0).addRange(0x17E0, 0x17E9).addRange(0x17F0, 0x17F9).addRange(0x1810, 0x1819).addRange(0x1946, 0x194F).addRange(0x19D0, 0x19DA).addRange(0x1A80, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1B50, 0x1B59).addRange(0x1BB0, 0x1BB9).addRange(0x1C40, 0x1C49).addRange(0x1C50, 0x1C59).addRange(0x2074, 0x2079).addRange(0x2080, 0x2089).addRange(0x2150, 0x2182).addRange(0x2185, 0x2189).addRange(0x2460, 0x249B).addRange(0x24EA, 0x24FF).addRange(0x2776, 0x2793).addRange(0x3021, 0x3029).addRange(0x3038, 0x303A).addRange(0x3192, 0x3195).addRange(0x3220, 0x3229).addRange(0x3248, 0x324F).addRange(0x3251, 0x325F);
	set.addRange(0x3280, 0x3289).addRange(0x32B1, 0x32BF).addRange(0xA620, 0xA629).addRange(0xA6E6, 0xA6EF).addRange(0xA830, 0xA835).addRange(0xA8D0, 0xA8D9).addRange(0xA900, 0xA909).addRange(0xA9D0, 0xA9D9).addRange(0xA9F0, 0xA9F9).addRange(0xAA50, 0xAA59).addRange(0xABF0, 0xABF9).addRange(0xFF10, 0xFF19).addRange(0x10107, 0x10133).addRange(0x10140, 0x10178).addRange(0x1018A, 0x1018B).addRange(0x102E1, 0x102FB).addRange(0x10320, 0x10323).addRange(0x103D1, 0x103D5).addRange(0x104A0, 0x104A9).addRange(0x10858, 0x1085F).addRange(0x10879, 0x1087F).addRange(0x108A7, 0x108AF).addRange(0x108FB, 0x108FF).addRange(0x10916, 0x1091B).addRange(0x109BC, 0x109BD).addRange(0x109C0, 0x109CF).addRange(0x109D2, 0x109FF).addRange(0x10A40, 0x10A48).addRange(0x10A7D, 0x10A7E).addRange(0x10A9D, 0x10A9F).addRange(0x10AEB, 0x10AEF).addRange(0x10B58, 0x10B5F).addRange(0x10B78, 0x10B7F).addRange(0x10BA9, 0x10BAF).addRange(0x10CFA, 0x10CFF).addRange(0x10D30, 0x10D39).addRange(0x10E60, 0x10E7E).addRange(0x10F1D, 0x10F26).addRange(0x10F51, 0x10F54).addRange(0x10FC5, 0x10FCB).addRange(0x11052, 0x1106F).addRange(0x110F0, 0x110F9).addRange(0x11136, 0x1113F).addRange(0x111D0, 0x111D9).addRange(0x111E1, 0x111F4).addRange(0x112F0, 0x112F9).addRange(0x11450, 0x11459).addRange(0x114D0, 0x114D9).addRange(0x11650, 0x11659).addRange(0x116C0, 0x116C9).addRange(0x11730, 0x1173B);
	set.addRange(0x118E0, 0x118F2).addRange(0x11950, 0x11959).addRange(0x11C50, 0x11C6C).addRange(0x11D50, 0x11D59).addRange(0x11DA0, 0x11DA9).addRange(0x11FC0, 0x11FD4).addRange(0x12400, 0x1246E).addRange(0x16A60, 0x16A69).addRange(0x16AC0, 0x16AC9).addRange(0x16B50, 0x16B59).addRange(0x16B5B, 0x16B61).addRange(0x16E80, 0x16E96).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D360, 0x1D378).addRange(0x1D7CE, 0x1D7FF).addRange(0x1E140, 0x1E149).addRange(0x1E2F0, 0x1E2F9).addRange(0x1E8C7, 0x1E8CF).addRange(0x1E950, 0x1E959).addRange(0x1EC71, 0x1ECAB).addRange(0x1ECAD, 0x1ECAF).addRange(0x1ECB1, 0x1ECB4).addRange(0x1ED01, 0x1ED2D).addRange(0x1ED2F, 0x1ED3D).addRange(0x1F100, 0x1F10C).addRange(0x1FBF0, 0x1FBF9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Open_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x28, 0x5B, 0x7B, 0xF3A, 0xF3C, 0x169B, 0x201A, 0x201E, 0x2045, 0x207D, 0x208D, 0x2308, 0x230A, 0x2329, 0x2768, 0x276A, 0x276C, 0x276E, 0x2770, 0x2772, 0x2774, 0x27C5, 0x27E6, 0x27E8, 0x27EA, 0x27EC, 0x27EE, 0x2983, 0x2985, 0x2987, 0x2989, 0x298B, 0x298D, 0x298F, 0x2991, 0x2993, 0x2995, 0x2997, 0x29D8, 0x29DA, 0x29FC, 0x2E22, 0x2E24, 0x2E26, 0x2E28, 0x2E42, 0x2E55, 0x2E57, 0x2E59, 0x2E5B, 0x3008, 0x300A, 0x300C, 0x300E, 0x3010, 0x3014, 0x3016, 0x3018, 0x301A, 0x301D, 0xFD3F, 0xFE17, 0xFE35, 0xFE37, 0xFE39, 0xFE3B, 0xFE3D, 0xFE3F, 0xFE41, 0xFE43, 0xFE47, 0xFE59, 0xFE5B, 0xFE5D, 0xFF08, 0xFF3B, 0xFF5B, 0xFF5F, 0xFF62);

	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Other_Letter.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xBA, 0x1BB, 0x294, 0x6D5, 0x6FF, 0x710, 0x7B1, 0x93D, 0x950, 0x9B2, 0x9BD, 0x9CE, 0x9FC, 0xA5E, 0xABD, 0xAD0, 0xAF9, 0xB3D, 0xB71, 0xB83, 0xB9C, 0xBD0, 0xC3D, 0xC5D, 0xC80, 0xCBD, 0xD3D, 0xD4E, 0xDBD, 0xE84, 0xEA5, 0xEBD, 0xF00, 0x103F, 0x1061, 0x108E, 0x1258, 0x12C0, 0x17DC, 0x18AA, 0x1CFA, 0x3006, 0x303C, 0x309F, 0x30FF, 0xA66E, 0xA78F, 0xA7F7, 0xA8FB, 0xAA7A, 0xAAB1, 0xAAC0, 0xAAC2, 0xAAF2, 0xFB1D, 0xFB3E, 0x10808, 0x1083C, 0x10A00, 0x10F27, 0x11075, 0x11144, 0x11147, 0x11176, 0x111DA, 0x111DC, 0x11288, 0x1133D, 0x11350, 0x114C7, 0x11644, 0x116B8, 0x11909, 0x1193F, 0x11941, 0x119E1, 0x119E3, 0x11A00, 0x11A3A, 0x11A50, 0x11A9D, 0x11C40, 0x11D46, 0x11D98, 0x11FB0, 0x16F50, 0x1DF0A, 0x1E14E, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x1C0, 0x1C3).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F2).addRange(0x620, 0x63F).addRange(0x641, 0x64A).addRange(0x66E, 0x66F).addRange(0x671, 0x6D3).addRange(0x6EE, 0x6EF).addRange(0x6FA, 0x6FC).addRange(0x712, 0x72F).addRange(0x74D, 0x7A5).addRange(0x7CA, 0x7EA).addRange(0x800, 0x815).addRange(0x840, 0x858).addRange(0x860, 0x86A).addRange(0x870, 0x887).addRange(0x889, 0x88E).addRange(0x8A0, 0x8C8).addRange(0x904, 0x939).addRange(0x958, 0x961).addRange(0x972, 0x980).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E1).addRange(0x9F0, 0x9F1).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA59, 0xA5C).addRange(0xA72, 0xA74).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xAE0, 0xAE1).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39);
	set.addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB61).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xC05, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC61).addRange(0xC85, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE1).addRange(0xCF1, 0xCF2).addRange(0xD04, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD3A).addRange(0xD54, 0xD56).addRange(0xD5F, 0xD61).addRange(0xD7A, 0xD7F).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xE01, 0xE30).addRange(0xE32, 0xE33).addRange(0xE40, 0xE45).addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEB0).addRange(0xEB2, 0xEB3).addRange(0xEC0, 0xEC4).addRange(0xEDC, 0xEDF).addRange(0xF40, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF88, 0xF8C).addRange(0x1000, 0x102A).addRange(0x1050, 0x1055).addRange(0x105A, 0x105D).addRange(0x1065, 0x1066);
	set.addRange(0x106E, 0x1070).addRange(0x1075, 0x1081).addRange(0x1100, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x1380, 0x138F).addRange(0x1401, 0x166C).addRange(0x166F, 0x167F).addRange(0x1681, 0x169A).addRange(0x16A0, 0x16EA).addRange(0x16F1, 0x16F8).addRange(0x1700, 0x1711).addRange(0x171F, 0x1731).addRange(0x1740, 0x1751).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1780, 0x17B3).addRange(0x1820, 0x1842).addRange(0x1844, 0x1878).addRange(0x1880, 0x1884).addRange(0x1887, 0x18A8).addRange(0x18B0, 0x18F5).addRange(0x1900, 0x191E).addRange(0x1950, 0x196D).addRange(0x1970, 0x1974).addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x1A00, 0x1A16).addRange(0x1A20, 0x1A54).addRange(0x1B05, 0x1B33).addRange(0x1B45, 0x1B4C).addRange(0x1B83, 0x1BA0).addRange(0x1BAE, 0x1BAF).addRange(0x1BBA, 0x1BE5).addRange(0x1C00, 0x1C23).addRange(0x1C4D, 0x1C4F).addRange(0x1C5A, 0x1C77).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF6);
	set.addRange(0x2135, 0x2138).addRange(0x2D30, 0x2D67).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0x3041, 0x3096).addRange(0x30A1, 0x30FA).addRange(0x3105, 0x312F).addRange(0x3131, 0x318E).addRange(0x31A0, 0x31BF).addRange(0x31F0, 0x31FF).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0xA014).addRange(0xA016, 0xA48C).addRange(0xA4D0, 0xA4F7).addRange(0xA500, 0xA60B).addRange(0xA610, 0xA61F).addRange(0xA62A, 0xA62B).addRange(0xA6A0, 0xA6E5).addRange(0xA7FB, 0xA801).addRange(0xA803, 0xA805).addRange(0xA807, 0xA80A).addRange(0xA80C, 0xA822).addRange(0xA840, 0xA873).addRange(0xA882, 0xA8B3).addRange(0xA8F2, 0xA8F7).addRange(0xA8FD, 0xA8FE).addRange(0xA90A, 0xA925).addRange(0xA930, 0xA946).addRange(0xA960, 0xA97C).addRange(0xA984, 0xA9B2).addRange(0xA9E0, 0xA9E4).addRange(0xA9E7, 0xA9EF).addRange(0xA9FA, 0xA9FE).addRange(0xAA00, 0xAA28).addRange(0xAA40, 0xAA42).addRange(0xAA44, 0xAA4B).addRange(0xAA60, 0xAA6F).addRange(0xAA71, 0xAA76).addRange(0xAA7E, 0xAAAF).addRange(0xAAB5, 0xAAB6).addRange(0xAAB9, 0xAABD).addRange(0xAADB, 0xAADC).addRange(0xAAE0, 0xAAEA).addRange(0xAB01, 0xAB06);
	set.addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0xABC0, 0xABE2).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFB1F, 0xFB28).addRange(0xFB2A, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFBB1).addRange(0xFBD3, 0xFD3D).addRange(0xFD50, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFB).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0xFF66, 0xFF6F).addRange(0xFF71, 0xFF9D).addRange(0xFFA0, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC).addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10280, 0x1029C).addRange(0x102A0, 0x102D0).addRange(0x10300, 0x1031F).addRange(0x1032D, 0x10340).addRange(0x10342, 0x10349).addRange(0x10350, 0x10375).addRange(0x10380, 0x1039D).addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103CF).addRange(0x10450, 0x1049D).addRange(0x10500, 0x10527).addRange(0x10530, 0x10563).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767);
	set.addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838).addRange(0x1083F, 0x10855).addRange(0x10860, 0x10876).addRange(0x10880, 0x1089E).addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x10900, 0x10915).addRange(0x10920, 0x10939).addRange(0x10980, 0x109B7).addRange(0x109BE, 0x109BF).addRange(0x10A10, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A60, 0x10A7C).addRange(0x10A80, 0x10A9C).addRange(0x10AC0, 0x10AC7).addRange(0x10AC9, 0x10AE4).addRange(0x10B00, 0x10B35).addRange(0x10B40, 0x10B55).addRange(0x10B60, 0x10B72).addRange(0x10B80, 0x10B91).addRange(0x10C00, 0x10C48).addRange(0x10D00, 0x10D23).addRange(0x10E80, 0x10EA9).addRange(0x10EB0, 0x10EB1).addRange(0x10F00, 0x10F1C).addRange(0x10F30, 0x10F45).addRange(0x10F70, 0x10F81).addRange(0x10FB0, 0x10FC4).addRange(0x10FE0, 0x10FF6).addRange(0x11003, 0x11037).addRange(0x11071, 0x11072).addRange(0x11083, 0x110AF).addRange(0x110D0, 0x110E8).addRange(0x11103, 0x11126).addRange(0x11150, 0x11172).addRange(0x11183, 0x111B2).addRange(0x111C1, 0x111C4).addRange(0x11200, 0x11211).addRange(0x11213, 0x1122B).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A8).addRange(0x112B0, 0x112DE).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330);
	set.addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1135D, 0x11361).addRange(0x11400, 0x11434).addRange(0x11447, 0x1144A).addRange(0x1145F, 0x11461).addRange(0x11480, 0x114AF).addRange(0x114C4, 0x114C5).addRange(0x11580, 0x115AE).addRange(0x115D8, 0x115DB).addRange(0x11600, 0x1162F).addRange(0x11680, 0x116AA).addRange(0x11700, 0x1171A).addRange(0x11740, 0x11746).addRange(0x11800, 0x1182B).addRange(0x118FF, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x1192F).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D0).addRange(0x11A0B, 0x11A32).addRange(0x11A5C, 0x11A89).addRange(0x11AB0, 0x11AF8).addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C2E).addRange(0x11C72, 0x11C8F).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D30).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D89).addRange(0x11EE0, 0x11EF2).addRange(0x12000, 0x12399).addRange(0x12480, 0x12543).addRange(0x12F90, 0x12FF0).addRange(0x13000, 0x1342E).addRange(0x14400, 0x14646).addRange(0x16800, 0x16A38).addRange(0x16A40, 0x16A5E).addRange(0x16A70, 0x16ABE).addRange(0x16AD0, 0x16AED).addRange(0x16B00, 0x16B2F).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F).addRange(0x16F00, 0x16F4A).addRange(0x17000, 0x187F7).addRange(0x18800, 0x18CD5).addRange(0x18D00, 0x18D08).addRange(0x1B000, 0x1B122);
	set.addRange(0x1B150, 0x1B152).addRange(0x1B164, 0x1B167).addRange(0x1B170, 0x1B2FB).addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1E100, 0x1E12C).addRange(0x1E290, 0x1E2AD).addRange(0x1E2C0, 0x1E2EB).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE).addRange(0x1E800, 0x1E8C4).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Other_Number.js", function (module, exports) {
	  const set = regenerate(0xB9, 0x19DA, 0x2070, 0x2189, 0x2CFD);
	set.addRange(0xB2, 0xB3).addRange(0xBC, 0xBE).addRange(0x9F4, 0x9F9).addRange(0xB72, 0xB77).addRange(0xBF0, 0xBF2).addRange(0xC78, 0xC7E).addRange(0xD58, 0xD5E).addRange(0xD70, 0xD78).addRange(0xF2A, 0xF33).addRange(0x1369, 0x137C).addRange(0x17F0, 0x17F9).addRange(0x2074, 0x2079).addRange(0x2080, 0x2089).addRange(0x2150, 0x215F).addRange(0x2460, 0x249B).addRange(0x24EA, 0x24FF).addRange(0x2776, 0x2793).addRange(0x3192, 0x3195).addRange(0x3220, 0x3229).addRange(0x3248, 0x324F).addRange(0x3251, 0x325F).addRange(0x3280, 0x3289).addRange(0x32B1, 0x32BF).addRange(0xA830, 0xA835).addRange(0x10107, 0x10133).addRange(0x10175, 0x10178).addRange(0x1018A, 0x1018B).addRange(0x102E1, 0x102FB).addRange(0x10320, 0x10323).addRange(0x10858, 0x1085F).addRange(0x10879, 0x1087F).addRange(0x108A7, 0x108AF).addRange(0x108FB, 0x108FF).addRange(0x10916, 0x1091B).addRange(0x109BC, 0x109BD).addRange(0x109C0, 0x109CF).addRange(0x109D2, 0x109FF).addRange(0x10A40, 0x10A48).addRange(0x10A7D, 0x10A7E).addRange(0x10A9D, 0x10A9F).addRange(0x10AEB, 0x10AEF).addRange(0x10B58, 0x10B5F).addRange(0x10B78, 0x10B7F).addRange(0x10BA9, 0x10BAF).addRange(0x10CFA, 0x10CFF).addRange(0x10E60, 0x10E7E).addRange(0x10F1D, 0x10F26).addRange(0x10F51, 0x10F54).addRange(0x10FC5, 0x10FCB).addRange(0x11052, 0x11065).addRange(0x111E1, 0x111F4);
	set.addRange(0x1173A, 0x1173B).addRange(0x118EA, 0x118F2).addRange(0x11C5A, 0x11C6C).addRange(0x11FC0, 0x11FD4).addRange(0x16B5B, 0x16B61).addRange(0x16E80, 0x16E96).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D360, 0x1D378).addRange(0x1E8C7, 0x1E8CF).addRange(0x1EC71, 0x1ECAB).addRange(0x1ECAD, 0x1ECAF).addRange(0x1ECB1, 0x1ECB4).addRange(0x1ED01, 0x1ED2D).addRange(0x1ED2F, 0x1ED3D).addRange(0x1F100, 0x1F10C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Other_Punctuation.js", function (module, exports) {
	  const set = regenerate(0x2A, 0x2C, 0x5C, 0xA1, 0xA7, 0xBF, 0x37E, 0x387, 0x589, 0x5C0, 0x5C3, 0x5C6, 0x61B, 0x6D4, 0x85E, 0x970, 0x9FD, 0xA76, 0xAF0, 0xC77, 0xC84, 0xDF4, 0xE4F, 0xF14, 0xF85, 0x10FB, 0x166E, 0x1CD3, 0x2053, 0x2D70, 0x2E0B, 0x2E1B, 0x2E41, 0x303D, 0x30FB, 0xA673, 0xA67E, 0xA8FC, 0xA95F, 0xABEB, 0xFE19, 0xFE30, 0xFE68, 0xFF0A, 0xFF0C, 0xFF3C, 0xFF61, 0x1039F, 0x103D0, 0x1056F, 0x10857, 0x1091F, 0x1093F, 0x10A7F, 0x111CD, 0x111DB, 0x112A9, 0x1145D, 0x114C6, 0x116B9, 0x1183B, 0x119E2, 0x11FFF, 0x16AF5, 0x16B44, 0x16FE2, 0x1BC9F);
	set.addRange(0x21, 0x23).addRange(0x25, 0x27).addRange(0x2E, 0x2F).addRange(0x3A, 0x3B).addRange(0x3F, 0x40).addRange(0xB6, 0xB7).addRange(0x55A, 0x55F).addRange(0x5F3, 0x5F4).addRange(0x609, 0x60A).addRange(0x60C, 0x60D).addRange(0x61D, 0x61F).addRange(0x66A, 0x66D).addRange(0x700, 0x70D).addRange(0x7F7, 0x7F9).addRange(0x830, 0x83E).addRange(0x964, 0x965).addRange(0xE5A, 0xE5B).addRange(0xF04, 0xF12).addRange(0xFD0, 0xFD4).addRange(0xFD9, 0xFDA).addRange(0x104A, 0x104F).addRange(0x1360, 0x1368).addRange(0x16EB, 0x16ED).addRange(0x1735, 0x1736).addRange(0x17D4, 0x17D6).addRange(0x17D8, 0x17DA).addRange(0x1800, 0x1805).addRange(0x1807, 0x180A).addRange(0x1944, 0x1945).addRange(0x1A1E, 0x1A1F).addRange(0x1AA0, 0x1AA6).addRange(0x1AA8, 0x1AAD).addRange(0x1B5A, 0x1B60).addRange(0x1B7D, 0x1B7E).addRange(0x1BFC, 0x1BFF).addRange(0x1C3B, 0x1C3F).addRange(0x1C7E, 0x1C7F).addRange(0x1CC0, 0x1CC7).addRange(0x2016, 0x2017).addRange(0x2020, 0x2027).addRange(0x2030, 0x2038).addRange(0x203B, 0x203E).addRange(0x2041, 0x2043).addRange(0x2047, 0x2051).addRange(0x2055, 0x205E).addRange(0x2CF9, 0x2CFC).addRange(0x2CFE, 0x2CFF).addRange(0x2E00, 0x2E01).addRange(0x2E06, 0x2E08).addRange(0x2E0E, 0x2E16).addRange(0x2E18, 0x2E19);
	set.addRange(0x2E1E, 0x2E1F).addRange(0x2E2A, 0x2E2E).addRange(0x2E30, 0x2E39).addRange(0x2E3C, 0x2E3F).addRange(0x2E43, 0x2E4F).addRange(0x2E52, 0x2E54).addRange(0x3001, 0x3003).addRange(0xA4FE, 0xA4FF).addRange(0xA60D, 0xA60F).addRange(0xA6F2, 0xA6F7).addRange(0xA874, 0xA877).addRange(0xA8CE, 0xA8CF).addRange(0xA8F8, 0xA8FA).addRange(0xA92E, 0xA92F).addRange(0xA9C1, 0xA9CD).addRange(0xA9DE, 0xA9DF).addRange(0xAA5C, 0xAA5F).addRange(0xAADE, 0xAADF).addRange(0xAAF0, 0xAAF1).addRange(0xFE10, 0xFE16).addRange(0xFE45, 0xFE46).addRange(0xFE49, 0xFE4C).addRange(0xFE50, 0xFE52).addRange(0xFE54, 0xFE57).addRange(0xFE5F, 0xFE61).addRange(0xFE6A, 0xFE6B).addRange(0xFF01, 0xFF03).addRange(0xFF05, 0xFF07).addRange(0xFF0E, 0xFF0F).addRange(0xFF1A, 0xFF1B).addRange(0xFF1F, 0xFF20).addRange(0xFF64, 0xFF65).addRange(0x10100, 0x10102).addRange(0x10A50, 0x10A58).addRange(0x10AF0, 0x10AF6).addRange(0x10B39, 0x10B3F).addRange(0x10B99, 0x10B9C).addRange(0x10F55, 0x10F59).addRange(0x10F86, 0x10F89).addRange(0x11047, 0x1104D).addRange(0x110BB, 0x110BC).addRange(0x110BE, 0x110C1).addRange(0x11140, 0x11143).addRange(0x11174, 0x11175).addRange(0x111C5, 0x111C8).addRange(0x111DD, 0x111DF).addRange(0x11238, 0x1123D).addRange(0x1144B, 0x1144F).addRange(0x1145A, 0x1145B).addRange(0x115C1, 0x115D7).addRange(0x11641, 0x11643);
	set.addRange(0x11660, 0x1166C).addRange(0x1173C, 0x1173E).addRange(0x11944, 0x11946).addRange(0x11A3F, 0x11A46).addRange(0x11A9A, 0x11A9C).addRange(0x11A9E, 0x11AA2).addRange(0x11C41, 0x11C45).addRange(0x11C70, 0x11C71).addRange(0x11EF7, 0x11EF8).addRange(0x12470, 0x12474).addRange(0x12FF1, 0x12FF2).addRange(0x16A6E, 0x16A6F).addRange(0x16B37, 0x16B3B).addRange(0x16E97, 0x16E9A).addRange(0x1DA87, 0x1DA8B).addRange(0x1E95E, 0x1E95F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Other_Symbol.js", function (module, exports) {
	  const set = regenerate(0xA6, 0xA9, 0xAE, 0xB0, 0x482, 0x6DE, 0x6E9, 0x7F6, 0x9FA, 0xB70, 0xBFA, 0xC7F, 0xD4F, 0xD79, 0xF13, 0xF34, 0xF36, 0xF38, 0x166D, 0x1940, 0x2114, 0x2125, 0x2127, 0x2129, 0x212E, 0x214A, 0x214F, 0x21D3, 0x3004, 0x3020, 0x3250, 0xA839, 0xFDCF, 0xFFE4, 0xFFE8, 0x101A0, 0x10AC8, 0x1173F, 0x16B45, 0x1BC9C, 0x1D245, 0x1E14F, 0x1ECAC, 0x1ED2E, 0x1F7F0);
	set.addRange(0x58D, 0x58E).addRange(0x60E, 0x60F).addRange(0x6FD, 0x6FE).addRange(0xBF3, 0xBF8).addRange(0xF01, 0xF03).addRange(0xF15, 0xF17).addRange(0xF1A, 0xF1F).addRange(0xFBE, 0xFC5).addRange(0xFC7, 0xFCC).addRange(0xFCE, 0xFCF).addRange(0xFD5, 0xFD8).addRange(0x109E, 0x109F).addRange(0x1390, 0x1399).addRange(0x19DE, 0x19FF).addRange(0x1B61, 0x1B6A).addRange(0x1B74, 0x1B7C).addRange(0x2100, 0x2101).addRange(0x2103, 0x2106).addRange(0x2108, 0x2109).addRange(0x2116, 0x2117).addRange(0x211E, 0x2123).addRange(0x213A, 0x213B).addRange(0x214C, 0x214D).addRange(0x218A, 0x218B).addRange(0x2195, 0x2199).addRange(0x219C, 0x219F).addRange(0x21A1, 0x21A2).addRange(0x21A4, 0x21A5).addRange(0x21A7, 0x21AD).addRange(0x21AF, 0x21CD).addRange(0x21D0, 0x21D1).addRange(0x21D5, 0x21F3).addRange(0x2300, 0x2307).addRange(0x230C, 0x231F).addRange(0x2322, 0x2328).addRange(0x232B, 0x237B).addRange(0x237D, 0x239A).addRange(0x23B4, 0x23DB).addRange(0x23E2, 0x2426).addRange(0x2440, 0x244A).addRange(0x249C, 0x24E9).addRange(0x2500, 0x25B6).addRange(0x25B8, 0x25C0).addRange(0x25C2, 0x25F7).addRange(0x2600, 0x266E).addRange(0x2670, 0x2767).addRange(0x2794, 0x27BF).addRange(0x2800, 0x28FF).addRange(0x2B00, 0x2B2F).addRange(0x2B45, 0x2B46).addRange(0x2B4D, 0x2B73);
	set.addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2BFF).addRange(0x2CE5, 0x2CEA).addRange(0x2E50, 0x2E51).addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x2FF0, 0x2FFB).addRange(0x3012, 0x3013).addRange(0x3036, 0x3037).addRange(0x303E, 0x303F).addRange(0x3190, 0x3191).addRange(0x3196, 0x319F).addRange(0x31C0, 0x31E3).addRange(0x3200, 0x321E).addRange(0x322A, 0x3247).addRange(0x3260, 0x327F).addRange(0x328A, 0x32B0).addRange(0x32C0, 0x33FF).addRange(0x4DC0, 0x4DFF).addRange(0xA490, 0xA4C6).addRange(0xA828, 0xA82B).addRange(0xA836, 0xA837).addRange(0xAA77, 0xAA79).addRange(0xFD40, 0xFD4F).addRange(0xFDFD, 0xFDFF).addRange(0xFFED, 0xFFEE).addRange(0xFFFC, 0xFFFD).addRange(0x10137, 0x1013F).addRange(0x10179, 0x10189).addRange(0x1018C, 0x1018E).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FC).addRange(0x10877, 0x10878).addRange(0x11FD5, 0x11FDC).addRange(0x11FE1, 0x11FF1).addRange(0x16B3C, 0x16B3F).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D164).addRange(0x1D16A, 0x1D16C).addRange(0x1D183, 0x1D184).addRange(0x1D18C, 0x1D1A9).addRange(0x1D1AE, 0x1D1EA).addRange(0x1D200, 0x1D241).addRange(0x1D300, 0x1D356).addRange(0x1D800, 0x1D9FF).addRange(0x1DA37, 0x1DA3A).addRange(0x1DA6D, 0x1DA74).addRange(0x1DA76, 0x1DA83);
	set.addRange(0x1DA85, 0x1DA86).addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F10D, 0x1F1AD).addRange(0x1F1E6, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F3FA).addRange(0x1F400, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Other.js", function (module, exports) {
	  const set = regenerate(0xAD, 0x38B, 0x38D, 0x3A2, 0x530, 0x590, 0x61C, 0x6DD, 0x83F, 0x85F, 0x8E2, 0x984, 0x9A9, 0x9B1, 0x9DE, 0xA04, 0xA29, 0xA31, 0xA34, 0xA37, 0xA3D, 0xA5D, 0xA84, 0xA8E, 0xA92, 0xAA9, 0xAB1, 0xAB4, 0xAC6, 0xACA, 0xB00, 0xB04, 0xB29, 0xB31, 0xB34, 0xB5E, 0xB84, 0xB91, 0xB9B, 0xB9D, 0xBC9, 0xC0D, 0xC11, 0xC29, 0xC45, 0xC49, 0xC57, 0xC8D, 0xC91, 0xCA9, 0xCB4, 0xCC5, 0xCC9, 0xCDF, 0xCF0, 0xD0D, 0xD11, 0xD45, 0xD49, 0xD80, 0xD84, 0xDB2, 0xDBC, 0xDD5, 0xDD7, 0xE83, 0xE85, 0xE8B, 0xEA4, 0xEA6, 0xEC5, 0xEC7, 0xF48, 0xF98, 0xFBD, 0xFCD, 0x10C6, 0x1249, 0x1257, 0x1259, 0x1289, 0x12B1, 0x12BF, 0x12C1, 0x12D7, 0x1311, 0x176D, 0x1771, 0x180E, 0x191F, 0x1A5F, 0x1B7F, 0x1F58, 0x1F5A, 0x1F5C, 0x1F5E, 0x1FB5, 0x1FC5, 0x1FDC, 0x1FF5, 0x1FFF, 0x208F, 0x2B96, 0x2D26, 0x2DA7, 0x2DAF, 0x2DB7, 0x2DBF, 0x2DC7, 0x2DCF, 0x2DD7, 0x2DDF, 0x2E9A, 0x3040, 0x3130, 0x318F, 0x321F, 0xA7D2, 0xA7D4, 0xA9CE, 0xA9FF, 0xAB27, 0xAB2F, 0xFB37, 0xFB3D, 0xFB3F, 0xFB42, 0xFB45, 0xFE53, 0xFE67, 0xFE75, 0xFFE7, 0x1000C, 0x10027, 0x1003B, 0x1003E, 0x1018F, 0x1039E, 0x1057B, 0x1058B, 0x10593, 0x10596, 0x105A2, 0x105B2, 0x105BA, 0x10786, 0x107B1, 0x10809, 0x10836, 0x10856, 0x108F3, 0x10A04, 0x10A14, 0x10A18, 0x10E7F, 0x10EAA, 0x110BD, 0x11135, 0x111E0, 0x11212, 0x11287, 0x11289, 0x1128E, 0x1129E, 0x11304, 0x11329, 0x11331, 0x11334, 0x1133A, 0x1145C, 0x11914, 0x11917, 0x11936, 0x11C09, 0x11C37, 0x11CA8, 0x11D07, 0x11D0A, 0x11D3B, 0x11D3E, 0x11D66, 0x11D69, 0x11D8F, 0x11D92, 0x1246F, 0x16A5F, 0x16ABF, 0x16B5A, 0x16B62, 0x1AFF4, 0x1AFFC, 0x1AFFF, 0x1D455, 0x1D49D, 0x1D4AD, 0x1D4BA, 0x1D4BC, 0x1D4C4, 0x1D506, 0x1D515, 0x1D51D, 0x1D53A, 0x1D53F, 0x1D545, 0x1D551, 0x1DAA0, 0x1E007, 0x1E022, 0x1E025, 0x1E7E7, 0x1E7EC, 0x1E7EF, 0x1E7FF, 0x1EE04, 0x1EE20, 0x1EE23, 0x1EE28, 0x1EE33, 0x1EE38, 0x1EE3A, 0x1EE48, 0x1EE4A, 0x1EE4C, 0x1EE50, 0x1EE53, 0x1EE58, 0x1EE5A, 0x1EE5C, 0x1EE5E, 0x1EE60, 0x1EE63, 0x1EE6B, 0x1EE73, 0x1EE78, 0x1EE7D, 0x1EE7F, 0x1EE8A, 0x1EEA4, 0x1EEAA, 0x1F0C0, 0x1F0D0, 0x1FB93);
	set.addRange(0x0, 0x1F).addRange(0x7F, 0x9F).addRange(0x378, 0x379).addRange(0x380, 0x383).addRange(0x557, 0x558).addRange(0x58B, 0x58C).addRange(0x5C8, 0x5CF).addRange(0x5EB, 0x5EE).addRange(0x5F5, 0x605).addRange(0x70E, 0x70F).addRange(0x74B, 0x74C).addRange(0x7B2, 0x7BF).addRange(0x7FB, 0x7FC).addRange(0x82E, 0x82F).addRange(0x85C, 0x85D).addRange(0x86B, 0x86F).addRange(0x88F, 0x897).addRange(0x98D, 0x98E).addRange(0x991, 0x992).addRange(0x9B3, 0x9B5).addRange(0x9BA, 0x9BB).addRange(0x9C5, 0x9C6).addRange(0x9C9, 0x9CA).addRange(0x9CF, 0x9D6).addRange(0x9D8, 0x9DB).addRange(0x9E4, 0x9E5).addRange(0x9FF, 0xA00).addRange(0xA0B, 0xA0E).addRange(0xA11, 0xA12).addRange(0xA3A, 0xA3B).addRange(0xA43, 0xA46).addRange(0xA49, 0xA4A).addRange(0xA4E, 0xA50).addRange(0xA52, 0xA58).addRange(0xA5F, 0xA65).addRange(0xA77, 0xA80).addRange(0xABA, 0xABB).addRange(0xACE, 0xACF).addRange(0xAD1, 0xADF).addRange(0xAE4, 0xAE5).addRange(0xAF2, 0xAF8).addRange(0xB0D, 0xB0E).addRange(0xB11, 0xB12).addRange(0xB3A, 0xB3B).addRange(0xB45, 0xB46).addRange(0xB49, 0xB4A).addRange(0xB4E, 0xB54).addRange(0xB58, 0xB5B).addRange(0xB64, 0xB65).addRange(0xB78, 0xB81).addRange(0xB8B, 0xB8D);
	set.addRange(0xB96, 0xB98).addRange(0xBA0, 0xBA2).addRange(0xBA5, 0xBA7).addRange(0xBAB, 0xBAD).addRange(0xBBA, 0xBBD).addRange(0xBC3, 0xBC5).addRange(0xBCE, 0xBCF).addRange(0xBD1, 0xBD6).addRange(0xBD8, 0xBE5).addRange(0xBFB, 0xBFF).addRange(0xC3A, 0xC3B).addRange(0xC4E, 0xC54).addRange(0xC5B, 0xC5C).addRange(0xC5E, 0xC5F).addRange(0xC64, 0xC65).addRange(0xC70, 0xC76).addRange(0xCBA, 0xCBB).addRange(0xCCE, 0xCD4).addRange(0xCD7, 0xCDC).addRange(0xCE4, 0xCE5).addRange(0xCF3, 0xCFF).addRange(0xD50, 0xD53).addRange(0xD64, 0xD65).addRange(0xD97, 0xD99).addRange(0xDBE, 0xDBF).addRange(0xDC7, 0xDC9).addRange(0xDCB, 0xDCE).addRange(0xDE0, 0xDE5).addRange(0xDF0, 0xDF1).addRange(0xDF5, 0xE00).addRange(0xE3B, 0xE3E).addRange(0xE5C, 0xE80).addRange(0xEBE, 0xEBF).addRange(0xECE, 0xECF).addRange(0xEDA, 0xEDB).addRange(0xEE0, 0xEFF).addRange(0xF6D, 0xF70).addRange(0xFDB, 0xFFF).addRange(0x10C8, 0x10CC).addRange(0x10CE, 0x10CF).addRange(0x124E, 0x124F).addRange(0x125E, 0x125F).addRange(0x128E, 0x128F).addRange(0x12B6, 0x12B7).addRange(0x12C6, 0x12C7).addRange(0x1316, 0x1317).addRange(0x135B, 0x135C).addRange(0x137D, 0x137F).addRange(0x139A, 0x139F).addRange(0x13F6, 0x13F7).addRange(0x13FE, 0x13FF);
	set.addRange(0x169D, 0x169F).addRange(0x16F9, 0x16FF).addRange(0x1716, 0x171E).addRange(0x1737, 0x173F).addRange(0x1754, 0x175F).addRange(0x1774, 0x177F).addRange(0x17DE, 0x17DF).addRange(0x17EA, 0x17EF).addRange(0x17FA, 0x17FF).addRange(0x181A, 0x181F).addRange(0x1879, 0x187F).addRange(0x18AB, 0x18AF).addRange(0x18F6, 0x18FF).addRange(0x192C, 0x192F).addRange(0x193C, 0x193F).addRange(0x1941, 0x1943).addRange(0x196E, 0x196F).addRange(0x1975, 0x197F).addRange(0x19AC, 0x19AF).addRange(0x19CA, 0x19CF).addRange(0x19DB, 0x19DD).addRange(0x1A1C, 0x1A1D).addRange(0x1A7D, 0x1A7E).addRange(0x1A8A, 0x1A8F).addRange(0x1A9A, 0x1A9F).addRange(0x1AAE, 0x1AAF).addRange(0x1ACF, 0x1AFF).addRange(0x1B4D, 0x1B4F).addRange(0x1BF4, 0x1BFB).addRange(0x1C38, 0x1C3A).addRange(0x1C4A, 0x1C4C).addRange(0x1C89, 0x1C8F).addRange(0x1CBB, 0x1CBC).addRange(0x1CC8, 0x1CCF).addRange(0x1CFB, 0x1CFF).addRange(0x1F16, 0x1F17).addRange(0x1F1E, 0x1F1F).addRange(0x1F46, 0x1F47).addRange(0x1F4E, 0x1F4F).addRange(0x1F7E, 0x1F7F).addRange(0x1FD4, 0x1FD5).addRange(0x1FF0, 0x1FF1).addRange(0x200B, 0x200F).addRange(0x202A, 0x202E).addRange(0x2060, 0x206F).addRange(0x2072, 0x2073).addRange(0x209D, 0x209F).addRange(0x20C1, 0x20CF).addRange(0x20F1, 0x20FF).addRange(0x218C, 0x218F).addRange(0x2427, 0x243F);
	set.addRange(0x244B, 0x245F).addRange(0x2B74, 0x2B75).addRange(0x2CF4, 0x2CF8).addRange(0x2D28, 0x2D2C).addRange(0x2D2E, 0x2D2F).addRange(0x2D68, 0x2D6E).addRange(0x2D71, 0x2D7E).addRange(0x2D97, 0x2D9F).addRange(0x2E5E, 0x2E7F).addRange(0x2EF4, 0x2EFF).addRange(0x2FD6, 0x2FEF).addRange(0x2FFC, 0x2FFF).addRange(0x3097, 0x3098).addRange(0x3100, 0x3104).addRange(0x31E4, 0x31EF).addRange(0xA48D, 0xA48F).addRange(0xA4C7, 0xA4CF).addRange(0xA62C, 0xA63F).addRange(0xA6F8, 0xA6FF).addRange(0xA7CB, 0xA7CF).addRange(0xA7DA, 0xA7F1).addRange(0xA82D, 0xA82F).addRange(0xA83A, 0xA83F).addRange(0xA878, 0xA87F).addRange(0xA8C6, 0xA8CD).addRange(0xA8DA, 0xA8DF).addRange(0xA954, 0xA95E).addRange(0xA97D, 0xA97F).addRange(0xA9DA, 0xA9DD).addRange(0xAA37, 0xAA3F).addRange(0xAA4E, 0xAA4F).addRange(0xAA5A, 0xAA5B).addRange(0xAAC3, 0xAADA).addRange(0xAAF7, 0xAB00).addRange(0xAB07, 0xAB08).addRange(0xAB0F, 0xAB10).addRange(0xAB17, 0xAB1F).addRange(0xAB6C, 0xAB6F).addRange(0xABEE, 0xABEF).addRange(0xABFA, 0xABFF).addRange(0xD7A4, 0xD7AF).addRange(0xD7C7, 0xD7CA).addRange(0xD7FC, 0xF8FF).addRange(0xFA6E, 0xFA6F).addRange(0xFADA, 0xFAFF).addRange(0xFB07, 0xFB12).addRange(0xFB18, 0xFB1C).addRange(0xFBC3, 0xFBD2).addRange(0xFD90, 0xFD91).addRange(0xFDC8, 0xFDCE).addRange(0xFDD0, 0xFDEF);
	set.addRange(0xFE1A, 0xFE1F).addRange(0xFE6C, 0xFE6F).addRange(0xFEFD, 0xFF00).addRange(0xFFBF, 0xFFC1).addRange(0xFFC8, 0xFFC9).addRange(0xFFD0, 0xFFD1).addRange(0xFFD8, 0xFFD9).addRange(0xFFDD, 0xFFDF).addRange(0xFFEF, 0xFFFB).addRange(0xFFFE, 0xFFFF).addRange(0x1004E, 0x1004F).addRange(0x1005E, 0x1007F).addRange(0x100FB, 0x100FF).addRange(0x10103, 0x10106).addRange(0x10134, 0x10136).addRange(0x1019D, 0x1019F).addRange(0x101A1, 0x101CF).addRange(0x101FE, 0x1027F).addRange(0x1029D, 0x1029F).addRange(0x102D1, 0x102DF).addRange(0x102FC, 0x102FF).addRange(0x10324, 0x1032C).addRange(0x1034B, 0x1034F).addRange(0x1037B, 0x1037F).addRange(0x103C4, 0x103C7).addRange(0x103D6, 0x103FF).addRange(0x1049E, 0x1049F).addRange(0x104AA, 0x104AF).addRange(0x104D4, 0x104D7).addRange(0x104FC, 0x104FF).addRange(0x10528, 0x1052F).addRange(0x10564, 0x1056E).addRange(0x105BD, 0x105FF).addRange(0x10737, 0x1073F).addRange(0x10756, 0x1075F).addRange(0x10768, 0x1077F).addRange(0x107BB, 0x107FF).addRange(0x10806, 0x10807).addRange(0x10839, 0x1083B).addRange(0x1083D, 0x1083E).addRange(0x1089F, 0x108A6).addRange(0x108B0, 0x108DF).addRange(0x108F6, 0x108FA).addRange(0x1091C, 0x1091E).addRange(0x1093A, 0x1093E).addRange(0x10940, 0x1097F).addRange(0x109B8, 0x109BB).addRange(0x109D0, 0x109D1).addRange(0x10A07, 0x10A0B).addRange(0x10A36, 0x10A37).addRange(0x10A3B, 0x10A3E);
	set.addRange(0x10A49, 0x10A4F).addRange(0x10A59, 0x10A5F).addRange(0x10AA0, 0x10ABF).addRange(0x10AE7, 0x10AEA).addRange(0x10AF7, 0x10AFF).addRange(0x10B36, 0x10B38).addRange(0x10B56, 0x10B57).addRange(0x10B73, 0x10B77).addRange(0x10B92, 0x10B98).addRange(0x10B9D, 0x10BA8).addRange(0x10BB0, 0x10BFF).addRange(0x10C49, 0x10C7F).addRange(0x10CB3, 0x10CBF).addRange(0x10CF3, 0x10CF9).addRange(0x10D28, 0x10D2F).addRange(0x10D3A, 0x10E5F).addRange(0x10EAE, 0x10EAF).addRange(0x10EB2, 0x10EFF).addRange(0x10F28, 0x10F2F).addRange(0x10F5A, 0x10F6F).addRange(0x10F8A, 0x10FAF).addRange(0x10FCC, 0x10FDF).addRange(0x10FF7, 0x10FFF).addRange(0x1104E, 0x11051).addRange(0x11076, 0x1107E).addRange(0x110C3, 0x110CF).addRange(0x110E9, 0x110EF).addRange(0x110FA, 0x110FF).addRange(0x11148, 0x1114F).addRange(0x11177, 0x1117F).addRange(0x111F5, 0x111FF).addRange(0x1123F, 0x1127F).addRange(0x112AA, 0x112AF).addRange(0x112EB, 0x112EF).addRange(0x112FA, 0x112FF).addRange(0x1130D, 0x1130E).addRange(0x11311, 0x11312).addRange(0x11345, 0x11346).addRange(0x11349, 0x1134A).addRange(0x1134E, 0x1134F).addRange(0x11351, 0x11356).addRange(0x11358, 0x1135C).addRange(0x11364, 0x11365).addRange(0x1136D, 0x1136F).addRange(0x11375, 0x113FF).addRange(0x11462, 0x1147F).addRange(0x114C8, 0x114CF).addRange(0x114DA, 0x1157F).addRange(0x115B6, 0x115B7).addRange(0x115DE, 0x115FF).addRange(0x11645, 0x1164F);
	set.addRange(0x1165A, 0x1165F).addRange(0x1166D, 0x1167F).addRange(0x116BA, 0x116BF).addRange(0x116CA, 0x116FF).addRange(0x1171B, 0x1171C).addRange(0x1172C, 0x1172F).addRange(0x11747, 0x117FF).addRange(0x1183C, 0x1189F).addRange(0x118F3, 0x118FE).addRange(0x11907, 0x11908).addRange(0x1190A, 0x1190B).addRange(0x11939, 0x1193A).addRange(0x11947, 0x1194F).addRange(0x1195A, 0x1199F).addRange(0x119A8, 0x119A9).addRange(0x119D8, 0x119D9).addRange(0x119E5, 0x119FF).addRange(0x11A48, 0x11A4F).addRange(0x11AA3, 0x11AAF).addRange(0x11AF9, 0x11BFF).addRange(0x11C46, 0x11C4F).addRange(0x11C6D, 0x11C6F).addRange(0x11C90, 0x11C91).addRange(0x11CB7, 0x11CFF).addRange(0x11D37, 0x11D39).addRange(0x11D48, 0x11D4F).addRange(0x11D5A, 0x11D5F).addRange(0x11D99, 0x11D9F).addRange(0x11DAA, 0x11EDF).addRange(0x11EF9, 0x11FAF).addRange(0x11FB1, 0x11FBF).addRange(0x11FF2, 0x11FFE).addRange(0x1239A, 0x123FF).addRange(0x12475, 0x1247F).addRange(0x12544, 0x12F8F).addRange(0x12FF3, 0x12FFF).addRange(0x1342F, 0x143FF).addRange(0x14647, 0x167FF).addRange(0x16A39, 0x16A3F).addRange(0x16A6A, 0x16A6D).addRange(0x16ACA, 0x16ACF).addRange(0x16AEE, 0x16AEF).addRange(0x16AF6, 0x16AFF).addRange(0x16B46, 0x16B4F).addRange(0x16B78, 0x16B7C).addRange(0x16B90, 0x16E3F).addRange(0x16E9B, 0x16EFF).addRange(0x16F4B, 0x16F4E).addRange(0x16F88, 0x16F8E).addRange(0x16FA0, 0x16FDF).addRange(0x16FE5, 0x16FEF);
	set.addRange(0x16FF2, 0x16FFF).addRange(0x187F8, 0x187FF).addRange(0x18CD6, 0x18CFF).addRange(0x18D09, 0x1AFEF).addRange(0x1B123, 0x1B14F).addRange(0x1B153, 0x1B163).addRange(0x1B168, 0x1B16F).addRange(0x1B2FC, 0x1BBFF).addRange(0x1BC6B, 0x1BC6F).addRange(0x1BC7D, 0x1BC7F).addRange(0x1BC89, 0x1BC8F).addRange(0x1BC9A, 0x1BC9B).addRange(0x1BCA0, 0x1CEFF).addRange(0x1CF2E, 0x1CF2F).addRange(0x1CF47, 0x1CF4F).addRange(0x1CFC4, 0x1CFFF).addRange(0x1D0F6, 0x1D0FF).addRange(0x1D127, 0x1D128).addRange(0x1D173, 0x1D17A).addRange(0x1D1EB, 0x1D1FF).addRange(0x1D246, 0x1D2DF).addRange(0x1D2F4, 0x1D2FF).addRange(0x1D357, 0x1D35F).addRange(0x1D379, 0x1D3FF).addRange(0x1D4A0, 0x1D4A1).addRange(0x1D4A3, 0x1D4A4).addRange(0x1D4A7, 0x1D4A8).addRange(0x1D50B, 0x1D50C).addRange(0x1D547, 0x1D549).addRange(0x1D6A6, 0x1D6A7).addRange(0x1D7CC, 0x1D7CD).addRange(0x1DA8C, 0x1DA9A).addRange(0x1DAB0, 0x1DEFF).addRange(0x1DF1F, 0x1DFFF).addRange(0x1E019, 0x1E01A).addRange(0x1E02B, 0x1E0FF).addRange(0x1E12D, 0x1E12F).addRange(0x1E13E, 0x1E13F).addRange(0x1E14A, 0x1E14D).addRange(0x1E150, 0x1E28F).addRange(0x1E2AF, 0x1E2BF).addRange(0x1E2FA, 0x1E2FE).addRange(0x1E300, 0x1E7DF).addRange(0x1E8C5, 0x1E8C6).addRange(0x1E8D7, 0x1E8FF).addRange(0x1E94C, 0x1E94F).addRange(0x1E95A, 0x1E95D).addRange(0x1E960, 0x1EC70).addRange(0x1ECB5, 0x1ED00).addRange(0x1ED3E, 0x1EDFF).addRange(0x1EE25, 0x1EE26);
	set.addRange(0x1EE3C, 0x1EE41).addRange(0x1EE43, 0x1EE46).addRange(0x1EE55, 0x1EE56).addRange(0x1EE65, 0x1EE66).addRange(0x1EE9C, 0x1EEA0).addRange(0x1EEBC, 0x1EEEF).addRange(0x1EEF2, 0x1EFFF).addRange(0x1F02C, 0x1F02F).addRange(0x1F094, 0x1F09F).addRange(0x1F0AF, 0x1F0B0).addRange(0x1F0F6, 0x1F0FF).addRange(0x1F1AE, 0x1F1E5).addRange(0x1F203, 0x1F20F).addRange(0x1F23C, 0x1F23F).addRange(0x1F249, 0x1F24F).addRange(0x1F252, 0x1F25F).addRange(0x1F266, 0x1F2FF).addRange(0x1F6D8, 0x1F6DC).addRange(0x1F6ED, 0x1F6EF).addRange(0x1F6FD, 0x1F6FF).addRange(0x1F774, 0x1F77F).addRange(0x1F7D9, 0x1F7DF).addRange(0x1F7EC, 0x1F7EF).addRange(0x1F7F1, 0x1F7FF).addRange(0x1F80C, 0x1F80F).addRange(0x1F848, 0x1F84F).addRange(0x1F85A, 0x1F85F).addRange(0x1F888, 0x1F88F).addRange(0x1F8AE, 0x1F8AF).addRange(0x1F8B2, 0x1F8FF).addRange(0x1FA54, 0x1FA5F).addRange(0x1FA6E, 0x1FA6F).addRange(0x1FA75, 0x1FA77).addRange(0x1FA7D, 0x1FA7F).addRange(0x1FA87, 0x1FA8F).addRange(0x1FAAD, 0x1FAAF).addRange(0x1FABB, 0x1FABF).addRange(0x1FAC6, 0x1FACF).addRange(0x1FADA, 0x1FADF).addRange(0x1FAE8, 0x1FAEF).addRange(0x1FAF7, 0x1FAFF).addRange(0x1FBCB, 0x1FBEF).addRange(0x1FBFA, 0x1FFFF).addRange(0x2A6E0, 0x2A6FF).addRange(0x2B739, 0x2B73F).addRange(0x2B81E, 0x2B81F).addRange(0x2CEA2, 0x2CEAF).addRange(0x2EBE1, 0x2F7FF).addRange(0x2FA1E, 0x2FFFF).addRange(0x3134B, 0xE00FF).addRange(0xE01F0, 0x10FFFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Paragraph_Separator.js", function (module, exports) {
	  const set = regenerate(0x2029);

	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Private_Use.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xE000, 0xF8FF).addRange(0xF0000, 0xFFFFD).addRange(0x100000, 0x10FFFD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Punctuation.js", function (module, exports) {
	  const set = regenerate(0x5F, 0x7B, 0x7D, 0xA1, 0xA7, 0xAB, 0xBB, 0xBF, 0x37E, 0x387, 0x5BE, 0x5C0, 0x5C3, 0x5C6, 0x61B, 0x6D4, 0x85E, 0x970, 0x9FD, 0xA76, 0xAF0, 0xC77, 0xC84, 0xDF4, 0xE4F, 0xF14, 0xF85, 0x10FB, 0x1400, 0x166E, 0x1CD3, 0x2D70, 0x3030, 0x303D, 0x30A0, 0x30FB, 0xA673, 0xA67E, 0xA8FC, 0xA95F, 0xABEB, 0xFE63, 0xFE68, 0xFF3F, 0xFF5B, 0xFF5D, 0x1039F, 0x103D0, 0x1056F, 0x10857, 0x1091F, 0x1093F, 0x10A7F, 0x10EAD, 0x111CD, 0x111DB, 0x112A9, 0x1145D, 0x114C6, 0x116B9, 0x1183B, 0x119E2, 0x11FFF, 0x16AF5, 0x16B44, 0x16FE2, 0x1BC9F);
	set.addRange(0x21, 0x23).addRange(0x25, 0x2A).addRange(0x2C, 0x2F).addRange(0x3A, 0x3B).addRange(0x3F, 0x40).addRange(0x5B, 0x5D).addRange(0xB6, 0xB7).addRange(0x55A, 0x55F).addRange(0x589, 0x58A).addRange(0x5F3, 0x5F4).addRange(0x609, 0x60A).addRange(0x60C, 0x60D).addRange(0x61D, 0x61F).addRange(0x66A, 0x66D).addRange(0x700, 0x70D).addRange(0x7F7, 0x7F9).addRange(0x830, 0x83E).addRange(0x964, 0x965).addRange(0xE5A, 0xE5B).addRange(0xF04, 0xF12).addRange(0xF3A, 0xF3D).addRange(0xFD0, 0xFD4).addRange(0xFD9, 0xFDA).addRange(0x104A, 0x104F).addRange(0x1360, 0x1368).addRange(0x169B, 0x169C).addRange(0x16EB, 0x16ED).addRange(0x1735, 0x1736).addRange(0x17D4, 0x17D6).addRange(0x17D8, 0x17DA).addRange(0x1800, 0x180A).addRange(0x1944, 0x1945).addRange(0x1A1E, 0x1A1F).addRange(0x1AA0, 0x1AA6).addRange(0x1AA8, 0x1AAD).addRange(0x1B5A, 0x1B60).addRange(0x1B7D, 0x1B7E).addRange(0x1BFC, 0x1BFF).addRange(0x1C3B, 0x1C3F).addRange(0x1C7E, 0x1C7F).addRange(0x1CC0, 0x1CC7).addRange(0x2010, 0x2027).addRange(0x2030, 0x2043).addRange(0x2045, 0x2051).addRange(0x2053, 0x205E).addRange(0x207D, 0x207E).addRange(0x208D, 0x208E).addRange(0x2308, 0x230B).addRange(0x2329, 0x232A).addRange(0x2768, 0x2775).addRange(0x27C5, 0x27C6);
	set.addRange(0x27E6, 0x27EF).addRange(0x2983, 0x2998).addRange(0x29D8, 0x29DB).addRange(0x29FC, 0x29FD).addRange(0x2CF9, 0x2CFC).addRange(0x2CFE, 0x2CFF).addRange(0x2E00, 0x2E2E).addRange(0x2E30, 0x2E4F).addRange(0x2E52, 0x2E5D).addRange(0x3001, 0x3003).addRange(0x3008, 0x3011).addRange(0x3014, 0x301F).addRange(0xA4FE, 0xA4FF).addRange(0xA60D, 0xA60F).addRange(0xA6F2, 0xA6F7).addRange(0xA874, 0xA877).addRange(0xA8CE, 0xA8CF).addRange(0xA8F8, 0xA8FA).addRange(0xA92E, 0xA92F).addRange(0xA9C1, 0xA9CD).addRange(0xA9DE, 0xA9DF).addRange(0xAA5C, 0xAA5F).addRange(0xAADE, 0xAADF).addRange(0xAAF0, 0xAAF1).addRange(0xFD3E, 0xFD3F).addRange(0xFE10, 0xFE19).addRange(0xFE30, 0xFE52).addRange(0xFE54, 0xFE61).addRange(0xFE6A, 0xFE6B).addRange(0xFF01, 0xFF03).addRange(0xFF05, 0xFF0A).addRange(0xFF0C, 0xFF0F).addRange(0xFF1A, 0xFF1B).addRange(0xFF1F, 0xFF20).addRange(0xFF3B, 0xFF3D).addRange(0xFF5F, 0xFF65).addRange(0x10100, 0x10102).addRange(0x10A50, 0x10A58).addRange(0x10AF0, 0x10AF6).addRange(0x10B39, 0x10B3F).addRange(0x10B99, 0x10B9C).addRange(0x10F55, 0x10F59).addRange(0x10F86, 0x10F89).addRange(0x11047, 0x1104D).addRange(0x110BB, 0x110BC).addRange(0x110BE, 0x110C1).addRange(0x11140, 0x11143).addRange(0x11174, 0x11175).addRange(0x111C5, 0x111C8).addRange(0x111DD, 0x111DF).addRange(0x11238, 0x1123D);
	set.addRange(0x1144B, 0x1144F).addRange(0x1145A, 0x1145B).addRange(0x115C1, 0x115D7).addRange(0x11641, 0x11643).addRange(0x11660, 0x1166C).addRange(0x1173C, 0x1173E).addRange(0x11944, 0x11946).addRange(0x11A3F, 0x11A46).addRange(0x11A9A, 0x11A9C).addRange(0x11A9E, 0x11AA2).addRange(0x11C41, 0x11C45).addRange(0x11C70, 0x11C71).addRange(0x11EF7, 0x11EF8).addRange(0x12470, 0x12474).addRange(0x12FF1, 0x12FF2).addRange(0x16A6E, 0x16A6F).addRange(0x16B37, 0x16B3B).addRange(0x16E97, 0x16E9A).addRange(0x1DA87, 0x1DA8B).addRange(0x1E95E, 0x1E95F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Separator.js", function (module, exports) {
	  const set = regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000);
	set.addRange(0x2000, 0x200A).addRange(0x2028, 0x2029);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Space_Separator.js", function (module, exports) {
	  const set = regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000);
	set.addRange(0x2000, 0x200A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Spacing_Mark.js", function (module, exports) {
	  const set = regenerate(0x903, 0x93B, 0x9D7, 0xA03, 0xA83, 0xAC9, 0xB3E, 0xB40, 0xB57, 0xBD7, 0xCBE, 0xD57, 0xF7F, 0x1031, 0x1038, 0x108F, 0x1715, 0x1734, 0x17B6, 0x1A55, 0x1A57, 0x1A61, 0x1B04, 0x1B35, 0x1B3B, 0x1B82, 0x1BA1, 0x1BAA, 0x1BE7, 0x1BEE, 0x1CE1, 0x1CF7, 0xA827, 0xA983, 0xAA4D, 0xAA7B, 0xAA7D, 0xAAEB, 0xAAF5, 0xABEC, 0x11000, 0x11002, 0x11082, 0x1112C, 0x11182, 0x111CE, 0x11235, 0x11357, 0x11445, 0x114B9, 0x114C1, 0x115BE, 0x1163E, 0x116AC, 0x116B6, 0x11726, 0x11838, 0x1193D, 0x11940, 0x11942, 0x119E4, 0x11A39, 0x11A97, 0x11C2F, 0x11C3E, 0x11CA9, 0x11CB1, 0x11CB4, 0x11D96);
	set.addRange(0x93E, 0x940).addRange(0x949, 0x94C).addRange(0x94E, 0x94F).addRange(0x982, 0x983).addRange(0x9BE, 0x9C0).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CC).addRange(0xA3E, 0xA40).addRange(0xABE, 0xAC0).addRange(0xACB, 0xACC).addRange(0xB02, 0xB03).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4C).addRange(0xBBE, 0xBBF).addRange(0xBC1, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCC).addRange(0xC01, 0xC03).addRange(0xC41, 0xC44).addRange(0xC82, 0xC83).addRange(0xCC0, 0xCC4).addRange(0xCC7, 0xCC8).addRange(0xCCA, 0xCCB).addRange(0xCD5, 0xCD6).addRange(0xD02, 0xD03).addRange(0xD3E, 0xD40).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4C).addRange(0xD82, 0xD83).addRange(0xDCF, 0xDD1).addRange(0xDD8, 0xDDF).addRange(0xDF2, 0xDF3).addRange(0xF3E, 0xF3F).addRange(0x102B, 0x102C).addRange(0x103B, 0x103C).addRange(0x1056, 0x1057).addRange(0x1062, 0x1064).addRange(0x1067, 0x106D).addRange(0x1083, 0x1084).addRange(0x1087, 0x108C).addRange(0x109A, 0x109C).addRange(0x17BE, 0x17C5).addRange(0x17C7, 0x17C8).addRange(0x1923, 0x1926).addRange(0x1929, 0x192B).addRange(0x1930, 0x1931).addRange(0x1933, 0x1938).addRange(0x1A19, 0x1A1A).addRange(0x1A63, 0x1A64).addRange(0x1A6D, 0x1A72).addRange(0x1B3D, 0x1B41);
	set.addRange(0x1B43, 0x1B44).addRange(0x1BA6, 0x1BA7).addRange(0x1BEA, 0x1BEC).addRange(0x1BF2, 0x1BF3).addRange(0x1C24, 0x1C2B).addRange(0x1C34, 0x1C35).addRange(0x302E, 0x302F).addRange(0xA823, 0xA824).addRange(0xA880, 0xA881).addRange(0xA8B4, 0xA8C3).addRange(0xA952, 0xA953).addRange(0xA9B4, 0xA9B5).addRange(0xA9BA, 0xA9BB).addRange(0xA9BE, 0xA9C0).addRange(0xAA2F, 0xAA30).addRange(0xAA33, 0xAA34).addRange(0xAAEE, 0xAAEF).addRange(0xABE3, 0xABE4).addRange(0xABE6, 0xABE7).addRange(0xABE9, 0xABEA).addRange(0x110B0, 0x110B2).addRange(0x110B7, 0x110B8).addRange(0x11145, 0x11146).addRange(0x111B3, 0x111B5).addRange(0x111BF, 0x111C0).addRange(0x1122C, 0x1122E).addRange(0x11232, 0x11233).addRange(0x112E0, 0x112E2).addRange(0x11302, 0x11303).addRange(0x1133E, 0x1133F).addRange(0x11341, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x11362, 0x11363).addRange(0x11435, 0x11437).addRange(0x11440, 0x11441).addRange(0x114B0, 0x114B2).addRange(0x114BB, 0x114BE).addRange(0x115AF, 0x115B1).addRange(0x115B8, 0x115BB).addRange(0x11630, 0x11632).addRange(0x1163B, 0x1163C).addRange(0x116AE, 0x116AF).addRange(0x11720, 0x11721).addRange(0x1182C, 0x1182E).addRange(0x11930, 0x11935).addRange(0x11937, 0x11938).addRange(0x119D1, 0x119D3).addRange(0x119DC, 0x119DF).addRange(0x11A57, 0x11A58).addRange(0x11D8A, 0x11D8E);
	set.addRange(0x11D93, 0x11D94).addRange(0x11EF5, 0x11EF6).addRange(0x16F51, 0x16F87).addRange(0x16FF0, 0x16FF1).addRange(0x1D165, 0x1D166).addRange(0x1D16D, 0x1D172);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Surrogate.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xD800, 0xDFFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Symbol.js", function (module, exports) {
	  const set = regenerate(0x24, 0x2B, 0x5E, 0x60, 0x7C, 0x7E, 0xAC, 0xB4, 0xB8, 0xD7, 0xF7, 0x2ED, 0x375, 0x3F6, 0x482, 0x60B, 0x6DE, 0x6E9, 0x7F6, 0x888, 0xAF1, 0xB70, 0xC7F, 0xD4F, 0xD79, 0xE3F, 0xF13, 0xF34, 0xF36, 0xF38, 0x166D, 0x17DB, 0x1940, 0x1FBD, 0x2044, 0x2052, 0x2114, 0x2125, 0x2127, 0x2129, 0x212E, 0x214F, 0x3004, 0x3020, 0x3250, 0xAB5B, 0xFB29, 0xFDCF, 0xFE62, 0xFE69, 0xFF04, 0xFF0B, 0xFF3E, 0xFF40, 0xFF5C, 0xFF5E, 0x101A0, 0x10AC8, 0x1173F, 0x16B45, 0x1BC9C, 0x1D245, 0x1D6C1, 0x1D6DB, 0x1D6FB, 0x1D715, 0x1D735, 0x1D74F, 0x1D76F, 0x1D789, 0x1D7A9, 0x1D7C3, 0x1E14F, 0x1E2FF, 0x1ECAC, 0x1ECB0, 0x1ED2E, 0x1F7F0);
	set.addRange(0x3C, 0x3E).addRange(0xA2, 0xA6).addRange(0xA8, 0xA9).addRange(0xAE, 0xB1).addRange(0x2C2, 0x2C5).addRange(0x2D2, 0x2DF).addRange(0x2E5, 0x2EB).addRange(0x2EF, 0x2FF).addRange(0x384, 0x385).addRange(0x58D, 0x58F).addRange(0x606, 0x608).addRange(0x60E, 0x60F).addRange(0x6FD, 0x6FE).addRange(0x7FE, 0x7FF).addRange(0x9F2, 0x9F3).addRange(0x9FA, 0x9FB).addRange(0xBF3, 0xBFA).addRange(0xF01, 0xF03).addRange(0xF15, 0xF17).addRange(0xF1A, 0xF1F).addRange(0xFBE, 0xFC5).addRange(0xFC7, 0xFCC).addRange(0xFCE, 0xFCF).addRange(0xFD5, 0xFD8).addRange(0x109E, 0x109F).addRange(0x1390, 0x1399).addRange(0x19DE, 0x19FF).addRange(0x1B61, 0x1B6A).addRange(0x1B74, 0x1B7C).addRange(0x1FBF, 0x1FC1).addRange(0x1FCD, 0x1FCF).addRange(0x1FDD, 0x1FDF).addRange(0x1FED, 0x1FEF).addRange(0x1FFD, 0x1FFE).addRange(0x207A, 0x207C).addRange(0x208A, 0x208C).addRange(0x20A0, 0x20C0).addRange(0x2100, 0x2101).addRange(0x2103, 0x2106).addRange(0x2108, 0x2109).addRange(0x2116, 0x2118).addRange(0x211E, 0x2123).addRange(0x213A, 0x213B).addRange(0x2140, 0x2144).addRange(0x214A, 0x214D).addRange(0x218A, 0x218B).addRange(0x2190, 0x2307).addRange(0x230C, 0x2328).addRange(0x232B, 0x2426).addRange(0x2440, 0x244A).addRange(0x249C, 0x24E9);
	set.addRange(0x2500, 0x2767).addRange(0x2794, 0x27C4).addRange(0x27C7, 0x27E5).addRange(0x27F0, 0x2982).addRange(0x2999, 0x29D7).addRange(0x29DC, 0x29FB).addRange(0x29FE, 0x2B73).addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2BFF).addRange(0x2CE5, 0x2CEA).addRange(0x2E50, 0x2E51).addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x2FF0, 0x2FFB).addRange(0x3012, 0x3013).addRange(0x3036, 0x3037).addRange(0x303E, 0x303F).addRange(0x309B, 0x309C).addRange(0x3190, 0x3191).addRange(0x3196, 0x319F).addRange(0x31C0, 0x31E3).addRange(0x3200, 0x321E).addRange(0x322A, 0x3247).addRange(0x3260, 0x327F).addRange(0x328A, 0x32B0).addRange(0x32C0, 0x33FF).addRange(0x4DC0, 0x4DFF).addRange(0xA490, 0xA4C6).addRange(0xA700, 0xA716).addRange(0xA720, 0xA721).addRange(0xA789, 0xA78A).addRange(0xA828, 0xA82B).addRange(0xA836, 0xA839).addRange(0xAA77, 0xAA79).addRange(0xAB6A, 0xAB6B).addRange(0xFBB2, 0xFBC2).addRange(0xFD40, 0xFD4F).addRange(0xFDFC, 0xFDFF).addRange(0xFE64, 0xFE66).addRange(0xFF1C, 0xFF1E).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE).addRange(0xFFFC, 0xFFFD).addRange(0x10137, 0x1013F).addRange(0x10179, 0x10189).addRange(0x1018C, 0x1018E).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FC).addRange(0x10877, 0x10878).addRange(0x11FD5, 0x11FF1);
	set.addRange(0x16B3C, 0x16B3F).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D164).addRange(0x1D16A, 0x1D16C).addRange(0x1D183, 0x1D184).addRange(0x1D18C, 0x1D1A9).addRange(0x1D1AE, 0x1D1EA).addRange(0x1D200, 0x1D241).addRange(0x1D300, 0x1D356).addRange(0x1D800, 0x1D9FF).addRange(0x1DA37, 0x1DA3A).addRange(0x1DA6D, 0x1DA74).addRange(0x1DA76, 0x1DA83).addRange(0x1DA85, 0x1DA86).addRange(0x1EEF0, 0x1EEF1).addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F10D, 0x1F1AD).addRange(0x1F1E6, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7);
	set.addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Titlecase_Letter.js", function (module, exports) {
	  const set = regenerate(0x1C5, 0x1C8, 0x1CB, 0x1F2, 0x1FBC, 0x1FCC, 0x1FFC);
	set.addRange(0x1F88, 0x1F8F).addRange(0x1F98, 0x1F9F).addRange(0x1FA8, 0x1FAF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Unassigned.js", function (module, exports) {
	  const set = regenerate(0x38B, 0x38D, 0x3A2, 0x530, 0x590, 0x70E, 0x83F, 0x85F, 0x88F, 0x984, 0x9A9, 0x9B1, 0x9DE, 0xA04, 0xA29, 0xA31, 0xA34, 0xA37, 0xA3D, 0xA5D, 0xA84, 0xA8E, 0xA92, 0xAA9, 0xAB1, 0xAB4, 0xAC6, 0xACA, 0xB00, 0xB04, 0xB29, 0xB31, 0xB34, 0xB5E, 0xB84, 0xB91, 0xB9B, 0xB9D, 0xBC9, 0xC0D, 0xC11, 0xC29, 0xC45, 0xC49, 0xC57, 0xC8D, 0xC91, 0xCA9, 0xCB4, 0xCC5, 0xCC9, 0xCDF, 0xCF0, 0xD0D, 0xD11, 0xD45, 0xD49, 0xD80, 0xD84, 0xDB2, 0xDBC, 0xDD5, 0xDD7, 0xE83, 0xE85, 0xE8B, 0xEA4, 0xEA6, 0xEC5, 0xEC7, 0xF48, 0xF98, 0xFBD, 0xFCD, 0x10C6, 0x1249, 0x1257, 0x1259, 0x1289, 0x12B1, 0x12BF, 0x12C1, 0x12D7, 0x1311, 0x176D, 0x1771, 0x191F, 0x1A5F, 0x1B7F, 0x1F58, 0x1F5A, 0x1F5C, 0x1F5E, 0x1FB5, 0x1FC5, 0x1FDC, 0x1FF5, 0x1FFF, 0x2065, 0x208F, 0x2B96, 0x2D26, 0x2DA7, 0x2DAF, 0x2DB7, 0x2DBF, 0x2DC7, 0x2DCF, 0x2DD7, 0x2DDF, 0x2E9A, 0x3040, 0x3130, 0x318F, 0x321F, 0xA7D2, 0xA7D4, 0xA9CE, 0xA9FF, 0xAB27, 0xAB2F, 0xFB37, 0xFB3D, 0xFB3F, 0xFB42, 0xFB45, 0xFE53, 0xFE67, 0xFE75, 0xFF00, 0xFFE7, 0x1000C, 0x10027, 0x1003B, 0x1003E, 0x1018F, 0x1039E, 0x1057B, 0x1058B, 0x10593, 0x10596, 0x105A2, 0x105B2, 0x105BA, 0x10786, 0x107B1, 0x10809, 0x10836, 0x10856, 0x108F3, 0x10A04, 0x10A14, 0x10A18, 0x10E7F, 0x10EAA, 0x11135, 0x111E0, 0x11212, 0x11287, 0x11289, 0x1128E, 0x1129E, 0x11304, 0x11329, 0x11331, 0x11334, 0x1133A, 0x1145C, 0x11914, 0x11917, 0x11936, 0x11C09, 0x11C37, 0x11CA8, 0x11D07, 0x11D0A, 0x11D3B, 0x11D3E, 0x11D66, 0x11D69, 0x11D8F, 0x11D92, 0x1246F, 0x1342F, 0x16A5F, 0x16ABF, 0x16B5A, 0x16B62, 0x1AFF4, 0x1AFFC, 0x1AFFF, 0x1D455, 0x1D49D, 0x1D4AD, 0x1D4BA, 0x1D4BC, 0x1D4C4, 0x1D506, 0x1D515, 0x1D51D, 0x1D53A, 0x1D53F, 0x1D545, 0x1D551, 0x1DAA0, 0x1E007, 0x1E022, 0x1E025, 0x1E7E7, 0x1E7EC, 0x1E7EF, 0x1E7FF, 0x1EE04, 0x1EE20, 0x1EE23, 0x1EE28, 0x1EE33, 0x1EE38, 0x1EE3A, 0x1EE48, 0x1EE4A, 0x1EE4C, 0x1EE50, 0x1EE53, 0x1EE58, 0x1EE5A, 0x1EE5C, 0x1EE5E, 0x1EE60, 0x1EE63, 0x1EE6B, 0x1EE73, 0x1EE78, 0x1EE7D, 0x1EE7F, 0x1EE8A, 0x1EEA4, 0x1EEAA, 0x1F0C0, 0x1F0D0, 0x1FB93);
	set.addRange(0x378, 0x379).addRange(0x380, 0x383).addRange(0x557, 0x558).addRange(0x58B, 0x58C).addRange(0x5C8, 0x5CF).addRange(0x5EB, 0x5EE).addRange(0x5F5, 0x5FF).addRange(0x74B, 0x74C).addRange(0x7B2, 0x7BF).addRange(0x7FB, 0x7FC).addRange(0x82E, 0x82F).addRange(0x85C, 0x85D).addRange(0x86B, 0x86F).addRange(0x892, 0x897).addRange(0x98D, 0x98E).addRange(0x991, 0x992).addRange(0x9B3, 0x9B5).addRange(0x9BA, 0x9BB).addRange(0x9C5, 0x9C6).addRange(0x9C9, 0x9CA).addRange(0x9CF, 0x9D6).addRange(0x9D8, 0x9DB).addRange(0x9E4, 0x9E5).addRange(0x9FF, 0xA00).addRange(0xA0B, 0xA0E).addRange(0xA11, 0xA12).addRange(0xA3A, 0xA3B).addRange(0xA43, 0xA46).addRange(0xA49, 0xA4A).addRange(0xA4E, 0xA50).addRange(0xA52, 0xA58).addRange(0xA5F, 0xA65).addRange(0xA77, 0xA80).addRange(0xABA, 0xABB).addRange(0xACE, 0xACF).addRange(0xAD1, 0xADF).addRange(0xAE4, 0xAE5).addRange(0xAF2, 0xAF8).addRange(0xB0D, 0xB0E).addRange(0xB11, 0xB12).addRange(0xB3A, 0xB3B).addRange(0xB45, 0xB46).addRange(0xB49, 0xB4A).addRange(0xB4E, 0xB54).addRange(0xB58, 0xB5B).addRange(0xB64, 0xB65).addRange(0xB78, 0xB81).addRange(0xB8B, 0xB8D).addRange(0xB96, 0xB98).addRange(0xBA0, 0xBA2).addRange(0xBA5, 0xBA7);
	set.addRange(0xBAB, 0xBAD).addRange(0xBBA, 0xBBD).addRange(0xBC3, 0xBC5).addRange(0xBCE, 0xBCF).addRange(0xBD1, 0xBD6).addRange(0xBD8, 0xBE5).addRange(0xBFB, 0xBFF).addRange(0xC3A, 0xC3B).addRange(0xC4E, 0xC54).addRange(0xC5B, 0xC5C).addRange(0xC5E, 0xC5F).addRange(0xC64, 0xC65).addRange(0xC70, 0xC76).addRange(0xCBA, 0xCBB).addRange(0xCCE, 0xCD4).addRange(0xCD7, 0xCDC).addRange(0xCE4, 0xCE5).addRange(0xCF3, 0xCFF).addRange(0xD50, 0xD53).addRange(0xD64, 0xD65).addRange(0xD97, 0xD99).addRange(0xDBE, 0xDBF).addRange(0xDC7, 0xDC9).addRange(0xDCB, 0xDCE).addRange(0xDE0, 0xDE5).addRange(0xDF0, 0xDF1).addRange(0xDF5, 0xE00).addRange(0xE3B, 0xE3E).addRange(0xE5C, 0xE80).addRange(0xEBE, 0xEBF).addRange(0xECE, 0xECF).addRange(0xEDA, 0xEDB).addRange(0xEE0, 0xEFF).addRange(0xF6D, 0xF70).addRange(0xFDB, 0xFFF).addRange(0x10C8, 0x10CC).addRange(0x10CE, 0x10CF).addRange(0x124E, 0x124F).addRange(0x125E, 0x125F).addRange(0x128E, 0x128F).addRange(0x12B6, 0x12B7).addRange(0x12C6, 0x12C7).addRange(0x1316, 0x1317).addRange(0x135B, 0x135C).addRange(0x137D, 0x137F).addRange(0x139A, 0x139F).addRange(0x13F6, 0x13F7).addRange(0x13FE, 0x13FF).addRange(0x169D, 0x169F).addRange(0x16F9, 0x16FF).addRange(0x1716, 0x171E);
	set.addRange(0x1737, 0x173F).addRange(0x1754, 0x175F).addRange(0x1774, 0x177F).addRange(0x17DE, 0x17DF).addRange(0x17EA, 0x17EF).addRange(0x17FA, 0x17FF).addRange(0x181A, 0x181F).addRange(0x1879, 0x187F).addRange(0x18AB, 0x18AF).addRange(0x18F6, 0x18FF).addRange(0x192C, 0x192F).addRange(0x193C, 0x193F).addRange(0x1941, 0x1943).addRange(0x196E, 0x196F).addRange(0x1975, 0x197F).addRange(0x19AC, 0x19AF).addRange(0x19CA, 0x19CF).addRange(0x19DB, 0x19DD).addRange(0x1A1C, 0x1A1D).addRange(0x1A7D, 0x1A7E).addRange(0x1A8A, 0x1A8F).addRange(0x1A9A, 0x1A9F).addRange(0x1AAE, 0x1AAF).addRange(0x1ACF, 0x1AFF).addRange(0x1B4D, 0x1B4F).addRange(0x1BF4, 0x1BFB).addRange(0x1C38, 0x1C3A).addRange(0x1C4A, 0x1C4C).addRange(0x1C89, 0x1C8F).addRange(0x1CBB, 0x1CBC).addRange(0x1CC8, 0x1CCF).addRange(0x1CFB, 0x1CFF).addRange(0x1F16, 0x1F17).addRange(0x1F1E, 0x1F1F).addRange(0x1F46, 0x1F47).addRange(0x1F4E, 0x1F4F).addRange(0x1F7E, 0x1F7F).addRange(0x1FD4, 0x1FD5).addRange(0x1FF0, 0x1FF1).addRange(0x2072, 0x2073).addRange(0x209D, 0x209F).addRange(0x20C1, 0x20CF).addRange(0x20F1, 0x20FF).addRange(0x218C, 0x218F).addRange(0x2427, 0x243F).addRange(0x244B, 0x245F).addRange(0x2B74, 0x2B75).addRange(0x2CF4, 0x2CF8).addRange(0x2D28, 0x2D2C).addRange(0x2D2E, 0x2D2F).addRange(0x2D68, 0x2D6E);
	set.addRange(0x2D71, 0x2D7E).addRange(0x2D97, 0x2D9F).addRange(0x2E5E, 0x2E7F).addRange(0x2EF4, 0x2EFF).addRange(0x2FD6, 0x2FEF).addRange(0x2FFC, 0x2FFF).addRange(0x3097, 0x3098).addRange(0x3100, 0x3104).addRange(0x31E4, 0x31EF).addRange(0xA48D, 0xA48F).addRange(0xA4C7, 0xA4CF).addRange(0xA62C, 0xA63F).addRange(0xA6F8, 0xA6FF).addRange(0xA7CB, 0xA7CF).addRange(0xA7DA, 0xA7F1).addRange(0xA82D, 0xA82F).addRange(0xA83A, 0xA83F).addRange(0xA878, 0xA87F).addRange(0xA8C6, 0xA8CD).addRange(0xA8DA, 0xA8DF).addRange(0xA954, 0xA95E).addRange(0xA97D, 0xA97F).addRange(0xA9DA, 0xA9DD).addRange(0xAA37, 0xAA3F).addRange(0xAA4E, 0xAA4F).addRange(0xAA5A, 0xAA5B).addRange(0xAAC3, 0xAADA).addRange(0xAAF7, 0xAB00).addRange(0xAB07, 0xAB08).addRange(0xAB0F, 0xAB10).addRange(0xAB17, 0xAB1F).addRange(0xAB6C, 0xAB6F).addRange(0xABEE, 0xABEF).addRange(0xABFA, 0xABFF).addRange(0xD7A4, 0xD7AF).addRange(0xD7C7, 0xD7CA).addRange(0xD7FC, 0xD7FF).addRange(0xFA6E, 0xFA6F).addRange(0xFADA, 0xFAFF).addRange(0xFB07, 0xFB12).addRange(0xFB18, 0xFB1C).addRange(0xFBC3, 0xFBD2).addRange(0xFD90, 0xFD91).addRange(0xFDC8, 0xFDCE).addRange(0xFDD0, 0xFDEF).addRange(0xFE1A, 0xFE1F).addRange(0xFE6C, 0xFE6F).addRange(0xFEFD, 0xFEFE).addRange(0xFFBF, 0xFFC1).addRange(0xFFC8, 0xFFC9).addRange(0xFFD0, 0xFFD1);
	set.addRange(0xFFD8, 0xFFD9).addRange(0xFFDD, 0xFFDF).addRange(0xFFEF, 0xFFF8).addRange(0xFFFE, 0xFFFF).addRange(0x1004E, 0x1004F).addRange(0x1005E, 0x1007F).addRange(0x100FB, 0x100FF).addRange(0x10103, 0x10106).addRange(0x10134, 0x10136).addRange(0x1019D, 0x1019F).addRange(0x101A1, 0x101CF).addRange(0x101FE, 0x1027F).addRange(0x1029D, 0x1029F).addRange(0x102D1, 0x102DF).addRange(0x102FC, 0x102FF).addRange(0x10324, 0x1032C).addRange(0x1034B, 0x1034F).addRange(0x1037B, 0x1037F).addRange(0x103C4, 0x103C7).addRange(0x103D6, 0x103FF).addRange(0x1049E, 0x1049F).addRange(0x104AA, 0x104AF).addRange(0x104D4, 0x104D7).addRange(0x104FC, 0x104FF).addRange(0x10528, 0x1052F).addRange(0x10564, 0x1056E).addRange(0x105BD, 0x105FF).addRange(0x10737, 0x1073F).addRange(0x10756, 0x1075F).addRange(0x10768, 0x1077F).addRange(0x107BB, 0x107FF).addRange(0x10806, 0x10807).addRange(0x10839, 0x1083B).addRange(0x1083D, 0x1083E).addRange(0x1089F, 0x108A6).addRange(0x108B0, 0x108DF).addRange(0x108F6, 0x108FA).addRange(0x1091C, 0x1091E).addRange(0x1093A, 0x1093E).addRange(0x10940, 0x1097F).addRange(0x109B8, 0x109BB).addRange(0x109D0, 0x109D1).addRange(0x10A07, 0x10A0B).addRange(0x10A36, 0x10A37).addRange(0x10A3B, 0x10A3E).addRange(0x10A49, 0x10A4F).addRange(0x10A59, 0x10A5F).addRange(0x10AA0, 0x10ABF).addRange(0x10AE7, 0x10AEA).addRange(0x10AF7, 0x10AFF).addRange(0x10B36, 0x10B38);
	set.addRange(0x10B56, 0x10B57).addRange(0x10B73, 0x10B77).addRange(0x10B92, 0x10B98).addRange(0x10B9D, 0x10BA8).addRange(0x10BB0, 0x10BFF).addRange(0x10C49, 0x10C7F).addRange(0x10CB3, 0x10CBF).addRange(0x10CF3, 0x10CF9).addRange(0x10D28, 0x10D2F).addRange(0x10D3A, 0x10E5F).addRange(0x10EAE, 0x10EAF).addRange(0x10EB2, 0x10EFF).addRange(0x10F28, 0x10F2F).addRange(0x10F5A, 0x10F6F).addRange(0x10F8A, 0x10FAF).addRange(0x10FCC, 0x10FDF).addRange(0x10FF7, 0x10FFF).addRange(0x1104E, 0x11051).addRange(0x11076, 0x1107E).addRange(0x110C3, 0x110CC).addRange(0x110CE, 0x110CF).addRange(0x110E9, 0x110EF).addRange(0x110FA, 0x110FF).addRange(0x11148, 0x1114F).addRange(0x11177, 0x1117F).addRange(0x111F5, 0x111FF).addRange(0x1123F, 0x1127F).addRange(0x112AA, 0x112AF).addRange(0x112EB, 0x112EF).addRange(0x112FA, 0x112FF).addRange(0x1130D, 0x1130E).addRange(0x11311, 0x11312).addRange(0x11345, 0x11346).addRange(0x11349, 0x1134A).addRange(0x1134E, 0x1134F).addRange(0x11351, 0x11356).addRange(0x11358, 0x1135C).addRange(0x11364, 0x11365).addRange(0x1136D, 0x1136F).addRange(0x11375, 0x113FF).addRange(0x11462, 0x1147F).addRange(0x114C8, 0x114CF).addRange(0x114DA, 0x1157F).addRange(0x115B6, 0x115B7).addRange(0x115DE, 0x115FF).addRange(0x11645, 0x1164F).addRange(0x1165A, 0x1165F).addRange(0x1166D, 0x1167F).addRange(0x116BA, 0x116BF).addRange(0x116CA, 0x116FF).addRange(0x1171B, 0x1171C);
	set.addRange(0x1172C, 0x1172F).addRange(0x11747, 0x117FF).addRange(0x1183C, 0x1189F).addRange(0x118F3, 0x118FE).addRange(0x11907, 0x11908).addRange(0x1190A, 0x1190B).addRange(0x11939, 0x1193A).addRange(0x11947, 0x1194F).addRange(0x1195A, 0x1199F).addRange(0x119A8, 0x119A9).addRange(0x119D8, 0x119D9).addRange(0x119E5, 0x119FF).addRange(0x11A48, 0x11A4F).addRange(0x11AA3, 0x11AAF).addRange(0x11AF9, 0x11BFF).addRange(0x11C46, 0x11C4F).addRange(0x11C6D, 0x11C6F).addRange(0x11C90, 0x11C91).addRange(0x11CB7, 0x11CFF).addRange(0x11D37, 0x11D39).addRange(0x11D48, 0x11D4F).addRange(0x11D5A, 0x11D5F).addRange(0x11D99, 0x11D9F).addRange(0x11DAA, 0x11EDF).addRange(0x11EF9, 0x11FAF).addRange(0x11FB1, 0x11FBF).addRange(0x11FF2, 0x11FFE).addRange(0x1239A, 0x123FF).addRange(0x12475, 0x1247F).addRange(0x12544, 0x12F8F).addRange(0x12FF3, 0x12FFF).addRange(0x13439, 0x143FF).addRange(0x14647, 0x167FF).addRange(0x16A39, 0x16A3F).addRange(0x16A6A, 0x16A6D).addRange(0x16ACA, 0x16ACF).addRange(0x16AEE, 0x16AEF).addRange(0x16AF6, 0x16AFF).addRange(0x16B46, 0x16B4F).addRange(0x16B78, 0x16B7C).addRange(0x16B90, 0x16E3F).addRange(0x16E9B, 0x16EFF).addRange(0x16F4B, 0x16F4E).addRange(0x16F88, 0x16F8E).addRange(0x16FA0, 0x16FDF).addRange(0x16FE5, 0x16FEF).addRange(0x16FF2, 0x16FFF).addRange(0x187F8, 0x187FF).addRange(0x18CD6, 0x18CFF).addRange(0x18D09, 0x1AFEF).addRange(0x1B123, 0x1B14F);
	set.addRange(0x1B153, 0x1B163).addRange(0x1B168, 0x1B16F).addRange(0x1B2FC, 0x1BBFF).addRange(0x1BC6B, 0x1BC6F).addRange(0x1BC7D, 0x1BC7F).addRange(0x1BC89, 0x1BC8F).addRange(0x1BC9A, 0x1BC9B).addRange(0x1BCA4, 0x1CEFF).addRange(0x1CF2E, 0x1CF2F).addRange(0x1CF47, 0x1CF4F).addRange(0x1CFC4, 0x1CFFF).addRange(0x1D0F6, 0x1D0FF).addRange(0x1D127, 0x1D128).addRange(0x1D1EB, 0x1D1FF).addRange(0x1D246, 0x1D2DF).addRange(0x1D2F4, 0x1D2FF).addRange(0x1D357, 0x1D35F).addRange(0x1D379, 0x1D3FF).addRange(0x1D4A0, 0x1D4A1).addRange(0x1D4A3, 0x1D4A4).addRange(0x1D4A7, 0x1D4A8).addRange(0x1D50B, 0x1D50C).addRange(0x1D547, 0x1D549).addRange(0x1D6A6, 0x1D6A7).addRange(0x1D7CC, 0x1D7CD).addRange(0x1DA8C, 0x1DA9A).addRange(0x1DAB0, 0x1DEFF).addRange(0x1DF1F, 0x1DFFF).addRange(0x1E019, 0x1E01A).addRange(0x1E02B, 0x1E0FF).addRange(0x1E12D, 0x1E12F).addRange(0x1E13E, 0x1E13F).addRange(0x1E14A, 0x1E14D).addRange(0x1E150, 0x1E28F).addRange(0x1E2AF, 0x1E2BF).addRange(0x1E2FA, 0x1E2FE).addRange(0x1E300, 0x1E7DF).addRange(0x1E8C5, 0x1E8C6).addRange(0x1E8D7, 0x1E8FF).addRange(0x1E94C, 0x1E94F).addRange(0x1E95A, 0x1E95D).addRange(0x1E960, 0x1EC70).addRange(0x1ECB5, 0x1ED00).addRange(0x1ED3E, 0x1EDFF).addRange(0x1EE25, 0x1EE26).addRange(0x1EE3C, 0x1EE41).addRange(0x1EE43, 0x1EE46).addRange(0x1EE55, 0x1EE56).addRange(0x1EE65, 0x1EE66).addRange(0x1EE9C, 0x1EEA0).addRange(0x1EEBC, 0x1EEEF);
	set.addRange(0x1EEF2, 0x1EFFF).addRange(0x1F02C, 0x1F02F).addRange(0x1F094, 0x1F09F).addRange(0x1F0AF, 0x1F0B0).addRange(0x1F0F6, 0x1F0FF).addRange(0x1F1AE, 0x1F1E5).addRange(0x1F203, 0x1F20F).addRange(0x1F23C, 0x1F23F).addRange(0x1F249, 0x1F24F).addRange(0x1F252, 0x1F25F).addRange(0x1F266, 0x1F2FF).addRange(0x1F6D8, 0x1F6DC).addRange(0x1F6ED, 0x1F6EF).addRange(0x1F6FD, 0x1F6FF).addRange(0x1F774, 0x1F77F).addRange(0x1F7D9, 0x1F7DF).addRange(0x1F7EC, 0x1F7EF).addRange(0x1F7F1, 0x1F7FF).addRange(0x1F80C, 0x1F80F).addRange(0x1F848, 0x1F84F).addRange(0x1F85A, 0x1F85F).addRange(0x1F888, 0x1F88F).addRange(0x1F8AE, 0x1F8AF).addRange(0x1F8B2, 0x1F8FF).addRange(0x1FA54, 0x1FA5F).addRange(0x1FA6E, 0x1FA6F).addRange(0x1FA75, 0x1FA77).addRange(0x1FA7D, 0x1FA7F).addRange(0x1FA87, 0x1FA8F).addRange(0x1FAAD, 0x1FAAF).addRange(0x1FABB, 0x1FABF).addRange(0x1FAC6, 0x1FACF).addRange(0x1FADA, 0x1FADF).addRange(0x1FAE8, 0x1FAEF).addRange(0x1FAF7, 0x1FAFF).addRange(0x1FBCB, 0x1FBEF).addRange(0x1FBFA, 0x1FFFF).addRange(0x2A6E0, 0x2A6FF).addRange(0x2B739, 0x2B73F).addRange(0x2B81E, 0x2B81F).addRange(0x2CEA2, 0x2CEAF).addRange(0x2EBE1, 0x2F7FF).addRange(0x2FA1E, 0x2FFFF).addRange(0x3134B, 0xE0000).addRange(0xE0002, 0xE001F).addRange(0xE0080, 0xE00FF).addRange(0xE01F0, 0xEFFFF).addRange(0xFFFFE, 0xFFFFF).addRange(0x10FFFE, 0x10FFFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/General_Category/Uppercase_Letter.js", function (module, exports) {
	  const set = regenerate(0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x17B, 0x17D, 0x184, 0x1A2, 0x1A4, 0x1A9, 0x1AC, 0x1B5, 0x1BC, 0x1C4, 0x1C7, 0x1CA, 0x1CD, 0x1CF, 0x1D1, 0x1D3, 0x1D5, 0x1D7, 0x1D9, 0x1DB, 0x1DE, 0x1E0, 0x1E2, 0x1E4, 0x1E6, 0x1E8, 0x1EA, 0x1EC, 0x1EE, 0x1F1, 0x1F4, 0x1FA, 0x1FC, 0x1FE, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20A, 0x20C, 0x20E, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21A, 0x21C, 0x21E, 0x220, 0x222, 0x224, 0x226, 0x228, 0x22A, 0x22C, 0x22E, 0x230, 0x232, 0x241, 0x248, 0x24A, 0x24C, 0x24E, 0x370, 0x372, 0x376, 0x37F, 0x386, 0x38C, 0x3CF, 0x3D8, 0x3DA, 0x3DC, 0x3DE, 0x3E0, 0x3E2, 0x3E4, 0x3E6, 0x3E8, 0x3EA, 0x3EC, 0x3EE, 0x3F4, 0x3F7, 0x460, 0x462, 0x464, 0x466, 0x468, 0x46A, 0x46C, 0x46E, 0x470, 0x472, 0x474, 0x476, 0x478, 0x47A, 0x47C, 0x47E, 0x480, 0x48A, 0x48C, 0x48E, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49A, 0x49C, 0x49E, 0x4A0, 0x4A2, 0x4A4, 0x4A6, 0x4A8, 0x4AA, 0x4AC, 0x4AE, 0x4B0, 0x4B2, 0x4B4, 0x4B6, 0x4B8, 0x4BA, 0x4BC, 0x4BE, 0x4C3, 0x4C5, 0x4C7, 0x4C9, 0x4CB, 0x4CD, 0x4D0, 0x4D2, 0x4D4, 0x4D6, 0x4D8, 0x4DA, 0x4DC, 0x4DE, 0x4E0, 0x4E2, 0x4E4, 0x4E6, 0x4E8, 0x4EA, 0x4EC, 0x4EE, 0x4F0, 0x4F2, 0x4F4, 0x4F6, 0x4F8, 0x4FA, 0x4FC, 0x4FE, 0x500, 0x502, 0x504, 0x506, 0x508, 0x50A, 0x50C, 0x50E, 0x510, 0x512, 0x514, 0x516, 0x518, 0x51A, 0x51C, 0x51E, 0x520, 0x522, 0x524, 0x526, 0x528, 0x52A, 0x52C, 0x52E, 0x10C7, 0x10CD, 0x1E00, 0x1E02, 0x1E04, 0x1E06, 0x1E08, 0x1E0A, 0x1E0C, 0x1E0E, 0x1E10, 0x1E12, 0x1E14, 0x1E16, 0x1E18, 0x1E1A, 0x1E1C, 0x1E1E, 0x1E20, 0x1E22, 0x1E24, 0x1E26, 0x1E28, 0x1E2A, 0x1E2C, 0x1E2E, 0x1E30, 0x1E32, 0x1E34, 0x1E36, 0x1E38, 0x1E3A, 0x1E3C, 0x1E3E, 0x1E40, 0x1E42, 0x1E44, 0x1E46, 0x1E48, 0x1E4A, 0x1E4C, 0x1E4E, 0x1E50, 0x1E52, 0x1E54, 0x1E56, 0x1E58, 0x1E5A, 0x1E5C, 0x1E5E, 0x1E60, 0x1E62, 0x1E64, 0x1E66, 0x1E68, 0x1E6A, 0x1E6C, 0x1E6E, 0x1E70, 0x1E72, 0x1E74, 0x1E76, 0x1E78, 0x1E7A, 0x1E7C, 0x1E7E, 0x1E80, 0x1E82, 0x1E84, 0x1E86, 0x1E88, 0x1E8A, 0x1E8C, 0x1E8E, 0x1E90, 0x1E92, 0x1E94, 0x1E9E, 0x1EA0, 0x1EA2, 0x1EA4, 0x1EA6, 0x1EA8, 0x1EAA, 0x1EAC, 0x1EAE, 0x1EB0, 0x1EB2, 0x1EB4, 0x1EB6, 0x1EB8, 0x1EBA, 0x1EBC, 0x1EBE, 0x1EC0, 0x1EC2, 0x1EC4, 0x1EC6, 0x1EC8, 0x1ECA, 0x1ECC, 0x1ECE, 0x1ED0, 0x1ED2, 0x1ED4, 0x1ED6, 0x1ED8, 0x1EDA, 0x1EDC, 0x1EDE, 0x1EE0, 0x1EE2, 0x1EE4, 0x1EE6, 0x1EE8, 0x1EEA, 0x1EEC, 0x1EEE, 0x1EF0, 0x1EF2, 0x1EF4, 0x1EF6, 0x1EF8, 0x1EFA, 0x1EFC, 0x1EFE, 0x1F59, 0x1F5B, 0x1F5D, 0x1F5F, 0x2102, 0x2107, 0x2115, 0x2124, 0x2126, 0x2128, 0x2145, 0x2183, 0x2C60, 0x2C67, 0x2C69, 0x2C6B, 0x2C72, 0x2C75, 0x2C82, 0x2C84, 0x2C86, 0x2C88, 0x2C8A, 0x2C8C, 0x2C8E, 0x2C90, 0x2C92, 0x2C94, 0x2C96, 0x2C98, 0x2C9A, 0x2C9C, 0x2C9E, 0x2CA0, 0x2CA2, 0x2CA4, 0x2CA6, 0x2CA8, 0x2CAA, 0x2CAC, 0x2CAE, 0x2CB0, 0x2CB2, 0x2CB4, 0x2CB6, 0x2CB8, 0x2CBA, 0x2CBC, 0x2CBE, 0x2CC0, 0x2CC2, 0x2CC4, 0x2CC6, 0x2CC8, 0x2CCA, 0x2CCC, 0x2CCE, 0x2CD0, 0x2CD2, 0x2CD4, 0x2CD6, 0x2CD8, 0x2CDA, 0x2CDC, 0x2CDE, 0x2CE0, 0x2CE2, 0x2CEB, 0x2CED, 0x2CF2, 0xA640, 0xA642, 0xA644, 0xA646, 0xA648, 0xA64A, 0xA64C, 0xA64E, 0xA650, 0xA652, 0xA654, 0xA656, 0xA658, 0xA65A, 0xA65C, 0xA65E, 0xA660, 0xA662, 0xA664, 0xA666, 0xA668, 0xA66A, 0xA66C, 0xA680, 0xA682, 0xA684, 0xA686, 0xA688, 0xA68A, 0xA68C, 0xA68E, 0xA690, 0xA692, 0xA694, 0xA696, 0xA698, 0xA69A, 0xA722, 0xA724, 0xA726, 0xA728, 0xA72A, 0xA72C, 0xA72E, 0xA732, 0xA734, 0xA736, 0xA738, 0xA73A, 0xA73C, 0xA73E, 0xA740, 0xA742, 0xA744, 0xA746, 0xA748, 0xA74A, 0xA74C, 0xA74E, 0xA750, 0xA752, 0xA754, 0xA756, 0xA758, 0xA75A, 0xA75C, 0xA75E, 0xA760, 0xA762, 0xA764, 0xA766, 0xA768, 0xA76A, 0xA76C, 0xA76E, 0xA779, 0xA77B, 0xA780, 0xA782, 0xA784, 0xA786, 0xA78B, 0xA78D, 0xA790, 0xA792, 0xA796, 0xA798, 0xA79A, 0xA79C, 0xA79E, 0xA7A0, 0xA7A2, 0xA7A4, 0xA7A6, 0xA7A8, 0xA7B6, 0xA7B8, 0xA7BA, 0xA7BC, 0xA7BE, 0xA7C0, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D6, 0xA7D8, 0xA7F5, 0x1D49C, 0x1D4A2, 0x1D546, 0x1D7CA);
	set.addRange(0x41, 0x5A).addRange(0xC0, 0xD6).addRange(0xD8, 0xDE).addRange(0x178, 0x179).addRange(0x181, 0x182).addRange(0x186, 0x187).addRange(0x189, 0x18B).addRange(0x18E, 0x191).addRange(0x193, 0x194).addRange(0x196, 0x198).addRange(0x19C, 0x19D).addRange(0x19F, 0x1A0).addRange(0x1A6, 0x1A7).addRange(0x1AE, 0x1AF).addRange(0x1B1, 0x1B3).addRange(0x1B7, 0x1B8).addRange(0x1F6, 0x1F8).addRange(0x23A, 0x23B).addRange(0x23D, 0x23E).addRange(0x243, 0x246).addRange(0x388, 0x38A).addRange(0x38E, 0x38F).addRange(0x391, 0x3A1).addRange(0x3A3, 0x3AB).addRange(0x3D2, 0x3D4).addRange(0x3F9, 0x3FA).addRange(0x3FD, 0x42F).addRange(0x4C0, 0x4C1).addRange(0x531, 0x556).addRange(0x10A0, 0x10C5).addRange(0x13A0, 0x13F5).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x1F08, 0x1F0F).addRange(0x1F18, 0x1F1D).addRange(0x1F28, 0x1F2F).addRange(0x1F38, 0x1F3F).addRange(0x1F48, 0x1F4D).addRange(0x1F68, 0x1F6F).addRange(0x1FB8, 0x1FBB).addRange(0x1FC8, 0x1FCB).addRange(0x1FD8, 0x1FDB).addRange(0x1FE8, 0x1FEC).addRange(0x1FF8, 0x1FFB).addRange(0x210B, 0x210D).addRange(0x2110, 0x2112).addRange(0x2119, 0x211D).addRange(0x212A, 0x212D).addRange(0x2130, 0x2133).addRange(0x213E, 0x213F).addRange(0x2C00, 0x2C2F);
	set.addRange(0x2C62, 0x2C64).addRange(0x2C6D, 0x2C70).addRange(0x2C7E, 0x2C80).addRange(0xA77D, 0xA77E).addRange(0xA7AA, 0xA7AE).addRange(0xA7B0, 0xA7B4).addRange(0xA7C4, 0xA7C7).addRange(0xFF21, 0xFF3A).addRange(0x10400, 0x10427).addRange(0x104B0, 0x104D3).addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10C80, 0x10CB2).addRange(0x118A0, 0x118BF).addRange(0x16E40, 0x16E5F).addRange(0x1D400, 0x1D419).addRange(0x1D434, 0x1D44D).addRange(0x1D468, 0x1D481).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B5).addRange(0x1D4D0, 0x1D4E9).addRange(0x1D504, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D538, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D56C, 0x1D585).addRange(0x1D5A0, 0x1D5B9).addRange(0x1D5D4, 0x1D5ED).addRange(0x1D608, 0x1D621).addRange(0x1D63C, 0x1D655).addRange(0x1D670, 0x1D689).addRange(0x1D6A8, 0x1D6C0).addRange(0x1D6E2, 0x1D6FA).addRange(0x1D71C, 0x1D734).addRange(0x1D756, 0x1D76E).addRange(0x1D790, 0x1D7A8).addRange(0x1E900, 0x1E921);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/index.js", function (module, exports) {
	  module.exports = new Map([
		['General_Category', [
			'Cased_Letter',
			'Close_Punctuation',
			'Connector_Punctuation',
			'Control',
			'Currency_Symbol',
			'Dash_Punctuation',
			'Decimal_Number',
			'Enclosing_Mark',
			'Final_Punctuation',
			'Format',
			'Initial_Punctuation',
			'Letter',
			'Letter_Number',
			'Line_Separator',
			'Lowercase_Letter',
			'Mark',
			'Math_Symbol',
			'Modifier_Letter',
			'Modifier_Symbol',
			'Nonspacing_Mark',
			'Number',
			'Open_Punctuation',
			'Other',
			'Other_Letter',
			'Other_Number',
			'Other_Punctuation',
			'Other_Symbol',
			'Paragraph_Separator',
			'Private_Use',
			'Punctuation',
			'Separator',
			'Space_Separator',
			'Spacing_Mark',
			'Surrogate',
			'Symbol',
			'Titlecase_Letter',
			'Unassigned',
			'Uppercase_Letter'
		]],
		['Script', [
			'Adlam',
			'Ahom',
			'Anatolian_Hieroglyphs',
			'Arabic',
			'Armenian',
			'Avestan',
			'Balinese',
			'Bamum',
			'Bassa_Vah',
			'Batak',
			'Bengali',
			'Bhaiksuki',
			'Bopomofo',
			'Brahmi',
			'Braille',
			'Buginese',
			'Buhid',
			'Canadian_Aboriginal',
			'Carian',
			'Caucasian_Albanian',
			'Chakma',
			'Cham',
			'Cherokee',
			'Chorasmian',
			'Common',
			'Coptic',
			'Cuneiform',
			'Cypriot',
			'Cypro_Minoan',
			'Cyrillic',
			'Deseret',
			'Devanagari',
			'Dives_Akuru',
			'Dogra',
			'Duployan',
			'Egyptian_Hieroglyphs',
			'Elbasan',
			'Elymaic',
			'Ethiopic',
			'Georgian',
			'Glagolitic',
			'Gothic',
			'Grantha',
			'Greek',
			'Gujarati',
			'Gunjala_Gondi',
			'Gurmukhi',
			'Han',
			'Hangul',
			'Hanifi_Rohingya',
			'Hanunoo',
			'Hatran',
			'Hebrew',
			'Hiragana',
			'Imperial_Aramaic',
			'Inherited',
			'Inscriptional_Pahlavi',
			'Inscriptional_Parthian',
			'Javanese',
			'Kaithi',
			'Kannada',
			'Katakana',
			'Kayah_Li',
			'Kharoshthi',
			'Khitan_Small_Script',
			'Khmer',
			'Khojki',
			'Khudawadi',
			'Lao',
			'Latin',
			'Lepcha',
			'Limbu',
			'Linear_A',
			'Linear_B',
			'Lisu',
			'Lycian',
			'Lydian',
			'Mahajani',
			'Makasar',
			'Malayalam',
			'Mandaic',
			'Manichaean',
			'Marchen',
			'Masaram_Gondi',
			'Medefaidrin',
			'Meetei_Mayek',
			'Mende_Kikakui',
			'Meroitic_Cursive',
			'Meroitic_Hieroglyphs',
			'Miao',
			'Modi',
			'Mongolian',
			'Mro',
			'Multani',
			'Myanmar',
			'Nabataean',
			'Nandinagari',
			'New_Tai_Lue',
			'Newa',
			'Nko',
			'Nushu',
			'Nyiakeng_Puachue_Hmong',
			'Ogham',
			'Ol_Chiki',
			'Old_Hungarian',
			'Old_Italic',
			'Old_North_Arabian',
			'Old_Permic',
			'Old_Persian',
			'Old_Sogdian',
			'Old_South_Arabian',
			'Old_Turkic',
			'Old_Uyghur',
			'Oriya',
			'Osage',
			'Osmanya',
			'Pahawh_Hmong',
			'Palmyrene',
			'Pau_Cin_Hau',
			'Phags_Pa',
			'Phoenician',
			'Psalter_Pahlavi',
			'Rejang',
			'Runic',
			'Samaritan',
			'Saurashtra',
			'Sharada',
			'Shavian',
			'Siddham',
			'SignWriting',
			'Sinhala',
			'Sogdian',
			'Sora_Sompeng',
			'Soyombo',
			'Sundanese',
			'Syloti_Nagri',
			'Syriac',
			'Tagalog',
			'Tagbanwa',
			'Tai_Le',
			'Tai_Tham',
			'Tai_Viet',
			'Takri',
			'Tamil',
			'Tangsa',
			'Tangut',
			'Telugu',
			'Thaana',
			'Thai',
			'Tibetan',
			'Tifinagh',
			'Tirhuta',
			'Toto',
			'Ugaritic',
			'Vai',
			'Vithkuqi',
			'Wancho',
			'Warang_Citi',
			'Yezidi',
			'Yi',
			'Zanabazar_Square'
		]],
		['Script_Extensions', [
			'Adlam',
			'Ahom',
			'Anatolian_Hieroglyphs',
			'Arabic',
			'Armenian',
			'Avestan',
			'Balinese',
			'Bamum',
			'Bassa_Vah',
			'Batak',
			'Bengali',
			'Bhaiksuki',
			'Bopomofo',
			'Brahmi',
			'Braille',
			'Buginese',
			'Buhid',
			'Canadian_Aboriginal',
			'Carian',
			'Caucasian_Albanian',
			'Chakma',
			'Cham',
			'Cherokee',
			'Chorasmian',
			'Common',
			'Coptic',
			'Cuneiform',
			'Cypriot',
			'Cypro_Minoan',
			'Cyrillic',
			'Deseret',
			'Devanagari',
			'Dives_Akuru',
			'Dogra',
			'Duployan',
			'Egyptian_Hieroglyphs',
			'Elbasan',
			'Elymaic',
			'Ethiopic',
			'Georgian',
			'Glagolitic',
			'Gothic',
			'Grantha',
			'Greek',
			'Gujarati',
			'Gunjala_Gondi',
			'Gurmukhi',
			'Han',
			'Hangul',
			'Hanifi_Rohingya',
			'Hanunoo',
			'Hatran',
			'Hebrew',
			'Hiragana',
			'Imperial_Aramaic',
			'Inherited',
			'Inscriptional_Pahlavi',
			'Inscriptional_Parthian',
			'Javanese',
			'Kaithi',
			'Kannada',
			'Katakana',
			'Kayah_Li',
			'Kharoshthi',
			'Khitan_Small_Script',
			'Khmer',
			'Khojki',
			'Khudawadi',
			'Lao',
			'Latin',
			'Lepcha',
			'Limbu',
			'Linear_A',
			'Linear_B',
			'Lisu',
			'Lycian',
			'Lydian',
			'Mahajani',
			'Makasar',
			'Malayalam',
			'Mandaic',
			'Manichaean',
			'Marchen',
			'Masaram_Gondi',
			'Medefaidrin',
			'Meetei_Mayek',
			'Mende_Kikakui',
			'Meroitic_Cursive',
			'Meroitic_Hieroglyphs',
			'Miao',
			'Modi',
			'Mongolian',
			'Mro',
			'Multani',
			'Myanmar',
			'Nabataean',
			'Nandinagari',
			'New_Tai_Lue',
			'Newa',
			'Nko',
			'Nushu',
			'Nyiakeng_Puachue_Hmong',
			'Ogham',
			'Ol_Chiki',
			'Old_Hungarian',
			'Old_Italic',
			'Old_North_Arabian',
			'Old_Permic',
			'Old_Persian',
			'Old_Sogdian',
			'Old_South_Arabian',
			'Old_Turkic',
			'Old_Uyghur',
			'Oriya',
			'Osage',
			'Osmanya',
			'Pahawh_Hmong',
			'Palmyrene',
			'Pau_Cin_Hau',
			'Phags_Pa',
			'Phoenician',
			'Psalter_Pahlavi',
			'Rejang',
			'Runic',
			'Samaritan',
			'Saurashtra',
			'Sharada',
			'Shavian',
			'Siddham',
			'SignWriting',
			'Sinhala',
			'Sogdian',
			'Sora_Sompeng',
			'Soyombo',
			'Sundanese',
			'Syloti_Nagri',
			'Syriac',
			'Tagalog',
			'Tagbanwa',
			'Tai_Le',
			'Tai_Tham',
			'Tai_Viet',
			'Takri',
			'Tamil',
			'Tangsa',
			'Tangut',
			'Telugu',
			'Thaana',
			'Thai',
			'Tibetan',
			'Tifinagh',
			'Tirhuta',
			'Toto',
			'Ugaritic',
			'Vai',
			'Vithkuqi',
			'Wancho',
			'Warang_Citi',
			'Yezidi',
			'Yi',
			'Zanabazar_Square'
		]],
		['Binary_Property', [
			'ASCII',
			'ASCII_Hex_Digit',
			'Alphabetic',
			'Any',
			'Assigned',
			'Bidi_Control',
			'Bidi_Mirrored',
			'Case_Ignorable',
			'Cased',
			'Changes_When_Casefolded',
			'Changes_When_Casemapped',
			'Changes_When_Lowercased',
			'Changes_When_NFKC_Casefolded',
			'Changes_When_Titlecased',
			'Changes_When_Uppercased',
			'Dash',
			'Default_Ignorable_Code_Point',
			'Deprecated',
			'Diacritic',
			'Emoji',
			'Emoji_Component',
			'Emoji_Modifier',
			'Emoji_Modifier_Base',
			'Emoji_Presentation',
			'Extended_Pictographic',
			'Extender',
			'Grapheme_Base',
			'Grapheme_Extend',
			'Hex_Digit',
			'IDS_Binary_Operator',
			'IDS_Trinary_Operator',
			'ID_Continue',
			'ID_Start',
			'Ideographic',
			'Join_Control',
			'Logical_Order_Exception',
			'Lowercase',
			'Math',
			'Noncharacter_Code_Point',
			'Pattern_Syntax',
			'Pattern_White_Space',
			'Quotation_Mark',
			'Radical',
			'Regional_Indicator',
			'Sentence_Terminal',
			'Soft_Dotted',
			'Terminal_Punctuation',
			'Unified_Ideograph',
			'Uppercase',
			'Variation_Selector',
			'White_Space',
			'XID_Continue',
			'XID_Start'
		]]
	]);

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Adlam.js", function (module, exports) {
	  const set = regenerate(0x61F, 0x640);
	set.addRange(0x1E900, 0x1E94B).addRange(0x1E950, 0x1E959).addRange(0x1E95E, 0x1E95F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Ahom.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172B).addRange(0x11730, 0x11746);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Anatolian_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x14400, 0x14646);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Arabic.js", function (module, exports) {
	  const set = regenerate(0xFDCF, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x600, 0x604).addRange(0x606, 0x6DC).addRange(0x6DE, 0x6FF).addRange(0x750, 0x77F).addRange(0x870, 0x88E).addRange(0x890, 0x891).addRange(0x898, 0x8E1).addRange(0x8E3, 0x8FF).addRange(0xFB50, 0xFBC2).addRange(0xFBD3, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFF).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0x102E0, 0x102FB).addRange(0x10E60, 0x10E7E).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1EEF0, 0x1EEF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Armenian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x531, 0x556).addRange(0x559, 0x58A).addRange(0x58D, 0x58F).addRange(0xFB13, 0xFB17);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Avestan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B00, 0x10B35).addRange(0x10B39, 0x10B3F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Balinese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1B00, 0x1B4C).addRange(0x1B50, 0x1B7E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Bamum.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA6A0, 0xA6F7).addRange(0x16800, 0x16A38);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Bassa_Vah.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16AD0, 0x16AED).addRange(0x16AF0, 0x16AF5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Batak.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1BC0, 0x1BF3).addRange(0x1BFC, 0x1BFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Bengali.js", function (module, exports) {
	  const set = regenerate(0x9B2, 0x9D7, 0x1CD0, 0x1CD2, 0x1CD8, 0x1CE1, 0x1CEA, 0x1CED, 0x1CF2, 0xA8F1);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0x980, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BC, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CE).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E3).addRange(0x9E6, 0x9FE).addRange(0x1CD5, 0x1CD6).addRange(0x1CF5, 0x1CF7);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Bhaiksuki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C45).addRange(0x11C50, 0x11C6C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Bopomofo.js", function (module, exports) {
	  const set = regenerate(0x3030, 0x3037, 0x30FB);
	set.addRange(0x2EA, 0x2EB).addRange(0x3001, 0x3003).addRange(0x3008, 0x3011).addRange(0x3013, 0x301F).addRange(0x302A, 0x302D).addRange(0x3105, 0x312F).addRange(0x31A0, 0x31BF).addRange(0xFE45, 0xFE46).addRange(0xFF61, 0xFF65);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Brahmi.js", function (module, exports) {
	  const set = regenerate(0x1107F);
	set.addRange(0x11000, 0x1104D).addRange(0x11052, 0x11075);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Braille.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2800, 0x28FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Buginese.js", function (module, exports) {
	  const set = regenerate(0xA9CF);
	set.addRange(0x1A00, 0x1A1B).addRange(0x1A1E, 0x1A1F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Buhid.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1735, 0x1736).addRange(0x1740, 0x1753);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Canadian_Aboriginal.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1400, 0x167F).addRange(0x18B0, 0x18F5).addRange(0x11AB0, 0x11ABF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Carian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x102A0, 0x102D0);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Caucasian_Albanian.js", function (module, exports) {
	  const set = regenerate(0x1056F);
	set.addRange(0x10530, 0x10563);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Chakma.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x9E6, 0x9EF).addRange(0x1040, 0x1049).addRange(0x11100, 0x11134).addRange(0x11136, 0x11147);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA50, 0xAA59).addRange(0xAA5C, 0xAA5F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cherokee.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0xAB70, 0xABBF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Chorasmian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10FB0, 0x10FCB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Common.js", function (module, exports) {
	  const set = regenerate(0xD7, 0xF7, 0x374, 0x37E, 0x385, 0x387, 0x605, 0x6DD, 0x8E2, 0xE3F, 0x3000, 0x3004, 0x3012, 0x3020, 0x3036, 0x327F, 0x33FF, 0xAB5B, 0xFEFF, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1F7F0, 0xE0001);
	set.addRange(0x0, 0x40).addRange(0x5B, 0x60).addRange(0x7B, 0xA9).addRange(0xAB, 0xB9).addRange(0xBB, 0xBF).addRange(0x2B9, 0x2DF).addRange(0x2E5, 0x2E9).addRange(0x2EC, 0x2FF).addRange(0xFD5, 0xFD8).addRange(0x16EB, 0x16ED).addRange(0x2000, 0x200B).addRange(0x200E, 0x202E).addRange(0x2030, 0x2064).addRange(0x2066, 0x2070).addRange(0x2074, 0x207E).addRange(0x2080, 0x208E).addRange(0x20A0, 0x20C0).addRange(0x2100, 0x2125).addRange(0x2127, 0x2129).addRange(0x212C, 0x2131).addRange(0x2133, 0x214D).addRange(0x214F, 0x215F).addRange(0x2189, 0x218B).addRange(0x2190, 0x2426).addRange(0x2440, 0x244A).addRange(0x2460, 0x27FF).addRange(0x2900, 0x2B73).addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2BFF).addRange(0x2E00, 0x2E42).addRange(0x2E44, 0x2E5D).addRange(0x2FF0, 0x2FFB).addRange(0x3248, 0x325F).addRange(0x32B1, 0x32BF).addRange(0x32CC, 0x32CF).addRange(0x3371, 0x337A).addRange(0x3380, 0x33DF).addRange(0x4DC0, 0x4DFF).addRange(0xA708, 0xA721).addRange(0xA788, 0xA78A).addRange(0xAB6A, 0xAB6B).addRange(0xFE10, 0xFE19).addRange(0xFE30, 0xFE44).addRange(0xFE47, 0xFE52).addRange(0xFE54, 0xFE66).addRange(0xFE68, 0xFE6B).addRange(0xFF01, 0xFF20).addRange(0xFF3B, 0xFF40).addRange(0xFF5B, 0xFF60).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE);
	set.addRange(0xFFF9, 0xFFFD).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FC).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D166).addRange(0x1D16A, 0x1D17A).addRange(0x1D183, 0x1D184).addRange(0x1D18C, 0x1D1A9).addRange(0x1D1AE, 0x1D1EA).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D300, 0x1D356).addRange(0x1D372, 0x1D378).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1EC71, 0x1ECB4).addRange(0x1ED01, 0x1ED3D).addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F100, 0x1F1AD).addRange(0x1F1E6, 0x1F1FF).addRange(0x1F201, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8);
	set.addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA).addRange(0x1FBF0, 0x1FBF9).addRange(0xE0020, 0xE007F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Coptic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x3E2, 0x3EF).addRange(0x2C80, 0x2CF3).addRange(0x2CF9, 0x2CFF).addRange(0x102E0, 0x102FB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cuneiform.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12470, 0x12474).addRange(0x12480, 0x12543);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cypriot.js", function (module, exports) {
	  const set = regenerate(0x10808, 0x1083C, 0x1083F);
	set.addRange(0x10100, 0x10102).addRange(0x10107, 0x10133).addRange(0x10137, 0x1013F).addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cypro_Minoan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10100, 0x10101).addRange(0x12F90, 0x12FF2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Cyrillic.js", function (module, exports) {
	  const set = regenerate(0x1D2B, 0x1D78, 0x1DF8, 0x2E43);
	set.addRange(0x400, 0x52F).addRange(0x1C80, 0x1C88).addRange(0x2DE0, 0x2DFF).addRange(0xA640, 0xA69F).addRange(0xFE2E, 0xFE2F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Deseret.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10400, 0x1044F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Devanagari.js", function (module, exports) {
	  const set = regenerate(0x20F0);
	set.addRange(0x900, 0x952).addRange(0x955, 0x97F).addRange(0x1CD0, 0x1CF6).addRange(0x1CF8, 0x1CF9).addRange(0xA830, 0xA839).addRange(0xA8E0, 0xA8FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Dives_Akuru.js", function (module, exports) {
	  const set = regenerate(0x11909);
	set.addRange(0x11900, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x11946).addRange(0x11950, 0x11959);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Dogra.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x96F).addRange(0xA830, 0xA839).addRange(0x11800, 0x1183B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Duployan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1BC9C, 0x1BCA3);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Egyptian_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x13000, 0x1342E).addRange(0x13430, 0x13438);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Elbasan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10500, 0x10527);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Elymaic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10FE0, 0x10FF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Ethiopic.js", function (module, exports) {
	  const set = regenerate(0x1258, 0x12C0);
	set.addRange(0x1200, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x135D, 0x137C).addRange(0x1380, 0x1399).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Georgian.js", function (module, exports) {
	  const set = regenerate(0x10C7, 0x10CD, 0x2D27, 0x2D2D);
	set.addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FF).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x2D00, 0x2D25);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Glagolitic.js", function (module, exports) {
	  const set = regenerate(0x484, 0x487, 0x2E43, 0xA66F);
	set.addRange(0x2C00, 0x2C5F).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Gothic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10330, 0x1034A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Grantha.js", function (module, exports) {
	  const set = regenerate(0x1CD0, 0x20F0, 0x11350, 0x11357, 0x11FD3);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xBE6, 0xBF3).addRange(0x1CD2, 0x1CD3).addRange(0x1CF2, 0x1CF4).addRange(0x1CF8, 0x1CF9).addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133B, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374).addRange(0x11FD0, 0x11FD1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Greek.js", function (module, exports) {
	  const set = regenerate(0x342, 0x345, 0x37F, 0x384, 0x386, 0x38C, 0x1F59, 0x1F5B, 0x1F5D, 0x2126, 0xAB65, 0x101A0);
	set.addRange(0x370, 0x373).addRange(0x375, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3E1).addRange(0x3F0, 0x3FF).addRange(0x1D26, 0x1D2A).addRange(0x1D5D, 0x1D61).addRange(0x1D66, 0x1D6A).addRange(0x1DBF, 0x1DC1).addRange(0x1F00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FC4).addRange(0x1FC6, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FDD, 0x1FEF).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFE).addRange(0x10140, 0x1018E).addRange(0x1D200, 0x1D245);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Gujarati.js", function (module, exports) {
	  const set = regenerate(0xAD0);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABC, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE0, 0xAE3).addRange(0xAE6, 0xAF1).addRange(0xAF9, 0xAFF).addRange(0xA830, 0xA839);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Gunjala_Gondi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x965).addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D98).addRange(0x11DA0, 0x11DA9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Gurmukhi.js", function (module, exports) {
	  const set = regenerate(0xA3C, 0xA51, 0xA5E);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA76).addRange(0xA830, 0xA839);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Han.js", function (module, exports) {
	  const set = regenerate(0x3030, 0x30FB, 0x32FF);
	set.addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x3001, 0x3003).addRange(0x3005, 0x3011).addRange(0x3013, 0x301F).addRange(0x3021, 0x302D).addRange(0x3037, 0x303F).addRange(0x3190, 0x319F).addRange(0x31C0, 0x31E3).addRange(0x3220, 0x3247).addRange(0x3280, 0x32B0).addRange(0x32C0, 0x32CB).addRange(0x3358, 0x3370).addRange(0x337B, 0x337F).addRange(0x33E0, 0x33FE).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0x9FFF).addRange(0xA700, 0xA707).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0xFE45, 0xFE46).addRange(0xFF61, 0xFF65).addRange(0x16FE2, 0x16FE3).addRange(0x16FF0, 0x16FF1).addRange(0x1D360, 0x1D371).addRange(0x1F250, 0x1F251).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hangul.js", function (module, exports) {
	  const set = regenerate(0x3037, 0x30FB);
	set.addRange(0x1100, 0x11FF).addRange(0x3001, 0x3003).addRange(0x3008, 0x3011).addRange(0x3013, 0x301F).addRange(0x302E, 0x3030).addRange(0x3131, 0x318E).addRange(0x3200, 0x321E).addRange(0x3260, 0x327E).addRange(0xA960, 0xA97C).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xFE45, 0xFE46).addRange(0xFF61, 0xFF65).addRange(0xFFA0, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hanifi_Rohingya.js", function (module, exports) {
	  const set = regenerate(0x60C, 0x61B, 0x61F, 0x640, 0x6D4);
	set.addRange(0x10D00, 0x10D27).addRange(0x10D30, 0x10D39);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hanunoo.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1720, 0x1736);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hatran.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x108FB, 0x108FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hebrew.js", function (module, exports) {
	  const set = regenerate(0xFB3E);
	set.addRange(0x591, 0x5C7).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F4).addRange(0xFB1D, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFB4F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Hiragana.js", function (module, exports) {
	  const set = regenerate(0x3037, 0xFF70, 0x1F200);
	set.addRange(0x3001, 0x3003).addRange(0x3008, 0x3011).addRange(0x3013, 0x301F).addRange(0x3030, 0x3035).addRange(0x303C, 0x303D).addRange(0x3041, 0x3096).addRange(0x3099, 0x30A0).addRange(0x30FB, 0x30FC).addRange(0xFE45, 0xFE46).addRange(0xFF61, 0xFF65).addRange(0xFF9E, 0xFF9F).addRange(0x1B001, 0x1B11F).addRange(0x1B150, 0x1B152);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Imperial_Aramaic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10840, 0x10855).addRange(0x10857, 0x1085F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Inherited.js", function (module, exports) {
	  const set = regenerate(0x1DF9, 0x101FD);
	set.addRange(0x300, 0x341).addRange(0x343, 0x344).addRange(0x346, 0x362).addRange(0x953, 0x954).addRange(0x1AB0, 0x1ACE).addRange(0x1DC2, 0x1DF7).addRange(0x1DFB, 0x1DFF).addRange(0x200C, 0x200D).addRange(0x20D0, 0x20EF).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2D).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Inscriptional_Pahlavi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B60, 0x10B72).addRange(0x10B78, 0x10B7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Inscriptional_Parthian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B40, 0x10B55).addRange(0x10B58, 0x10B5F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Javanese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA980, 0xA9CD).addRange(0xA9CF, 0xA9D9).addRange(0xA9DE, 0xA9DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Kaithi.js", function (module, exports) {
	  const set = regenerate(0x110CD);
	set.addRange(0x966, 0x96F).addRange(0xA830, 0xA839).addRange(0x11080, 0x110C2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Kannada.js", function (module, exports) {
	  const set = regenerate(0x1CD0, 0x1CD2, 0x1CDA, 0x1CF2, 0x1CF4);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xC80, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBC, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2).addRange(0xA830, 0xA835);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Katakana.js", function (module, exports) {
	  const set = regenerate(0x3037, 0x1B000);
	set.addRange(0x3001, 0x3003).addRange(0x3008, 0x3011).addRange(0x3013, 0x301F).addRange(0x3030, 0x3035).addRange(0x303C, 0x303D).addRange(0x3099, 0x309C).addRange(0x30A0, 0x30FF).addRange(0x31F0, 0x31FF).addRange(0x32D0, 0x32FE).addRange(0x3300, 0x3357).addRange(0xFE45, 0xFE46).addRange(0xFF61, 0xFF9F).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B120, 0x1B122).addRange(0x1B164, 0x1B167);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Kayah_Li.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA900, 0xA92F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Kharoshthi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A00, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A38, 0x10A3A).addRange(0x10A3F, 0x10A48).addRange(0x10A50, 0x10A58);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Khitan_Small_Script.js", function (module, exports) {
	  const set = regenerate(0x16FE4);
	set.addRange(0x18B00, 0x18CD5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Khmer.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1780, 0x17DD).addRange(0x17E0, 0x17E9).addRange(0x17F0, 0x17F9).addRange(0x19E0, 0x19FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Khojki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAE6, 0xAEF).addRange(0xA830, 0xA839).addRange(0x11200, 0x11211).addRange(0x11213, 0x1123E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Khudawadi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x965).addRange(0xA830, 0xA839).addRange(0x112B0, 0x112EA).addRange(0x112F0, 0x112F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Lao.js", function (module, exports) {
	  const set = regenerate(0xE84, 0xEA5, 0xEC6);
	set.addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEC8, 0xECD).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Latin.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xBA, 0x10FB, 0x202F, 0x2071, 0x207F, 0x20F0, 0x2132, 0x214E, 0xA7D3, 0xA92E);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2B8).addRange(0x2E0, 0x2E4).addRange(0x363, 0x36F).addRange(0x485, 0x486).addRange(0x951, 0x952).addRange(0x1D00, 0x1D25).addRange(0x1D2C, 0x1D5C).addRange(0x1D62, 0x1D65).addRange(0x1D6B, 0x1D77).addRange(0x1D79, 0x1DBE).addRange(0x1E00, 0x1EFF).addRange(0x2090, 0x209C).addRange(0x212A, 0x212B).addRange(0x2160, 0x2188).addRange(0x2C60, 0x2C7F).addRange(0xA700, 0xA707).addRange(0xA722, 0xA787).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA7FF).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB64).addRange(0xAB66, 0xAB69).addRange(0xFB00, 0xFB06).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x1DF00, 0x1DF1E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Lepcha.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1C00, 0x1C37).addRange(0x1C3B, 0x1C49).addRange(0x1C4D, 0x1C4F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Limbu.js", function (module, exports) {
	  const set = regenerate(0x965, 0x1940);
	set.addRange(0x1900, 0x191E).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1944, 0x194F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Linear_A.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10107, 0x10133).addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Linear_B.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA).addRange(0x10100, 0x10102).addRange(0x10107, 0x10133).addRange(0x10137, 0x1013F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Lisu.js", function (module, exports) {
	  const set = regenerate(0x11FB0);
	set.addRange(0xA4D0, 0xA4FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Lycian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10280, 0x1029C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Lydian.js", function (module, exports) {
	  const set = regenerate(0x1093F);
	set.addRange(0x10920, 0x10939);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Mahajani.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x96F).addRange(0xA830, 0xA839).addRange(0x11150, 0x11176);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Makasar.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11EE0, 0x11EF8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Malayalam.js", function (module, exports) {
	  const set = regenerate(0x1CDA);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4F).addRange(0xD54, 0xD63).addRange(0xD66, 0xD7F).addRange(0xA830, 0xA832);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Mandaic.js", function (module, exports) {
	  const set = regenerate(0x640, 0x85E);
	set.addRange(0x840, 0x85B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Manichaean.js", function (module, exports) {
	  const set = regenerate(0x640);
	set.addRange(0x10AC0, 0x10AE6).addRange(0x10AEB, 0x10AF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Marchen.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11C70, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Masaram_Gondi.js", function (module, exports) {
	  const set = regenerate(0x11D3A);
	set.addRange(0x964, 0x965).addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D47).addRange(0x11D50, 0x11D59);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Medefaidrin.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16E40, 0x16E9A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Meetei_Mayek.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAAE0, 0xAAF6).addRange(0xABC0, 0xABED).addRange(0xABF0, 0xABF9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Mende_Kikakui.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E800, 0x1E8C4).addRange(0x1E8C7, 0x1E8D6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Meroitic_Cursive.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x109A0, 0x109B7).addRange(0x109BC, 0x109CF).addRange(0x109D2, 0x109FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Meroitic_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10980, 0x1099F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Miao.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Modi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA830, 0xA839).addRange(0x11600, 0x11644).addRange(0x11650, 0x11659);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Mongolian.js", function (module, exports) {
	  const set = regenerate(0x202F);
	set.addRange(0x1800, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x11660, 0x1166C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Mro.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A6E, 0x16A6F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Multani.js", function (module, exports) {
	  const set = regenerate(0x11288);
	set.addRange(0xA66, 0xA6F).addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Myanmar.js", function (module, exports) {
	  const set = regenerate(0xA92E);
	set.addRange(0x1000, 0x109F).addRange(0xA9E0, 0xA9FE).addRange(0xAA60, 0xAA7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Nabataean.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10880, 0x1089E).addRange(0x108A7, 0x108AF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Nandinagari.js", function (module, exports) {
	  const set = regenerate(0x1CE9, 0x1CF2, 0x1CFA);
	set.addRange(0x964, 0x965).addRange(0xCE6, 0xCEF).addRange(0xA830, 0xA835).addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119E4);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/New_Tai_Lue.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x19DE, 0x19DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Newa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11400, 0x1145B).addRange(0x1145D, 0x11461);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Nko.js", function (module, exports) {
	  const set = regenerate(0x60C, 0x61B, 0x61F);
	set.addRange(0x7C0, 0x7FA).addRange(0x7FD, 0x7FF).addRange(0xFD3E, 0xFD3F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Nushu.js", function (module, exports) {
	  const set = regenerate(0x16FE1);
	set.addRange(0x1B170, 0x1B2FB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Nyiakeng_Puachue_Hmong.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E100, 0x1E12C).addRange(0x1E130, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E14E, 0x1E14F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Ogham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1680, 0x169C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Ol_Chiki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1C50, 0x1C7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Hungarian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10CFA, 0x10CFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Italic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10300, 0x10323).addRange(0x1032D, 0x1032F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_North_Arabian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A80, 0x10A9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Permic.js", function (module, exports) {
	  const set = regenerate(0x483);
	set.addRange(0x10350, 0x1037A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Persian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103D5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Sogdian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10F00, 0x10F27);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_South_Arabian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A60, 0x10A7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Turkic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10C00, 0x10C48);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Old_Uyghur.js", function (module, exports) {
	  const set = regenerate(0x640, 0x10AF2);
	set.addRange(0x10F70, 0x10F89);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Oriya.js", function (module, exports) {
	  const set = regenerate(0x1CDA, 0x1CF2);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3C, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB66, 0xB77);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Osage.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Osmanya.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10480, 0x1049D).addRange(0x104A0, 0x104A9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Pahawh_Hmong.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16B00, 0x16B45).addRange(0x16B50, 0x16B59).addRange(0x16B5B, 0x16B61).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Palmyrene.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10860, 0x1087F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Pau_Cin_Hau.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11AC0, 0x11AF8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Phags_Pa.js", function (module, exports) {
	  const set = regenerate(0x1805);
	set.addRange(0x1802, 0x1803).addRange(0xA840, 0xA877);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Phoenician.js", function (module, exports) {
	  const set = regenerate(0x1091F);
	set.addRange(0x10900, 0x1091B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Psalter_Pahlavi.js", function (module, exports) {
	  const set = regenerate(0x640);
	set.addRange(0x10B80, 0x10B91).addRange(0x10B99, 0x10B9C).addRange(0x10BA9, 0x10BAF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Rejang.js", function (module, exports) {
	  const set = regenerate(0xA95F);
	set.addRange(0xA930, 0xA953);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Runic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Samaritan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x800, 0x82D).addRange(0x830, 0x83E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Saurashtra.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA880, 0xA8C5).addRange(0xA8CE, 0xA8D9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Sharada.js", function (module, exports) {
	  const set = regenerate(0x951, 0x1CD7, 0x1CD9, 0x1CE0);
	set.addRange(0x1CDC, 0x1CDD).addRange(0x11180, 0x111DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Shavian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10450, 0x1047F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Siddham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115DD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/SignWriting.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1D800, 0x1DA8B).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Sinhala.js", function (module, exports) {
	  const set = regenerate(0xDBD, 0xDCA, 0xDD6);
	set.addRange(0x964, 0x965).addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF4).addRange(0x111E1, 0x111F4);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Sogdian.js", function (module, exports) {
	  const set = regenerate(0x640);
	set.addRange(0x10F30, 0x10F59);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Sora_Sompeng.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Soyombo.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11A50, 0x11AA2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Sundanese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1B80, 0x1BBF).addRange(0x1CC0, 0x1CC7);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Syloti_Nagri.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x965).addRange(0x9E6, 0x9EF).addRange(0xA800, 0xA82C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Syriac.js", function (module, exports) {
	  const set = regenerate(0x60C, 0x61F, 0x640, 0x670, 0x1DF8, 0x1DFA);
	set.addRange(0x61B, 0x61C).addRange(0x64B, 0x655).addRange(0x700, 0x70D).addRange(0x70F, 0x74A).addRange(0x74D, 0x74F).addRange(0x860, 0x86A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tagalog.js", function (module, exports) {
	  const set = regenerate(0x171F);
	set.addRange(0x1700, 0x1715).addRange(0x1735, 0x1736);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tagbanwa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1735, 0x1736).addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tai_Le.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1040, 0x1049).addRange(0x1950, 0x196D).addRange(0x1970, 0x1974);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tai_Tham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1A20, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1A7F, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AA0, 0x1AAD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tai_Viet.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAA80, 0xAAC2).addRange(0xAADB, 0xAADF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Takri.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x964, 0x965).addRange(0xA830, 0xA839).addRange(0x11680, 0x116B9).addRange(0x116C0, 0x116C9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tamil.js", function (module, exports) {
	  const set = regenerate(0xB9C, 0xBD0, 0xBD7, 0x1CDA, 0xA8F3, 0x11301, 0x11303, 0x11FFF);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD).addRange(0xBE6, 0xBFA).addRange(0x1133B, 0x1133C).addRange(0x11FC0, 0x11FF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tangsa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A70, 0x16ABE).addRange(0x16AC0, 0x16AC9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tangut.js", function (module, exports) {
	  const set = regenerate(0x16FE0);
	set.addRange(0x17000, 0x187F7).addRange(0x18800, 0x18AFF).addRange(0x18D00, 0x18D08);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Telugu.js", function (module, exports) {
	  const set = regenerate(0xC5D, 0x1CDA, 0x1CF2);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xC00, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3C, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC66, 0xC6F).addRange(0xC77, 0xC7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Thaana.js", function (module, exports) {
	  const set = regenerate(0x60C, 0x61F, 0xFDF2, 0xFDFD);
	set.addRange(0x61B, 0x61C).addRange(0x660, 0x669).addRange(0x780, 0x7B1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Thai.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xE01, 0xE3A).addRange(0xE40, 0xE5B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tibetan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xF00, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF97).addRange(0xF99, 0xFBC).addRange(0xFBE, 0xFCC).addRange(0xFCE, 0xFD4).addRange(0xFD9, 0xFDA);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tifinagh.js", function (module, exports) {
	  const set = regenerate(0x2D7F);
	set.addRange(0x2D30, 0x2D67).addRange(0x2D6F, 0x2D70);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Tirhuta.js", function (module, exports) {
	  const set = regenerate(0x1CF2);
	set.addRange(0x951, 0x952).addRange(0x964, 0x965).addRange(0xA830, 0xA839).addRange(0x11480, 0x114C7).addRange(0x114D0, 0x114D9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Toto.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E290, 0x1E2AE);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Ugaritic.js", function (module, exports) {
	  const set = regenerate(0x1039F);
	set.addRange(0x10380, 0x1039D);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Vai.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA500, 0xA62B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Vithkuqi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Wancho.js", function (module, exports) {
	  const set = regenerate(0x1E2FF);
	set.addRange(0x1E2C0, 0x1E2F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Warang_Citi.js", function (module, exports) {
	  const set = regenerate(0x118FF);
	set.addRange(0x118A0, 0x118F2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Yezidi.js", function (module, exports) {
	  const set = regenerate(0x60C, 0x61B, 0x61F);
	set.addRange(0x660, 0x669).addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAD).addRange(0x10EB0, 0x10EB1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Yi.js", function (module, exports) {
	  const set = regenerate(0x30FB);
	set.addRange(0x3001, 0x3002).addRange(0x3008, 0x3011).addRange(0x3014, 0x301B).addRange(0xA000, 0xA48C).addRange(0xA490, 0xA4C6).addRange(0xFF61, 0xFF65);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script_Extensions/Zanabazar_Square.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11A00, 0x11A47);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Adlam.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E900, 0x1E94B).addRange(0x1E950, 0x1E959).addRange(0x1E95E, 0x1E95F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Ahom.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11700, 0x1171A).addRange(0x1171D, 0x1172B).addRange(0x11730, 0x11746);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Anatolian_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x14400, 0x14646);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Arabic.js", function (module, exports) {
	  const set = regenerate(0xFDCF, 0x1EE24, 0x1EE27, 0x1EE39, 0x1EE3B, 0x1EE42, 0x1EE47, 0x1EE49, 0x1EE4B, 0x1EE54, 0x1EE57, 0x1EE59, 0x1EE5B, 0x1EE5D, 0x1EE5F, 0x1EE64, 0x1EE7E);
	set.addRange(0x600, 0x604).addRange(0x606, 0x60B).addRange(0x60D, 0x61A).addRange(0x61C, 0x61E).addRange(0x620, 0x63F).addRange(0x641, 0x64A).addRange(0x656, 0x66F).addRange(0x671, 0x6DC).addRange(0x6DE, 0x6FF).addRange(0x750, 0x77F).addRange(0x870, 0x88E).addRange(0x890, 0x891).addRange(0x898, 0x8E1).addRange(0x8E3, 0x8FF).addRange(0xFB50, 0xFBC2).addRange(0xFBD3, 0xFD3D).addRange(0xFD40, 0xFD8F).addRange(0xFD92, 0xFDC7).addRange(0xFDF0, 0xFDFF).addRange(0xFE70, 0xFE74).addRange(0xFE76, 0xFEFC).addRange(0x10E60, 0x10E7E).addRange(0x1EE00, 0x1EE03).addRange(0x1EE05, 0x1EE1F).addRange(0x1EE21, 0x1EE22).addRange(0x1EE29, 0x1EE32).addRange(0x1EE34, 0x1EE37).addRange(0x1EE4D, 0x1EE4F).addRange(0x1EE51, 0x1EE52).addRange(0x1EE61, 0x1EE62).addRange(0x1EE67, 0x1EE6A).addRange(0x1EE6C, 0x1EE72).addRange(0x1EE74, 0x1EE77).addRange(0x1EE79, 0x1EE7C).addRange(0x1EE80, 0x1EE89).addRange(0x1EE8B, 0x1EE9B).addRange(0x1EEA1, 0x1EEA3).addRange(0x1EEA5, 0x1EEA9).addRange(0x1EEAB, 0x1EEBB).addRange(0x1EEF0, 0x1EEF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Armenian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x531, 0x556).addRange(0x559, 0x58A).addRange(0x58D, 0x58F).addRange(0xFB13, 0xFB17);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Avestan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B00, 0x10B35).addRange(0x10B39, 0x10B3F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Balinese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1B00, 0x1B4C).addRange(0x1B50, 0x1B7E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Bamum.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA6A0, 0xA6F7).addRange(0x16800, 0x16A38);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Bassa_Vah.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16AD0, 0x16AED).addRange(0x16AF0, 0x16AF5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Batak.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1BC0, 0x1BF3).addRange(0x1BFC, 0x1BFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Bengali.js", function (module, exports) {
	  const set = regenerate(0x9B2, 0x9D7);
	set.addRange(0x980, 0x983).addRange(0x985, 0x98C).addRange(0x98F, 0x990).addRange(0x993, 0x9A8).addRange(0x9AA, 0x9B0).addRange(0x9B6, 0x9B9).addRange(0x9BC, 0x9C4).addRange(0x9C7, 0x9C8).addRange(0x9CB, 0x9CE).addRange(0x9DC, 0x9DD).addRange(0x9DF, 0x9E3).addRange(0x9E6, 0x9FE);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Bhaiksuki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11C00, 0x11C08).addRange(0x11C0A, 0x11C36).addRange(0x11C38, 0x11C45).addRange(0x11C50, 0x11C6C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Bopomofo.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2EA, 0x2EB).addRange(0x3105, 0x312F).addRange(0x31A0, 0x31BF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Brahmi.js", function (module, exports) {
	  const set = regenerate(0x1107F);
	set.addRange(0x11000, 0x1104D).addRange(0x11052, 0x11075);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Braille.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2800, 0x28FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Buginese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1A00, 0x1A1B).addRange(0x1A1E, 0x1A1F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Buhid.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1740, 0x1753);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Canadian_Aboriginal.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1400, 0x167F).addRange(0x18B0, 0x18F5).addRange(0x11AB0, 0x11ABF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Carian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x102A0, 0x102D0);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Caucasian_Albanian.js", function (module, exports) {
	  const set = regenerate(0x1056F);
	set.addRange(0x10530, 0x10563);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Chakma.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11100, 0x11134).addRange(0x11136, 0x11147);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAA00, 0xAA36).addRange(0xAA40, 0xAA4D).addRange(0xAA50, 0xAA59).addRange(0xAA5C, 0xAA5F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cherokee.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x13A0, 0x13F5).addRange(0x13F8, 0x13FD).addRange(0xAB70, 0xABBF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Chorasmian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10FB0, 0x10FCB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Common.js", function (module, exports) {
	  const set = regenerate(0xD7, 0xF7, 0x374, 0x37E, 0x385, 0x387, 0x605, 0x60C, 0x61B, 0x61F, 0x640, 0x6DD, 0x8E2, 0xE3F, 0x10FB, 0x1805, 0x1CD3, 0x1CE1, 0x1CFA, 0x3006, 0x30A0, 0x32FF, 0xA92E, 0xA9CF, 0xAB5B, 0xFEFF, 0xFF70, 0x1D4A2, 0x1D4BB, 0x1D546, 0x1F7F0, 0xE0001);
	set.addRange(0x0, 0x40).addRange(0x5B, 0x60).addRange(0x7B, 0xA9).addRange(0xAB, 0xB9).addRange(0xBB, 0xBF).addRange(0x2B9, 0x2DF).addRange(0x2E5, 0x2E9).addRange(0x2EC, 0x2FF).addRange(0x964, 0x965).addRange(0xFD5, 0xFD8).addRange(0x16EB, 0x16ED).addRange(0x1735, 0x1736).addRange(0x1802, 0x1803).addRange(0x1CE9, 0x1CEC).addRange(0x1CEE, 0x1CF3).addRange(0x1CF5, 0x1CF7).addRange(0x2000, 0x200B).addRange(0x200E, 0x2064).addRange(0x2066, 0x2070).addRange(0x2074, 0x207E).addRange(0x2080, 0x208E).addRange(0x20A0, 0x20C0).addRange(0x2100, 0x2125).addRange(0x2127, 0x2129).addRange(0x212C, 0x2131).addRange(0x2133, 0x214D).addRange(0x214F, 0x215F).addRange(0x2189, 0x218B).addRange(0x2190, 0x2426).addRange(0x2440, 0x244A).addRange(0x2460, 0x27FF).addRange(0x2900, 0x2B73).addRange(0x2B76, 0x2B95).addRange(0x2B97, 0x2BFF).addRange(0x2E00, 0x2E5D).addRange(0x2FF0, 0x2FFB).addRange(0x3000, 0x3004).addRange(0x3008, 0x3020).addRange(0x3030, 0x3037).addRange(0x303C, 0x303F).addRange(0x309B, 0x309C).addRange(0x30FB, 0x30FC).addRange(0x3190, 0x319F).addRange(0x31C0, 0x31E3).addRange(0x3220, 0x325F).addRange(0x327F, 0x32CF).addRange(0x3358, 0x33FF).addRange(0x4DC0, 0x4DFF).addRange(0xA700, 0xA721).addRange(0xA788, 0xA78A).addRange(0xA830, 0xA839);
	set.addRange(0xAB6A, 0xAB6B).addRange(0xFD3E, 0xFD3F).addRange(0xFE10, 0xFE19).addRange(0xFE30, 0xFE52).addRange(0xFE54, 0xFE66).addRange(0xFE68, 0xFE6B).addRange(0xFF01, 0xFF20).addRange(0xFF3B, 0xFF40).addRange(0xFF5B, 0xFF65).addRange(0xFF9E, 0xFF9F).addRange(0xFFE0, 0xFFE6).addRange(0xFFE8, 0xFFEE).addRange(0xFFF9, 0xFFFD).addRange(0x10100, 0x10102).addRange(0x10107, 0x10133).addRange(0x10137, 0x1013F).addRange(0x10190, 0x1019C).addRange(0x101D0, 0x101FC).addRange(0x102E1, 0x102FB).addRange(0x1BCA0, 0x1BCA3).addRange(0x1CF50, 0x1CFC3).addRange(0x1D000, 0x1D0F5).addRange(0x1D100, 0x1D126).addRange(0x1D129, 0x1D166).addRange(0x1D16A, 0x1D17A).addRange(0x1D183, 0x1D184).addRange(0x1D18C, 0x1D1A9).addRange(0x1D1AE, 0x1D1EA).addRange(0x1D2E0, 0x1D2F3).addRange(0x1D300, 0x1D356).addRange(0x1D360, 0x1D378).addRange(0x1D400, 0x1D454).addRange(0x1D456, 0x1D49C).addRange(0x1D49E, 0x1D49F).addRange(0x1D4A5, 0x1D4A6).addRange(0x1D4A9, 0x1D4AC).addRange(0x1D4AE, 0x1D4B9).addRange(0x1D4BD, 0x1D4C3).addRange(0x1D4C5, 0x1D505).addRange(0x1D507, 0x1D50A).addRange(0x1D50D, 0x1D514).addRange(0x1D516, 0x1D51C).addRange(0x1D51E, 0x1D539).addRange(0x1D53B, 0x1D53E).addRange(0x1D540, 0x1D544).addRange(0x1D54A, 0x1D550).addRange(0x1D552, 0x1D6A5).addRange(0x1D6A8, 0x1D7CB).addRange(0x1D7CE, 0x1D7FF).addRange(0x1EC71, 0x1ECB4).addRange(0x1ED01, 0x1ED3D);
	set.addRange(0x1F000, 0x1F02B).addRange(0x1F030, 0x1F093).addRange(0x1F0A0, 0x1F0AE).addRange(0x1F0B1, 0x1F0BF).addRange(0x1F0C1, 0x1F0CF).addRange(0x1F0D1, 0x1F0F5).addRange(0x1F100, 0x1F1AD).addRange(0x1F1E6, 0x1F1FF).addRange(0x1F201, 0x1F202).addRange(0x1F210, 0x1F23B).addRange(0x1F240, 0x1F248).addRange(0x1F250, 0x1F251).addRange(0x1F260, 0x1F265).addRange(0x1F300, 0x1F6D7).addRange(0x1F6DD, 0x1F6EC).addRange(0x1F6F0, 0x1F6FC).addRange(0x1F700, 0x1F773).addRange(0x1F780, 0x1F7D8).addRange(0x1F7E0, 0x1F7EB).addRange(0x1F800, 0x1F80B).addRange(0x1F810, 0x1F847).addRange(0x1F850, 0x1F859).addRange(0x1F860, 0x1F887).addRange(0x1F890, 0x1F8AD).addRange(0x1F8B0, 0x1F8B1).addRange(0x1F900, 0x1FA53).addRange(0x1FA60, 0x1FA6D).addRange(0x1FA70, 0x1FA74).addRange(0x1FA78, 0x1FA7C).addRange(0x1FA80, 0x1FA86).addRange(0x1FA90, 0x1FAAC).addRange(0x1FAB0, 0x1FABA).addRange(0x1FAC0, 0x1FAC5).addRange(0x1FAD0, 0x1FAD9).addRange(0x1FAE0, 0x1FAE7).addRange(0x1FAF0, 0x1FAF6).addRange(0x1FB00, 0x1FB92).addRange(0x1FB94, 0x1FBCA).addRange(0x1FBF0, 0x1FBF9).addRange(0xE0020, 0xE007F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Coptic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x3E2, 0x3EF).addRange(0x2C80, 0x2CF3).addRange(0x2CF9, 0x2CFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cuneiform.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x12000, 0x12399).addRange(0x12400, 0x1246E).addRange(0x12470, 0x12474).addRange(0x12480, 0x12543);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cypriot.js", function (module, exports) {
	  const set = regenerate(0x10808, 0x1083C, 0x1083F);
	set.addRange(0x10800, 0x10805).addRange(0x1080A, 0x10835).addRange(0x10837, 0x10838);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cypro_Minoan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x12F90, 0x12FF2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Cyrillic.js", function (module, exports) {
	  const set = regenerate(0x1D2B, 0x1D78);
	set.addRange(0x400, 0x484).addRange(0x487, 0x52F).addRange(0x1C80, 0x1C88).addRange(0x2DE0, 0x2DFF).addRange(0xA640, 0xA69F).addRange(0xFE2E, 0xFE2F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Deseret.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10400, 0x1044F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Devanagari.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x900, 0x950).addRange(0x955, 0x963).addRange(0x966, 0x97F).addRange(0xA8E0, 0xA8FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Dives_Akuru.js", function (module, exports) {
	  const set = regenerate(0x11909);
	set.addRange(0x11900, 0x11906).addRange(0x1190C, 0x11913).addRange(0x11915, 0x11916).addRange(0x11918, 0x11935).addRange(0x11937, 0x11938).addRange(0x1193B, 0x11946).addRange(0x11950, 0x11959);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Dogra.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11800, 0x1183B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Duployan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1BC00, 0x1BC6A).addRange(0x1BC70, 0x1BC7C).addRange(0x1BC80, 0x1BC88).addRange(0x1BC90, 0x1BC99).addRange(0x1BC9C, 0x1BC9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Egyptian_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x13000, 0x1342E).addRange(0x13430, 0x13438);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Elbasan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10500, 0x10527);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Elymaic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10FE0, 0x10FF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Ethiopic.js", function (module, exports) {
	  const set = regenerate(0x1258, 0x12C0);
	set.addRange(0x1200, 0x1248).addRange(0x124A, 0x124D).addRange(0x1250, 0x1256).addRange(0x125A, 0x125D).addRange(0x1260, 0x1288).addRange(0x128A, 0x128D).addRange(0x1290, 0x12B0).addRange(0x12B2, 0x12B5).addRange(0x12B8, 0x12BE).addRange(0x12C2, 0x12C5).addRange(0x12C8, 0x12D6).addRange(0x12D8, 0x1310).addRange(0x1312, 0x1315).addRange(0x1318, 0x135A).addRange(0x135D, 0x137C).addRange(0x1380, 0x1399).addRange(0x2D80, 0x2D96).addRange(0x2DA0, 0x2DA6).addRange(0x2DA8, 0x2DAE).addRange(0x2DB0, 0x2DB6).addRange(0x2DB8, 0x2DBE).addRange(0x2DC0, 0x2DC6).addRange(0x2DC8, 0x2DCE).addRange(0x2DD0, 0x2DD6).addRange(0x2DD8, 0x2DDE).addRange(0xAB01, 0xAB06).addRange(0xAB09, 0xAB0E).addRange(0xAB11, 0xAB16).addRange(0xAB20, 0xAB26).addRange(0xAB28, 0xAB2E).addRange(0x1E7E0, 0x1E7E6).addRange(0x1E7E8, 0x1E7EB).addRange(0x1E7ED, 0x1E7EE).addRange(0x1E7F0, 0x1E7FE);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Georgian.js", function (module, exports) {
	  const set = regenerate(0x10C7, 0x10CD, 0x2D27, 0x2D2D);
	set.addRange(0x10A0, 0x10C5).addRange(0x10D0, 0x10FA).addRange(0x10FC, 0x10FF).addRange(0x1C90, 0x1CBA).addRange(0x1CBD, 0x1CBF).addRange(0x2D00, 0x2D25);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Glagolitic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x2C00, 0x2C5F).addRange(0x1E000, 0x1E006).addRange(0x1E008, 0x1E018).addRange(0x1E01B, 0x1E021).addRange(0x1E023, 0x1E024).addRange(0x1E026, 0x1E02A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Gothic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10330, 0x1034A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Grantha.js", function (module, exports) {
	  const set = regenerate(0x11350, 0x11357);
	set.addRange(0x11300, 0x11303).addRange(0x11305, 0x1130C).addRange(0x1130F, 0x11310).addRange(0x11313, 0x11328).addRange(0x1132A, 0x11330).addRange(0x11332, 0x11333).addRange(0x11335, 0x11339).addRange(0x1133C, 0x11344).addRange(0x11347, 0x11348).addRange(0x1134B, 0x1134D).addRange(0x1135D, 0x11363).addRange(0x11366, 0x1136C).addRange(0x11370, 0x11374);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Greek.js", function (module, exports) {
	  const set = regenerate(0x37F, 0x384, 0x386, 0x38C, 0x1DBF, 0x1F59, 0x1F5B, 0x1F5D, 0x2126, 0xAB65, 0x101A0);
	set.addRange(0x370, 0x373).addRange(0x375, 0x377).addRange(0x37A, 0x37D).addRange(0x388, 0x38A).addRange(0x38E, 0x3A1).addRange(0x3A3, 0x3E1).addRange(0x3F0, 0x3FF).addRange(0x1D26, 0x1D2A).addRange(0x1D5D, 0x1D61).addRange(0x1D66, 0x1D6A).addRange(0x1F00, 0x1F15).addRange(0x1F18, 0x1F1D).addRange(0x1F20, 0x1F45).addRange(0x1F48, 0x1F4D).addRange(0x1F50, 0x1F57).addRange(0x1F5F, 0x1F7D).addRange(0x1F80, 0x1FB4).addRange(0x1FB6, 0x1FC4).addRange(0x1FC6, 0x1FD3).addRange(0x1FD6, 0x1FDB).addRange(0x1FDD, 0x1FEF).addRange(0x1FF2, 0x1FF4).addRange(0x1FF6, 0x1FFE).addRange(0x10140, 0x1018E).addRange(0x1D200, 0x1D245);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Gujarati.js", function (module, exports) {
	  const set = regenerate(0xAD0);
	set.addRange(0xA81, 0xA83).addRange(0xA85, 0xA8D).addRange(0xA8F, 0xA91).addRange(0xA93, 0xAA8).addRange(0xAAA, 0xAB0).addRange(0xAB2, 0xAB3).addRange(0xAB5, 0xAB9).addRange(0xABC, 0xAC5).addRange(0xAC7, 0xAC9).addRange(0xACB, 0xACD).addRange(0xAE0, 0xAE3).addRange(0xAE6, 0xAF1).addRange(0xAF9, 0xAFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Gunjala_Gondi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11D60, 0x11D65).addRange(0x11D67, 0x11D68).addRange(0x11D6A, 0x11D8E).addRange(0x11D90, 0x11D91).addRange(0x11D93, 0x11D98).addRange(0x11DA0, 0x11DA9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Gurmukhi.js", function (module, exports) {
	  const set = regenerate(0xA3C, 0xA51, 0xA5E);
	set.addRange(0xA01, 0xA03).addRange(0xA05, 0xA0A).addRange(0xA0F, 0xA10).addRange(0xA13, 0xA28).addRange(0xA2A, 0xA30).addRange(0xA32, 0xA33).addRange(0xA35, 0xA36).addRange(0xA38, 0xA39).addRange(0xA3E, 0xA42).addRange(0xA47, 0xA48).addRange(0xA4B, 0xA4D).addRange(0xA59, 0xA5C).addRange(0xA66, 0xA76);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Han.js", function (module, exports) {
	  const set = regenerate(0x3005, 0x3007);
	set.addRange(0x2E80, 0x2E99).addRange(0x2E9B, 0x2EF3).addRange(0x2F00, 0x2FD5).addRange(0x3021, 0x3029).addRange(0x3038, 0x303B).addRange(0x3400, 0x4DBF).addRange(0x4E00, 0x9FFF).addRange(0xF900, 0xFA6D).addRange(0xFA70, 0xFAD9).addRange(0x16FE2, 0x16FE3).addRange(0x16FF0, 0x16FF1).addRange(0x20000, 0x2A6DF).addRange(0x2A700, 0x2B738).addRange(0x2B740, 0x2B81D).addRange(0x2B820, 0x2CEA1).addRange(0x2CEB0, 0x2EBE0).addRange(0x2F800, 0x2FA1D).addRange(0x30000, 0x3134A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hangul.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1100, 0x11FF).addRange(0x302E, 0x302F).addRange(0x3131, 0x318E).addRange(0x3200, 0x321E).addRange(0x3260, 0x327E).addRange(0xA960, 0xA97C).addRange(0xAC00, 0xD7A3).addRange(0xD7B0, 0xD7C6).addRange(0xD7CB, 0xD7FB).addRange(0xFFA0, 0xFFBE).addRange(0xFFC2, 0xFFC7).addRange(0xFFCA, 0xFFCF).addRange(0xFFD2, 0xFFD7).addRange(0xFFDA, 0xFFDC);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hanifi_Rohingya.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10D00, 0x10D27).addRange(0x10D30, 0x10D39);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hanunoo.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1720, 0x1734);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hatran.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x108E0, 0x108F2).addRange(0x108F4, 0x108F5).addRange(0x108FB, 0x108FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hebrew.js", function (module, exports) {
	  const set = regenerate(0xFB3E);
	set.addRange(0x591, 0x5C7).addRange(0x5D0, 0x5EA).addRange(0x5EF, 0x5F4).addRange(0xFB1D, 0xFB36).addRange(0xFB38, 0xFB3C).addRange(0xFB40, 0xFB41).addRange(0xFB43, 0xFB44).addRange(0xFB46, 0xFB4F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Hiragana.js", function (module, exports) {
	  const set = regenerate(0x1F200);
	set.addRange(0x3041, 0x3096).addRange(0x309D, 0x309F).addRange(0x1B001, 0x1B11F).addRange(0x1B150, 0x1B152);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Imperial_Aramaic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10840, 0x10855).addRange(0x10857, 0x1085F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Inherited.js", function (module, exports) {
	  const set = regenerate(0x670, 0x1CED, 0x1CF4, 0x101FD, 0x102E0, 0x1133B);
	set.addRange(0x300, 0x36F).addRange(0x485, 0x486).addRange(0x64B, 0x655).addRange(0x951, 0x954).addRange(0x1AB0, 0x1ACE).addRange(0x1CD0, 0x1CD2).addRange(0x1CD4, 0x1CE0).addRange(0x1CE2, 0x1CE8).addRange(0x1CF8, 0x1CF9).addRange(0x1DC0, 0x1DFF).addRange(0x200C, 0x200D).addRange(0x20D0, 0x20F0).addRange(0x302A, 0x302D).addRange(0x3099, 0x309A).addRange(0xFE00, 0xFE0F).addRange(0xFE20, 0xFE2D).addRange(0x1CF00, 0x1CF2D).addRange(0x1CF30, 0x1CF46).addRange(0x1D167, 0x1D169).addRange(0x1D17B, 0x1D182).addRange(0x1D185, 0x1D18B).addRange(0x1D1AA, 0x1D1AD).addRange(0xE0100, 0xE01EF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Inscriptional_Pahlavi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B60, 0x10B72).addRange(0x10B78, 0x10B7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Inscriptional_Parthian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B40, 0x10B55).addRange(0x10B58, 0x10B5F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Javanese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA980, 0xA9CD).addRange(0xA9D0, 0xA9D9).addRange(0xA9DE, 0xA9DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Kaithi.js", function (module, exports) {
	  const set = regenerate(0x110CD);
	set.addRange(0x11080, 0x110C2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Kannada.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xC80, 0xC8C).addRange(0xC8E, 0xC90).addRange(0xC92, 0xCA8).addRange(0xCAA, 0xCB3).addRange(0xCB5, 0xCB9).addRange(0xCBC, 0xCC4).addRange(0xCC6, 0xCC8).addRange(0xCCA, 0xCCD).addRange(0xCD5, 0xCD6).addRange(0xCDD, 0xCDE).addRange(0xCE0, 0xCE3).addRange(0xCE6, 0xCEF).addRange(0xCF1, 0xCF2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Katakana.js", function (module, exports) {
	  const set = regenerate(0x1B000);
	set.addRange(0x30A1, 0x30FA).addRange(0x30FD, 0x30FF).addRange(0x31F0, 0x31FF).addRange(0x32D0, 0x32FE).addRange(0x3300, 0x3357).addRange(0xFF66, 0xFF6F).addRange(0xFF71, 0xFF9D).addRange(0x1AFF0, 0x1AFF3).addRange(0x1AFF5, 0x1AFFB).addRange(0x1AFFD, 0x1AFFE).addRange(0x1B120, 0x1B122).addRange(0x1B164, 0x1B167);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Kayah_Li.js", function (module, exports) {
	  const set = regenerate(0xA92F);
	set.addRange(0xA900, 0xA92D);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Kharoshthi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A00, 0x10A03).addRange(0x10A05, 0x10A06).addRange(0x10A0C, 0x10A13).addRange(0x10A15, 0x10A17).addRange(0x10A19, 0x10A35).addRange(0x10A38, 0x10A3A).addRange(0x10A3F, 0x10A48).addRange(0x10A50, 0x10A58);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Khitan_Small_Script.js", function (module, exports) {
	  const set = regenerate(0x16FE4);
	set.addRange(0x18B00, 0x18CD5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Khmer.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1780, 0x17DD).addRange(0x17E0, 0x17E9).addRange(0x17F0, 0x17F9).addRange(0x19E0, 0x19FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Khojki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11200, 0x11211).addRange(0x11213, 0x1123E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Khudawadi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x112B0, 0x112EA).addRange(0x112F0, 0x112F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Lao.js", function (module, exports) {
	  const set = regenerate(0xE84, 0xEA5, 0xEC6);
	set.addRange(0xE81, 0xE82).addRange(0xE86, 0xE8A).addRange(0xE8C, 0xEA3).addRange(0xEA7, 0xEBD).addRange(0xEC0, 0xEC4).addRange(0xEC8, 0xECD).addRange(0xED0, 0xED9).addRange(0xEDC, 0xEDF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Latin.js", function (module, exports) {
	  const set = regenerate(0xAA, 0xBA, 0x2071, 0x207F, 0x2132, 0x214E, 0xA7D3);
	set.addRange(0x41, 0x5A).addRange(0x61, 0x7A).addRange(0xC0, 0xD6).addRange(0xD8, 0xF6).addRange(0xF8, 0x2B8).addRange(0x2E0, 0x2E4).addRange(0x1D00, 0x1D25).addRange(0x1D2C, 0x1D5C).addRange(0x1D62, 0x1D65).addRange(0x1D6B, 0x1D77).addRange(0x1D79, 0x1DBE).addRange(0x1E00, 0x1EFF).addRange(0x2090, 0x209C).addRange(0x212A, 0x212B).addRange(0x2160, 0x2188).addRange(0x2C60, 0x2C7F).addRange(0xA722, 0xA787).addRange(0xA78B, 0xA7CA).addRange(0xA7D0, 0xA7D1).addRange(0xA7D5, 0xA7D9).addRange(0xA7F2, 0xA7FF).addRange(0xAB30, 0xAB5A).addRange(0xAB5C, 0xAB64).addRange(0xAB66, 0xAB69).addRange(0xFB00, 0xFB06).addRange(0xFF21, 0xFF3A).addRange(0xFF41, 0xFF5A).addRange(0x10780, 0x10785).addRange(0x10787, 0x107B0).addRange(0x107B2, 0x107BA).addRange(0x1DF00, 0x1DF1E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Lepcha.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1C00, 0x1C37).addRange(0x1C3B, 0x1C49).addRange(0x1C4D, 0x1C4F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Limbu.js", function (module, exports) {
	  const set = regenerate(0x1940);
	set.addRange(0x1900, 0x191E).addRange(0x1920, 0x192B).addRange(0x1930, 0x193B).addRange(0x1944, 0x194F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Linear_A.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10600, 0x10736).addRange(0x10740, 0x10755).addRange(0x10760, 0x10767);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Linear_B.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10000, 0x1000B).addRange(0x1000D, 0x10026).addRange(0x10028, 0x1003A).addRange(0x1003C, 0x1003D).addRange(0x1003F, 0x1004D).addRange(0x10050, 0x1005D).addRange(0x10080, 0x100FA);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Lisu.js", function (module, exports) {
	  const set = regenerate(0x11FB0);
	set.addRange(0xA4D0, 0xA4FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Lycian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10280, 0x1029C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Lydian.js", function (module, exports) {
	  const set = regenerate(0x1093F);
	set.addRange(0x10920, 0x10939);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Mahajani.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11150, 0x11176);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Makasar.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11EE0, 0x11EF8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Malayalam.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xD00, 0xD0C).addRange(0xD0E, 0xD10).addRange(0xD12, 0xD44).addRange(0xD46, 0xD48).addRange(0xD4A, 0xD4F).addRange(0xD54, 0xD63).addRange(0xD66, 0xD7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Mandaic.js", function (module, exports) {
	  const set = regenerate(0x85E);
	set.addRange(0x840, 0x85B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Manichaean.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10AC0, 0x10AE6).addRange(0x10AEB, 0x10AF6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Marchen.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11C70, 0x11C8F).addRange(0x11C92, 0x11CA7).addRange(0x11CA9, 0x11CB6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Masaram_Gondi.js", function (module, exports) {
	  const set = regenerate(0x11D3A);
	set.addRange(0x11D00, 0x11D06).addRange(0x11D08, 0x11D09).addRange(0x11D0B, 0x11D36).addRange(0x11D3C, 0x11D3D).addRange(0x11D3F, 0x11D47).addRange(0x11D50, 0x11D59);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Medefaidrin.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16E40, 0x16E9A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Meetei_Mayek.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAAE0, 0xAAF6).addRange(0xABC0, 0xABED).addRange(0xABF0, 0xABF9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Mende_Kikakui.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E800, 0x1E8C4).addRange(0x1E8C7, 0x1E8D6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Meroitic_Cursive.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x109A0, 0x109B7).addRange(0x109BC, 0x109CF).addRange(0x109D2, 0x109FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Meroitic_Hieroglyphs.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10980, 0x1099F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Miao.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16F00, 0x16F4A).addRange(0x16F4F, 0x16F87).addRange(0x16F8F, 0x16F9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Modi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11600, 0x11644).addRange(0x11650, 0x11659);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Mongolian.js", function (module, exports) {
	  const set = regenerate(0x1804);
	set.addRange(0x1800, 0x1801).addRange(0x1806, 0x1819).addRange(0x1820, 0x1878).addRange(0x1880, 0x18AA).addRange(0x11660, 0x1166C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Mro.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A40, 0x16A5E).addRange(0x16A60, 0x16A69).addRange(0x16A6E, 0x16A6F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Multani.js", function (module, exports) {
	  const set = regenerate(0x11288);
	set.addRange(0x11280, 0x11286).addRange(0x1128A, 0x1128D).addRange(0x1128F, 0x1129D).addRange(0x1129F, 0x112A9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Myanmar.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1000, 0x109F).addRange(0xA9E0, 0xA9FE).addRange(0xAA60, 0xAA7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Nabataean.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10880, 0x1089E).addRange(0x108A7, 0x108AF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Nandinagari.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x119A0, 0x119A7).addRange(0x119AA, 0x119D7).addRange(0x119DA, 0x119E4);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/New_Tai_Lue.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1980, 0x19AB).addRange(0x19B0, 0x19C9).addRange(0x19D0, 0x19DA).addRange(0x19DE, 0x19DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Newa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11400, 0x1145B).addRange(0x1145D, 0x11461);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Nko.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x7C0, 0x7FA).addRange(0x7FD, 0x7FF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Nushu.js", function (module, exports) {
	  const set = regenerate(0x16FE1);
	set.addRange(0x1B170, 0x1B2FB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Nyiakeng_Puachue_Hmong.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E100, 0x1E12C).addRange(0x1E130, 0x1E13D).addRange(0x1E140, 0x1E149).addRange(0x1E14E, 0x1E14F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Ogham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1680, 0x169C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Ol_Chiki.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1C50, 0x1C7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Hungarian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10C80, 0x10CB2).addRange(0x10CC0, 0x10CF2).addRange(0x10CFA, 0x10CFF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Italic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10300, 0x10323).addRange(0x1032D, 0x1032F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_North_Arabian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A80, 0x10A9F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Permic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10350, 0x1037A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Persian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x103A0, 0x103C3).addRange(0x103C8, 0x103D5);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Sogdian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10F00, 0x10F27);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_South_Arabian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10A60, 0x10A7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Turkic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10C00, 0x10C48);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Old_Uyghur.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10F70, 0x10F89);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Oriya.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xB01, 0xB03).addRange(0xB05, 0xB0C).addRange(0xB0F, 0xB10).addRange(0xB13, 0xB28).addRange(0xB2A, 0xB30).addRange(0xB32, 0xB33).addRange(0xB35, 0xB39).addRange(0xB3C, 0xB44).addRange(0xB47, 0xB48).addRange(0xB4B, 0xB4D).addRange(0xB55, 0xB57).addRange(0xB5C, 0xB5D).addRange(0xB5F, 0xB63).addRange(0xB66, 0xB77);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Osage.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x104B0, 0x104D3).addRange(0x104D8, 0x104FB);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Osmanya.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10480, 0x1049D).addRange(0x104A0, 0x104A9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Pahawh_Hmong.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16B00, 0x16B45).addRange(0x16B50, 0x16B59).addRange(0x16B5B, 0x16B61).addRange(0x16B63, 0x16B77).addRange(0x16B7D, 0x16B8F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Palmyrene.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10860, 0x1087F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Pau_Cin_Hau.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11AC0, 0x11AF8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Phags_Pa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA840, 0xA877);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Phoenician.js", function (module, exports) {
	  const set = regenerate(0x1091F);
	set.addRange(0x10900, 0x1091B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Psalter_Pahlavi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10B80, 0x10B91).addRange(0x10B99, 0x10B9C).addRange(0x10BA9, 0x10BAF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Rejang.js", function (module, exports) {
	  const set = regenerate(0xA95F);
	set.addRange(0xA930, 0xA953);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Runic.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A0, 0x16EA).addRange(0x16EE, 0x16F8);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Samaritan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x800, 0x82D).addRange(0x830, 0x83E);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Saurashtra.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA880, 0xA8C5).addRange(0xA8CE, 0xA8D9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Sharada.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11180, 0x111DF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Shavian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10450, 0x1047F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Siddham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11580, 0x115B5).addRange(0x115B8, 0x115DD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/SignWriting.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1D800, 0x1DA8B).addRange(0x1DA9B, 0x1DA9F).addRange(0x1DAA1, 0x1DAAF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Sinhala.js", function (module, exports) {
	  const set = regenerate(0xDBD, 0xDCA, 0xDD6);
	set.addRange(0xD81, 0xD83).addRange(0xD85, 0xD96).addRange(0xD9A, 0xDB1).addRange(0xDB3, 0xDBB).addRange(0xDC0, 0xDC6).addRange(0xDCF, 0xDD4).addRange(0xDD8, 0xDDF).addRange(0xDE6, 0xDEF).addRange(0xDF2, 0xDF4).addRange(0x111E1, 0x111F4);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Sogdian.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10F30, 0x10F59);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Sora_Sompeng.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x110D0, 0x110E8).addRange(0x110F0, 0x110F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Soyombo.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11A50, 0x11AA2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Sundanese.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1B80, 0x1BBF).addRange(0x1CC0, 0x1CC7);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Syloti_Nagri.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA800, 0xA82C);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Syriac.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x700, 0x70D).addRange(0x70F, 0x74A).addRange(0x74D, 0x74F).addRange(0x860, 0x86A);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tagalog.js", function (module, exports) {
	  const set = regenerate(0x171F);
	set.addRange(0x1700, 0x1715);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tagbanwa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1760, 0x176C).addRange(0x176E, 0x1770).addRange(0x1772, 0x1773);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tai_Le.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1950, 0x196D).addRange(0x1970, 0x1974);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tai_Tham.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1A20, 0x1A5E).addRange(0x1A60, 0x1A7C).addRange(0x1A7F, 0x1A89).addRange(0x1A90, 0x1A99).addRange(0x1AA0, 0x1AAD);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tai_Viet.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xAA80, 0xAAC2).addRange(0xAADB, 0xAADF);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Takri.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11680, 0x116B9).addRange(0x116C0, 0x116C9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tamil.js", function (module, exports) {
	  const set = regenerate(0xB9C, 0xBD0, 0xBD7, 0x11FFF);
	set.addRange(0xB82, 0xB83).addRange(0xB85, 0xB8A).addRange(0xB8E, 0xB90).addRange(0xB92, 0xB95).addRange(0xB99, 0xB9A).addRange(0xB9E, 0xB9F).addRange(0xBA3, 0xBA4).addRange(0xBA8, 0xBAA).addRange(0xBAE, 0xBB9).addRange(0xBBE, 0xBC2).addRange(0xBC6, 0xBC8).addRange(0xBCA, 0xBCD).addRange(0xBE6, 0xBFA).addRange(0x11FC0, 0x11FF1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tangsa.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x16A70, 0x16ABE).addRange(0x16AC0, 0x16AC9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tangut.js", function (module, exports) {
	  const set = regenerate(0x16FE0);
	set.addRange(0x17000, 0x187F7).addRange(0x18800, 0x18AFF).addRange(0x18D00, 0x18D08);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Telugu.js", function (module, exports) {
	  const set = regenerate(0xC5D);
	set.addRange(0xC00, 0xC0C).addRange(0xC0E, 0xC10).addRange(0xC12, 0xC28).addRange(0xC2A, 0xC39).addRange(0xC3C, 0xC44).addRange(0xC46, 0xC48).addRange(0xC4A, 0xC4D).addRange(0xC55, 0xC56).addRange(0xC58, 0xC5A).addRange(0xC60, 0xC63).addRange(0xC66, 0xC6F).addRange(0xC77, 0xC7F);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Thaana.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x780, 0x7B1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Thai.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xE01, 0xE3A).addRange(0xE40, 0xE5B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tibetan.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xF00, 0xF47).addRange(0xF49, 0xF6C).addRange(0xF71, 0xF97).addRange(0xF99, 0xFBC).addRange(0xFBE, 0xFCC).addRange(0xFCE, 0xFD4).addRange(0xFD9, 0xFDA);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tifinagh.js", function (module, exports) {
	  const set = regenerate(0x2D7F);
	set.addRange(0x2D30, 0x2D67).addRange(0x2D6F, 0x2D70);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Tirhuta.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11480, 0x114C7).addRange(0x114D0, 0x114D9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Toto.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x1E290, 0x1E2AE);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Ugaritic.js", function (module, exports) {
	  const set = regenerate(0x1039F);
	set.addRange(0x10380, 0x1039D);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Vai.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA500, 0xA62B);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Vithkuqi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10570, 0x1057A).addRange(0x1057C, 0x1058A).addRange(0x1058C, 0x10592).addRange(0x10594, 0x10595).addRange(0x10597, 0x105A1).addRange(0x105A3, 0x105B1).addRange(0x105B3, 0x105B9).addRange(0x105BB, 0x105BC);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Wancho.js", function (module, exports) {
	  const set = regenerate(0x1E2FF);
	set.addRange(0x1E2C0, 0x1E2F9);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Warang_Citi.js", function (module, exports) {
	  const set = regenerate(0x118FF);
	set.addRange(0x118A0, 0x118F2);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Yezidi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x10E80, 0x10EA9).addRange(0x10EAB, 0x10EAD).addRange(0x10EB0, 0x10EB1);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Yi.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0xA000, 0xA48C).addRange(0xA490, 0xA4C6);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/Script/Zanabazar_Square.js", function (module, exports) {
	  const set = regenerate();
	set.addRange(0x11A00, 0x11A47);
	module.exports = set;

	});

	commonjsRegister("/$$rollup_base$$/node_modules/regenerate-unicode-properties/unicode-version.js", function (module, exports) {
	  module.exports = '14.0.0';

	});

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _taggedTemplateLiteralLoose(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }

	  strings.raw = raw;
	  return strings;
	}

	function _slicedToArray$1(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

	  if (_i == null) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;

	  var _s, _e;

	  try {
	    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);

	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }

	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function shallowEqual(actual, expected) {
	  var keys = Object.keys(expected);

	  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
	    var key = _keys[_i];

	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }

	  return true;
	}

	function isArrayExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ArrayExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isAssignmentExpression$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "AssignmentExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBinaryExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BinaryExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isInterpreterDirective(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "InterpreterDirective") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDirective(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Directive") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDirectiveLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DirectiveLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBlockStatement$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BlockStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBreakStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BreakStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isCallExpression$6(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "CallExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isCatchClause(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "CatchClause") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isConditionalExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ConditionalExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isContinueStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ContinueStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDebuggerStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DebuggerStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDoWhileStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DoWhileStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEmptyStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EmptyStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExpressionStatement$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExpressionStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFile$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "File") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isForInStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ForInStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isForStatement$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ForStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunctionDeclaration$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "FunctionDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunctionExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "FunctionExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isIdentifier$g(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Identifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isIfStatement$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "IfStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isLabeledStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "LabeledStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStringLiteral$7(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "StringLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNumericLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NumericLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNullLiteral$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NullLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBooleanLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BooleanLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isRegExpLiteral$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "RegExpLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isLogicalExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "LogicalExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isMemberExpression$8(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "MemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNewExpression$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NewExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isProgram$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Program") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectExpression$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectMethod$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectProperty$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isRestElement$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "RestElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isReturnStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ReturnStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSequenceExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SequenceExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isParenthesizedExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ParenthesizedExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSwitchCase(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SwitchCase") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSwitchStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SwitchStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isThisExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ThisExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isThrowStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ThrowStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTryStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TryStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isUnaryExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "UnaryExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isUpdateExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "UpdateExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isVariableDeclaration$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "VariableDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isVariableDeclarator$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "VariableDeclarator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isWhileStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "WhileStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isWithStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "WithStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isAssignmentPattern$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "AssignmentPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isArrayPattern(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ArrayPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isArrowFunctionExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ArrowFunctionExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassBody$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassDeclaration$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportAllDeclaration$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportAllDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportDefaultDeclaration$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportDefaultDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportNamedDeclaration$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportNamedDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportSpecifier(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isForOfStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ForOfStatement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImportDeclaration$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ImportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImportDefaultSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ImportDefaultSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImportNamespaceSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ImportNamespaceSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImportSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ImportSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isMetaProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "MetaProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassMethod$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectPattern$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectPattern") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSpreadElement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SpreadElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSuper$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Super") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTaggedTemplateExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TaggedTemplateExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTemplateElement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TemplateElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTemplateLiteral$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TemplateLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isYieldExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "YieldExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isAwaitExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "AwaitExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImport(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Import") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBigIntLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BigIntLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportNamespaceSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportNamespaceSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isOptionalMemberExpression$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "OptionalMemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isOptionalCallExpression$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "OptionalCallExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassPrivateProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassPrivateProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassPrivateMethod(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassPrivateMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPrivateName$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "PrivateName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStaticBlock(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "StaticBlock") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isAnyTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "AnyTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isArrayTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ArrayTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBooleanTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BooleanTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBooleanLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BooleanLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNullLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NullLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClassImplements(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ClassImplements") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareClass(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareClass") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareFunction(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareFunction") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareInterface(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareInterface") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareModule(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareModule") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareModuleExports(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareModuleExports") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareTypeAlias(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareTypeAlias") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareOpaqueType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareOpaqueType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareVariable(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareVariable") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareExportDeclaration$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareExportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclareExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclareExportAllDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclaredPredicate(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DeclaredPredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExistsTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExistsTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunctionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "FunctionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunctionTypeParam(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "FunctionTypeParam") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isGenericTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "GenericTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isInferredPredicate(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "InferredPredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isInterfaceExtends(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "InterfaceExtends") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "InterfaceDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isInterfaceTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "InterfaceTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isIntersectionTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "IntersectionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isMixedTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "MixedTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEmptyTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EmptyTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNullableTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NullableTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNumberLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NumberLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNumberTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NumberTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeInternalSlot(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeInternalSlot") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeCallProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeCallProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeIndexer(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeIndexer") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectTypeSpreadProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ObjectTypeSpreadProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isOpaqueType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "OpaqueType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isQualifiedTypeIdentifier(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "QualifiedTypeIdentifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStringLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "StringLiteralTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStringTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "StringTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSymbolTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SymbolTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isThisTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ThisTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTupleTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TupleTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeofTypeAnnotation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeofTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeAlias(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeAlias") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeAnnotation$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeCastExpression$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeCastExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeParameter(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeParameter") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeParameterDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TypeParameterInstantiation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isUnionTypeAnnotation$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "UnionTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isVariance(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Variance") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isVoidTypeAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "VoidTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumBooleanBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumBooleanBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumNumberBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumNumberBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumStringBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumStringBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumSymbolBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumSymbolBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumBooleanMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumBooleanMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumNumberMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumNumberMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumStringMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumStringMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumDefaultedMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "EnumDefaultedMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isIndexedAccessType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "IndexedAccessType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isOptionalIndexedAccessType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "OptionalIndexedAccessType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXAttribute(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXAttribute") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXClosingElement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXClosingElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXElement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXEmptyExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXEmptyExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXExpressionContainer$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXExpressionContainer") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXSpreadChild(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXSpreadChild") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXIdentifier$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXIdentifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXMemberExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXMemberExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXNamespacedName$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXNamespacedName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXOpeningElement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXOpeningElement") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXSpreadAttribute$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXSpreadAttribute") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXText(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXText") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXFragment(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXOpeningFragment(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXOpeningFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSXClosingFragment(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "JSXClosingFragment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNoop(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Noop") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPlaceholder$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Placeholder") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isV8IntrinsicIdentifier(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "V8IntrinsicIdentifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isArgumentPlaceholder(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ArgumentPlaceholder") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBindExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "BindExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isImportAttribute(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ImportAttribute") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDecorator(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "Decorator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDoExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DoExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportDefaultSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ExportDefaultSpecifier") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isRecordExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "RecordExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTupleExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TupleExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDecimalLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "DecimalLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isModuleExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "ModuleExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTopicReference(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TopicReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPipelineTopicExpression(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "PipelineTopicExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPipelineBareFunction(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "PipelineBareFunction") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPipelinePrimaryTopicReference(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "PipelinePrimaryTopicReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSParameterProperty(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSParameterProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSDeclareFunction(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSDeclareFunction") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSDeclareMethod(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSDeclareMethod") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSQualifiedName(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSQualifiedName") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSCallSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSCallSignatureDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSConstructSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSConstructSignatureDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSPropertySignature(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSPropertySignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSMethodSignature(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSMethodSignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSIndexSignature(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSIndexSignature") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSAnyKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSAnyKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSBooleanKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSBooleanKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSBigIntKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSBigIntKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSIntrinsicKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSIntrinsicKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNeverKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNeverKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNullKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNullKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNumberKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNumberKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSObjectKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSObjectKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSStringKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSStringKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSSymbolKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSSymbolKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSUndefinedKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSUndefinedKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSUnknownKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSUnknownKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSVoidKeyword(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSVoidKeyword") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSThisType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSThisType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSFunctionType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSFunctionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSConstructorType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSConstructorType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeReference(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypePredicate(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypePredicate") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeQuery(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeQuery") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeLiteral(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSArrayType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSArrayType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTupleType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTupleType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSOptionalType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSOptionalType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSRestType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSRestType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNamedTupleMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNamedTupleMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSUnionType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSUnionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSIntersectionType$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSIntersectionType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSConditionalType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSConditionalType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSInferType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSInferType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSParenthesizedType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSParenthesizedType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeOperator(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeOperator") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSIndexedAccessType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSIndexedAccessType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSMappedType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSMappedType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSLiteralType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSLiteralType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSExpressionWithTypeArguments(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSExpressionWithTypeArguments") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSInterfaceDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSInterfaceBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSInterfaceBody") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeAliasDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeAliasDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSAsExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSAsExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeAssertion$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeAssertion") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSEnumDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSEnumDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSEnumMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSEnumMember") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSModuleDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSModuleDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSModuleBlock(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSModuleBlock") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSImportType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSImportType") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSImportEqualsDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSImportEqualsDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSExternalModuleReference(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSExternalModuleReference") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNonNullExpression$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNonNullExpression") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSExportAssignment(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSExportAssignment") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSNamespaceExportDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSNamespaceExportDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeAnnotation$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeAnnotation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeParameterInstantiation") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeParameterDeclaration") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeParameter(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "TSTypeParameter") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStandardized(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExpression$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBinary$3(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isScopable(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBlockParent(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isBlock(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isStatement$7(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTerminatorless(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isCompletionStatement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isConditional$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isLoop$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isWhile(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExpressionWrapper(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFor$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isForXStatement$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunction$4(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFunctionParent(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPureish$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isDeclaration$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPatternLike(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isLVal(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSEntityName(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isLiteral$7(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isUserWhitespacable(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isMethod$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isObjectMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isProperty$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isUnaryLike$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPattern(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isClass$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isModuleDeclaration$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isExportDeclaration$2(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isModuleSpecifier$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isPrivate(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFlow$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFlowType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFlowBaseAnnotation$1(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFlowDeclaration(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isFlowPredicate(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumBody(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isEnumMember(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isJSX(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isMiscellaneous(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTypeScript(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSTypeElement(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isTSBaseType(node, opts) {
	  if (!node) return false;
	  var nodeType = node.type;

	  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "NumberLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "RegexLiteral") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "RestProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}
	function isSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  if (!node) return false;
	  var nodeType = node.type;

	  if (nodeType === "SpreadProperty") {
	    if (typeof opts === "undefined") {
	      return true;
	    } else {
	      return shallowEqual(node, opts);
	    }
	  }

	  return false;
	}

	function matchesPattern$2(member, match, allowPartial) {
	  if (!isMemberExpression$8(member)) return false;
	  var parts = Array.isArray(match) ? match : match.split(".");
	  var nodes = [];
	  var node;

	  for (node = member; isMemberExpression$8(node); node = node.object) {
	    nodes.push(node.property);
	  }

	  nodes.push(node);
	  if (nodes.length < parts.length) return false;
	  if (!allowPartial && nodes.length > parts.length) return false;

	  for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
	    var _node = nodes[j];
	    var value = void 0;

	    if (isIdentifier$g(_node)) {
	      value = _node.name;
	    } else if (isStringLiteral$7(_node)) {
	      value = _node.value;
	    } else if (isThisExpression$2(_node)) {
	      value = "this";
	    } else {
	      return false;
	    }

	    if (parts[i] !== value) return false;
	  }

	  return true;
	}

	function buildMatchMemberExpression$1(match, allowPartial) {
	  var parts = match.split(".");
	  return function (member) {
	    return matchesPattern$2(member, parts, allowPartial);
	  };
	}

	var isReactComponent = buildMatchMemberExpression$1("React.Component");

	function isCompatTag$1(tagName) {
	  return !!tagName && /^[a-z]/.test(tagName);
	}

	var fastProto = null;

	function FastObject(o) {
	  if (fastProto !== null && typeof fastProto.property) {
	    var result = fastProto;
	    fastProto = FastObject.prototype = null;
	    return result;
	  }

	  fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
	  return new FastObject();
	}

	FastObject();

	var toFastProperties = function toFastproperties(o) {
	  return FastObject(o);
	};

	var browser$4 = createCommonjsModule(function (module) {
	  var process = module.exports = {};
	  var cachedSetTimeout;
	  var cachedClearTimeout;

	  function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	  }

	  function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	  }

	  (function () {
	    try {
	      if (typeof setTimeout === 'function') {
	        cachedSetTimeout = setTimeout;
	      } else {
	        cachedSetTimeout = defaultSetTimout;
	      }
	    } catch (e) {
	      cachedSetTimeout = defaultSetTimout;
	    }

	    try {
	      if (typeof clearTimeout === 'function') {
	        cachedClearTimeout = clearTimeout;
	      } else {
	        cachedClearTimeout = defaultClearTimeout;
	      }
	    } catch (e) {
	      cachedClearTimeout = defaultClearTimeout;
	    }
	  })();

	  function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	      return setTimeout(fun, 0);
	    }

	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	      cachedSetTimeout = setTimeout;
	      return setTimeout(fun, 0);
	    }

	    try {
	      return cachedSetTimeout(fun, 0);
	    } catch (e) {
	      try {
	        return cachedSetTimeout.call(null, fun, 0);
	      } catch (e) {
	        return cachedSetTimeout.call(this, fun, 0);
	      }
	    }
	  }

	  function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	      return clearTimeout(marker);
	    }

	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	      cachedClearTimeout = clearTimeout;
	      return clearTimeout(marker);
	    }

	    try {
	      return cachedClearTimeout(marker);
	    } catch (e) {
	      try {
	        return cachedClearTimeout.call(null, marker);
	      } catch (e) {
	        return cachedClearTimeout.call(this, marker);
	      }
	    }
	  }

	  var queue = [];
	  var draining = false;
	  var currentQueue;
	  var queueIndex = -1;

	  function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	      return;
	    }

	    draining = false;

	    if (currentQueue.length) {
	      queue = currentQueue.concat(queue);
	    } else {
	      queueIndex = -1;
	    }

	    if (queue.length) {
	      drainQueue();
	    }
	  }

	  function drainQueue() {
	    if (draining) {
	      return;
	    }

	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	    var len = queue.length;

	    while (len) {
	      currentQueue = queue;
	      queue = [];

	      while (++queueIndex < len) {
	        if (currentQueue) {
	          currentQueue[queueIndex].run();
	        }
	      }

	      queueIndex = -1;
	      len = queue.length;
	    }

	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	  }

	  process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);

	    if (arguments.length > 1) {
	      for (var i = 1; i < arguments.length; i++) {
	        args[i - 1] = arguments[i];
	      }
	    }

	    queue.push(new Item(fun, args));

	    if (queue.length === 1 && !draining) {
	      runTimeout(drainQueue);
	    }
	  };

	  function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	  }

	  Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	  };

	  process.title = 'browser';
	  process.browser = true;
	  process.env = {};
	  process.argv = [];
	  process.version = '';
	  process.versions = {};

	  function noop() {}

	  process.on = noop;
	  process.addListener = noop;
	  process.once = noop;
	  process.off = noop;
	  process.removeListener = noop;
	  process.removeAllListeners = noop;
	  process.emit = noop;
	  process.prependListener = noop;
	  process.prependOnceListener = noop;

	  process.listeners = function (name) {
	    return [];
	  };

	  process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	  };

	  process.cwd = function () {
	    return '/';
	  };

	  process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	  };

	  process.umask = function () {
	    return 0;
	  };
	}, "/$$rollup_base$$/node_modules/process");

	function isType$2(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	  if (ALIAS_KEYS[targetType]) return false;
	  var aliases = FLIPPED_ALIAS_KEYS$3[targetType];

	  if (aliases) {
	    if (aliases[0] === nodeType) return true;

	    for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
	      var alias = _step.value;
	      if (nodeType === alias) return true;
	    }
	  }

	  return false;
	}

	function isPlaceholderType(placeholderType, targetType) {
	  if (placeholderType === targetType) return true;
	  var aliases = PLACEHOLDERS_ALIAS[placeholderType];

	  if (aliases) {
	    for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
	      var alias = _step.value;
	      if (targetType === alias) return true;
	    }
	  }

	  return false;
	}

	function is$1(type, node, opts) {
	  if (!node) return false;
	  var matches = isType$2(node.type, type);

	  if (!matches) {
	    if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS$3) {
	      return isPlaceholderType(node.expectedNode, type);
	    }

	    return false;
	  }

	  if (typeof opts === "undefined") {
	    return true;
	  } else {
	    return shallowEqual(node, opts);
	  }
	}

	var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
	var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

	function isInAstralSet(code, set) {
	  var pos = 0x10000;

	  for (var i = 0, length = set.length; i < length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }

	  return false;
	}

	function isIdentifierStart(code) {
	  if (code < 65) return code === 36;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;

	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }

	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;

	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  }

	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	function isIdentifierName(name) {
	  var isFirst = true;

	  for (var i = 0; i < name.length; i++) {
	    var cp = name.charCodeAt(i);

	    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
	      var trail = name.charCodeAt(++i);

	      if ((trail & 0xfc00) === 0xdc00) {
	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
	      }
	    }

	    if (isFirst) {
	      isFirst = false;

	      if (!isIdentifierStart(cp)) {
	        return false;
	      }
	    } else if (!isIdentifierChar(cp)) {
	      return false;
	    }
	  }

	  return !isFirst;
	}

	var reservedWords = {
	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
	  strictBind: ["eval", "arguments"]
	};
	var keywords$1 = new Set(reservedWords.keyword);
	var reservedWordsStrictSet = new Set(reservedWords.strict);
	var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
	  return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
	  return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
	  return keywords$1.has(word);
	}

	function isValidIdentifier$1(name, reserved) {
	  if (reserved === void 0) {
	    reserved = true;
	  }

	  if (typeof name !== "string") return false;

	  if (reserved) {
	    if (isKeyword(name) || isStrictReservedWord(name, true)) {
	      return false;
	    }
	  }

	  return isIdentifierName(name);
	}

	var STATEMENT_OR_BLOCK_KEYS$1 = ["consequent", "body", "alternate"];
	var FLATTENABLE_KEYS = ["body", "expressions"];
	var FOR_INIT_KEYS = ["left", "init"];
	var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
	var LOGICAL_OPERATORS$2 = ["||", "&&", "??"];
	var UPDATE_OPERATORS = ["++", "--"];
	var BOOLEAN_NUMBER_BINARY_OPERATORS$1 = [">", "<", ">=", "<="];
	var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
	var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
	var BOOLEAN_BINARY_OPERATORS$1 = [].concat(_toConsumableArray(COMPARISON_BINARY_OPERATORS), BOOLEAN_NUMBER_BINARY_OPERATORS$1);
	var NUMBER_BINARY_OPERATORS$1 = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
	var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS$1, _toConsumableArray(BOOLEAN_BINARY_OPERATORS$1));
	var ASSIGNMENT_OPERATORS = ["=", "+="].concat(_toConsumableArray(NUMBER_BINARY_OPERATORS$1.map(function (op) {
	  return op + "=";
	})), _toConsumableArray(LOGICAL_OPERATORS$2.map(function (op) {
	  return op + "=";
	})));
	var BOOLEAN_UNARY_OPERATORS$1 = ["delete", "!"];
	var NUMBER_UNARY_OPERATORS$1 = ["+", "-", "~"];
	var STRING_UNARY_OPERATORS$1 = ["typeof"];
	var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS$1, NUMBER_UNARY_OPERATORS$1, STRING_UNARY_OPERATORS$1);
	var INHERIT_KEYS = {
	  optional: ["typeAnnotation", "typeParameters", "returnType"],
	  force: ["start", "loc", "end"]
	};
	var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
	var NOT_LOCAL_BINDING$2 = Symbol["for"]("should not be considered a local binding");

	function validate$6(node, key, val) {
	  if (!node) return;
	  var fields = NODE_FIELDS[node.type];
	  if (!fields) return;
	  var field = fields[key];
	  validateField(node, key, val, field);
	  validateChild(node, key, val);
	}
	function validateField(node, key, val, field) {
	  if (!(field != null && field.validate)) return;
	  if (field.optional && val == null) return;
	  field.validate(node, key, val);
	}
	function validateChild(node, key, val) {
	  if (val == null) return;
	  var validate = NODE_PARENT_VALIDATIONS[val.type];
	  if (!validate) return;
	  validate(node, key, val);
	}

	var VISITOR_KEYS$6 = {};
	var ALIAS_KEYS = {};
	var FLIPPED_ALIAS_KEYS$3 = {};
	var NODE_FIELDS = {};
	var BUILDER_KEYS = {};
	var DEPRECATED_KEYS$1 = {};
	var NODE_PARENT_VALIDATIONS = {};

	function getType$2(val) {
	  if (Array.isArray(val)) {
	    return "array";
	  } else if (val === null) {
	    return "null";
	  } else {
	    return typeof val;
	  }
	}

	function validate$5(validate) {
	  return {
	    validate: validate
	  };
	}
	function typeIs(typeName) {
	  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));
	}
	function validateType(typeName) {
	  return validate$5(typeIs(typeName));
	}
	function validateOptional(validate) {
	  return {
	    validate: validate,
	    optional: true
	  };
	}
	function validateOptionalType(typeName) {
	  return {
	    validate: typeIs(typeName),
	    optional: true
	  };
	}
	function arrayOf(elementType) {
	  return chain$1(assertValueType("array"), assertEach(elementType));
	}
	function arrayOfType(typeName) {
	  return arrayOf(typeIs(typeName));
	}
	function validateArrayOfType(typeName) {
	  return validate$5(arrayOfType(typeName));
	}
	function assertEach(callback) {
	  function validator(node, key, val) {
	    if (!Array.isArray(val)) return;

	    for (var i = 0; i < val.length; i++) {
	      var subkey = key + "[" + i + "]";
	      var v = val[i];
	      callback(node, subkey, v);
	      if (browser$4.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);
	    }
	  }

	  validator.each = callback;
	  return validator;
	}
	function assertOneOf() {
	  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
	    values[_key] = arguments[_key];
	  }

	  function validate(node, key, val) {
	    if (values.indexOf(val) < 0) {
	      throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
	    }
	  }

	  validate.oneOf = values;
	  return validate;
	}
	function assertNodeType() {
	  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    types[_key2] = arguments[_key2];
	  }

	  function validate(node, key, val) {
	    for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
	      var type = _step.value;

	      if (is$1(type, val)) {
	        validateChild(node, key, val);
	        return;
	      }
	    }

	    throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
	  }

	  validate.oneOfNodeTypes = types;
	  return validate;
	}
	function assertNodeOrValueType() {
	  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	    types[_key3] = arguments[_key3];
	  }

	  function validate(node, key, val) {
	    for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
	      var type = _step2.value;

	      if (getType$2(val) === type || is$1(type, val)) {
	        validateChild(node, key, val);
	        return;
	      }
	    }

	    throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
	  }

	  validate.oneOfNodeOrValueTypes = types;
	  return validate;
	}
	function assertValueType(type) {
	  function validate(node, key, val) {
	    var valid = getType$2(val) === type;

	    if (!valid) {
	      throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType$2(val));
	    }
	  }

	  validate.type = type;
	  return validate;
	}
	function assertShape(shape) {
	  function validate(node, key, val) {
	    var errors = [];

	    for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
	      var property = _Object$keys[_i];

	      try {
	        validateField(node, property, val[property], shape[property]);
	      } catch (error) {
	        if (error instanceof TypeError) {
	          errors.push(error.message);
	          continue;
	        }

	        throw error;
	      }
	    }

	    if (errors.length) {
	      throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
	    }
	  }

	  validate.shapeOf = shape;
	  return validate;
	}
	function assertOptionalChainStart() {
	  function validate(node) {
	    var _current2;

	    var current = node;

	    while (node) {
	      var _current = current,
	          type = _current.type;

	      if (type === "OptionalCallExpression") {
	        if (current.optional) return;
	        current = current.callee;
	        continue;
	      }

	      if (type === "OptionalMemberExpression") {
	        if (current.optional) return;
	        current = current.object;
	        continue;
	      }

	      break;
	    }

	    throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
	  }

	  return validate;
	}
	function chain$1() {
	  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	    fns[_key4] = arguments[_key4];
	  }

	  function validate() {
	    for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
	      var fn = _step3.value;
	      fn.apply(void 0, arguments);
	    }
	  }

	  validate.chainOf = fns;

	  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
	    throw new Error("An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.");
	  }

	  return validate;
	}
	var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
	var validFieldKeys = ["default", "optional", "validate"];
	function defineAliasedType() {
	  for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	    aliases[_key5] = arguments[_key5];
	  }

	  return function (type, opts) {
	    var _defined2;

	    if (opts === void 0) {
	      opts = {};
	    }

	    var defined = opts.aliases;

	    if (!defined) {
	      var _store$opts$inherits$, _defined;

	      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
	      (_defined = defined) != null ? _defined : defined = [];
	      opts.aliases = defined;
	    }

	    var additional = aliases.filter(function (a) {
	      return !defined.includes(a);
	    });

	    (_defined2 = defined).unshift.apply(_defined2, _toConsumableArray(additional));

	    return defineType$5(type, opts);
	  };
	}
	function defineType$5(type, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var inherits = opts.inherits && store[opts.inherits] || {};
	  var fields = opts.fields;

	  if (!fields) {
	    fields = {};

	    if (inherits.fields) {
	      var keys = Object.getOwnPropertyNames(inherits.fields);

	      for (var _iterator4 = _createForOfIteratorHelperLoose(keys), _step4; !(_step4 = _iterator4()).done;) {
	        var _key6 = _step4.value;
	        var field = inherits.fields[_key6];
	        var def = field["default"];

	        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
	          throw new Error("field defaults can only be primitives or empty arrays currently");
	        }

	        fields[_key6] = {
	          "default": Array.isArray(def) ? [] : def,
	          optional: field.optional,
	          validate: field.validate
	        };
	      }
	    }
	  }

	  var visitor = opts.visitor || inherits.visitor || [];
	  var aliases = opts.aliases || inherits.aliases || [];
	  var builder = opts.builder || inherits.builder || opts.visitor || [];

	  for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {
	    var k = _Object$keys2[_i2];

	    if (validTypeOpts.indexOf(k) === -1) {
	      throw new Error("Unknown type option \"" + k + "\" on " + type);
	    }
	  }

	  if (opts.deprecatedAlias) {
	    DEPRECATED_KEYS$1[opts.deprecatedAlias] = type;
	  }

	  for (var _iterator5 = _createForOfIteratorHelperLoose(visitor.concat(builder)), _step5; !(_step5 = _iterator5()).done;) {
	    var _key8 = _step5.value;
	    fields[_key8] = fields[_key8] || {};
	  }

	  for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {
	    var _key7 = _Object$keys3[_i3];
	    var _field = fields[_key7];

	    if (_field["default"] !== undefined && builder.indexOf(_key7) === -1) {
	      _field.optional = true;
	    }

	    if (_field["default"] === undefined) {
	      _field["default"] = null;
	    } else if (!_field.validate && _field["default"] != null) {
	      _field.validate = assertValueType(getType$2(_field["default"]));
	    }

	    for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {
	      var _k = _Object$keys4[_i4];

	      if (validFieldKeys.indexOf(_k) === -1) {
	        throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key7);
	      }
	    }
	  }

	  VISITOR_KEYS$6[type] = opts.visitor = visitor;
	  BUILDER_KEYS[type] = opts.builder = builder;
	  NODE_FIELDS[type] = opts.fields = fields;
	  ALIAS_KEYS[type] = opts.aliases = aliases;
	  aliases.forEach(function (alias) {
	    FLIPPED_ALIAS_KEYS$3[alias] = FLIPPED_ALIAS_KEYS$3[alias] || [];
	    FLIPPED_ALIAS_KEYS$3[alias].push(type);
	  });

	  if (opts.validate) {
	    NODE_PARENT_VALIDATIONS[type] = opts.validate;
	  }

	  store[type] = opts;
	}
	var store = {};

	var defineType$4 = defineAliasedType("Standardized");
	defineType$4("ArrayExpression", {
	  fields: {
	    elements: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
	      "default": !browser$4.env.BABEL_TYPES_8_BREAKING ? [] : undefined
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	defineType$4("AssignmentExpression", {
	  fields: {
	    operator: {
	      validate: function () {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) {
	          return assertValueType("string");
	        }

	        var identifier = assertOneOf.apply(void 0, _toConsumableArray(ASSIGNMENT_OPERATORS));
	        var pattern = assertOneOf("=");
	        return function (node, key, val) {
	          var validator = is$1("Pattern", node.left) ? pattern : identifier;
	          validator(node, key, val);
	        };
	      }()
	    },
	    left: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Expression"]
	});
	defineType$4("BinaryExpression", {
	  builder: ["operator", "left", "right"],
	  fields: {
	    operator: {
	      validate: assertOneOf.apply(void 0, _toConsumableArray(BINARY_OPERATORS))
	    },
	    left: {
	      validate: function () {
	        var expression = assertNodeType("Expression");
	        var inOp = assertNodeType("Expression", "PrivateName");

	        var validator = function validator(node, key, val) {
	          var validator = node.operator === "in" ? inOp : expression;
	          validator(node, key, val);
	        };

	        validator.oneOfNodeTypes = ["Expression", "PrivateName"];
	        return validator;
	      }()
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"]
	});
	defineType$4("InterpreterDirective", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  }
	});
	defineType$4("Directive", {
	  visitor: ["value"],
	  fields: {
	    value: {
	      validate: assertNodeType("DirectiveLiteral")
	    }
	  }
	});
	defineType$4("DirectiveLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  }
	});
	defineType$4("BlockStatement", {
	  builder: ["body", "directives"],
	  visitor: ["directives", "body"],
	  fields: {
	    directives: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Directive"))),
	      "default": []
	    },
	    body: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
	});
	defineType$4("BreakStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: assertNodeType("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	defineType$4("CallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments"],
	  aliases: ["Expression"],
	  fields: Object.assign({
	    callee: {
	      validate: assertNodeType("Expression", "V8IntrinsicIdentifier")
	    },
	    arguments: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
	    }
	  }, !browser$4.env.BABEL_TYPES_8_BREAKING ? {
	    optional: {
	      validate: assertOneOf(true, false),
	      optional: true
	    }
	  } : {}, {
	    typeArguments: {
	      validate: assertNodeType("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: assertNodeType("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  })
	});
	defineType$4("CatchClause", {
	  visitor: ["param", "body"],
	  fields: {
	    param: {
	      validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  },
	  aliases: ["Scopable", "BlockParent"]
	});
	defineType$4("ConditionalExpression", {
	  visitor: ["test", "consequent", "alternate"],
	  fields: {
	    test: {
	      validate: assertNodeType("Expression")
	    },
	    consequent: {
	      validate: assertNodeType("Expression")
	    },
	    alternate: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  aliases: ["Expression", "Conditional"]
	});
	defineType$4("ContinueStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: assertNodeType("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	defineType$4("DebuggerStatement", {
	  aliases: ["Statement"]
	});
	defineType$4("DoWhileStatement", {
	  visitor: ["test", "body"],
	  fields: {
	    test: {
	      validate: assertNodeType("Expression")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  },
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
	});
	defineType$4("EmptyStatement", {
	  aliases: ["Statement"]
	});
	defineType$4("ExpressionStatement", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  aliases: ["Statement", "ExpressionWrapper"]
	});
	defineType$4("File", {
	  builder: ["program", "comments", "tokens"],
	  visitor: ["program"],
	  fields: {
	    program: {
	      validate: assertNodeType("Program")
	    },
	    comments: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {
	        each: {
	          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
	        }
	      }) : assertEach(assertNodeType("CommentBlock", "CommentLine")),
	      optional: true
	    },
	    tokens: {
	      validate: assertEach(Object.assign(function () {}, {
	        type: "any"
	      })),
	      optional: true
	    }
	  }
	});
	defineType$4("ForInStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	defineType$4("ForStatement", {
	  visitor: ["init", "test", "update", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
	  fields: {
	    init: {
	      validate: assertNodeType("VariableDeclaration", "Expression"),
	      optional: true
	    },
	    test: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    },
	    update: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	var functionCommon = {
	  params: {
	    validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement")))
	  },
	  generator: {
	    "default": false
	  },
	  async: {
	    "default": false
	  }
	};
	var functionTypeAnnotationCommon = {
	  returnType: {
	    validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	var functionDeclarationCommon = Object.assign({}, functionCommon, {
	  declare: {
	    validate: assertValueType("boolean"),
	    optional: true
	  },
	  id: {
	    validate: assertNodeType("Identifier"),
	    optional: true
	  }
	});
	defineType$4("FunctionDeclaration", {
	  builder: ["id", "params", "body", "generator", "async"],
	  visitor: ["id", "params", "body", "returnType", "typeParameters"],
	  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  }),
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
	  validate: function () {
	    if (!browser$4.env.BABEL_TYPES_8_BREAKING) return function () {};
	    var identifier = assertNodeType("Identifier");
	    return function (parent, key, node) {
	      if (!is$1("ExportDefaultDeclaration", parent)) {
	        identifier(node, "id", node.id);
	      }
	    };
	  }()
	});
	defineType$4("FunctionExpression", {
	  inherits: "FunctionDeclaration",
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    id: {
	      validate: assertNodeType("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  })
	});
	var patternLikeCommon = {
	  typeAnnotation: {
	    validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  decorators: {
	    validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator")))
	  }
	};
	defineType$4("Identifier", {
	  builder: ["name"],
	  visitor: ["typeAnnotation", "decorators"],
	  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
	  fields: Object.assign({}, patternLikeCommon, {
	    name: {
	      validate: chain$1(assertValueType("string"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (!isValidIdentifier$1(val, false)) {
	          throw new TypeError("\"" + val + "\" is not a valid identifier name");
	        }
	      }, {
	        type: "string"
	      }))
	    },
	    optional: {
	      validate: assertValueType("boolean"),
	      optional: true
	    }
	  }),
	  validate: function validate(parent, key, node) {
	    if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	    var match = /\.(\w+)$/.exec(key);
	    if (!match) return;

	    var _match = _slicedToArray$1(match, 2),
	        parentKey = _match[1];

	    var nonComp = {
	      computed: false
	    };

	    if (parentKey === "property") {
	      if (is$1("MemberExpression", parent, nonComp)) return;
	      if (is$1("OptionalMemberExpression", parent, nonComp)) return;
	    } else if (parentKey === "key") {
	      if (is$1("Property", parent, nonComp)) return;
	      if (is$1("Method", parent, nonComp)) return;
	    } else if (parentKey === "exported") {
	      if (is$1("ExportSpecifier", parent)) return;
	    } else if (parentKey === "imported") {
	      if (is$1("ImportSpecifier", parent, {
	        imported: node
	      })) return;
	    } else if (parentKey === "meta") {
	      if (is$1("MetaProperty", parent, {
	        meta: node
	      })) return;
	    }

	    if ((isKeyword(node.name) || isReservedWord(node.name, false)) && node.name !== "this") {
	      throw new TypeError("\"" + node.name + "\" is not a valid identifier");
	    }
	  }
	});
	defineType$4("IfStatement", {
	  visitor: ["test", "consequent", "alternate"],
	  aliases: ["Statement", "Conditional"],
	  fields: {
	    test: {
	      validate: assertNodeType("Expression")
	    },
	    consequent: {
	      validate: assertNodeType("Statement")
	    },
	    alternate: {
	      optional: true,
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	defineType$4("LabeledStatement", {
	  visitor: ["label", "body"],
	  aliases: ["Statement"],
	  fields: {
	    label: {
	      validate: assertNodeType("Identifier")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	defineType$4("StringLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$4("NumericLiteral", {
	  builder: ["value"],
	  deprecatedAlias: "NumberLiteral",
	  fields: {
	    value: {
	      validate: assertValueType("number")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$4("NullLiteral", {
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$4("BooleanLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("boolean")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$4("RegExpLiteral", {
	  builder: ["pattern", "flags"],
	  deprecatedAlias: "RegexLiteral",
	  aliases: ["Expression", "Pureish", "Literal"],
	  fields: {
	    pattern: {
	      validate: assertValueType("string")
	    },
	    flags: {
	      validate: chain$1(assertValueType("string"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	        var invalid = /[^gimsuy]/.exec(val);

	        if (invalid) {
	          throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
	        }
	      }, {
	        type: "string"
	      })),
	      "default": ""
	    }
	  }
	});
	defineType$4("LogicalExpression", {
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"],
	  fields: {
	    operator: {
	      validate: assertOneOf.apply(void 0, _toConsumableArray(LOGICAL_OPERATORS$2))
	    },
	    left: {
	      validate: assertNodeType("Expression")
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("MemberExpression", {
	  builder: ["object", "property", "computed"].concat(_toConsumableArray(!browser$4.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])),
	  visitor: ["object", "property"],
	  aliases: ["Expression", "LVal"],
	  fields: Object.assign({
	    object: {
	      validate: assertNodeType("Expression")
	    },
	    property: {
	      validate: function () {
	        var normal = assertNodeType("Identifier", "PrivateName");
	        var computed = assertNodeType("Expression");

	        var validator = function validator(node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };

	        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
	        return validator;
	      }()
	    },
	    computed: {
	      "default": false
	    }
	  }, !browser$4.env.BABEL_TYPES_8_BREAKING ? {
	    optional: {
	      validate: assertOneOf(true, false),
	      optional: true
	    }
	  } : {})
	});
	defineType$4("NewExpression", {
	  inherits: "CallExpression"
	});
	defineType$4("Program", {
	  visitor: ["directives", "body"],
	  builder: ["body", "directives", "sourceType", "interpreter"],
	  fields: {
	    sourceFile: {
	      validate: assertValueType("string")
	    },
	    sourceType: {
	      validate: assertOneOf("script", "module"),
	      "default": "script"
	    },
	    interpreter: {
	      validate: assertNodeType("InterpreterDirective"),
	      "default": null,
	      optional: true
	    },
	    directives: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Directive"))),
	      "default": []
	    },
	    body: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "Block"]
	});
	defineType$4("ObjectExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
	    }
	  }
	});
	defineType$4("ObjectMethod", {
	  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    kind: Object.assign({
	      validate: assertOneOf("method", "get", "set")
	    }, !browser$4.env.BABEL_TYPES_8_BREAKING ? {
	      "default": "method"
	    } : {}),
	    computed: {
	      "default": false
	    },
	    key: {
	      validate: function () {
	        var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
	        var computed = assertNodeType("Expression");

	        var validator = function validator(node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };

	        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
	        return validator;
	      }()
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  }),
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
	});
	defineType$4("ObjectProperty", {
	  builder: ["key", "value", "computed", "shorthand"].concat(_toConsumableArray(!browser$4.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])),
	  fields: {
	    computed: {
	      "default": false
	    },
	    key: {
	      validate: function () {
	        var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
	        var computed = assertNodeType("Expression");

	        var validator = function validator(node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };

	        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
	        return validator;
	      }()
	    },
	    value: {
	      validate: assertNodeType("Expression", "PatternLike")
	    },
	    shorthand: {
	      validate: chain$1(assertValueType("boolean"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (val && node.computed) {
	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
	        }
	      }, {
	        type: "boolean"
	      }), function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (val && !is$1("Identifier", node.key)) {
	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
	        }
	      }),
	      "default": false
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    }
	  },
	  visitor: ["key", "value", "decorators"],
	  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
	  validate: function () {
	    var pattern = assertNodeType("Identifier", "Pattern");
	    var expression = assertNodeType("Expression");
	    return function (parent, key, node) {
	      if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	      var validator = is$1("ObjectPattern", parent) ? pattern : expression;
	      validator(node, "value", node.value);
	    };
	  }()
	});
	defineType$4("RestElement", {
	  visitor: ["argument", "typeAnnotation"],
	  builder: ["argument"],
	  aliases: ["LVal", "PatternLike"],
	  deprecatedAlias: "RestProperty",
	  fields: Object.assign({}, patternLikeCommon, {
	    argument: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression")
	    },
	    optional: {
	      validate: assertValueType("boolean"),
	      optional: true
	    }
	  }),
	  validate: function validate(parent, key) {
	    if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	    var match = /(\w+)\[(\d+)\]/.exec(key);
	    if (!match) throw new Error("Internal Babel error: malformed key.");

	    var _match2 = _slicedToArray$1(match, 3),
	        listKey = _match2[1],
	        index = _match2[2];

	    if (parent[listKey].length > index + 1) {
	      throw new TypeError("RestElement must be last element of " + listKey);
	    }
	  }
	});
	defineType$4("ReturnStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    }
	  }
	});
	defineType$4("SequenceExpression", {
	  visitor: ["expressions"],
	  fields: {
	    expressions: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression")))
	    }
	  },
	  aliases: ["Expression"]
	});
	defineType$4("ParenthesizedExpression", {
	  visitor: ["expression"],
	  aliases: ["Expression", "ExpressionWrapper"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("SwitchCase", {
	  visitor: ["test", "consequent"],
	  fields: {
	    test: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    },
	    consequent: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
	    }
	  }
	});
	defineType$4("SwitchStatement", {
	  visitor: ["discriminant", "cases"],
	  aliases: ["Statement", "BlockParent", "Scopable"],
	  fields: {
	    discriminant: {
	      validate: assertNodeType("Expression")
	    },
	    cases: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
	    }
	  }
	});
	defineType$4("ThisExpression", {
	  aliases: ["Expression"]
	});
	defineType$4("ThrowStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("TryStatement", {
	  visitor: ["block", "handler", "finalizer"],
	  aliases: ["Statement"],
	  fields: {
	    block: {
	      validate: chain$1(assertNodeType("BlockStatement"), Object.assign(function (node) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (!node.handler && !node.finalizer) {
	          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
	        }
	      }, {
	        oneOfNodeTypes: ["BlockStatement"]
	      }))
	    },
	    handler: {
	      optional: true,
	      validate: assertNodeType("CatchClause")
	    },
	    finalizer: {
	      optional: true,
	      validate: assertNodeType("BlockStatement")
	    }
	  }
	});
	defineType$4("UnaryExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      "default": true
	    },
	    argument: {
	      validate: assertNodeType("Expression")
	    },
	    operator: {
	      validate: assertOneOf.apply(void 0, _toConsumableArray(UNARY_OPERATORS))
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["UnaryLike", "Expression"]
	});
	defineType$4("UpdateExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      "default": false
	    },
	    argument: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
	    },
	    operator: {
	      validate: assertOneOf.apply(void 0, _toConsumableArray(UPDATE_OPERATORS))
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["Expression"]
	});
	defineType$4("VariableDeclaration", {
	  builder: ["kind", "declarations"],
	  visitor: ["declarations"],
	  aliases: ["Statement", "Declaration"],
	  fields: {
	    declare: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    kind: {
	      validate: assertOneOf("var", "let", "const")
	    },
	    declarations: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
	    }
	  },
	  validate: function validate(parent, key, node) {
	    if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	    if (!is$1("ForXStatement", parent, {
	      left: node
	    })) return;

	    if (node.declarations.length !== 1) {
	      throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
	    }
	  }
	});
	defineType$4("VariableDeclarator", {
	  visitor: ["id", "init"],
	  fields: {
	    id: {
	      validate: function () {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) {
	          return assertNodeType("LVal");
	        }

	        var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
	        var without = assertNodeType("Identifier");
	        return function (node, key, val) {
	          var validator = node.init ? normal : without;
	          validator(node, key, val);
	        };
	      }()
	    },
	    definite: {
	      optional: true,
	      validate: assertValueType("boolean")
	    },
	    init: {
	      optional: true,
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("WhileStatement", {
	  visitor: ["test", "body"],
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
	  fields: {
	    test: {
	      validate: assertNodeType("Expression")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	defineType$4("WithStatement", {
	  visitor: ["object", "body"],
	  aliases: ["Statement"],
	  fields: {
	    object: {
	      validate: assertNodeType("Expression")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    }
	  }
	});
	defineType$4("AssignmentPattern", {
	  visitor: ["left", "right", "decorators"],
	  builder: ["left", "right"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon, {
	    left: {
	      validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    }
	  })
	});
	defineType$4("ArrayPattern", {
	  visitor: ["elements", "typeAnnotation"],
	  builder: ["elements"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon, {
	    elements: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    optional: {
	      validate: assertValueType("boolean"),
	      optional: true
	    }
	  })
	});
	defineType$4("ArrowFunctionExpression", {
	  builder: ["params", "body", "async"],
	  visitor: ["params", "body", "returnType", "typeParameters"],
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
	    expression: {
	      validate: assertValueType("boolean")
	    },
	    body: {
	      validate: assertNodeType("BlockStatement", "Expression")
	    }
	  })
	});
	defineType$4("ClassBody", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
	    }
	  }
	});
	defineType$4("ClassExpression", {
	  builder: ["id", "superClass", "body", "decorators"],
	  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
	  aliases: ["Scopable", "Class", "Expression"],
	  fields: {
	    id: {
	      validate: assertNodeType("Identifier"),
	      optional: true
	    },
	    typeParameters: {
	      validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: assertNodeType("Expression")
	    },
	    superTypeParameters: {
	      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    },
	    "implements": {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
	      optional: true
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    mixins: {
	      validate: assertNodeType("InterfaceExtends"),
	      optional: true
	    }
	  }
	});
	defineType$4("ClassDeclaration", {
	  inherits: "ClassExpression",
	  aliases: ["Scopable", "Class", "Statement", "Declaration"],
	  fields: {
	    id: {
	      validate: assertNodeType("Identifier")
	    },
	    typeParameters: {
	      validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	      optional: true
	    },
	    body: {
	      validate: assertNodeType("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: assertNodeType("Expression")
	    },
	    superTypeParameters: {
	      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    },
	    "implements": {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
	      optional: true
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    mixins: {
	      validate: assertNodeType("InterfaceExtends"),
	      optional: true
	    },
	    declare: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    "abstract": {
	      validate: assertValueType("boolean"),
	      optional: true
	    }
	  },
	  validate: function () {
	    var identifier = assertNodeType("Identifier");
	    return function (parent, key, node) {
	      if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	      if (!is$1("ExportDefaultDeclaration", parent)) {
	        identifier(node, "id", node.id);
	      }
	    };
	  }()
	});
	defineType$4("ExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    source: {
	      validate: assertNodeType("StringLiteral")
	    },
	    exportKind: validateOptional(assertOneOf("type", "value")),
	    assertions: {
	      optional: true,
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
	    }
	  }
	});
	defineType$4("ExportDefaultDeclaration", {
	  visitor: ["declaration"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      validate: assertNodeType("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
	    },
	    exportKind: validateOptional(assertOneOf("value"))
	  }
	});
	defineType$4("ExportNamedDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: {
	      optional: true,
	      validate: chain$1(assertNodeType("Declaration"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (val && node.specifiers.length) {
	          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
	        }
	      }, {
	        oneOfNodeTypes: ["Declaration"]
	      }), function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (val && node.source) {
	          throw new TypeError("Cannot export a declaration from a source");
	        }
	      })
	    },
	    assertions: {
	      optional: true,
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
	    },
	    specifiers: {
	      "default": [],
	      validate: chain$1(assertValueType("array"), assertEach(function () {
	        var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
	        var sourceless = assertNodeType("ExportSpecifier");
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return sourced;
	        return function (node, key, val) {
	          var validator = node.source ? sourced : sourceless;
	          validator(node, key, val);
	        };
	      }()))
	    },
	    source: {
	      validate: assertNodeType("StringLiteral"),
	      optional: true
	    },
	    exportKind: validateOptional(assertOneOf("type", "value"))
	  }
	});
	defineType$4("ExportSpecifier", {
	  visitor: ["local", "exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: assertNodeType("Identifier")
	    },
	    exported: {
	      validate: assertNodeType("Identifier", "StringLiteral")
	    },
	    exportKind: {
	      validate: assertOneOf("type", "value"),
	      optional: true
	    }
	  }
	});
	defineType$4("ForOfStatement", {
	  visitor: ["left", "right", "body"],
	  builder: ["left", "right", "body", "await"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: function () {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) {
	          return assertNodeType("VariableDeclaration", "LVal");
	        }

	        var declaration = assertNodeType("VariableDeclaration");
	        var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
	        return function (node, key, val) {
	          if (is$1("VariableDeclaration", val)) {
	            declaration(node, key, val);
	          } else {
	            lval(node, key, val);
	          }
	        };
	      }()
	    },
	    right: {
	      validate: assertNodeType("Expression")
	    },
	    body: {
	      validate: assertNodeType("Statement")
	    },
	    "await": {
	      "default": false
	    }
	  }
	});
	defineType$4("ImportDeclaration", {
	  visitor: ["specifiers", "source"],
	  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
	  fields: {
	    assertions: {
	      optional: true,
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
	    },
	    specifiers: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
	    },
	    source: {
	      validate: assertNodeType("StringLiteral")
	    },
	    importKind: {
	      validate: assertOneOf("type", "typeof", "value"),
	      optional: true
	    }
	  }
	});
	defineType$4("ImportDefaultSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	defineType$4("ImportNamespaceSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	defineType$4("ImportSpecifier", {
	  visitor: ["local", "imported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: assertNodeType("Identifier")
	    },
	    imported: {
	      validate: assertNodeType("Identifier", "StringLiteral")
	    },
	    importKind: {
	      validate: assertOneOf("type", "typeof", "value"),
	      optional: true
	    }
	  }
	});
	defineType$4("MetaProperty", {
	  visitor: ["meta", "property"],
	  aliases: ["Expression"],
	  fields: {
	    meta: {
	      validate: chain$1(assertNodeType("Identifier"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;
	        var property;

	        switch (val.name) {
	          case "function":
	            property = "sent";
	            break;

	          case "new":
	            property = "target";
	            break;

	          case "import":
	            property = "meta";
	            break;
	        }

	        if (!is$1("Identifier", node.property, {
	          name: property
	        })) {
	          throw new TypeError("Unrecognised MetaProperty");
	        }
	      }, {
	        oneOfNodeTypes: ["Identifier"]
	      }))
	    },
	    property: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	var classMethodOrPropertyCommon = {
	  "abstract": {
	    validate: assertValueType("boolean"),
	    optional: true
	  },
	  accessibility: {
	    validate: assertOneOf("public", "private", "protected"),
	    optional: true
	  },
	  "static": {
	    "default": false
	  },
	  override: {
	    "default": false
	  },
	  computed: {
	    "default": false
	  },
	  optional: {
	    validate: assertValueType("boolean"),
	    optional: true
	  },
	  key: {
	    validate: chain$1(function () {
	      var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
	      var computed = assertNodeType("Expression");
	      return function (node, key, val) {
	        var validator = node.computed ? computed : normal;
	        validator(node, key, val);
	      };
	    }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
	  }
	};
	var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
	  params: {
	    validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
	  },
	  kind: {
	    validate: assertOneOf("get", "set", "method", "constructor"),
	    "default": "method"
	  },
	  access: {
	    validate: chain$1(assertValueType("string"), assertOneOf("public", "private", "protected")),
	    optional: true
	  },
	  decorators: {
	    validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	    optional: true
	  }
	});
	defineType$4("ClassMethod", {
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
	  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  })
	});
	defineType$4("ObjectPattern", {
	  visitor: ["properties", "typeAnnotation", "decorators"],
	  builder: ["properties"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon, {
	    properties: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
	    }
	  })
	});
	defineType$4("SpreadElement", {
	  visitor: ["argument"],
	  aliases: ["UnaryLike"],
	  deprecatedAlias: "SpreadProperty",
	  fields: {
	    argument: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("Super", {
	  aliases: ["Expression"]
	});
	defineType$4("TaggedTemplateExpression", {
	  visitor: ["tag", "quasi", "typeParameters"],
	  builder: ["tag", "quasi"],
	  aliases: ["Expression"],
	  fields: {
	    tag: {
	      validate: assertNodeType("Expression")
	    },
	    quasi: {
	      validate: assertNodeType("TemplateLiteral")
	    },
	    typeParameters: {
	      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType$4("TemplateElement", {
	  builder: ["value", "tail"],
	  fields: {
	    value: {
	      validate: assertShape({
	        raw: {
	          validate: assertValueType("string")
	        },
	        cooked: {
	          validate: assertValueType("string"),
	          optional: true
	        }
	      })
	    },
	    tail: {
	      "default": false
	    }
	  }
	});
	defineType$4("TemplateLiteral", {
	  visitor: ["quasis", "expressions"],
	  aliases: ["Expression", "Literal"],
	  fields: {
	    quasis: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
	    },
	    expressions: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "TSType")), function (node, key, val) {
	        if (node.quasis.length !== val.length + 1) {
	          throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
	        }
	      })
	    }
	  }
	});
	defineType$4("YieldExpression", {
	  builder: ["argument", "delegate"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    delegate: {
	      validate: chain$1(assertValueType("boolean"), Object.assign(function (node, key, val) {
	        if (!browser$4.env.BABEL_TYPES_8_BREAKING) return;

	        if (val && !node.argument) {
	          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
	        }
	      }, {
	        type: "boolean"
	      })),
	      "default": false
	    },
	    argument: {
	      optional: true,
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("AwaitExpression", {
	  builder: ["argument"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    argument: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$4("Import", {
	  aliases: ["Expression"]
	});
	defineType$4("BigIntLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$4("ExportNamespaceSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	defineType$4("OptionalMemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression"],
	  fields: {
	    object: {
	      validate: assertNodeType("Expression")
	    },
	    property: {
	      validate: function () {
	        var normal = assertNodeType("Identifier");
	        var computed = assertNodeType("Expression");

	        var validator = function validator(node, key, val) {
	          var validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };

	        validator.oneOfNodeTypes = ["Expression", "Identifier"];
	        return validator;
	      }()
	    },
	    computed: {
	      "default": false
	    },
	    optional: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain$1(assertValueType("boolean"), assertOptionalChainStart())
	    }
	  }
	});
	defineType$4("OptionalCallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments", "optional"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: assertNodeType("Expression")
	    },
	    arguments: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
	    },
	    optional: {
	      validate: !browser$4.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain$1(assertValueType("boolean"), assertOptionalChainStart())
	    },
	    typeArguments: {
	      validate: assertNodeType("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: assertNodeType("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType$4("ClassProperty", {
	  visitor: ["key", "value", "typeAnnotation", "decorators"],
	  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
	  aliases: ["Property"],
	  fields: Object.assign({}, classMethodOrPropertyCommon, {
	    value: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    },
	    definite: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    readonly: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    declare: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    variance: {
	      validate: assertNodeType("Variance"),
	      optional: true
	    }
	  })
	});
	defineType$4("ClassPrivateProperty", {
	  visitor: ["key", "value", "decorators", "typeAnnotation"],
	  builder: ["key", "value", "decorators", "static"],
	  aliases: ["Property", "Private"],
	  fields: {
	    key: {
	      validate: assertNodeType("PrivateName")
	    },
	    value: {
	      validate: assertNodeType("Expression"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    },
	    readonly: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    definite: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    variance: {
	      validate: assertNodeType("Variance"),
	      optional: true
	    }
	  }
	});
	defineType$4("ClassPrivateMethod", {
	  builder: ["kind", "key", "params", "body", "static"],
	  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
	    key: {
	      validate: assertNodeType("PrivateName")
	    },
	    body: {
	      validate: assertNodeType("BlockStatement")
	    }
	  })
	});
	defineType$4("PrivateName", {
	  visitor: ["id"],
	  aliases: ["Private"],
	  fields: {
	    id: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	defineType$4("StaticBlock", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
	    }
	  },
	  aliases: ["Scopable", "BlockParent", "FunctionParent"]
	});

	var defineType$3 = defineAliasedType("Flow");

	var defineInterfaceishType = function defineInterfaceishType(name, typeParameterType) {
	  if (typeParameterType === void 0) {
	    typeParameterType = "TypeParameterDeclaration";
	  }

	  defineType$3(name, {
	    builder: ["id", "typeParameters", "extends", "body"],
	    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
	    aliases: ["FlowDeclaration", "Statement", "Declaration"],
	    fields: {
	      id: validateType("Identifier"),
	      typeParameters: validateOptionalType(typeParameterType),
	      "extends": validateOptional(arrayOfType("InterfaceExtends")),
	      mixins: validateOptional(arrayOfType("InterfaceExtends")),
	      "implements": validateOptional(arrayOfType("ClassImplements")),
	      body: validateType("ObjectTypeAnnotation")
	    }
	  });
	};

	defineType$3("AnyTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("ArrayTypeAnnotation", {
	  visitor: ["elementType"],
	  aliases: ["FlowType"],
	  fields: {
	    elementType: validateType("FlowType")
	  }
	});
	defineType$3("BooleanTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("BooleanLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("NullLiteralTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("ClassImplements", {
	  visitor: ["id", "typeParameters"],
	  fields: {
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("DeclareClass");
	defineType$3("DeclareFunction", {
	  visitor: ["id"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier"),
	    predicate: validateOptionalType("DeclaredPredicate")
	  }
	});
	defineInterfaceishType("DeclareInterface");
	defineType$3("DeclareModule", {
	  builder: ["id", "body", "kind"],
	  visitor: ["id", "body"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType(["Identifier", "StringLiteral"]),
	    body: validateType("BlockStatement"),
	    kind: validateOptional(assertOneOf("CommonJS", "ES"))
	  }
	});
	defineType$3("DeclareModuleExports", {
	  visitor: ["typeAnnotation"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    typeAnnotation: validateType("TypeAnnotation")
	  }
	});
	defineType$3("DeclareTypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TypeParameterDeclaration"),
	    right: validateType("FlowType")
	  }
	});
	defineType$3("DeclareOpaqueType", {
	  visitor: ["id", "typeParameters", "supertype"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TypeParameterDeclaration"),
	    supertype: validateOptionalType("FlowType"),
	    impltype: validateOptionalType("FlowType")
	  }
	});
	defineType$3("DeclareVariable", {
	  visitor: ["id"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier")
	  }
	});
	defineType$3("DeclareExportDeclaration", {
	  visitor: ["declaration", "specifiers", "source"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    declaration: validateOptionalType("Flow"),
	    specifiers: validateOptional(arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
	    source: validateOptionalType("StringLiteral"),
	    "default": validateOptional(assertValueType("boolean"))
	  }
	});
	defineType$3("DeclareExportAllDeclaration", {
	  visitor: ["source"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    source: validateType("StringLiteral"),
	    exportKind: validateOptional(assertOneOf("type", "value"))
	  }
	});
	defineType$3("DeclaredPredicate", {
	  visitor: ["value"],
	  aliases: ["FlowPredicate"],
	  fields: {
	    value: validateType("Flow")
	  }
	});
	defineType$3("ExistsTypeAnnotation", {
	  aliases: ["FlowType"]
	});
	defineType$3("FunctionTypeAnnotation", {
	  visitor: ["typeParameters", "params", "rest", "returnType"],
	  aliases: ["FlowType"],
	  fields: {
	    typeParameters: validateOptionalType("TypeParameterDeclaration"),
	    params: validate$5(arrayOfType("FunctionTypeParam")),
	    rest: validateOptionalType("FunctionTypeParam"),
	    "this": validateOptionalType("FunctionTypeParam"),
	    returnType: validateType("FlowType")
	  }
	});
	defineType$3("FunctionTypeParam", {
	  visitor: ["name", "typeAnnotation"],
	  fields: {
	    name: validateOptionalType("Identifier"),
	    typeAnnotation: validateType("FlowType"),
	    optional: validateOptional(assertValueType("boolean"))
	  }
	});
	defineType$3("GenericTypeAnnotation", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["FlowType"],
	  fields: {
	    id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
	    typeParameters: validateOptionalType("TypeParameterInstantiation")
	  }
	});
	defineType$3("InferredPredicate", {
	  aliases: ["FlowPredicate"]
	});
	defineType$3("InterfaceExtends", {
	  visitor: ["id", "typeParameters"],
	  fields: {
	    id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
	    typeParameters: validateOptionalType("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("InterfaceDeclaration");
	defineType$3("InterfaceTypeAnnotation", {
	  visitor: ["extends", "body"],
	  aliases: ["FlowType"],
	  fields: {
	    "extends": validateOptional(arrayOfType("InterfaceExtends")),
	    body: validateType("ObjectTypeAnnotation")
	  }
	});
	defineType$3("IntersectionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: validate$5(arrayOfType("FlowType"))
	  }
	});
	defineType$3("MixedTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("EmptyTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("NullableTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  aliases: ["FlowType"],
	  fields: {
	    typeAnnotation: validateType("FlowType")
	  }
	});
	defineType$3("NumberLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: validate$5(assertValueType("number"))
	  }
	});
	defineType$3("NumberTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("ObjectTypeAnnotation", {
	  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
	  aliases: ["FlowType"],
	  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
	  fields: {
	    properties: validate$5(arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
	    indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
	    callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
	    internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
	    exact: {
	      validate: assertValueType("boolean"),
	      "default": false
	    },
	    inexact: validateOptional(assertValueType("boolean"))
	  }
	});
	defineType$3("ObjectTypeInternalSlot", {
	  visitor: ["id", "value", "optional", "static", "method"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    id: validateType("Identifier"),
	    value: validateType("FlowType"),
	    optional: validate$5(assertValueType("boolean")),
	    "static": validate$5(assertValueType("boolean")),
	    method: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("ObjectTypeCallProperty", {
	  visitor: ["value"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    value: validateType("FlowType"),
	    "static": validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("ObjectTypeIndexer", {
	  visitor: ["id", "key", "value", "variance"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    id: validateOptionalType("Identifier"),
	    key: validateType("FlowType"),
	    value: validateType("FlowType"),
	    "static": validate$5(assertValueType("boolean")),
	    variance: validateOptionalType("Variance")
	  }
	});
	defineType$3("ObjectTypeProperty", {
	  visitor: ["key", "value", "variance"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    key: validateType(["Identifier", "StringLiteral"]),
	    value: validateType("FlowType"),
	    kind: validate$5(assertOneOf("init", "get", "set")),
	    "static": validate$5(assertValueType("boolean")),
	    proto: validate$5(assertValueType("boolean")),
	    optional: validate$5(assertValueType("boolean")),
	    variance: validateOptionalType("Variance"),
	    method: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("ObjectTypeSpreadProperty", {
	  visitor: ["argument"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    argument: validateType("FlowType")
	  }
	});
	defineType$3("OpaqueType", {
	  visitor: ["id", "typeParameters", "supertype", "impltype"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TypeParameterDeclaration"),
	    supertype: validateOptionalType("FlowType"),
	    impltype: validateType("FlowType")
	  }
	});
	defineType$3("QualifiedTypeIdentifier", {
	  visitor: ["id", "qualification"],
	  fields: {
	    id: validateType("Identifier"),
	    qualification: validateType(["Identifier", "QualifiedTypeIdentifier"])
	  }
	});
	defineType$3("StringLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: validate$5(assertValueType("string"))
	  }
	});
	defineType$3("StringTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("SymbolTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("ThisTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("TupleTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: validate$5(arrayOfType("FlowType"))
	  }
	});
	defineType$3("TypeofTypeAnnotation", {
	  visitor: ["argument"],
	  aliases: ["FlowType"],
	  fields: {
	    argument: validateType("FlowType")
	  }
	});
	defineType$3("TypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TypeParameterDeclaration"),
	    right: validateType("FlowType")
	  }
	});
	defineType$3("TypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: validateType("FlowType")
	  }
	});
	defineType$3("TypeCastExpression", {
	  visitor: ["expression", "typeAnnotation"],
	  aliases: ["ExpressionWrapper", "Expression"],
	  fields: {
	    expression: validateType("Expression"),
	    typeAnnotation: validateType("TypeAnnotation")
	  }
	});
	defineType$3("TypeParameter", {
	  visitor: ["bound", "default", "variance"],
	  fields: {
	    name: validate$5(assertValueType("string")),
	    bound: validateOptionalType("TypeAnnotation"),
	    "default": validateOptionalType("FlowType"),
	    variance: validateOptionalType("Variance")
	  }
	});
	defineType$3("TypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: validate$5(arrayOfType("TypeParameter"))
	  }
	});
	defineType$3("TypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: validate$5(arrayOfType("FlowType"))
	  }
	});
	defineType$3("UnionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: validate$5(arrayOfType("FlowType"))
	  }
	});
	defineType$3("Variance", {
	  builder: ["kind"],
	  fields: {
	    kind: validate$5(assertOneOf("minus", "plus"))
	  }
	});
	defineType$3("VoidTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType$3("EnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: {
	    id: validateType("Identifier"),
	    body: validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
	  }
	});
	defineType$3("EnumBooleanBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: validate$5(assertValueType("boolean")),
	    members: validateArrayOfType("EnumBooleanMember"),
	    hasUnknownMembers: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("EnumNumberBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: validate$5(assertValueType("boolean")),
	    members: validateArrayOfType("EnumNumberMember"),
	    hasUnknownMembers: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("EnumStringBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: validate$5(assertValueType("boolean")),
	    members: validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"]),
	    hasUnknownMembers: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("EnumSymbolBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    members: validateArrayOfType("EnumDefaultedMember"),
	    hasUnknownMembers: validate$5(assertValueType("boolean"))
	  }
	});
	defineType$3("EnumBooleanMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id"],
	  fields: {
	    id: validateType("Identifier"),
	    init: validateType("BooleanLiteral")
	  }
	});
	defineType$3("EnumNumberMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id", "init"],
	  fields: {
	    id: validateType("Identifier"),
	    init: validateType("NumericLiteral")
	  }
	});
	defineType$3("EnumStringMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id", "init"],
	  fields: {
	    id: validateType("Identifier"),
	    init: validateType("StringLiteral")
	  }
	});
	defineType$3("EnumDefaultedMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id"],
	  fields: {
	    id: validateType("Identifier")
	  }
	});
	defineType$3("IndexedAccessType", {
	  visitor: ["objectType", "indexType"],
	  aliases: ["FlowType"],
	  fields: {
	    objectType: validateType("FlowType"),
	    indexType: validateType("FlowType")
	  }
	});
	defineType$3("OptionalIndexedAccessType", {
	  visitor: ["objectType", "indexType"],
	  aliases: ["FlowType"],
	  fields: {
	    objectType: validateType("FlowType"),
	    indexType: validateType("FlowType"),
	    optional: validate$5(assertValueType("boolean"))
	  }
	});

	var defineType$2 = defineAliasedType("JSX");
	defineType$2("JSXAttribute", {
	  visitor: ["name", "value"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
	    },
	    value: {
	      optional: true,
	      validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
	    }
	  }
	});
	defineType$2("JSXClosingElement", {
	  visitor: ["name"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
	    }
	  }
	});
	defineType$2("JSXElement", {
	  builder: ["openingElement", "closingElement", "children", "selfClosing"],
	  visitor: ["openingElement", "children", "closingElement"],
	  aliases: ["Immutable", "Expression"],
	  fields: {
	    openingElement: {
	      validate: assertNodeType("JSXOpeningElement")
	    },
	    closingElement: {
	      optional: true,
	      validate: assertNodeType("JSXClosingElement")
	    },
	    children: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    },
	    selfClosing: {
	      validate: assertValueType("boolean"),
	      optional: true
	    }
	  }
	});
	defineType$2("JSXEmptyExpression", {});
	defineType$2("JSXExpressionContainer", {
	  visitor: ["expression"],
	  aliases: ["Immutable"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression", "JSXEmptyExpression")
	    }
	  }
	});
	defineType$2("JSXSpreadChild", {
	  visitor: ["expression"],
	  aliases: ["Immutable"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$2("JSXIdentifier", {
	  builder: ["name"],
	  fields: {
	    name: {
	      validate: assertValueType("string")
	    }
	  }
	});
	defineType$2("JSXMemberExpression", {
	  visitor: ["object", "property"],
	  fields: {
	    object: {
	      validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
	    },
	    property: {
	      validate: assertNodeType("JSXIdentifier")
	    }
	  }
	});
	defineType$2("JSXNamespacedName", {
	  visitor: ["namespace", "name"],
	  fields: {
	    namespace: {
	      validate: assertNodeType("JSXIdentifier")
	    },
	    name: {
	      validate: assertNodeType("JSXIdentifier")
	    }
	  }
	});
	defineType$2("JSXOpeningElement", {
	  builder: ["name", "attributes", "selfClosing"],
	  visitor: ["name", "attributes"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
	    },
	    selfClosing: {
	      "default": false
	    },
	    attributes: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
	    },
	    typeParameters: {
	      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType$2("JSXSpreadAttribute", {
	  visitor: ["argument"],
	  fields: {
	    argument: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$2("JSXText", {
	  aliases: ["Immutable"],
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  }
	});
	defineType$2("JSXFragment", {
	  builder: ["openingFragment", "closingFragment", "children"],
	  visitor: ["openingFragment", "children", "closingFragment"],
	  aliases: ["Immutable", "Expression"],
	  fields: {
	    openingFragment: {
	      validate: assertNodeType("JSXOpeningFragment")
	    },
	    closingFragment: {
	      validate: assertNodeType("JSXClosingFragment")
	    },
	    children: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
	    }
	  }
	});
	defineType$2("JSXOpeningFragment", {
	  aliases: ["Immutable"]
	});
	defineType$2("JSXClosingFragment", {
	  aliases: ["Immutable"]
	});

	var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
	var PLACEHOLDERS_ALIAS = {
	  Declaration: ["Statement"],
	  Pattern: ["PatternLike", "LVal"]
	};

	for (var _i$3 = 0, _PLACEHOLDERS = PLACEHOLDERS; _i$3 < _PLACEHOLDERS.length; _i$3++) {
	  var type$2 = _PLACEHOLDERS[_i$3];
	  var alias = ALIAS_KEYS[type$2];
	  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type$2] = alias;
	}

	var PLACEHOLDERS_FLIPPED_ALIAS = {};
	Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
	  PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
	    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
	      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
	    }

	    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
	  });
	});

	var defineType$1 = defineAliasedType("Miscellaneous");
	{
	  defineType$1("Noop", {
	    visitor: []
	  });
	}
	defineType$1("Placeholder", {
	  visitor: [],
	  builder: ["expectedNode", "name"],
	  fields: {
	    name: {
	      validate: assertNodeType("Identifier")
	    },
	    expectedNode: {
	      validate: assertOneOf.apply(void 0, _toConsumableArray(PLACEHOLDERS))
	    }
	  }
	});
	defineType$1("V8IntrinsicIdentifier", {
	  builder: ["name"],
	  fields: {
	    name: {
	      validate: assertValueType("string")
	    }
	  }
	});

	defineType$5("ArgumentPlaceholder", {});
	defineType$5("BindExpression", {
	  visitor: ["object", "callee"],
	  aliases: ["Expression"],
	  fields: !browser$4.env.BABEL_TYPES_8_BREAKING ? {
	    object: {
	      validate: Object.assign(function () {}, {
	        oneOfNodeTypes: ["Expression"]
	      })
	    },
	    callee: {
	      validate: Object.assign(function () {}, {
	        oneOfNodeTypes: ["Expression"]
	      })
	    }
	  } : {
	    object: {
	      validate: assertNodeType("Expression")
	    },
	    callee: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$5("ImportAttribute", {
	  visitor: ["key", "value"],
	  fields: {
	    key: {
	      validate: assertNodeType("Identifier", "StringLiteral")
	    },
	    value: {
	      validate: assertNodeType("StringLiteral")
	    }
	  }
	});
	defineType$5("Decorator", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression")
	    }
	  }
	});
	defineType$5("DoExpression", {
	  visitor: ["body"],
	  builder: ["body", "async"],
	  aliases: ["Expression"],
	  fields: {
	    body: {
	      validate: assertNodeType("BlockStatement")
	    },
	    async: {
	      validate: assertValueType("boolean"),
	      "default": false
	    }
	  }
	});
	defineType$5("ExportDefaultSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: assertNodeType("Identifier")
	    }
	  }
	});
	defineType$5("RecordExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "SpreadElement")))
	    }
	  }
	});
	defineType$5("TupleExpression", {
	  fields: {
	    elements: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement"))),
	      "default": []
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	defineType$5("DecimalLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: assertValueType("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType$5("ModuleExpression", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: assertNodeType("Program")
	    }
	  },
	  aliases: ["Expression"]
	});
	defineType$5("TopicReference", {
	  aliases: ["Expression"]
	});
	defineType$5("PipelineTopicExpression", {
	  builder: ["expression"],
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  aliases: ["Expression"]
	});
	defineType$5("PipelineBareFunction", {
	  builder: ["callee"],
	  visitor: ["callee"],
	  fields: {
	    callee: {
	      validate: assertNodeType("Expression")
	    }
	  },
	  aliases: ["Expression"]
	});
	defineType$5("PipelinePrimaryTopicReference", {
	  aliases: ["Expression"]
	});

	var defineType = defineAliasedType("TypeScript");
	var bool = assertValueType("boolean");
	var tSFunctionTypeAnnotationCommon = {
	  returnType: {
	    validate: assertNodeType("TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	};
	defineType("TSParameterProperty", {
	  aliases: ["LVal"],
	  visitor: ["parameter"],
	  fields: {
	    accessibility: {
	      validate: assertOneOf("public", "private", "protected"),
	      optional: true
	    },
	    readonly: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    parameter: {
	      validate: assertNodeType("Identifier", "AssignmentPattern")
	    },
	    override: {
	      validate: assertValueType("boolean"),
	      optional: true
	    },
	    decorators: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
	      optional: true
	    }
	  }
	});
	defineType("TSDeclareFunction", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
	});
	defineType("TSDeclareMethod", {
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
	});
	defineType("TSQualifiedName", {
	  aliases: ["TSEntityName"],
	  visitor: ["left", "right"],
	  fields: {
	    left: validateType("TSEntityName"),
	    right: validateType("Identifier")
	  }
	});
	var signatureDeclarationCommon = {
	  typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
	  parameters: validateArrayOfType(["Identifier", "RestElement"]),
	  typeAnnotation: validateOptionalType("TSTypeAnnotation")
	};
	var callConstructSignatureDeclaration = {
	  aliases: ["TSTypeElement"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon
	};
	defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
	defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
	var namedTypeElementCommon = {
	  key: validateType("Expression"),
	  computed: validate$5(bool),
	  optional: validateOptional(bool)
	};
	defineType("TSPropertySignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeAnnotation", "initializer"],
	  fields: Object.assign({}, namedTypeElementCommon, {
	    readonly: validateOptional(bool),
	    typeAnnotation: validateOptionalType("TSTypeAnnotation"),
	    initializer: validateOptionalType("Expression"),
	    kind: {
	      validate: assertOneOf("get", "set")
	    }
	  })
	});
	defineType("TSMethodSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
	  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
	    kind: {
	      validate: assertOneOf("method", "get", "set")
	    }
	  })
	});
	defineType("TSIndexSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["parameters", "typeAnnotation"],
	  fields: {
	    readonly: validateOptional(bool),
	    "static": validateOptional(bool),
	    parameters: validateArrayOfType("Identifier"),
	    typeAnnotation: validateOptionalType("TSTypeAnnotation")
	  }
	});
	var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

	for (var _i$2 = 0, _tsKeywordTypes = tsKeywordTypes; _i$2 < _tsKeywordTypes.length; _i$2++) {
	  var type$1 = _tsKeywordTypes[_i$2];
	  defineType(type$1, {
	    aliases: ["TSType", "TSBaseType"],
	    visitor: [],
	    fields: {}
	  });
	}

	defineType("TSThisType", {
	  aliases: ["TSType", "TSBaseType"],
	  visitor: [],
	  fields: {}
	});
	var fnOrCtrBase = {
	  aliases: ["TSType"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"]
	};
	defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
	  fields: signatureDeclarationCommon
	}));
	defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
	  fields: Object.assign({}, signatureDeclarationCommon, {
	    "abstract": validateOptional(bool)
	  })
	}));
	defineType("TSTypeReference", {
	  aliases: ["TSType"],
	  visitor: ["typeName", "typeParameters"],
	  fields: {
	    typeName: validateType("TSEntityName"),
	    typeParameters: validateOptionalType("TSTypeParameterInstantiation")
	  }
	});
	defineType("TSTypePredicate", {
	  aliases: ["TSType"],
	  visitor: ["parameterName", "typeAnnotation"],
	  builder: ["parameterName", "typeAnnotation", "asserts"],
	  fields: {
	    parameterName: validateType(["Identifier", "TSThisType"]),
	    typeAnnotation: validateOptionalType("TSTypeAnnotation"),
	    asserts: validateOptional(bool)
	  }
	});
	defineType("TSTypeQuery", {
	  aliases: ["TSType"],
	  visitor: ["exprName"],
	  fields: {
	    exprName: validateType(["TSEntityName", "TSImportType"])
	  }
	});
	defineType("TSTypeLiteral", {
	  aliases: ["TSType"],
	  visitor: ["members"],
	  fields: {
	    members: validateArrayOfType("TSTypeElement")
	  }
	});
	defineType("TSArrayType", {
	  aliases: ["TSType"],
	  visitor: ["elementType"],
	  fields: {
	    elementType: validateType("TSType")
	  }
	});
	defineType("TSTupleType", {
	  aliases: ["TSType"],
	  visitor: ["elementTypes"],
	  fields: {
	    elementTypes: validateArrayOfType(["TSType", "TSNamedTupleMember"])
	  }
	});
	defineType("TSOptionalType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSRestType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSNamedTupleMember", {
	  visitor: ["label", "elementType"],
	  builder: ["label", "elementType", "optional"],
	  fields: {
	    label: validateType("Identifier"),
	    optional: {
	      validate: bool,
	      "default": false
	    },
	    elementType: validateType("TSType")
	  }
	});
	var unionOrIntersection = {
	  aliases: ["TSType"],
	  visitor: ["types"],
	  fields: {
	    types: validateArrayOfType("TSType")
	  }
	};
	defineType("TSUnionType", unionOrIntersection);
	defineType("TSIntersectionType", unionOrIntersection);
	defineType("TSConditionalType", {
	  aliases: ["TSType"],
	  visitor: ["checkType", "extendsType", "trueType", "falseType"],
	  fields: {
	    checkType: validateType("TSType"),
	    extendsType: validateType("TSType"),
	    trueType: validateType("TSType"),
	    falseType: validateType("TSType")
	  }
	});
	defineType("TSInferType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter"],
	  fields: {
	    typeParameter: validateType("TSTypeParameter")
	  }
	});
	defineType("TSParenthesizedType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSTypeOperator", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    operator: validate$5(assertValueType("string")),
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSIndexedAccessType", {
	  aliases: ["TSType"],
	  visitor: ["objectType", "indexType"],
	  fields: {
	    objectType: validateType("TSType"),
	    indexType: validateType("TSType")
	  }
	});
	defineType("TSMappedType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter", "typeAnnotation", "nameType"],
	  fields: {
	    readonly: validateOptional(bool),
	    typeParameter: validateType("TSTypeParameter"),
	    optional: validateOptional(bool),
	    typeAnnotation: validateOptionalType("TSType"),
	    nameType: validateOptionalType("TSType")
	  }
	});
	defineType("TSLiteralType", {
	  aliases: ["TSType", "TSBaseType"],
	  visitor: ["literal"],
	  fields: {
	    literal: {
	      validate: function () {
	        var unaryExpression = assertNodeType("NumericLiteral", "BigIntLiteral");
	        var unaryOperator = assertOneOf("-");
	        var literal = assertNodeType("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");

	        function validator(parent, key, node) {
	          if (is$1("UnaryExpression", node)) {
	            unaryOperator(node, "operator", node.operator);
	            unaryExpression(node, "argument", node.argument);
	          } else {
	            literal(parent, key, node);
	          }
	        }

	        validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"];
	        return validator;
	      }()
	    }
	  }
	});
	defineType("TSExpressionWithTypeArguments", {
	  aliases: ["TSType"],
	  visitor: ["expression", "typeParameters"],
	  fields: {
	    expression: validateType("TSEntityName"),
	    typeParameters: validateOptionalType("TSTypeParameterInstantiation")
	  }
	});
	defineType("TSInterfaceDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "extends", "body"],
	  fields: {
	    declare: validateOptional(bool),
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
	    "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
	    body: validateType("TSInterfaceBody")
	  }
	});
	defineType("TSInterfaceBody", {
	  visitor: ["body"],
	  fields: {
	    body: validateArrayOfType("TSTypeElement")
	  }
	});
	defineType("TSTypeAliasDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "typeAnnotation"],
	  fields: {
	    declare: validateOptional(bool),
	    id: validateType("Identifier"),
	    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSAsExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression", "typeAnnotation"],
	  fields: {
	    expression: validateType("Expression"),
	    typeAnnotation: validateType("TSType")
	  }
	});
	defineType("TSTypeAssertion", {
	  aliases: ["Expression"],
	  visitor: ["typeAnnotation", "expression"],
	  fields: {
	    typeAnnotation: validateType("TSType"),
	    expression: validateType("Expression")
	  }
	});
	defineType("TSEnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "members"],
	  fields: {
	    declare: validateOptional(bool),
	    "const": validateOptional(bool),
	    id: validateType("Identifier"),
	    members: validateArrayOfType("TSEnumMember"),
	    initializer: validateOptionalType("Expression")
	  }
	});
	defineType("TSEnumMember", {
	  visitor: ["id", "initializer"],
	  fields: {
	    id: validateType(["Identifier", "StringLiteral"]),
	    initializer: validateOptionalType("Expression")
	  }
	});
	defineType("TSModuleDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: {
	    declare: validateOptional(bool),
	    global: validateOptional(bool),
	    id: validateType(["Identifier", "StringLiteral"]),
	    body: validateType(["TSModuleBlock", "TSModuleDeclaration"])
	  }
	});
	defineType("TSModuleBlock", {
	  aliases: ["Scopable", "Block", "BlockParent"],
	  visitor: ["body"],
	  fields: {
	    body: validateArrayOfType("Statement")
	  }
	});
	defineType("TSImportType", {
	  aliases: ["TSType"],
	  visitor: ["argument", "qualifier", "typeParameters"],
	  fields: {
	    argument: validateType("StringLiteral"),
	    qualifier: validateOptionalType("TSEntityName"),
	    typeParameters: validateOptionalType("TSTypeParameterInstantiation")
	  }
	});
	defineType("TSImportEqualsDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id", "moduleReference"],
	  fields: {
	    isExport: validate$5(bool),
	    id: validateType("Identifier"),
	    moduleReference: validateType(["TSEntityName", "TSExternalModuleReference"]),
	    importKind: {
	      validate: assertOneOf("type", "value"),
	      optional: true
	    }
	  }
	});
	defineType("TSExternalModuleReference", {
	  visitor: ["expression"],
	  fields: {
	    expression: validateType("StringLiteral")
	  }
	});
	defineType("TSNonNullExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression"],
	  fields: {
	    expression: validateType("Expression")
	  }
	});
	defineType("TSExportAssignment", {
	  aliases: ["Statement"],
	  visitor: ["expression"],
	  fields: {
	    expression: validateType("Expression")
	  }
	});
	defineType("TSNamespaceExportDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id"],
	  fields: {
	    id: validateType("Identifier")
	  }
	});
	defineType("TSTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: {
	      validate: assertNodeType("TSType")
	    }
	  }
	});
	defineType("TSTypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSType")))
	    }
	  }
	});
	defineType("TSTypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: {
	      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
	    }
	  }
	});
	defineType("TSTypeParameter", {
	  builder: ["constraint", "default", "name"],
	  visitor: ["constraint", "default"],
	  fields: {
	    name: {
	      validate: assertValueType("string")
	    },
	    constraint: {
	      validate: assertNodeType("TSType"),
	      optional: true
	    },
	    "default": {
	      validate: assertNodeType("TSType"),
	      optional: true
	    }
	  }
	});

	toFastProperties(VISITOR_KEYS$6);
	toFastProperties(ALIAS_KEYS);
	toFastProperties(FLIPPED_ALIAS_KEYS$3);
	toFastProperties(NODE_FIELDS);
	toFastProperties(BUILDER_KEYS);
	toFastProperties(DEPRECATED_KEYS$1);
	toFastProperties(PLACEHOLDERS_ALIAS);
	toFastProperties(PLACEHOLDERS_FLIPPED_ALIAS);
	var TYPES$1 = [].concat(Object.keys(VISITOR_KEYS$6), Object.keys(FLIPPED_ALIAS_KEYS$3), Object.keys(DEPRECATED_KEYS$1));

	function builder() {
	  var type = this;
	  var keys = BUILDER_KEYS[type];
	  var countArgs = arguments.length;

	  if (countArgs > keys.length) {
	    throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
	  }

	  var node = {
	    type: type
	  };

	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    var field = NODE_FIELDS[type][key];
	    var arg = void 0;
	    if (i < countArgs) arg = arguments[i];

	    if (arg === undefined) {
	      arg = Array.isArray(field["default"]) ? [] : field["default"];
	    }

	    node[key] = arg;
	  }

	  for (var _key in node) {
	    validate$6(node, _key, node[_key]);
	  }

	  return node;
	}

	function arrayExpression$2(elements) {
	  return builder.apply("ArrayExpression", arguments);
	}
	function assignmentExpression$c(operator, left, right) {
	  return builder.apply("AssignmentExpression", arguments);
	}
	function binaryExpression$4(operator, left, right) {
	  return builder.apply("BinaryExpression", arguments);
	}
	function interpreterDirective$1(value) {
	  return builder.apply("InterpreterDirective", arguments);
	}
	function directive$1(value) {
	  return builder.apply("Directive", arguments);
	}
	function directiveLiteral$1(value) {
	  return builder.apply("DirectiveLiteral", arguments);
	}
	function blockStatement$6(body, directives) {
	  return builder.apply("BlockStatement", arguments);
	}
	function breakStatement(label) {
	  return builder.apply("BreakStatement", arguments);
	}
	function callExpression$e(callee, _arguments) {
	  return builder.apply("CallExpression", arguments);
	}
	function catchClause(param, body) {
	  return builder.apply("CatchClause", arguments);
	}
	function conditionalExpression$3(test, consequent, alternate) {
	  return builder.apply("ConditionalExpression", arguments);
	}
	function continueStatement(label) {
	  return builder.apply("ContinueStatement", arguments);
	}
	function debuggerStatement() {
	  return builder.apply("DebuggerStatement", arguments);
	}
	function doWhileStatement(test, body) {
	  return builder.apply("DoWhileStatement", arguments);
	}
	function emptyStatement$1() {
	  return builder.apply("EmptyStatement", arguments);
	}
	function expressionStatement$a(expression) {
	  return builder.apply("ExpressionStatement", arguments);
	}
	function file$1(program, comments, tokens) {
	  return builder.apply("File", arguments);
	}
	function forInStatement(left, right, body) {
	  return builder.apply("ForInStatement", arguments);
	}
	function forStatement(init, test, update, body) {
	  return builder.apply("ForStatement", arguments);
	}
	function functionDeclaration(id, params, body, generator, async) {
	  return builder.apply("FunctionDeclaration", arguments);
	}
	function functionExpression$3(id, params, body, generator, async) {
	  return builder.apply("FunctionExpression", arguments);
	}
	function identifier$j(name) {
	  return builder.apply("Identifier", arguments);
	}
	function ifStatement(test, consequent, alternate) {
	  return builder.apply("IfStatement", arguments);
	}
	function labeledStatement(label, body) {
	  return builder.apply("LabeledStatement", arguments);
	}
	function stringLiteral$8(value) {
	  return builder.apply("StringLiteral", arguments);
	}
	function numericLiteral$8(value) {
	  return builder.apply("NumericLiteral", arguments);
	}
	function nullLiteral$2() {
	  return builder.apply("NullLiteral", arguments);
	}
	function booleanLiteral$5(value) {
	  return builder.apply("BooleanLiteral", arguments);
	}
	function regExpLiteral(pattern, flags) {
	  return builder.apply("RegExpLiteral", arguments);
	}
	function logicalExpression$2(operator, left, right) {
	  return builder.apply("LogicalExpression", arguments);
	}
	function memberExpression$b(object, property, computed, optional) {
	  return builder.apply("MemberExpression", arguments);
	}
	function newExpression(callee, _arguments) {
	  return builder.apply("NewExpression", arguments);
	}
	function program$3(body, directives, sourceType, interpreter) {
	  return builder.apply("Program", arguments);
	}
	function objectExpression$4(properties) {
	  return builder.apply("ObjectExpression", arguments);
	}
	function objectMethod(kind, key, params, body, computed, generator, async) {
	  return builder.apply("ObjectMethod", arguments);
	}
	function objectProperty$2(key, value, computed, shorthand, decorators) {
	  return builder.apply("ObjectProperty", arguments);
	}
	function restElement$1(argument) {
	  return builder.apply("RestElement", arguments);
	}
	function returnStatement$3(argument) {
	  return builder.apply("ReturnStatement", arguments);
	}
	function sequenceExpression$7(expressions) {
	  return builder.apply("SequenceExpression", arguments);
	}
	function parenthesizedExpression(expression) {
	  return builder.apply("ParenthesizedExpression", arguments);
	}
	function switchCase(test, consequent) {
	  return builder.apply("SwitchCase", arguments);
	}
	function switchStatement(discriminant, cases) {
	  return builder.apply("SwitchStatement", arguments);
	}
	function thisExpression$3() {
	  return builder.apply("ThisExpression", arguments);
	}
	function throwStatement(argument) {
	  return builder.apply("ThrowStatement", arguments);
	}
	function tryStatement(block, handler, finalizer) {
	  return builder.apply("TryStatement", arguments);
	}
	function unaryExpression$7(operator, argument, prefix) {
	  return builder.apply("UnaryExpression", arguments);
	}
	function updateExpression(operator, argument, prefix) {
	  return builder.apply("UpdateExpression", arguments);
	}
	function variableDeclaration$8(kind, declarations) {
	  return builder.apply("VariableDeclaration", arguments);
	}
	function variableDeclarator$8(id, init) {
	  return builder.apply("VariableDeclarator", arguments);
	}
	function whileStatement(test, body) {
	  return builder.apply("WhileStatement", arguments);
	}
	function withStatement(object, body) {
	  return builder.apply("WithStatement", arguments);
	}
	function assignmentPattern(left, right) {
	  return builder.apply("AssignmentPattern", arguments);
	}
	function arrayPattern(elements) {
	  return builder.apply("ArrayPattern", arguments);
	}
	function arrowFunctionExpression$4(params, body, async) {
	  return builder.apply("ArrowFunctionExpression", arguments);
	}
	function classBody(body) {
	  return builder.apply("ClassBody", arguments);
	}
	function classExpression(id, superClass, body, decorators) {
	  return builder.apply("ClassExpression", arguments);
	}
	function classDeclaration(id, superClass, body, decorators) {
	  return builder.apply("ClassDeclaration", arguments);
	}
	function exportAllDeclaration(source) {
	  return builder.apply("ExportAllDeclaration", arguments);
	}
	function exportDefaultDeclaration(declaration) {
	  return builder.apply("ExportDefaultDeclaration", arguments);
	}
	function exportNamedDeclaration$2(declaration, specifiers, source) {
	  return builder.apply("ExportNamedDeclaration", arguments);
	}
	function exportSpecifier$2(local, exported) {
	  return builder.apply("ExportSpecifier", arguments);
	}
	function forOfStatement(left, right, body, _await) {
	  return builder.apply("ForOfStatement", arguments);
	}
	function importDeclaration$1(specifiers, source) {
	  return builder.apply("ImportDeclaration", arguments);
	}
	function importDefaultSpecifier$1(local) {
	  return builder.apply("ImportDefaultSpecifier", arguments);
	}
	function importNamespaceSpecifier$1(local) {
	  return builder.apply("ImportNamespaceSpecifier", arguments);
	}
	function importSpecifier$1(local, imported) {
	  return builder.apply("ImportSpecifier", arguments);
	}
	function metaProperty$1(meta, property) {
	  return builder.apply("MetaProperty", arguments);
	}
	function classMethod(kind, key, params, body, computed, _static, generator, async) {
	  return builder.apply("ClassMethod", arguments);
	}
	function objectPattern(properties) {
	  return builder.apply("ObjectPattern", arguments);
	}
	function spreadElement$2(argument) {
	  return builder.apply("SpreadElement", arguments);
	}

	function _super$1() {
	  return builder.apply("Super", arguments);
	}
	function taggedTemplateExpression(tag, quasi) {
	  return builder.apply("TaggedTemplateExpression", arguments);
	}
	function templateElement(value, tail) {
	  return builder.apply("TemplateElement", arguments);
	}
	function templateLiteral(quasis, expressions) {
	  return builder.apply("TemplateLiteral", arguments);
	}
	function yieldExpression$2(argument, delegate) {
	  return builder.apply("YieldExpression", arguments);
	}
	function awaitExpression$1(argument) {
	  return builder.apply("AwaitExpression", arguments);
	}

	function _import() {
	  return builder.apply("Import", arguments);
	}
	function bigIntLiteral(value) {
	  return builder.apply("BigIntLiteral", arguments);
	}
	function exportNamespaceSpecifier(exported) {
	  return builder.apply("ExportNamespaceSpecifier", arguments);
	}
	function optionalMemberExpression$2(object, property, computed, optional) {
	  return builder.apply("OptionalMemberExpression", arguments);
	}
	function optionalCallExpression$2(callee, _arguments, optional) {
	  return builder.apply("OptionalCallExpression", arguments);
	}
	function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
	  return builder.apply("ClassProperty", arguments);
	}
	function classPrivateProperty(key, value, decorators, _static) {
	  return builder.apply("ClassPrivateProperty", arguments);
	}
	function classPrivateMethod(kind, key, params, body, _static) {
	  return builder.apply("ClassPrivateMethod", arguments);
	}
	function privateName(id) {
	  return builder.apply("PrivateName", arguments);
	}
	function staticBlock$1(body) {
	  return builder.apply("StaticBlock", arguments);
	}
	function anyTypeAnnotation$2() {
	  return builder.apply("AnyTypeAnnotation", arguments);
	}
	function arrayTypeAnnotation$1(elementType) {
	  return builder.apply("ArrayTypeAnnotation", arguments);
	}
	function booleanTypeAnnotation$1() {
	  return builder.apply("BooleanTypeAnnotation", arguments);
	}
	function booleanLiteralTypeAnnotation(value) {
	  return builder.apply("BooleanLiteralTypeAnnotation", arguments);
	}
	function nullLiteralTypeAnnotation$1() {
	  return builder.apply("NullLiteralTypeAnnotation", arguments);
	}
	function classImplements(id, typeParameters) {
	  return builder.apply("ClassImplements", arguments);
	}
	function declareClass(id, typeParameters, _extends, body) {
	  return builder.apply("DeclareClass", arguments);
	}
	function declareFunction(id) {
	  return builder.apply("DeclareFunction", arguments);
	}
	function declareInterface(id, typeParameters, _extends, body) {
	  return builder.apply("DeclareInterface", arguments);
	}
	function declareModule(id, body, kind) {
	  return builder.apply("DeclareModule", arguments);
	}
	function declareModuleExports(typeAnnotation) {
	  return builder.apply("DeclareModuleExports", arguments);
	}
	function declareTypeAlias(id, typeParameters, right) {
	  return builder.apply("DeclareTypeAlias", arguments);
	}
	function declareOpaqueType(id, typeParameters, supertype) {
	  return builder.apply("DeclareOpaqueType", arguments);
	}
	function declareVariable(id) {
	  return builder.apply("DeclareVariable", arguments);
	}
	function declareExportDeclaration(declaration, specifiers, source) {
	  return builder.apply("DeclareExportDeclaration", arguments);
	}
	function declareExportAllDeclaration(source) {
	  return builder.apply("DeclareExportAllDeclaration", arguments);
	}
	function declaredPredicate(value) {
	  return builder.apply("DeclaredPredicate", arguments);
	}
	function existsTypeAnnotation() {
	  return builder.apply("ExistsTypeAnnotation", arguments);
	}
	function functionTypeAnnotation(typeParameters, params, rest, returnType) {
	  return builder.apply("FunctionTypeAnnotation", arguments);
	}
	function functionTypeParam(name, typeAnnotation) {
	  return builder.apply("FunctionTypeParam", arguments);
	}
	function genericTypeAnnotation$1(id, typeParameters) {
	  return builder.apply("GenericTypeAnnotation", arguments);
	}
	function inferredPredicate() {
	  return builder.apply("InferredPredicate", arguments);
	}
	function interfaceExtends(id, typeParameters) {
	  return builder.apply("InterfaceExtends", arguments);
	}
	function interfaceDeclaration(id, typeParameters, _extends, body) {
	  return builder.apply("InterfaceDeclaration", arguments);
	}
	function interfaceTypeAnnotation(_extends, body) {
	  return builder.apply("InterfaceTypeAnnotation", arguments);
	}
	function intersectionTypeAnnotation(types) {
	  return builder.apply("IntersectionTypeAnnotation", arguments);
	}
	function mixedTypeAnnotation() {
	  return builder.apply("MixedTypeAnnotation", arguments);
	}
	function emptyTypeAnnotation() {
	  return builder.apply("EmptyTypeAnnotation", arguments);
	}
	function nullableTypeAnnotation(typeAnnotation) {
	  return builder.apply("NullableTypeAnnotation", arguments);
	}
	function numberLiteralTypeAnnotation(value) {
	  return builder.apply("NumberLiteralTypeAnnotation", arguments);
	}
	function numberTypeAnnotation$2() {
	  return builder.apply("NumberTypeAnnotation", arguments);
	}
	function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
	  return builder.apply("ObjectTypeAnnotation", arguments);
	}
	function objectTypeInternalSlot(id, value, optional, _static, method) {
	  return builder.apply("ObjectTypeInternalSlot", arguments);
	}
	function objectTypeCallProperty(value) {
	  return builder.apply("ObjectTypeCallProperty", arguments);
	}
	function objectTypeIndexer(id, key, value, variance) {
	  return builder.apply("ObjectTypeIndexer", arguments);
	}
	function objectTypeProperty(key, value, variance) {
	  return builder.apply("ObjectTypeProperty", arguments);
	}
	function objectTypeSpreadProperty(argument) {
	  return builder.apply("ObjectTypeSpreadProperty", arguments);
	}
	function opaqueType(id, typeParameters, supertype, impltype) {
	  return builder.apply("OpaqueType", arguments);
	}
	function qualifiedTypeIdentifier(id, qualification) {
	  return builder.apply("QualifiedTypeIdentifier", arguments);
	}
	function stringLiteralTypeAnnotation(value) {
	  return builder.apply("StringLiteralTypeAnnotation", arguments);
	}
	function stringTypeAnnotation$2() {
	  return builder.apply("StringTypeAnnotation", arguments);
	}
	function symbolTypeAnnotation() {
	  return builder.apply("SymbolTypeAnnotation", arguments);
	}
	function thisTypeAnnotation() {
	  return builder.apply("ThisTypeAnnotation", arguments);
	}
	function tupleTypeAnnotation$1(types) {
	  return builder.apply("TupleTypeAnnotation", arguments);
	}
	function typeofTypeAnnotation(argument) {
	  return builder.apply("TypeofTypeAnnotation", arguments);
	}
	function typeAlias(id, typeParameters, right) {
	  return builder.apply("TypeAlias", arguments);
	}
	function typeAnnotation(typeAnnotation) {
	  return builder.apply("TypeAnnotation", arguments);
	}
	function typeCastExpression(expression, typeAnnotation) {
	  return builder.apply("TypeCastExpression", arguments);
	}
	function typeParameter(bound, _default, variance) {
	  return builder.apply("TypeParameter", arguments);
	}
	function typeParameterDeclaration(params) {
	  return builder.apply("TypeParameterDeclaration", arguments);
	}
	function typeParameterInstantiation(params) {
	  return builder.apply("TypeParameterInstantiation", arguments);
	}
	function unionTypeAnnotation$1(types) {
	  return builder.apply("UnionTypeAnnotation", arguments);
	}
	function variance(kind) {
	  return builder.apply("Variance", arguments);
	}
	function voidTypeAnnotation$3() {
	  return builder.apply("VoidTypeAnnotation", arguments);
	}
	function enumDeclaration(id, body) {
	  return builder.apply("EnumDeclaration", arguments);
	}
	function enumBooleanBody(members) {
	  return builder.apply("EnumBooleanBody", arguments);
	}
	function enumNumberBody(members) {
	  return builder.apply("EnumNumberBody", arguments);
	}
	function enumStringBody(members) {
	  return builder.apply("EnumStringBody", arguments);
	}
	function enumSymbolBody(members) {
	  return builder.apply("EnumSymbolBody", arguments);
	}
	function enumBooleanMember(id) {
	  return builder.apply("EnumBooleanMember", arguments);
	}
	function enumNumberMember(id, init) {
	  return builder.apply("EnumNumberMember", arguments);
	}
	function enumStringMember(id, init) {
	  return builder.apply("EnumStringMember", arguments);
	}
	function enumDefaultedMember(id) {
	  return builder.apply("EnumDefaultedMember", arguments);
	}
	function indexedAccessType(objectType, indexType) {
	  return builder.apply("IndexedAccessType", arguments);
	}
	function optionalIndexedAccessType(objectType, indexType) {
	  return builder.apply("OptionalIndexedAccessType", arguments);
	}
	function jsxAttribute(name, value) {
	  return builder.apply("JSXAttribute", arguments);
	}
	function jsxClosingElement(name) {
	  return builder.apply("JSXClosingElement", arguments);
	}
	function jsxElement(openingElement, closingElement, children, selfClosing) {
	  return builder.apply("JSXElement", arguments);
	}
	function jsxEmptyExpression() {
	  return builder.apply("JSXEmptyExpression", arguments);
	}
	function jsxExpressionContainer$1(expression) {
	  return builder.apply("JSXExpressionContainer", arguments);
	}
	function jsxSpreadChild(expression) {
	  return builder.apply("JSXSpreadChild", arguments);
	}
	function jsxIdentifier$2(name) {
	  return builder.apply("JSXIdentifier", arguments);
	}
	function jsxMemberExpression$1(object, property) {
	  return builder.apply("JSXMemberExpression", arguments);
	}
	function jsxNamespacedName(namespace, name) {
	  return builder.apply("JSXNamespacedName", arguments);
	}
	function jsxOpeningElement(name, attributes, selfClosing) {
	  return builder.apply("JSXOpeningElement", arguments);
	}
	function jsxSpreadAttribute(argument) {
	  return builder.apply("JSXSpreadAttribute", arguments);
	}
	function jsxText(value) {
	  return builder.apply("JSXText", arguments);
	}
	function jsxFragment(openingFragment, closingFragment, children) {
	  return builder.apply("JSXFragment", arguments);
	}
	function jsxOpeningFragment() {
	  return builder.apply("JSXOpeningFragment", arguments);
	}
	function jsxClosingFragment() {
	  return builder.apply("JSXClosingFragment", arguments);
	}
	function noop$1() {
	  return builder.apply("Noop", arguments);
	}
	function placeholder(expectedNode, name) {
	  return builder.apply("Placeholder", arguments);
	}
	function v8IntrinsicIdentifier(name) {
	  return builder.apply("V8IntrinsicIdentifier", arguments);
	}
	function argumentPlaceholder() {
	  return builder.apply("ArgumentPlaceholder", arguments);
	}
	function bindExpression(object, callee) {
	  return builder.apply("BindExpression", arguments);
	}
	function importAttribute(key, value) {
	  return builder.apply("ImportAttribute", arguments);
	}
	function decorator(expression) {
	  return builder.apply("Decorator", arguments);
	}
	function doExpression(body, async) {
	  return builder.apply("DoExpression", arguments);
	}
	function exportDefaultSpecifier(exported) {
	  return builder.apply("ExportDefaultSpecifier", arguments);
	}
	function recordExpression(properties) {
	  return builder.apply("RecordExpression", arguments);
	}
	function tupleExpression(elements) {
	  return builder.apply("TupleExpression", arguments);
	}
	function decimalLiteral(value) {
	  return builder.apply("DecimalLiteral", arguments);
	}
	function moduleExpression(body) {
	  return builder.apply("ModuleExpression", arguments);
	}
	function topicReference() {
	  return builder.apply("TopicReference", arguments);
	}
	function pipelineTopicExpression(expression) {
	  return builder.apply("PipelineTopicExpression", arguments);
	}
	function pipelineBareFunction(callee) {
	  return builder.apply("PipelineBareFunction", arguments);
	}
	function pipelinePrimaryTopicReference() {
	  return builder.apply("PipelinePrimaryTopicReference", arguments);
	}
	function tsParameterProperty(parameter) {
	  return builder.apply("TSParameterProperty", arguments);
	}
	function tsDeclareFunction(id, typeParameters, params, returnType) {
	  return builder.apply("TSDeclareFunction", arguments);
	}
	function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
	  return builder.apply("TSDeclareMethod", arguments);
	}
	function tsQualifiedName(left, right) {
	  return builder.apply("TSQualifiedName", arguments);
	}
	function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
	  return builder.apply("TSCallSignatureDeclaration", arguments);
	}
	function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
	  return builder.apply("TSConstructSignatureDeclaration", arguments);
	}
	function tsPropertySignature(key, typeAnnotation, initializer) {
	  return builder.apply("TSPropertySignature", arguments);
	}
	function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
	  return builder.apply("TSMethodSignature", arguments);
	}
	function tsIndexSignature(parameters, typeAnnotation) {
	  return builder.apply("TSIndexSignature", arguments);
	}
	function tsAnyKeyword() {
	  return builder.apply("TSAnyKeyword", arguments);
	}
	function tsBooleanKeyword() {
	  return builder.apply("TSBooleanKeyword", arguments);
	}
	function tsBigIntKeyword() {
	  return builder.apply("TSBigIntKeyword", arguments);
	}
	function tsIntrinsicKeyword() {
	  return builder.apply("TSIntrinsicKeyword", arguments);
	}
	function tsNeverKeyword() {
	  return builder.apply("TSNeverKeyword", arguments);
	}
	function tsNullKeyword() {
	  return builder.apply("TSNullKeyword", arguments);
	}
	function tsNumberKeyword() {
	  return builder.apply("TSNumberKeyword", arguments);
	}
	function tsObjectKeyword() {
	  return builder.apply("TSObjectKeyword", arguments);
	}
	function tsStringKeyword() {
	  return builder.apply("TSStringKeyword", arguments);
	}
	function tsSymbolKeyword() {
	  return builder.apply("TSSymbolKeyword", arguments);
	}
	function tsUndefinedKeyword() {
	  return builder.apply("TSUndefinedKeyword", arguments);
	}
	function tsUnknownKeyword() {
	  return builder.apply("TSUnknownKeyword", arguments);
	}
	function tsVoidKeyword() {
	  return builder.apply("TSVoidKeyword", arguments);
	}
	function tsThisType() {
	  return builder.apply("TSThisType", arguments);
	}
	function tsFunctionType(typeParameters, parameters, typeAnnotation) {
	  return builder.apply("TSFunctionType", arguments);
	}
	function tsConstructorType(typeParameters, parameters, typeAnnotation) {
	  return builder.apply("TSConstructorType", arguments);
	}
	function tsTypeReference(typeName, typeParameters) {
	  return builder.apply("TSTypeReference", arguments);
	}
	function tsTypePredicate(parameterName, typeAnnotation, asserts) {
	  return builder.apply("TSTypePredicate", arguments);
	}
	function tsTypeQuery(exprName) {
	  return builder.apply("TSTypeQuery", arguments);
	}
	function tsTypeLiteral(members) {
	  return builder.apply("TSTypeLiteral", arguments);
	}
	function tsArrayType(elementType) {
	  return builder.apply("TSArrayType", arguments);
	}
	function tsTupleType(elementTypes) {
	  return builder.apply("TSTupleType", arguments);
	}
	function tsOptionalType(typeAnnotation) {
	  return builder.apply("TSOptionalType", arguments);
	}
	function tsRestType(typeAnnotation) {
	  return builder.apply("TSRestType", arguments);
	}
	function tsNamedTupleMember(label, elementType, optional) {
	  return builder.apply("TSNamedTupleMember", arguments);
	}
	function tsUnionType(types) {
	  return builder.apply("TSUnionType", arguments);
	}
	function tsIntersectionType(types) {
	  return builder.apply("TSIntersectionType", arguments);
	}
	function tsConditionalType(checkType, extendsType, trueType, falseType) {
	  return builder.apply("TSConditionalType", arguments);
	}
	function tsInferType(typeParameter) {
	  return builder.apply("TSInferType", arguments);
	}
	function tsParenthesizedType(typeAnnotation) {
	  return builder.apply("TSParenthesizedType", arguments);
	}
	function tsTypeOperator(typeAnnotation) {
	  return builder.apply("TSTypeOperator", arguments);
	}
	function tsIndexedAccessType(objectType, indexType) {
	  return builder.apply("TSIndexedAccessType", arguments);
	}
	function tsMappedType(typeParameter, typeAnnotation, nameType) {
	  return builder.apply("TSMappedType", arguments);
	}
	function tsLiteralType(literal) {
	  return builder.apply("TSLiteralType", arguments);
	}
	function tsExpressionWithTypeArguments(expression, typeParameters) {
	  return builder.apply("TSExpressionWithTypeArguments", arguments);
	}
	function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
	  return builder.apply("TSInterfaceDeclaration", arguments);
	}
	function tsInterfaceBody(body) {
	  return builder.apply("TSInterfaceBody", arguments);
	}
	function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
	  return builder.apply("TSTypeAliasDeclaration", arguments);
	}
	function tsAsExpression(expression, typeAnnotation) {
	  return builder.apply("TSAsExpression", arguments);
	}
	function tsTypeAssertion(typeAnnotation, expression) {
	  return builder.apply("TSTypeAssertion", arguments);
	}
	function tsEnumDeclaration(id, members) {
	  return builder.apply("TSEnumDeclaration", arguments);
	}
	function tsEnumMember(id, initializer) {
	  return builder.apply("TSEnumMember", arguments);
	}
	function tsModuleDeclaration(id, body) {
	  return builder.apply("TSModuleDeclaration", arguments);
	}
	function tsModuleBlock(body) {
	  return builder.apply("TSModuleBlock", arguments);
	}
	function tsImportType(argument, qualifier, typeParameters) {
	  return builder.apply("TSImportType", arguments);
	}
	function tsImportEqualsDeclaration(id, moduleReference) {
	  return builder.apply("TSImportEqualsDeclaration", arguments);
	}
	function tsExternalModuleReference(expression) {
	  return builder.apply("TSExternalModuleReference", arguments);
	}
	function tsNonNullExpression(expression) {
	  return builder.apply("TSNonNullExpression", arguments);
	}
	function tsExportAssignment(expression) {
	  return builder.apply("TSExportAssignment", arguments);
	}
	function tsNamespaceExportDeclaration(id) {
	  return builder.apply("TSNamespaceExportDeclaration", arguments);
	}
	function tsTypeAnnotation(typeAnnotation) {
	  return builder.apply("TSTypeAnnotation", arguments);
	}
	function tsTypeParameterInstantiation(params) {
	  return builder.apply("TSTypeParameterInstantiation", arguments);
	}
	function tsTypeParameterDeclaration(params) {
	  return builder.apply("TSTypeParameterDeclaration", arguments);
	}
	function tsTypeParameter(constraint, _default, name) {
	  return builder.apply("TSTypeParameter", arguments);
	}

	function NumberLiteral(value) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  return builder.apply("NumberLiteral", arguments);
	}

	function RegexLiteral(pattern, flags) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  return builder.apply("RegexLiteral", arguments);
	}

	function RestProperty$1(argument) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  return builder.apply("RestProperty", arguments);
	}

	function SpreadProperty$1(argument) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  return builder.apply("SpreadProperty", arguments);
	}

	function cleanJSXElementLiteralChild(child, args) {
	  var lines = child.value.split(/\r\n|\n|\r/);
	  var lastNonEmptyLine = 0;

	  for (var i = 0; i < lines.length; i++) {
	    if (lines[i].match(/[^ \t]/)) {
	      lastNonEmptyLine = i;
	    }
	  }

	  var str = "";

	  for (var _i = 0; _i < lines.length; _i++) {
	    var line = lines[_i];
	    var isFirstLine = _i === 0;
	    var isLastLine = _i === lines.length - 1;
	    var isLastNonEmptyLine = _i === lastNonEmptyLine;
	    var trimmedLine = line.replace(/\t/g, " ");

	    if (!isFirstLine) {
	      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
	    }

	    if (!isLastLine) {
	      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
	    }

	    if (trimmedLine) {
	      if (!isLastNonEmptyLine) {
	        trimmedLine += " ";
	      }

	      str += trimmedLine;
	    }
	  }

	  if (str) args.push(stringLiteral$8(str));
	}

	function buildChildren(node) {
	  var elements = [];

	  for (var i = 0; i < node.children.length; i++) {
	    var child = node.children[i];

	    if (isJSXText(child)) {
	      cleanJSXElementLiteralChild(child, elements);
	      continue;
	    }

	    if (isJSXExpressionContainer$1(child)) child = child.expression;
	    if (isJSXEmptyExpression(child)) continue;
	    elements.push(child);
	  }

	  return elements;
	}

	function isNode(node) {
	  return !!(node && VISITOR_KEYS$6[node.type]);
	}

	function assertNode(node) {
	  if (!isNode(node)) {
	    var _node$type;

	    var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
	    throw new TypeError("Not a valid node of type \"" + type + "\"");
	  }
	}

	function assert$1(type, node, opts) {
	  if (!is$1(type, node, opts)) {
	    throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
	  }
	}

	function assertArrayExpression(node, opts) {
	  assert$1("ArrayExpression", node, opts);
	}
	function assertAssignmentExpression(node, opts) {
	  assert$1("AssignmentExpression", node, opts);
	}
	function assertBinaryExpression(node, opts) {
	  assert$1("BinaryExpression", node, opts);
	}
	function assertInterpreterDirective(node, opts) {
	  assert$1("InterpreterDirective", node, opts);
	}
	function assertDirective(node, opts) {
	  assert$1("Directive", node, opts);
	}
	function assertDirectiveLiteral(node, opts) {
	  assert$1("DirectiveLiteral", node, opts);
	}
	function assertBlockStatement(node, opts) {
	  assert$1("BlockStatement", node, opts);
	}
	function assertBreakStatement(node, opts) {
	  assert$1("BreakStatement", node, opts);
	}
	function assertCallExpression(node, opts) {
	  assert$1("CallExpression", node, opts);
	}
	function assertCatchClause(node, opts) {
	  assert$1("CatchClause", node, opts);
	}
	function assertConditionalExpression(node, opts) {
	  assert$1("ConditionalExpression", node, opts);
	}
	function assertContinueStatement(node, opts) {
	  assert$1("ContinueStatement", node, opts);
	}
	function assertDebuggerStatement(node, opts) {
	  assert$1("DebuggerStatement", node, opts);
	}
	function assertDoWhileStatement(node, opts) {
	  assert$1("DoWhileStatement", node, opts);
	}
	function assertEmptyStatement(node, opts) {
	  assert$1("EmptyStatement", node, opts);
	}
	function assertExpressionStatement$1(node, opts) {
	  assert$1("ExpressionStatement", node, opts);
	}
	function assertFile(node, opts) {
	  assert$1("File", node, opts);
	}
	function assertForInStatement(node, opts) {
	  assert$1("ForInStatement", node, opts);
	}
	function assertForStatement(node, opts) {
	  assert$1("ForStatement", node, opts);
	}
	function assertFunctionDeclaration(node, opts) {
	  assert$1("FunctionDeclaration", node, opts);
	}
	function assertFunctionExpression(node, opts) {
	  assert$1("FunctionExpression", node, opts);
	}
	function assertIdentifier(node, opts) {
	  assert$1("Identifier", node, opts);
	}
	function assertIfStatement(node, opts) {
	  assert$1("IfStatement", node, opts);
	}
	function assertLabeledStatement(node, opts) {
	  assert$1("LabeledStatement", node, opts);
	}
	function assertStringLiteral(node, opts) {
	  assert$1("StringLiteral", node, opts);
	}
	function assertNumericLiteral(node, opts) {
	  assert$1("NumericLiteral", node, opts);
	}
	function assertNullLiteral(node, opts) {
	  assert$1("NullLiteral", node, opts);
	}
	function assertBooleanLiteral(node, opts) {
	  assert$1("BooleanLiteral", node, opts);
	}
	function assertRegExpLiteral(node, opts) {
	  assert$1("RegExpLiteral", node, opts);
	}
	function assertLogicalExpression(node, opts) {
	  assert$1("LogicalExpression", node, opts);
	}
	function assertMemberExpression(node, opts) {
	  assert$1("MemberExpression", node, opts);
	}
	function assertNewExpression(node, opts) {
	  assert$1("NewExpression", node, opts);
	}
	function assertProgram(node, opts) {
	  assert$1("Program", node, opts);
	}
	function assertObjectExpression(node, opts) {
	  assert$1("ObjectExpression", node, opts);
	}
	function assertObjectMethod(node, opts) {
	  assert$1("ObjectMethod", node, opts);
	}
	function assertObjectProperty(node, opts) {
	  assert$1("ObjectProperty", node, opts);
	}
	function assertRestElement(node, opts) {
	  assert$1("RestElement", node, opts);
	}
	function assertReturnStatement(node, opts) {
	  assert$1("ReturnStatement", node, opts);
	}
	function assertSequenceExpression(node, opts) {
	  assert$1("SequenceExpression", node, opts);
	}
	function assertParenthesizedExpression(node, opts) {
	  assert$1("ParenthesizedExpression", node, opts);
	}
	function assertSwitchCase(node, opts) {
	  assert$1("SwitchCase", node, opts);
	}
	function assertSwitchStatement(node, opts) {
	  assert$1("SwitchStatement", node, opts);
	}
	function assertThisExpression(node, opts) {
	  assert$1("ThisExpression", node, opts);
	}
	function assertThrowStatement(node, opts) {
	  assert$1("ThrowStatement", node, opts);
	}
	function assertTryStatement(node, opts) {
	  assert$1("TryStatement", node, opts);
	}
	function assertUnaryExpression(node, opts) {
	  assert$1("UnaryExpression", node, opts);
	}
	function assertUpdateExpression(node, opts) {
	  assert$1("UpdateExpression", node, opts);
	}
	function assertVariableDeclaration(node, opts) {
	  assert$1("VariableDeclaration", node, opts);
	}
	function assertVariableDeclarator(node, opts) {
	  assert$1("VariableDeclarator", node, opts);
	}
	function assertWhileStatement(node, opts) {
	  assert$1("WhileStatement", node, opts);
	}
	function assertWithStatement(node, opts) {
	  assert$1("WithStatement", node, opts);
	}
	function assertAssignmentPattern(node, opts) {
	  assert$1("AssignmentPattern", node, opts);
	}
	function assertArrayPattern(node, opts) {
	  assert$1("ArrayPattern", node, opts);
	}
	function assertArrowFunctionExpression(node, opts) {
	  assert$1("ArrowFunctionExpression", node, opts);
	}
	function assertClassBody(node, opts) {
	  assert$1("ClassBody", node, opts);
	}
	function assertClassExpression(node, opts) {
	  assert$1("ClassExpression", node, opts);
	}
	function assertClassDeclaration(node, opts) {
	  assert$1("ClassDeclaration", node, opts);
	}
	function assertExportAllDeclaration(node, opts) {
	  assert$1("ExportAllDeclaration", node, opts);
	}
	function assertExportDefaultDeclaration(node, opts) {
	  assert$1("ExportDefaultDeclaration", node, opts);
	}
	function assertExportNamedDeclaration(node, opts) {
	  assert$1("ExportNamedDeclaration", node, opts);
	}
	function assertExportSpecifier$1(node, opts) {
	  assert$1("ExportSpecifier", node, opts);
	}
	function assertForOfStatement(node, opts) {
	  assert$1("ForOfStatement", node, opts);
	}
	function assertImportDeclaration(node, opts) {
	  assert$1("ImportDeclaration", node, opts);
	}
	function assertImportDefaultSpecifier(node, opts) {
	  assert$1("ImportDefaultSpecifier", node, opts);
	}
	function assertImportNamespaceSpecifier(node, opts) {
	  assert$1("ImportNamespaceSpecifier", node, opts);
	}
	function assertImportSpecifier(node, opts) {
	  assert$1("ImportSpecifier", node, opts);
	}
	function assertMetaProperty(node, opts) {
	  assert$1("MetaProperty", node, opts);
	}
	function assertClassMethod(node, opts) {
	  assert$1("ClassMethod", node, opts);
	}
	function assertObjectPattern(node, opts) {
	  assert$1("ObjectPattern", node, opts);
	}
	function assertSpreadElement(node, opts) {
	  assert$1("SpreadElement", node, opts);
	}
	function assertSuper(node, opts) {
	  assert$1("Super", node, opts);
	}
	function assertTaggedTemplateExpression(node, opts) {
	  assert$1("TaggedTemplateExpression", node, opts);
	}
	function assertTemplateElement(node, opts) {
	  assert$1("TemplateElement", node, opts);
	}
	function assertTemplateLiteral(node, opts) {
	  assert$1("TemplateLiteral", node, opts);
	}
	function assertYieldExpression(node, opts) {
	  assert$1("YieldExpression", node, opts);
	}
	function assertAwaitExpression(node, opts) {
	  assert$1("AwaitExpression", node, opts);
	}
	function assertImport(node, opts) {
	  assert$1("Import", node, opts);
	}
	function assertBigIntLiteral(node, opts) {
	  assert$1("BigIntLiteral", node, opts);
	}
	function assertExportNamespaceSpecifier(node, opts) {
	  assert$1("ExportNamespaceSpecifier", node, opts);
	}
	function assertOptionalMemberExpression(node, opts) {
	  assert$1("OptionalMemberExpression", node, opts);
	}
	function assertOptionalCallExpression(node, opts) {
	  assert$1("OptionalCallExpression", node, opts);
	}
	function assertClassProperty(node, opts) {
	  assert$1("ClassProperty", node, opts);
	}
	function assertClassPrivateProperty(node, opts) {
	  assert$1("ClassPrivateProperty", node, opts);
	}
	function assertClassPrivateMethod(node, opts) {
	  assert$1("ClassPrivateMethod", node, opts);
	}
	function assertPrivateName(node, opts) {
	  assert$1("PrivateName", node, opts);
	}
	function assertStaticBlock(node, opts) {
	  assert$1("StaticBlock", node, opts);
	}
	function assertAnyTypeAnnotation(node, opts) {
	  assert$1("AnyTypeAnnotation", node, opts);
	}
	function assertArrayTypeAnnotation(node, opts) {
	  assert$1("ArrayTypeAnnotation", node, opts);
	}
	function assertBooleanTypeAnnotation(node, opts) {
	  assert$1("BooleanTypeAnnotation", node, opts);
	}
	function assertBooleanLiteralTypeAnnotation(node, opts) {
	  assert$1("BooleanLiteralTypeAnnotation", node, opts);
	}
	function assertNullLiteralTypeAnnotation(node, opts) {
	  assert$1("NullLiteralTypeAnnotation", node, opts);
	}
	function assertClassImplements(node, opts) {
	  assert$1("ClassImplements", node, opts);
	}
	function assertDeclareClass(node, opts) {
	  assert$1("DeclareClass", node, opts);
	}
	function assertDeclareFunction(node, opts) {
	  assert$1("DeclareFunction", node, opts);
	}
	function assertDeclareInterface(node, opts) {
	  assert$1("DeclareInterface", node, opts);
	}
	function assertDeclareModule(node, opts) {
	  assert$1("DeclareModule", node, opts);
	}
	function assertDeclareModuleExports(node, opts) {
	  assert$1("DeclareModuleExports", node, opts);
	}
	function assertDeclareTypeAlias(node, opts) {
	  assert$1("DeclareTypeAlias", node, opts);
	}
	function assertDeclareOpaqueType(node, opts) {
	  assert$1("DeclareOpaqueType", node, opts);
	}
	function assertDeclareVariable(node, opts) {
	  assert$1("DeclareVariable", node, opts);
	}
	function assertDeclareExportDeclaration(node, opts) {
	  assert$1("DeclareExportDeclaration", node, opts);
	}
	function assertDeclareExportAllDeclaration(node, opts) {
	  assert$1("DeclareExportAllDeclaration", node, opts);
	}
	function assertDeclaredPredicate(node, opts) {
	  assert$1("DeclaredPredicate", node, opts);
	}
	function assertExistsTypeAnnotation(node, opts) {
	  assert$1("ExistsTypeAnnotation", node, opts);
	}
	function assertFunctionTypeAnnotation(node, opts) {
	  assert$1("FunctionTypeAnnotation", node, opts);
	}
	function assertFunctionTypeParam(node, opts) {
	  assert$1("FunctionTypeParam", node, opts);
	}
	function assertGenericTypeAnnotation(node, opts) {
	  assert$1("GenericTypeAnnotation", node, opts);
	}
	function assertInferredPredicate(node, opts) {
	  assert$1("InferredPredicate", node, opts);
	}
	function assertInterfaceExtends(node, opts) {
	  assert$1("InterfaceExtends", node, opts);
	}
	function assertInterfaceDeclaration(node, opts) {
	  assert$1("InterfaceDeclaration", node, opts);
	}
	function assertInterfaceTypeAnnotation(node, opts) {
	  assert$1("InterfaceTypeAnnotation", node, opts);
	}
	function assertIntersectionTypeAnnotation(node, opts) {
	  assert$1("IntersectionTypeAnnotation", node, opts);
	}
	function assertMixedTypeAnnotation(node, opts) {
	  assert$1("MixedTypeAnnotation", node, opts);
	}
	function assertEmptyTypeAnnotation(node, opts) {
	  assert$1("EmptyTypeAnnotation", node, opts);
	}
	function assertNullableTypeAnnotation(node, opts) {
	  assert$1("NullableTypeAnnotation", node, opts);
	}
	function assertNumberLiteralTypeAnnotation(node, opts) {
	  assert$1("NumberLiteralTypeAnnotation", node, opts);
	}
	function assertNumberTypeAnnotation(node, opts) {
	  assert$1("NumberTypeAnnotation", node, opts);
	}
	function assertObjectTypeAnnotation(node, opts) {
	  assert$1("ObjectTypeAnnotation", node, opts);
	}
	function assertObjectTypeInternalSlot(node, opts) {
	  assert$1("ObjectTypeInternalSlot", node, opts);
	}
	function assertObjectTypeCallProperty(node, opts) {
	  assert$1("ObjectTypeCallProperty", node, opts);
	}
	function assertObjectTypeIndexer(node, opts) {
	  assert$1("ObjectTypeIndexer", node, opts);
	}
	function assertObjectTypeProperty(node, opts) {
	  assert$1("ObjectTypeProperty", node, opts);
	}
	function assertObjectTypeSpreadProperty(node, opts) {
	  assert$1("ObjectTypeSpreadProperty", node, opts);
	}
	function assertOpaqueType(node, opts) {
	  assert$1("OpaqueType", node, opts);
	}
	function assertQualifiedTypeIdentifier(node, opts) {
	  assert$1("QualifiedTypeIdentifier", node, opts);
	}
	function assertStringLiteralTypeAnnotation(node, opts) {
	  assert$1("StringLiteralTypeAnnotation", node, opts);
	}
	function assertStringTypeAnnotation(node, opts) {
	  assert$1("StringTypeAnnotation", node, opts);
	}
	function assertSymbolTypeAnnotation(node, opts) {
	  assert$1("SymbolTypeAnnotation", node, opts);
	}
	function assertThisTypeAnnotation(node, opts) {
	  assert$1("ThisTypeAnnotation", node, opts);
	}
	function assertTupleTypeAnnotation(node, opts) {
	  assert$1("TupleTypeAnnotation", node, opts);
	}
	function assertTypeofTypeAnnotation(node, opts) {
	  assert$1("TypeofTypeAnnotation", node, opts);
	}
	function assertTypeAlias(node, opts) {
	  assert$1("TypeAlias", node, opts);
	}
	function assertTypeAnnotation(node, opts) {
	  assert$1("TypeAnnotation", node, opts);
	}
	function assertTypeCastExpression(node, opts) {
	  assert$1("TypeCastExpression", node, opts);
	}
	function assertTypeParameter(node, opts) {
	  assert$1("TypeParameter", node, opts);
	}
	function assertTypeParameterDeclaration(node, opts) {
	  assert$1("TypeParameterDeclaration", node, opts);
	}
	function assertTypeParameterInstantiation(node, opts) {
	  assert$1("TypeParameterInstantiation", node, opts);
	}
	function assertUnionTypeAnnotation(node, opts) {
	  assert$1("UnionTypeAnnotation", node, opts);
	}
	function assertVariance(node, opts) {
	  assert$1("Variance", node, opts);
	}
	function assertVoidTypeAnnotation(node, opts) {
	  assert$1("VoidTypeAnnotation", node, opts);
	}
	function assertEnumDeclaration(node, opts) {
	  assert$1("EnumDeclaration", node, opts);
	}
	function assertEnumBooleanBody(node, opts) {
	  assert$1("EnumBooleanBody", node, opts);
	}
	function assertEnumNumberBody(node, opts) {
	  assert$1("EnumNumberBody", node, opts);
	}
	function assertEnumStringBody(node, opts) {
	  assert$1("EnumStringBody", node, opts);
	}
	function assertEnumSymbolBody(node, opts) {
	  assert$1("EnumSymbolBody", node, opts);
	}
	function assertEnumBooleanMember(node, opts) {
	  assert$1("EnumBooleanMember", node, opts);
	}
	function assertEnumNumberMember(node, opts) {
	  assert$1("EnumNumberMember", node, opts);
	}
	function assertEnumStringMember(node, opts) {
	  assert$1("EnumStringMember", node, opts);
	}
	function assertEnumDefaultedMember(node, opts) {
	  assert$1("EnumDefaultedMember", node, opts);
	}
	function assertIndexedAccessType(node, opts) {
	  assert$1("IndexedAccessType", node, opts);
	}
	function assertOptionalIndexedAccessType(node, opts) {
	  assert$1("OptionalIndexedAccessType", node, opts);
	}
	function assertJSXAttribute(node, opts) {
	  assert$1("JSXAttribute", node, opts);
	}
	function assertJSXClosingElement(node, opts) {
	  assert$1("JSXClosingElement", node, opts);
	}
	function assertJSXElement(node, opts) {
	  assert$1("JSXElement", node, opts);
	}
	function assertJSXEmptyExpression(node, opts) {
	  assert$1("JSXEmptyExpression", node, opts);
	}
	function assertJSXExpressionContainer(node, opts) {
	  assert$1("JSXExpressionContainer", node, opts);
	}
	function assertJSXSpreadChild(node, opts) {
	  assert$1("JSXSpreadChild", node, opts);
	}
	function assertJSXIdentifier(node, opts) {
	  assert$1("JSXIdentifier", node, opts);
	}
	function assertJSXMemberExpression(node, opts) {
	  assert$1("JSXMemberExpression", node, opts);
	}
	function assertJSXNamespacedName(node, opts) {
	  assert$1("JSXNamespacedName", node, opts);
	}
	function assertJSXOpeningElement(node, opts) {
	  assert$1("JSXOpeningElement", node, opts);
	}
	function assertJSXSpreadAttribute(node, opts) {
	  assert$1("JSXSpreadAttribute", node, opts);
	}
	function assertJSXText(node, opts) {
	  assert$1("JSXText", node, opts);
	}
	function assertJSXFragment(node, opts) {
	  assert$1("JSXFragment", node, opts);
	}
	function assertJSXOpeningFragment(node, opts) {
	  assert$1("JSXOpeningFragment", node, opts);
	}
	function assertJSXClosingFragment(node, opts) {
	  assert$1("JSXClosingFragment", node, opts);
	}
	function assertNoop(node, opts) {
	  assert$1("Noop", node, opts);
	}
	function assertPlaceholder(node, opts) {
	  assert$1("Placeholder", node, opts);
	}
	function assertV8IntrinsicIdentifier(node, opts) {
	  assert$1("V8IntrinsicIdentifier", node, opts);
	}
	function assertArgumentPlaceholder(node, opts) {
	  assert$1("ArgumentPlaceholder", node, opts);
	}
	function assertBindExpression(node, opts) {
	  assert$1("BindExpression", node, opts);
	}
	function assertImportAttribute(node, opts) {
	  assert$1("ImportAttribute", node, opts);
	}
	function assertDecorator(node, opts) {
	  assert$1("Decorator", node, opts);
	}
	function assertDoExpression(node, opts) {
	  assert$1("DoExpression", node, opts);
	}
	function assertExportDefaultSpecifier(node, opts) {
	  assert$1("ExportDefaultSpecifier", node, opts);
	}
	function assertRecordExpression(node, opts) {
	  assert$1("RecordExpression", node, opts);
	}
	function assertTupleExpression(node, opts) {
	  assert$1("TupleExpression", node, opts);
	}
	function assertDecimalLiteral(node, opts) {
	  assert$1("DecimalLiteral", node, opts);
	}
	function assertModuleExpression(node, opts) {
	  assert$1("ModuleExpression", node, opts);
	}
	function assertTopicReference(node, opts) {
	  assert$1("TopicReference", node, opts);
	}
	function assertPipelineTopicExpression(node, opts) {
	  assert$1("PipelineTopicExpression", node, opts);
	}
	function assertPipelineBareFunction(node, opts) {
	  assert$1("PipelineBareFunction", node, opts);
	}
	function assertPipelinePrimaryTopicReference(node, opts) {
	  assert$1("PipelinePrimaryTopicReference", node, opts);
	}
	function assertTSParameterProperty(node, opts) {
	  assert$1("TSParameterProperty", node, opts);
	}
	function assertTSDeclareFunction(node, opts) {
	  assert$1("TSDeclareFunction", node, opts);
	}
	function assertTSDeclareMethod(node, opts) {
	  assert$1("TSDeclareMethod", node, opts);
	}
	function assertTSQualifiedName(node, opts) {
	  assert$1("TSQualifiedName", node, opts);
	}
	function assertTSCallSignatureDeclaration(node, opts) {
	  assert$1("TSCallSignatureDeclaration", node, opts);
	}
	function assertTSConstructSignatureDeclaration(node, opts) {
	  assert$1("TSConstructSignatureDeclaration", node, opts);
	}
	function assertTSPropertySignature(node, opts) {
	  assert$1("TSPropertySignature", node, opts);
	}
	function assertTSMethodSignature(node, opts) {
	  assert$1("TSMethodSignature", node, opts);
	}
	function assertTSIndexSignature(node, opts) {
	  assert$1("TSIndexSignature", node, opts);
	}
	function assertTSAnyKeyword(node, opts) {
	  assert$1("TSAnyKeyword", node, opts);
	}
	function assertTSBooleanKeyword(node, opts) {
	  assert$1("TSBooleanKeyword", node, opts);
	}
	function assertTSBigIntKeyword(node, opts) {
	  assert$1("TSBigIntKeyword", node, opts);
	}
	function assertTSIntrinsicKeyword(node, opts) {
	  assert$1("TSIntrinsicKeyword", node, opts);
	}
	function assertTSNeverKeyword(node, opts) {
	  assert$1("TSNeverKeyword", node, opts);
	}
	function assertTSNullKeyword(node, opts) {
	  assert$1("TSNullKeyword", node, opts);
	}
	function assertTSNumberKeyword(node, opts) {
	  assert$1("TSNumberKeyword", node, opts);
	}
	function assertTSObjectKeyword(node, opts) {
	  assert$1("TSObjectKeyword", node, opts);
	}
	function assertTSStringKeyword(node, opts) {
	  assert$1("TSStringKeyword", node, opts);
	}
	function assertTSSymbolKeyword(node, opts) {
	  assert$1("TSSymbolKeyword", node, opts);
	}
	function assertTSUndefinedKeyword(node, opts) {
	  assert$1("TSUndefinedKeyword", node, opts);
	}
	function assertTSUnknownKeyword(node, opts) {
	  assert$1("TSUnknownKeyword", node, opts);
	}
	function assertTSVoidKeyword(node, opts) {
	  assert$1("TSVoidKeyword", node, opts);
	}
	function assertTSThisType(node, opts) {
	  assert$1("TSThisType", node, opts);
	}
	function assertTSFunctionType(node, opts) {
	  assert$1("TSFunctionType", node, opts);
	}
	function assertTSConstructorType(node, opts) {
	  assert$1("TSConstructorType", node, opts);
	}
	function assertTSTypeReference(node, opts) {
	  assert$1("TSTypeReference", node, opts);
	}
	function assertTSTypePredicate(node, opts) {
	  assert$1("TSTypePredicate", node, opts);
	}
	function assertTSTypeQuery(node, opts) {
	  assert$1("TSTypeQuery", node, opts);
	}
	function assertTSTypeLiteral(node, opts) {
	  assert$1("TSTypeLiteral", node, opts);
	}
	function assertTSArrayType(node, opts) {
	  assert$1("TSArrayType", node, opts);
	}
	function assertTSTupleType(node, opts) {
	  assert$1("TSTupleType", node, opts);
	}
	function assertTSOptionalType(node, opts) {
	  assert$1("TSOptionalType", node, opts);
	}
	function assertTSRestType(node, opts) {
	  assert$1("TSRestType", node, opts);
	}
	function assertTSNamedTupleMember(node, opts) {
	  assert$1("TSNamedTupleMember", node, opts);
	}
	function assertTSUnionType(node, opts) {
	  assert$1("TSUnionType", node, opts);
	}
	function assertTSIntersectionType(node, opts) {
	  assert$1("TSIntersectionType", node, opts);
	}
	function assertTSConditionalType(node, opts) {
	  assert$1("TSConditionalType", node, opts);
	}
	function assertTSInferType(node, opts) {
	  assert$1("TSInferType", node, opts);
	}
	function assertTSParenthesizedType(node, opts) {
	  assert$1("TSParenthesizedType", node, opts);
	}
	function assertTSTypeOperator(node, opts) {
	  assert$1("TSTypeOperator", node, opts);
	}
	function assertTSIndexedAccessType(node, opts) {
	  assert$1("TSIndexedAccessType", node, opts);
	}
	function assertTSMappedType(node, opts) {
	  assert$1("TSMappedType", node, opts);
	}
	function assertTSLiteralType(node, opts) {
	  assert$1("TSLiteralType", node, opts);
	}
	function assertTSExpressionWithTypeArguments(node, opts) {
	  assert$1("TSExpressionWithTypeArguments", node, opts);
	}
	function assertTSInterfaceDeclaration(node, opts) {
	  assert$1("TSInterfaceDeclaration", node, opts);
	}
	function assertTSInterfaceBody(node, opts) {
	  assert$1("TSInterfaceBody", node, opts);
	}
	function assertTSTypeAliasDeclaration(node, opts) {
	  assert$1("TSTypeAliasDeclaration", node, opts);
	}
	function assertTSAsExpression(node, opts) {
	  assert$1("TSAsExpression", node, opts);
	}
	function assertTSTypeAssertion(node, opts) {
	  assert$1("TSTypeAssertion", node, opts);
	}
	function assertTSEnumDeclaration(node, opts) {
	  assert$1("TSEnumDeclaration", node, opts);
	}
	function assertTSEnumMember(node, opts) {
	  assert$1("TSEnumMember", node, opts);
	}
	function assertTSModuleDeclaration(node, opts) {
	  assert$1("TSModuleDeclaration", node, opts);
	}
	function assertTSModuleBlock(node, opts) {
	  assert$1("TSModuleBlock", node, opts);
	}
	function assertTSImportType(node, opts) {
	  assert$1("TSImportType", node, opts);
	}
	function assertTSImportEqualsDeclaration(node, opts) {
	  assert$1("TSImportEqualsDeclaration", node, opts);
	}
	function assertTSExternalModuleReference(node, opts) {
	  assert$1("TSExternalModuleReference", node, opts);
	}
	function assertTSNonNullExpression(node, opts) {
	  assert$1("TSNonNullExpression", node, opts);
	}
	function assertTSExportAssignment(node, opts) {
	  assert$1("TSExportAssignment", node, opts);
	}
	function assertTSNamespaceExportDeclaration(node, opts) {
	  assert$1("TSNamespaceExportDeclaration", node, opts);
	}
	function assertTSTypeAnnotation(node, opts) {
	  assert$1("TSTypeAnnotation", node, opts);
	}
	function assertTSTypeParameterInstantiation(node, opts) {
	  assert$1("TSTypeParameterInstantiation", node, opts);
	}
	function assertTSTypeParameterDeclaration(node, opts) {
	  assert$1("TSTypeParameterDeclaration", node, opts);
	}
	function assertTSTypeParameter(node, opts) {
	  assert$1("TSTypeParameter", node, opts);
	}
	function assertStandardized(node, opts) {
	  assert$1("Standardized", node, opts);
	}
	function assertExpression$1(node, opts) {
	  assert$1("Expression", node, opts);
	}
	function assertBinary(node, opts) {
	  assert$1("Binary", node, opts);
	}
	function assertScopable(node, opts) {
	  assert$1("Scopable", node, opts);
	}
	function assertBlockParent(node, opts) {
	  assert$1("BlockParent", node, opts);
	}
	function assertBlock(node, opts) {
	  assert$1("Block", node, opts);
	}
	function assertStatement(node, opts) {
	  assert$1("Statement", node, opts);
	}
	function assertTerminatorless(node, opts) {
	  assert$1("Terminatorless", node, opts);
	}
	function assertCompletionStatement(node, opts) {
	  assert$1("CompletionStatement", node, opts);
	}
	function assertConditional(node, opts) {
	  assert$1("Conditional", node, opts);
	}
	function assertLoop(node, opts) {
	  assert$1("Loop", node, opts);
	}
	function assertWhile(node, opts) {
	  assert$1("While", node, opts);
	}
	function assertExpressionWrapper(node, opts) {
	  assert$1("ExpressionWrapper", node, opts);
	}
	function assertFor(node, opts) {
	  assert$1("For", node, opts);
	}
	function assertForXStatement(node, opts) {
	  assert$1("ForXStatement", node, opts);
	}
	function assertFunction$1(node, opts) {
	  assert$1("Function", node, opts);
	}
	function assertFunctionParent(node, opts) {
	  assert$1("FunctionParent", node, opts);
	}
	function assertPureish(node, opts) {
	  assert$1("Pureish", node, opts);
	}
	function assertDeclaration(node, opts) {
	  assert$1("Declaration", node, opts);
	}
	function assertPatternLike(node, opts) {
	  assert$1("PatternLike", node, opts);
	}
	function assertLVal(node, opts) {
	  assert$1("LVal", node, opts);
	}
	function assertTSEntityName(node, opts) {
	  assert$1("TSEntityName", node, opts);
	}
	function assertLiteral(node, opts) {
	  assert$1("Literal", node, opts);
	}
	function assertImmutable(node, opts) {
	  assert$1("Immutable", node, opts);
	}
	function assertUserWhitespacable(node, opts) {
	  assert$1("UserWhitespacable", node, opts);
	}
	function assertMethod(node, opts) {
	  assert$1("Method", node, opts);
	}
	function assertObjectMember(node, opts) {
	  assert$1("ObjectMember", node, opts);
	}
	function assertProperty(node, opts) {
	  assert$1("Property", node, opts);
	}
	function assertUnaryLike(node, opts) {
	  assert$1("UnaryLike", node, opts);
	}
	function assertPattern(node, opts) {
	  assert$1("Pattern", node, opts);
	}
	function assertClass(node, opts) {
	  assert$1("Class", node, opts);
	}
	function assertModuleDeclaration(node, opts) {
	  assert$1("ModuleDeclaration", node, opts);
	}
	function assertExportDeclaration(node, opts) {
	  assert$1("ExportDeclaration", node, opts);
	}
	function assertModuleSpecifier(node, opts) {
	  assert$1("ModuleSpecifier", node, opts);
	}
	function assertPrivate(node, opts) {
	  assert$1("Private", node, opts);
	}
	function assertFlow(node, opts) {
	  assert$1("Flow", node, opts);
	}
	function assertFlowType(node, opts) {
	  assert$1("FlowType", node, opts);
	}
	function assertFlowBaseAnnotation(node, opts) {
	  assert$1("FlowBaseAnnotation", node, opts);
	}
	function assertFlowDeclaration(node, opts) {
	  assert$1("FlowDeclaration", node, opts);
	}
	function assertFlowPredicate(node, opts) {
	  assert$1("FlowPredicate", node, opts);
	}
	function assertEnumBody(node, opts) {
	  assert$1("EnumBody", node, opts);
	}
	function assertEnumMember(node, opts) {
	  assert$1("EnumMember", node, opts);
	}
	function assertJSX(node, opts) {
	  assert$1("JSX", node, opts);
	}
	function assertMiscellaneous(node, opts) {
	  assert$1("Miscellaneous", node, opts);
	}
	function assertTypeScript(node, opts) {
	  assert$1("TypeScript", node, opts);
	}
	function assertTSTypeElement(node, opts) {
	  assert$1("TSTypeElement", node, opts);
	}
	function assertTSType(node, opts) {
	  assert$1("TSType", node, opts);
	}
	function assertTSBaseType(node, opts) {
	  assert$1("TSBaseType", node, opts);
	}
	function assertNumberLiteral(node, opts) {
	  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
	  assert$1("NumberLiteral", node, opts);
	}
	function assertRegexLiteral(node, opts) {
	  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
	  assert$1("RegexLiteral", node, opts);
	}
	function assertRestProperty(node, opts) {
	  console.trace("The node type RestProperty has been renamed to RestElement");
	  assert$1("RestProperty", node, opts);
	}
	function assertSpreadProperty(node, opts) {
	  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
	  assert$1("SpreadProperty", node, opts);
	}

	function createTypeAnnotationBasedOnTypeof$1(type) {
	  switch (type) {
	    case "string":
	      return stringTypeAnnotation$2();

	    case "number":
	      return numberTypeAnnotation$2();

	    case "undefined":
	      return voidTypeAnnotation$3();

	    case "boolean":
	      return booleanTypeAnnotation$1();

	    case "function":
	      return genericTypeAnnotation$1(identifier$j("Function"));

	    case "object":
	      return genericTypeAnnotation$1(identifier$j("Object"));

	    case "symbol":
	      return genericTypeAnnotation$1(identifier$j("Symbol"));

	    case "bigint":
	      return anyTypeAnnotation$2();
	  }

	  throw new Error("Invalid typeof value: " + type);
	}

	function getQualifiedName(node) {
	  return isIdentifier$g(node) ? node.name : node.id.name + "." + getQualifiedName(node.qualification);
	}

	function removeTypeDuplicates$1(nodes) {
	  var generics = {};
	  var bases = {};
	  var typeGroups = new Set();
	  var types = [];

	  for (var i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    if (!node) continue;

	    if (types.indexOf(node) >= 0) {
	      continue;
	    }

	    if (isAnyTypeAnnotation$1(node)) {
	      return [node];
	    }

	    if (isFlowBaseAnnotation$1(node)) {
	      bases[node.type] = node;
	      continue;
	    }

	    if (isUnionTypeAnnotation$2(node)) {
	      if (!typeGroups.has(node.types)) {
	        nodes = nodes.concat(node.types);
	        typeGroups.add(node.types);
	      }

	      continue;
	    }

	    if (isGenericTypeAnnotation$1(node)) {
	      var name = getQualifiedName(node.id);

	      if (generics[name]) {
	        var existing = generics[name];

	        if (existing.typeParameters) {
	          if (node.typeParameters) {
	            existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params.concat(node.typeParameters.params));
	          }
	        } else {
	          existing = node.typeParameters;
	        }
	      } else {
	        generics[name] = node;
	      }

	      continue;
	    }

	    types.push(node);
	  }

	  for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
	    var type = _Object$keys[_i];
	    types.push(bases[type]);
	  }

	  for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
	    var _name = _Object$keys2[_i2];
	    types.push(generics[_name]);
	  }

	  return types;
	}

	function createFlowUnionType$2(types) {
	  var flattened = removeTypeDuplicates$1(types);

	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return unionTypeAnnotation$1(flattened);
	  }
	}

	function removeTypeDuplicates(nodes) {
	  var generics = {};
	  var bases = {};
	  var typeGroups = new Set();
	  var types = [];

	  for (var i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    if (!node) continue;

	    if (types.indexOf(node) >= 0) {
	      continue;
	    }

	    if (isTSAnyKeyword(node)) {
	      return [node];
	    }

	    if (isTSBaseType(node)) {
	      bases[node.type] = node;
	      continue;
	    }

	    if (isTSUnionType$1(node)) {
	      if (!typeGroups.has(node.types)) {
	        nodes.push.apply(nodes, _toConsumableArray(node.types));
	        typeGroups.add(node.types);
	      }

	      continue;
	    }

	    types.push(node);
	  }

	  for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
	    var type = _Object$keys[_i];
	    types.push(bases[type]);
	  }

	  for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
	    var name = _Object$keys2[_i2];
	    types.push(generics[name]);
	  }

	  return types;
	}

	function createTSUnionType$2(typeAnnotations) {
	  var types = typeAnnotations.map(function (type) {
	    return type.typeAnnotation;
	  });
	  var flattened = removeTypeDuplicates(types);

	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return tsUnionType(flattened);
	  }
	}

	var has$c = Function.call.bind(Object.prototype.hasOwnProperty);

	function cloneIfNode(obj, deep, withoutLoc) {
	  if (obj && typeof obj.type === "string") {
	    return cloneNode$i(obj, deep, withoutLoc);
	  }

	  return obj;
	}

	function cloneIfNodeOrArray(obj, deep, withoutLoc) {
	  if (Array.isArray(obj)) {
	    return obj.map(function (node) {
	      return cloneIfNode(node, deep, withoutLoc);
	    });
	  }

	  return cloneIfNode(obj, deep, withoutLoc);
	}

	function cloneNode$i(node, deep, withoutLoc) {
	  if (deep === void 0) {
	    deep = true;
	  }

	  if (withoutLoc === void 0) {
	    withoutLoc = false;
	  }

	  if (!node) return node;
	  var type = node.type;
	  var newNode = {
	    type: node.type
	  };

	  if (isIdentifier$g(node)) {
	    newNode.name = node.name;

	    if (has$c(node, "optional") && typeof node.optional === "boolean") {
	      newNode.optional = node.optional;
	    }

	    if (has$c(node, "typeAnnotation")) {
	      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
	    }
	  } else if (!has$c(NODE_FIELDS, type)) {
	    throw new Error("Unknown node type: \"" + type + "\"");
	  } else {
	    for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
	      var field = _Object$keys[_i];

	      if (has$c(node, field)) {
	        if (deep) {
	          newNode[field] = isFile$1(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
	        } else {
	          newNode[field] = node[field];
	        }
	      }
	    }
	  }

	  if (has$c(node, "loc")) {
	    if (withoutLoc) {
	      newNode.loc = null;
	    } else {
	      newNode.loc = node.loc;
	    }
	  }

	  if (has$c(node, "leadingComments")) {
	    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
	  }

	  if (has$c(node, "innerComments")) {
	    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
	  }

	  if (has$c(node, "trailingComments")) {
	    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
	  }

	  if (has$c(node, "extra")) {
	    newNode.extra = Object.assign({}, node.extra);
	  }

	  return newNode;
	}

	function maybeCloneComments(comments, deep, withoutLoc) {
	  if (!comments || !deep) {
	    return comments;
	  }

	  return comments.map(function (_ref) {
	    var type = _ref.type,
	        value = _ref.value,
	        loc = _ref.loc;

	    if (withoutLoc) {
	      return {
	        type: type,
	        value: value,
	        loc: null
	      };
	    }

	    return {
	      type: type,
	      value: value,
	      loc: loc
	    };
	  });
	}

	function clone(node) {
	  return cloneNode$i(node, false);
	}

	function cloneDeep$1(node) {
	  return cloneNode$i(node);
	}

	function cloneDeepWithoutLoc(node) {
	  return cloneNode$i(node, true, true);
	}

	function cloneWithoutLoc(node) {
	  return cloneNode$i(node, false, true);
	}

	function addComments$1(node, type, comments) {
	  if (!comments || !node) return node;
	  var key = type + "Comments";

	  if (node[key]) {
	    if (type === "leading") {
	      node[key] = comments.concat(node[key]);
	    } else {
	      var _node$key;

	      (_node$key = node[key]).push.apply(_node$key, _toConsumableArray(comments));
	    }
	  } else {
	    node[key] = comments;
	  }

	  return node;
	}

	function addComment$2(node, type, content, line) {
	  return addComments$1(node, type, [{
	    type: line ? "CommentLine" : "CommentBlock",
	    value: content
	  }]);
	}

	function inherit(key, child, parent) {
	  if (child && parent) {
	    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
	  }
	}

	function inheritInnerComments(child, parent) {
	  inherit("innerComments", child, parent);
	}

	function inheritLeadingComments$1(child, parent) {
	  inherit("leadingComments", child, parent);
	}

	function inheritTrailingComments$1(child, parent) {
	  inherit("trailingComments", child, parent);
	}

	function inheritsComments$2(child, parent) {
	  inheritTrailingComments$1(child, parent);
	  inheritLeadingComments$1(child, parent);
	  inheritInnerComments(child, parent);
	  return child;
	}

	function removeComments$2(node) {
	  COMMENT_KEYS.forEach(function (key) {
	    node[key] = null;
	  });
	  return node;
	}

	var STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS$3["Standardized"];
	var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS$3["Expression"];
	var BINARY_TYPES = FLIPPED_ALIAS_KEYS$3["Binary"];
	var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS$3["Scopable"];
	var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS$3["BlockParent"];
	var BLOCK_TYPES = FLIPPED_ALIAS_KEYS$3["Block"];
	var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["Statement"];
	var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS$3["Terminatorless"];
	var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["CompletionStatement"];
	var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS$3["Conditional"];
	var LOOP_TYPES = FLIPPED_ALIAS_KEYS$3["Loop"];
	var WHILE_TYPES = FLIPPED_ALIAS_KEYS$3["While"];
	var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS$3["ExpressionWrapper"];
	var FOR_TYPES = FLIPPED_ALIAS_KEYS$3["For"];
	var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["ForXStatement"];
	var FUNCTION_TYPES$1 = FLIPPED_ALIAS_KEYS$3["Function"];
	var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS$3["FunctionParent"];
	var PUREISH_TYPES = FLIPPED_ALIAS_KEYS$3["Pureish"];
	var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["Declaration"];
	var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS$3["PatternLike"];
	var LVAL_TYPES = FLIPPED_ALIAS_KEYS$3["LVal"];
	var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS$3["TSEntityName"];
	var LITERAL_TYPES = FLIPPED_ALIAS_KEYS$3["Literal"];
	var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS$3["Immutable"];
	var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS$3["UserWhitespacable"];
	var METHOD_TYPES = FLIPPED_ALIAS_KEYS$3["Method"];
	var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS$3["ObjectMember"];
	var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS$3["Property"];
	var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS$3["UnaryLike"];
	var PATTERN_TYPES = FLIPPED_ALIAS_KEYS$3["Pattern"];
	var CLASS_TYPES = FLIPPED_ALIAS_KEYS$3["Class"];
	var MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["ModuleDeclaration"];
	var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["ExportDeclaration"];
	var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS$3["ModuleSpecifier"];
	var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS$3["Private"];
	var FLOW_TYPES = FLIPPED_ALIAS_KEYS$3["Flow"];
	var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS$3["FlowType"];
	var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS$3["FlowBaseAnnotation"];
	var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["FlowDeclaration"];
	var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS$3["FlowPredicate"];
	var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS$3["EnumBody"];
	var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS$3["EnumMember"];
	var JSX_TYPES = FLIPPED_ALIAS_KEYS$3["JSX"];
	var MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS$3["Miscellaneous"];
	var TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS$3["TypeScript"];
	var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["TSTypeElement"];
	var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS$3["TSType"];
	var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS$3["TSBaseType"];

	function toBlock(node, parent) {
	  if (isBlockStatement$2(node)) {
	    return node;
	  }

	  var blockNodes = [];

	  if (isEmptyStatement$1(node)) {
	    blockNodes = [];
	  } else {
	    if (!isStatement$7(node)) {
	      if (isFunction$4(parent)) {
	        node = returnStatement$3(node);
	      } else {
	        node = expressionStatement$a(node);
	      }
	    }

	    blockNodes = [node];
	  }

	  return blockStatement$6(blockNodes);
	}

	function ensureBlock$1(node, key) {
	  if (key === void 0) {
	    key = "body";
	  }

	  return node[key] = toBlock(node[key], node);
	}

	function toIdentifier$1(input) {
	  input = input + "";
	  var name = "";

	  for (var _iterator = _createForOfIteratorHelperLoose(input), _step; !(_step = _iterator()).done;) {
	    var c = _step.value;
	    name += isIdentifierChar(c.codePointAt(0)) ? c : "-";
	  }

	  name = name.replace(/^[-0-9]+/, "");
	  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
	    return c ? c.toUpperCase() : "";
	  });

	  if (!isValidIdentifier$1(name)) {
	    name = "_" + name;
	  }

	  return name || "_";
	}

	function toBindingIdentifierName$1(name) {
	  name = toIdentifier$1(name);
	  if (name === "eval" || name === "arguments") name = "_" + name;
	  return name;
	}

	function toComputedKey$3(node, key) {
	  if (key === void 0) {
	    key = node.key || node.property;
	  }

	  if (!node.computed && isIdentifier$g(key)) key = stringLiteral$8(key.name);
	  return key;
	}

	function toExpression$1(node) {
	  if (isExpressionStatement$4(node)) {
	    node = node.expression;
	  }

	  if (isExpression$4(node)) {
	    return node;
	  }

	  if (isClass$1(node)) {
	    node.type = "ClassExpression";
	  } else if (isFunction$4(node)) {
	    node.type = "FunctionExpression";
	  }

	  if (!isExpression$4(node)) {
	    throw new Error("cannot turn " + node.type + " to an expression");
	  }

	  return node;
	}

	function traverseFast$2(node, enter, opts) {
	  if (!node) return;
	  var keys = VISITOR_KEYS$6[node.type];
	  if (!keys) return;
	  opts = opts || {};
	  enter(node, opts);

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    var subNode = node[key];

	    if (Array.isArray(subNode)) {
	      for (var _iterator2 = _createForOfIteratorHelperLoose(subNode), _step2; !(_step2 = _iterator2()).done;) {
	        var _node = _step2.value;
	        traverseFast$2(_node, enter, opts);
	      }
	    } else {
	      traverseFast$2(subNode, enter, opts);
	    }
	  }
	}

	var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
	var CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
	function removeProperties$1(node, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

	  for (var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;) {
	    var _key = _step.value;
	    if (node[_key] != null) node[_key] = undefined;
	  }

	  for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
	    var key = _Object$keys[_i];
	    if (key[0] === "_" && node[key] != null) node[key] = undefined;
	  }

	  var symbols = Object.getOwnPropertySymbols(node);

	  for (var _iterator2 = _createForOfIteratorHelperLoose(symbols), _step2; !(_step2 = _iterator2()).done;) {
	    var sym = _step2.value;
	    node[sym] = null;
	  }
	}

	function removePropertiesDeep$1(tree, opts) {
	  traverseFast$2(tree, removeProperties$1, opts);
	  return tree;
	}

	function toKeyAlias$1(node, key) {
	  if (key === void 0) {
	    key = node.key;
	  }

	  var alias;

	  if (node.kind === "method") {
	    return toKeyAlias$1.increment() + "";
	  } else if (isIdentifier$g(key)) {
	    alias = key.name;
	  } else if (isStringLiteral$7(key)) {
	    alias = JSON.stringify(key.value);
	  } else {
	    alias = JSON.stringify(removePropertiesDeep$1(cloneNode$i(key)));
	  }

	  if (node.computed) {
	    alias = "[" + alias + "]";
	  }

	  if (node["static"]) {
	    alias = "static:" + alias;
	  }

	  return alias;
	}
	toKeyAlias$1.uid = 0;

	toKeyAlias$1.increment = function () {
	  if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
	    return toKeyAlias$1.uid = 0;
	  } else {
	    return toKeyAlias$1.uid++;
	  }
	};

	function getBindingIdentifiers$2(node, duplicates, outerOnly) {
	  var search = [].concat(node);
	  var ids = Object.create(null);

	  while (search.length) {
	    var id = search.shift();
	    if (!id) continue;
	    var keys = getBindingIdentifiers$2.keys[id.type];

	    if (isIdentifier$g(id)) {
	      if (duplicates) {
	        var _ids = ids[id.name] = ids[id.name] || [];

	        _ids.push(id);
	      } else {
	        ids[id.name] = id;
	      }

	      continue;
	    }

	    if (isExportDeclaration$2(id) && !isExportAllDeclaration$1(id)) {
	      if (isDeclaration$1(id.declaration)) {
	        search.push(id.declaration);
	      }

	      continue;
	    }

	    if (outerOnly) {
	      if (isFunctionDeclaration$1(id)) {
	        search.push(id.id);
	        continue;
	      }

	      if (isFunctionExpression$1(id)) {
	        continue;
	      }
	    }

	    if (keys) {
	      for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];

	        if (id[key]) {
	          search = search.concat(id[key]);
	        }
	      }
	    }
	  }

	  return ids;
	}

	getBindingIdentifiers$2.keys = {
	  DeclareClass: ["id"],
	  DeclareFunction: ["id"],
	  DeclareModule: ["id"],
	  DeclareVariable: ["id"],
	  DeclareInterface: ["id"],
	  DeclareTypeAlias: ["id"],
	  DeclareOpaqueType: ["id"],
	  InterfaceDeclaration: ["id"],
	  TypeAlias: ["id"],
	  OpaqueType: ["id"],
	  CatchClause: ["param"],
	  LabeledStatement: ["label"],
	  UnaryExpression: ["argument"],
	  AssignmentExpression: ["left"],
	  ImportSpecifier: ["local"],
	  ImportNamespaceSpecifier: ["local"],
	  ImportDefaultSpecifier: ["local"],
	  ImportDeclaration: ["specifiers"],
	  ExportSpecifier: ["exported"],
	  ExportNamespaceSpecifier: ["exported"],
	  ExportDefaultSpecifier: ["exported"],
	  FunctionDeclaration: ["id", "params"],
	  FunctionExpression: ["id", "params"],
	  ArrowFunctionExpression: ["params"],
	  ObjectMethod: ["params"],
	  ClassMethod: ["params"],
	  ClassPrivateMethod: ["params"],
	  ForInStatement: ["left"],
	  ForOfStatement: ["left"],
	  ClassDeclaration: ["id"],
	  ClassExpression: ["id"],
	  RestElement: ["argument"],
	  UpdateExpression: ["argument"],
	  ObjectProperty: ["value"],
	  AssignmentPattern: ["left"],
	  ArrayPattern: ["elements"],
	  ObjectPattern: ["properties"],
	  VariableDeclaration: ["declarations"],
	  VariableDeclarator: ["id"]
	};

	function gatherSequenceExpressions(nodes, scope, declars) {
	  var exprs = [];
	  var ensureLastUndefined = true;

	  for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
	    var node = _step.value;

	    if (!isEmptyStatement$1(node)) {
	      ensureLastUndefined = false;
	    }

	    if (isExpression$4(node)) {
	      exprs.push(node);
	    } else if (isExpressionStatement$4(node)) {
	      exprs.push(node.expression);
	    } else if (isVariableDeclaration$3(node)) {
	      if (node.kind !== "var") return;

	      for (var _iterator2 = _createForOfIteratorHelperLoose(node.declarations), _step2; !(_step2 = _iterator2()).done;) {
	        var declar = _step2.value;
	        var bindings = getBindingIdentifiers$2(declar);

	        for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
	          var key = _Object$keys[_i];
	          declars.push({
	            kind: node.kind,
	            id: cloneNode$i(bindings[key])
	          });
	        }

	        if (declar.init) {
	          exprs.push(assignmentExpression$c("=", declar.id, declar.init));
	        }
	      }

	      ensureLastUndefined = true;
	    } else if (isIfStatement$2(node)) {
	      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
	      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
	      if (!consequent || !alternate) return;
	      exprs.push(conditionalExpression$3(node.test, consequent, alternate));
	    } else if (isBlockStatement$2(node)) {
	      var body = gatherSequenceExpressions(node.body, scope, declars);
	      if (!body) return;
	      exprs.push(body);
	    } else if (isEmptyStatement$1(node)) {
	      if (nodes.indexOf(node) === 0) {
	        ensureLastUndefined = true;
	      }
	    } else {
	      return;
	    }
	  }

	  if (ensureLastUndefined) {
	    exprs.push(scope.buildUndefinedNode());
	  }

	  if (exprs.length === 1) {
	    return exprs[0];
	  } else {
	    return sequenceExpression$7(exprs);
	  }
	}

	function toSequenceExpression$1(nodes, scope) {
	  if (!(nodes != null && nodes.length)) return;
	  var declars = [];
	  var result = gatherSequenceExpressions(nodes, scope, declars);
	  if (!result) return;

	  for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
	    var declar = _declars[_i];
	    scope.push(declar);
	  }

	  return result;
	}

	function toStatement(node, ignore) {
	  if (isStatement$7(node)) {
	    return node;
	  }

	  var mustHaveId = false;
	  var newType;

	  if (isClass$1(node)) {
	    mustHaveId = true;
	    newType = "ClassDeclaration";
	  } else if (isFunction$4(node)) {
	    mustHaveId = true;
	    newType = "FunctionDeclaration";
	  } else if (isAssignmentExpression$3(node)) {
	    return expressionStatement$a(node);
	  }

	  if (mustHaveId && !node.id) {
	    newType = false;
	  }

	  if (!newType) {
	    if (ignore) {
	      return false;
	    } else {
	      throw new Error("cannot turn " + node.type + " to a statement");
	    }
	  }

	  node.type = newType;
	  return node;
	}

	var objectToString = Function.call.bind(Object.prototype.toString);

	function isRegExp(value) {
	  return objectToString(value) === "[object RegExp]";
	}

	function isPlainObject(value) {
	  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
	    return false;
	  }

	  var proto = Object.getPrototypeOf(value);
	  return proto === null || Object.getPrototypeOf(proto) === null;
	}

	function valueToNode$1(value) {
	  if (value === undefined) {
	    return identifier$j("undefined");
	  }

	  if (value === true || value === false) {
	    return booleanLiteral$5(value);
	  }

	  if (value === null) {
	    return nullLiteral$2();
	  }

	  if (typeof value === "string") {
	    return stringLiteral$8(value);
	  }

	  if (typeof value === "number") {
	    var result;

	    if (Number.isFinite(value)) {
	      result = numericLiteral$8(Math.abs(value));
	    } else {
	      var numerator;

	      if (Number.isNaN(value)) {
	        numerator = numericLiteral$8(0);
	      } else {
	        numerator = numericLiteral$8(1);
	      }

	      result = binaryExpression$4("/", numerator, numericLiteral$8(0));
	    }

	    if (value < 0 || Object.is(value, -0)) {
	      result = unaryExpression$7("-", result);
	    }

	    return result;
	  }

	  if (isRegExp(value)) {
	    var pattern = value.source;
	    var flags = value.toString().match(/\/([a-z]+|)$/)[1];
	    return regExpLiteral(pattern, flags);
	  }

	  if (Array.isArray(value)) {
	    return arrayExpression$2(value.map(valueToNode$1));
	  }

	  if (isPlainObject(value)) {
	    var props = [];

	    for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
	      var key = _Object$keys[_i];
	      var nodeKey = void 0;

	      if (isValidIdentifier$1(key)) {
	        nodeKey = identifier$j(key);
	      } else {
	        nodeKey = stringLiteral$8(key);
	      }

	      props.push(objectProperty$2(nodeKey, valueToNode$1(value[key])));
	    }

	    return objectExpression$4(props);
	  }

	  throw new Error("don't know how to turn this value into a node");
	}

	function appendToMemberExpression(member, append, computed) {
	  if (computed === void 0) {
	    computed = false;
	  }

	  member.object = memberExpression$b(member.object, member.property, member.computed);
	  member.property = append;
	  member.computed = !!computed;
	  return member;
	}

	function inherits$1(child, parent) {
	  if (!child || !parent) return child;

	  for (var _iterator = _createForOfIteratorHelperLoose(INHERIT_KEYS.optional), _step; !(_step = _iterator()).done;) {
	    var _key = _step.value;

	    if (child[_key] == null) {
	      child[_key] = parent[_key];
	    }
	  }

	  for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
	    var key = _Object$keys[_i];
	    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
	  }

	  for (var _iterator2 = _createForOfIteratorHelperLoose(INHERIT_KEYS.force), _step2; !(_step2 = _iterator2()).done;) {
	    var _key2 = _step2.value;
	    child[_key2] = parent[_key2];
	  }

	  inheritsComments$2(child, parent);
	  return child;
	}

	function prependToMemberExpression(member, prepend) {
	  member.object = memberExpression$b(prepend, member.object);
	  return member;
	}

	function getOuterBindingIdentifiers$2(node, duplicates) {
	  return getBindingIdentifiers$2(node, duplicates, true);
	}

	function traverse$2(node, handlers, state) {
	  if (typeof handlers === "function") {
	    handlers = {
	      enter: handlers
	    };
	  }

	  var _ref = handlers,
	      enter = _ref.enter,
	      exit = _ref.exit;
	  traverseSimpleImpl(node, enter, exit, state, []);
	}

	function traverseSimpleImpl(node, enter, exit, state, ancestors) {
	  var keys = VISITOR_KEYS$6[node.type];
	  if (!keys) return;
	  if (enter) enter(node, ancestors, state);

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    var subNode = node[key];

	    if (Array.isArray(subNode)) {
	      for (var i = 0; i < subNode.length; i++) {
	        var child = subNode[i];
	        if (!child) continue;
	        ancestors.push({
	          node: node,
	          key: key,
	          index: i
	        });
	        traverseSimpleImpl(child, enter, exit, state, ancestors);
	        ancestors.pop();
	      }
	    } else if (subNode) {
	      ancestors.push({
	        node: node,
	        key: key
	      });
	      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
	      ancestors.pop();
	    }
	  }

	  if (exit) exit(node, ancestors, state);
	}

	function isBinding$1(node, parent, grandparent) {
	  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
	    return false;
	  }

	  var keys = getBindingIdentifiers$2.keys[parent.type];

	  if (keys) {
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var val = parent[key];

	      if (Array.isArray(val)) {
	        if (val.indexOf(node) >= 0) return true;
	      } else {
	        if (val === node) return true;
	      }
	    }
	  }

	  return false;
	}

	function isLet(node) {
	  return isVariableDeclaration$3(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
	}

	function isBlockScoped$2(node) {
	  return isFunctionDeclaration$1(node) || isClassDeclaration$3(node) || isLet(node);
	}

	function isImmutable(node) {
	  if (isType$2(node.type, "Immutable")) return true;

	  if (isIdentifier$g(node)) {
	    if (node.name === "undefined") {
	      return true;
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

	function isNodesEquivalent(a, b) {
	  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
	    return a === b;
	  }

	  if (a.type !== b.type) {
	    return false;
	  }

	  var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
	  var visitorKeys = VISITOR_KEYS$6[a.type];

	  for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
	    var field = _fields[_i];

	    if (typeof a[field] !== typeof b[field]) {
	      return false;
	    }

	    if (a[field] == null && b[field] == null) {
	      continue;
	    } else if (a[field] == null || b[field] == null) {
	      return false;
	    }

	    if (Array.isArray(a[field])) {
	      if (!Array.isArray(b[field])) {
	        return false;
	      }

	      if (a[field].length !== b[field].length) {
	        return false;
	      }

	      for (var i = 0; i < a[field].length; i++) {
	        if (!isNodesEquivalent(a[field][i], b[field][i])) {
	          return false;
	        }
	      }

	      continue;
	    }

	    if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
	      for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
	        var key = _Object$keys[_i2];

	        if (a[field][key] !== b[field][key]) {
	          return false;
	        }
	      }

	      continue;
	    }

	    if (!isNodesEquivalent(a[field], b[field])) {
	      return false;
	    }
	  }

	  return true;
	}

	function isReferenced$2(node, parent, grandparent) {
	  switch (parent.type) {
	    case "MemberExpression":
	    case "OptionalMemberExpression":
	      if (parent.property === node) {
	        return !!parent.computed;
	      }

	      return parent.object === node;

	    case "JSXMemberExpression":
	      return parent.object === node;

	    case "VariableDeclarator":
	      return parent.init === node;

	    case "ArrowFunctionExpression":
	      return parent.body === node;

	    case "PrivateName":
	      return false;

	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "ObjectMethod":
	      if (parent.key === node) {
	        return !!parent.computed;
	      }

	      return false;

	    case "ObjectProperty":
	      if (parent.key === node) {
	        return !!parent.computed;
	      }

	      return !grandparent || grandparent.type !== "ObjectPattern";

	    case "ClassProperty":
	      if (parent.key === node) {
	        return !!parent.computed;
	      }

	      return true;

	    case "ClassPrivateProperty":
	      return parent.key !== node;

	    case "ClassDeclaration":
	    case "ClassExpression":
	      return parent.superClass === node;

	    case "AssignmentExpression":
	      return parent.right === node;

	    case "AssignmentPattern":
	      return parent.right === node;

	    case "LabeledStatement":
	      return false;

	    case "CatchClause":
	      return false;

	    case "RestElement":
	      return false;

	    case "BreakStatement":
	    case "ContinueStatement":
	      return false;

	    case "FunctionDeclaration":
	    case "FunctionExpression":
	      return false;

	    case "ExportNamespaceSpecifier":
	    case "ExportDefaultSpecifier":
	      return false;

	    case "ExportSpecifier":
	      if (grandparent != null && grandparent.source) {
	        return false;
	      }

	      return parent.local === node;

	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	      return false;

	    case "ImportAttribute":
	      return false;

	    case "JSXAttribute":
	      return false;

	    case "ObjectPattern":
	    case "ArrayPattern":
	      return false;

	    case "MetaProperty":
	      return false;

	    case "ObjectTypeProperty":
	      return parent.key !== node;

	    case "TSEnumMember":
	      return parent.id !== node;

	    case "TSPropertySignature":
	      if (parent.key === node) {
	        return !!parent.computed;
	      }

	      return true;
	  }

	  return true;
	}

	function isScope$1(node, parent) {
	  if (isBlockStatement$2(node) && (isFunction$4(parent) || isCatchClause(parent))) {
	    return false;
	  }

	  if (isPattern(node) && (isFunction$4(parent) || isCatchClause(parent))) {
	    return true;
	  }

	  return isScopable(node);
	}

	function isSpecifierDefault(specifier) {
	  return isImportDefaultSpecifier$1(specifier) || isIdentifier$g(specifier.imported || specifier.exported, {
	    name: "default"
	  });
	}

	var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
	function isValidES3Identifier(name) {
	  return isValidIdentifier$1(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
	}

	function isVar$2(node) {
	  return isVariableDeclaration$3(node, {
	    kind: "var"
	  }) && !node[BLOCK_SCOPED_SYMBOL];
	}

	var react$3 = {
	  isReactComponent: isReactComponent,
	  isCompatTag: isCompatTag$1,
	  buildChildren: buildChildren
	};

	var t$f = /*#__PURE__*/Object.freeze({
		__proto__: null,
		react: react$3,
		assertNode: assertNode,
		createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof$1,
		createUnionTypeAnnotation: createFlowUnionType$2,
		createFlowUnionType: createFlowUnionType$2,
		createTSUnionType: createTSUnionType$2,
		cloneNode: cloneNode$i,
		clone: clone,
		cloneDeep: cloneDeep$1,
		cloneDeepWithoutLoc: cloneDeepWithoutLoc,
		cloneWithoutLoc: cloneWithoutLoc,
		addComment: addComment$2,
		addComments: addComments$1,
		inheritInnerComments: inheritInnerComments,
		inheritLeadingComments: inheritLeadingComments$1,
		inheritsComments: inheritsComments$2,
		inheritTrailingComments: inheritTrailingComments$1,
		removeComments: removeComments$2,
		ensureBlock: ensureBlock$1,
		toBindingIdentifierName: toBindingIdentifierName$1,
		toBlock: toBlock,
		toComputedKey: toComputedKey$3,
		toExpression: toExpression$1,
		toIdentifier: toIdentifier$1,
		toKeyAlias: toKeyAlias$1,
		toSequenceExpression: toSequenceExpression$1,
		toStatement: toStatement,
		valueToNode: valueToNode$1,
		appendToMemberExpression: appendToMemberExpression,
		inherits: inherits$1,
		prependToMemberExpression: prependToMemberExpression,
		removeProperties: removeProperties$1,
		removePropertiesDeep: removePropertiesDeep$1,
		removeTypeDuplicates: removeTypeDuplicates$1,
		getBindingIdentifiers: getBindingIdentifiers$2,
		getOuterBindingIdentifiers: getOuterBindingIdentifiers$2,
		traverse: traverse$2,
		traverseFast: traverseFast$2,
		shallowEqual: shallowEqual,
		is: is$1,
		isBinding: isBinding$1,
		isBlockScoped: isBlockScoped$2,
		isImmutable: isImmutable,
		isLet: isLet,
		isNode: isNode,
		isNodesEquivalent: isNodesEquivalent,
		isPlaceholderType: isPlaceholderType,
		isReferenced: isReferenced$2,
		isScope: isScope$1,
		isSpecifierDefault: isSpecifierDefault,
		isType: isType$2,
		isValidES3Identifier: isValidES3Identifier,
		isValidIdentifier: isValidIdentifier$1,
		isVar: isVar$2,
		matchesPattern: matchesPattern$2,
		validate: validate$6,
		buildMatchMemberExpression: buildMatchMemberExpression$1,
		assertArrayExpression: assertArrayExpression,
		assertAssignmentExpression: assertAssignmentExpression,
		assertBinaryExpression: assertBinaryExpression,
		assertInterpreterDirective: assertInterpreterDirective,
		assertDirective: assertDirective,
		assertDirectiveLiteral: assertDirectiveLiteral,
		assertBlockStatement: assertBlockStatement,
		assertBreakStatement: assertBreakStatement,
		assertCallExpression: assertCallExpression,
		assertCatchClause: assertCatchClause,
		assertConditionalExpression: assertConditionalExpression,
		assertContinueStatement: assertContinueStatement,
		assertDebuggerStatement: assertDebuggerStatement,
		assertDoWhileStatement: assertDoWhileStatement,
		assertEmptyStatement: assertEmptyStatement,
		assertExpressionStatement: assertExpressionStatement$1,
		assertFile: assertFile,
		assertForInStatement: assertForInStatement,
		assertForStatement: assertForStatement,
		assertFunctionDeclaration: assertFunctionDeclaration,
		assertFunctionExpression: assertFunctionExpression,
		assertIdentifier: assertIdentifier,
		assertIfStatement: assertIfStatement,
		assertLabeledStatement: assertLabeledStatement,
		assertStringLiteral: assertStringLiteral,
		assertNumericLiteral: assertNumericLiteral,
		assertNullLiteral: assertNullLiteral,
		assertBooleanLiteral: assertBooleanLiteral,
		assertRegExpLiteral: assertRegExpLiteral,
		assertLogicalExpression: assertLogicalExpression,
		assertMemberExpression: assertMemberExpression,
		assertNewExpression: assertNewExpression,
		assertProgram: assertProgram,
		assertObjectExpression: assertObjectExpression,
		assertObjectMethod: assertObjectMethod,
		assertObjectProperty: assertObjectProperty,
		assertRestElement: assertRestElement,
		assertReturnStatement: assertReturnStatement,
		assertSequenceExpression: assertSequenceExpression,
		assertParenthesizedExpression: assertParenthesizedExpression,
		assertSwitchCase: assertSwitchCase,
		assertSwitchStatement: assertSwitchStatement,
		assertThisExpression: assertThisExpression,
		assertThrowStatement: assertThrowStatement,
		assertTryStatement: assertTryStatement,
		assertUnaryExpression: assertUnaryExpression,
		assertUpdateExpression: assertUpdateExpression,
		assertVariableDeclaration: assertVariableDeclaration,
		assertVariableDeclarator: assertVariableDeclarator,
		assertWhileStatement: assertWhileStatement,
		assertWithStatement: assertWithStatement,
		assertAssignmentPattern: assertAssignmentPattern,
		assertArrayPattern: assertArrayPattern,
		assertArrowFunctionExpression: assertArrowFunctionExpression,
		assertClassBody: assertClassBody,
		assertClassExpression: assertClassExpression,
		assertClassDeclaration: assertClassDeclaration,
		assertExportAllDeclaration: assertExportAllDeclaration,
		assertExportDefaultDeclaration: assertExportDefaultDeclaration,
		assertExportNamedDeclaration: assertExportNamedDeclaration,
		assertExportSpecifier: assertExportSpecifier$1,
		assertForOfStatement: assertForOfStatement,
		assertImportDeclaration: assertImportDeclaration,
		assertImportDefaultSpecifier: assertImportDefaultSpecifier,
		assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
		assertImportSpecifier: assertImportSpecifier,
		assertMetaProperty: assertMetaProperty,
		assertClassMethod: assertClassMethod,
		assertObjectPattern: assertObjectPattern,
		assertSpreadElement: assertSpreadElement,
		assertSuper: assertSuper,
		assertTaggedTemplateExpression: assertTaggedTemplateExpression,
		assertTemplateElement: assertTemplateElement,
		assertTemplateLiteral: assertTemplateLiteral,
		assertYieldExpression: assertYieldExpression,
		assertAwaitExpression: assertAwaitExpression,
		assertImport: assertImport,
		assertBigIntLiteral: assertBigIntLiteral,
		assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
		assertOptionalMemberExpression: assertOptionalMemberExpression,
		assertOptionalCallExpression: assertOptionalCallExpression,
		assertClassProperty: assertClassProperty,
		assertClassPrivateProperty: assertClassPrivateProperty,
		assertClassPrivateMethod: assertClassPrivateMethod,
		assertPrivateName: assertPrivateName,
		assertStaticBlock: assertStaticBlock,
		assertAnyTypeAnnotation: assertAnyTypeAnnotation,
		assertArrayTypeAnnotation: assertArrayTypeAnnotation,
		assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
		assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
		assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
		assertClassImplements: assertClassImplements,
		assertDeclareClass: assertDeclareClass,
		assertDeclareFunction: assertDeclareFunction,
		assertDeclareInterface: assertDeclareInterface,
		assertDeclareModule: assertDeclareModule,
		assertDeclareModuleExports: assertDeclareModuleExports,
		assertDeclareTypeAlias: assertDeclareTypeAlias,
		assertDeclareOpaqueType: assertDeclareOpaqueType,
		assertDeclareVariable: assertDeclareVariable,
		assertDeclareExportDeclaration: assertDeclareExportDeclaration,
		assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
		assertDeclaredPredicate: assertDeclaredPredicate,
		assertExistsTypeAnnotation: assertExistsTypeAnnotation,
		assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
		assertFunctionTypeParam: assertFunctionTypeParam,
		assertGenericTypeAnnotation: assertGenericTypeAnnotation,
		assertInferredPredicate: assertInferredPredicate,
		assertInterfaceExtends: assertInterfaceExtends,
		assertInterfaceDeclaration: assertInterfaceDeclaration,
		assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
		assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
		assertMixedTypeAnnotation: assertMixedTypeAnnotation,
		assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
		assertNullableTypeAnnotation: assertNullableTypeAnnotation,
		assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
		assertNumberTypeAnnotation: assertNumberTypeAnnotation,
		assertObjectTypeAnnotation: assertObjectTypeAnnotation,
		assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
		assertObjectTypeCallProperty: assertObjectTypeCallProperty,
		assertObjectTypeIndexer: assertObjectTypeIndexer,
		assertObjectTypeProperty: assertObjectTypeProperty,
		assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
		assertOpaqueType: assertOpaqueType,
		assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
		assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
		assertStringTypeAnnotation: assertStringTypeAnnotation,
		assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
		assertThisTypeAnnotation: assertThisTypeAnnotation,
		assertTupleTypeAnnotation: assertTupleTypeAnnotation,
		assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
		assertTypeAlias: assertTypeAlias,
		assertTypeAnnotation: assertTypeAnnotation,
		assertTypeCastExpression: assertTypeCastExpression,
		assertTypeParameter: assertTypeParameter,
		assertTypeParameterDeclaration: assertTypeParameterDeclaration,
		assertTypeParameterInstantiation: assertTypeParameterInstantiation,
		assertUnionTypeAnnotation: assertUnionTypeAnnotation,
		assertVariance: assertVariance,
		assertVoidTypeAnnotation: assertVoidTypeAnnotation,
		assertEnumDeclaration: assertEnumDeclaration,
		assertEnumBooleanBody: assertEnumBooleanBody,
		assertEnumNumberBody: assertEnumNumberBody,
		assertEnumStringBody: assertEnumStringBody,
		assertEnumSymbolBody: assertEnumSymbolBody,
		assertEnumBooleanMember: assertEnumBooleanMember,
		assertEnumNumberMember: assertEnumNumberMember,
		assertEnumStringMember: assertEnumStringMember,
		assertEnumDefaultedMember: assertEnumDefaultedMember,
		assertIndexedAccessType: assertIndexedAccessType,
		assertOptionalIndexedAccessType: assertOptionalIndexedAccessType,
		assertJSXAttribute: assertJSXAttribute,
		assertJSXClosingElement: assertJSXClosingElement,
		assertJSXElement: assertJSXElement,
		assertJSXEmptyExpression: assertJSXEmptyExpression,
		assertJSXExpressionContainer: assertJSXExpressionContainer,
		assertJSXSpreadChild: assertJSXSpreadChild,
		assertJSXIdentifier: assertJSXIdentifier,
		assertJSXMemberExpression: assertJSXMemberExpression,
		assertJSXNamespacedName: assertJSXNamespacedName,
		assertJSXOpeningElement: assertJSXOpeningElement,
		assertJSXSpreadAttribute: assertJSXSpreadAttribute,
		assertJSXText: assertJSXText,
		assertJSXFragment: assertJSXFragment,
		assertJSXOpeningFragment: assertJSXOpeningFragment,
		assertJSXClosingFragment: assertJSXClosingFragment,
		assertNoop: assertNoop,
		assertPlaceholder: assertPlaceholder,
		assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
		assertArgumentPlaceholder: assertArgumentPlaceholder,
		assertBindExpression: assertBindExpression,
		assertImportAttribute: assertImportAttribute,
		assertDecorator: assertDecorator,
		assertDoExpression: assertDoExpression,
		assertExportDefaultSpecifier: assertExportDefaultSpecifier,
		assertRecordExpression: assertRecordExpression,
		assertTupleExpression: assertTupleExpression,
		assertDecimalLiteral: assertDecimalLiteral,
		assertModuleExpression: assertModuleExpression,
		assertTopicReference: assertTopicReference,
		assertPipelineTopicExpression: assertPipelineTopicExpression,
		assertPipelineBareFunction: assertPipelineBareFunction,
		assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
		assertTSParameterProperty: assertTSParameterProperty,
		assertTSDeclareFunction: assertTSDeclareFunction,
		assertTSDeclareMethod: assertTSDeclareMethod,
		assertTSQualifiedName: assertTSQualifiedName,
		assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
		assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
		assertTSPropertySignature: assertTSPropertySignature,
		assertTSMethodSignature: assertTSMethodSignature,
		assertTSIndexSignature: assertTSIndexSignature,
		assertTSAnyKeyword: assertTSAnyKeyword,
		assertTSBooleanKeyword: assertTSBooleanKeyword,
		assertTSBigIntKeyword: assertTSBigIntKeyword,
		assertTSIntrinsicKeyword: assertTSIntrinsicKeyword,
		assertTSNeverKeyword: assertTSNeverKeyword,
		assertTSNullKeyword: assertTSNullKeyword,
		assertTSNumberKeyword: assertTSNumberKeyword,
		assertTSObjectKeyword: assertTSObjectKeyword,
		assertTSStringKeyword: assertTSStringKeyword,
		assertTSSymbolKeyword: assertTSSymbolKeyword,
		assertTSUndefinedKeyword: assertTSUndefinedKeyword,
		assertTSUnknownKeyword: assertTSUnknownKeyword,
		assertTSVoidKeyword: assertTSVoidKeyword,
		assertTSThisType: assertTSThisType,
		assertTSFunctionType: assertTSFunctionType,
		assertTSConstructorType: assertTSConstructorType,
		assertTSTypeReference: assertTSTypeReference,
		assertTSTypePredicate: assertTSTypePredicate,
		assertTSTypeQuery: assertTSTypeQuery,
		assertTSTypeLiteral: assertTSTypeLiteral,
		assertTSArrayType: assertTSArrayType,
		assertTSTupleType: assertTSTupleType,
		assertTSOptionalType: assertTSOptionalType,
		assertTSRestType: assertTSRestType,
		assertTSNamedTupleMember: assertTSNamedTupleMember,
		assertTSUnionType: assertTSUnionType,
		assertTSIntersectionType: assertTSIntersectionType,
		assertTSConditionalType: assertTSConditionalType,
		assertTSInferType: assertTSInferType,
		assertTSParenthesizedType: assertTSParenthesizedType,
		assertTSTypeOperator: assertTSTypeOperator,
		assertTSIndexedAccessType: assertTSIndexedAccessType,
		assertTSMappedType: assertTSMappedType,
		assertTSLiteralType: assertTSLiteralType,
		assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
		assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
		assertTSInterfaceBody: assertTSInterfaceBody,
		assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
		assertTSAsExpression: assertTSAsExpression,
		assertTSTypeAssertion: assertTSTypeAssertion,
		assertTSEnumDeclaration: assertTSEnumDeclaration,
		assertTSEnumMember: assertTSEnumMember,
		assertTSModuleDeclaration: assertTSModuleDeclaration,
		assertTSModuleBlock: assertTSModuleBlock,
		assertTSImportType: assertTSImportType,
		assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
		assertTSExternalModuleReference: assertTSExternalModuleReference,
		assertTSNonNullExpression: assertTSNonNullExpression,
		assertTSExportAssignment: assertTSExportAssignment,
		assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
		assertTSTypeAnnotation: assertTSTypeAnnotation,
		assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
		assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
		assertTSTypeParameter: assertTSTypeParameter,
		assertStandardized: assertStandardized,
		assertExpression: assertExpression$1,
		assertBinary: assertBinary,
		assertScopable: assertScopable,
		assertBlockParent: assertBlockParent,
		assertBlock: assertBlock,
		assertStatement: assertStatement,
		assertTerminatorless: assertTerminatorless,
		assertCompletionStatement: assertCompletionStatement,
		assertConditional: assertConditional,
		assertLoop: assertLoop,
		assertWhile: assertWhile,
		assertExpressionWrapper: assertExpressionWrapper,
		assertFor: assertFor,
		assertForXStatement: assertForXStatement,
		assertFunction: assertFunction$1,
		assertFunctionParent: assertFunctionParent,
		assertPureish: assertPureish,
		assertDeclaration: assertDeclaration,
		assertPatternLike: assertPatternLike,
		assertLVal: assertLVal,
		assertTSEntityName: assertTSEntityName,
		assertLiteral: assertLiteral,
		assertImmutable: assertImmutable,
		assertUserWhitespacable: assertUserWhitespacable,
		assertMethod: assertMethod,
		assertObjectMember: assertObjectMember,
		assertProperty: assertProperty,
		assertUnaryLike: assertUnaryLike,
		assertPattern: assertPattern,
		assertClass: assertClass,
		assertModuleDeclaration: assertModuleDeclaration,
		assertExportDeclaration: assertExportDeclaration,
		assertModuleSpecifier: assertModuleSpecifier,
		assertPrivate: assertPrivate,
		assertFlow: assertFlow,
		assertFlowType: assertFlowType,
		assertFlowBaseAnnotation: assertFlowBaseAnnotation,
		assertFlowDeclaration: assertFlowDeclaration,
		assertFlowPredicate: assertFlowPredicate,
		assertEnumBody: assertEnumBody,
		assertEnumMember: assertEnumMember,
		assertJSX: assertJSX,
		assertMiscellaneous: assertMiscellaneous,
		assertTypeScript: assertTypeScript,
		assertTSTypeElement: assertTSTypeElement,
		assertTSType: assertTSType,
		assertTSBaseType: assertTSBaseType,
		assertNumberLiteral: assertNumberLiteral,
		assertRegexLiteral: assertRegexLiteral,
		assertRestProperty: assertRestProperty,
		assertSpreadProperty: assertSpreadProperty,
		arrayExpression: arrayExpression$2,
		assignmentExpression: assignmentExpression$c,
		binaryExpression: binaryExpression$4,
		interpreterDirective: interpreterDirective$1,
		directive: directive$1,
		directiveLiteral: directiveLiteral$1,
		blockStatement: blockStatement$6,
		breakStatement: breakStatement,
		callExpression: callExpression$e,
		catchClause: catchClause,
		conditionalExpression: conditionalExpression$3,
		continueStatement: continueStatement,
		debuggerStatement: debuggerStatement,
		doWhileStatement: doWhileStatement,
		emptyStatement: emptyStatement$1,
		expressionStatement: expressionStatement$a,
		file: file$1,
		forInStatement: forInStatement,
		forStatement: forStatement,
		functionDeclaration: functionDeclaration,
		functionExpression: functionExpression$3,
		identifier: identifier$j,
		ifStatement: ifStatement,
		labeledStatement: labeledStatement,
		stringLiteral: stringLiteral$8,
		numericLiteral: numericLiteral$8,
		nullLiteral: nullLiteral$2,
		booleanLiteral: booleanLiteral$5,
		regExpLiteral: regExpLiteral,
		logicalExpression: logicalExpression$2,
		memberExpression: memberExpression$b,
		newExpression: newExpression,
		program: program$3,
		objectExpression: objectExpression$4,
		objectMethod: objectMethod,
		objectProperty: objectProperty$2,
		restElement: restElement$1,
		returnStatement: returnStatement$3,
		sequenceExpression: sequenceExpression$7,
		parenthesizedExpression: parenthesizedExpression,
		switchCase: switchCase,
		switchStatement: switchStatement,
		thisExpression: thisExpression$3,
		throwStatement: throwStatement,
		tryStatement: tryStatement,
		unaryExpression: unaryExpression$7,
		updateExpression: updateExpression,
		variableDeclaration: variableDeclaration$8,
		variableDeclarator: variableDeclarator$8,
		whileStatement: whileStatement,
		withStatement: withStatement,
		assignmentPattern: assignmentPattern,
		arrayPattern: arrayPattern,
		arrowFunctionExpression: arrowFunctionExpression$4,
		classBody: classBody,
		classExpression: classExpression,
		classDeclaration: classDeclaration,
		exportAllDeclaration: exportAllDeclaration,
		exportDefaultDeclaration: exportDefaultDeclaration,
		exportNamedDeclaration: exportNamedDeclaration$2,
		exportSpecifier: exportSpecifier$2,
		forOfStatement: forOfStatement,
		importDeclaration: importDeclaration$1,
		importDefaultSpecifier: importDefaultSpecifier$1,
		importNamespaceSpecifier: importNamespaceSpecifier$1,
		importSpecifier: importSpecifier$1,
		metaProperty: metaProperty$1,
		classMethod: classMethod,
		objectPattern: objectPattern,
		spreadElement: spreadElement$2,
		'super': _super$1,
		taggedTemplateExpression: taggedTemplateExpression,
		templateElement: templateElement,
		templateLiteral: templateLiteral,
		yieldExpression: yieldExpression$2,
		awaitExpression: awaitExpression$1,
		'import': _import,
		bigIntLiteral: bigIntLiteral,
		exportNamespaceSpecifier: exportNamespaceSpecifier,
		optionalMemberExpression: optionalMemberExpression$2,
		optionalCallExpression: optionalCallExpression$2,
		classProperty: classProperty,
		classPrivateProperty: classPrivateProperty,
		classPrivateMethod: classPrivateMethod,
		privateName: privateName,
		staticBlock: staticBlock$1,
		anyTypeAnnotation: anyTypeAnnotation$2,
		arrayTypeAnnotation: arrayTypeAnnotation$1,
		booleanTypeAnnotation: booleanTypeAnnotation$1,
		booleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
		nullLiteralTypeAnnotation: nullLiteralTypeAnnotation$1,
		classImplements: classImplements,
		declareClass: declareClass,
		declareFunction: declareFunction,
		declareInterface: declareInterface,
		declareModule: declareModule,
		declareModuleExports: declareModuleExports,
		declareTypeAlias: declareTypeAlias,
		declareOpaqueType: declareOpaqueType,
		declareVariable: declareVariable,
		declareExportDeclaration: declareExportDeclaration,
		declareExportAllDeclaration: declareExportAllDeclaration,
		declaredPredicate: declaredPredicate,
		existsTypeAnnotation: existsTypeAnnotation,
		functionTypeAnnotation: functionTypeAnnotation,
		functionTypeParam: functionTypeParam,
		genericTypeAnnotation: genericTypeAnnotation$1,
		inferredPredicate: inferredPredicate,
		interfaceExtends: interfaceExtends,
		interfaceDeclaration: interfaceDeclaration,
		interfaceTypeAnnotation: interfaceTypeAnnotation,
		intersectionTypeAnnotation: intersectionTypeAnnotation,
		mixedTypeAnnotation: mixedTypeAnnotation,
		emptyTypeAnnotation: emptyTypeAnnotation,
		nullableTypeAnnotation: nullableTypeAnnotation,
		numberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
		numberTypeAnnotation: numberTypeAnnotation$2,
		objectTypeAnnotation: objectTypeAnnotation,
		objectTypeInternalSlot: objectTypeInternalSlot,
		objectTypeCallProperty: objectTypeCallProperty,
		objectTypeIndexer: objectTypeIndexer,
		objectTypeProperty: objectTypeProperty,
		objectTypeSpreadProperty: objectTypeSpreadProperty,
		opaqueType: opaqueType,
		qualifiedTypeIdentifier: qualifiedTypeIdentifier,
		stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
		stringTypeAnnotation: stringTypeAnnotation$2,
		symbolTypeAnnotation: symbolTypeAnnotation,
		thisTypeAnnotation: thisTypeAnnotation,
		tupleTypeAnnotation: tupleTypeAnnotation$1,
		typeofTypeAnnotation: typeofTypeAnnotation,
		typeAlias: typeAlias,
		typeAnnotation: typeAnnotation,
		typeCastExpression: typeCastExpression,
		typeParameter: typeParameter,
		typeParameterDeclaration: typeParameterDeclaration,
		typeParameterInstantiation: typeParameterInstantiation,
		unionTypeAnnotation: unionTypeAnnotation$1,
		variance: variance,
		voidTypeAnnotation: voidTypeAnnotation$3,
		enumDeclaration: enumDeclaration,
		enumBooleanBody: enumBooleanBody,
		enumNumberBody: enumNumberBody,
		enumStringBody: enumStringBody,
		enumSymbolBody: enumSymbolBody,
		enumBooleanMember: enumBooleanMember,
		enumNumberMember: enumNumberMember,
		enumStringMember: enumStringMember,
		enumDefaultedMember: enumDefaultedMember,
		indexedAccessType: indexedAccessType,
		optionalIndexedAccessType: optionalIndexedAccessType,
		jsxAttribute: jsxAttribute,
		jSXAttribute: jsxAttribute,
		jsxClosingElement: jsxClosingElement,
		jSXClosingElement: jsxClosingElement,
		jsxElement: jsxElement,
		jSXElement: jsxElement,
		jsxEmptyExpression: jsxEmptyExpression,
		jSXEmptyExpression: jsxEmptyExpression,
		jsxExpressionContainer: jsxExpressionContainer$1,
		jSXExpressionContainer: jsxExpressionContainer$1,
		jsxSpreadChild: jsxSpreadChild,
		jSXSpreadChild: jsxSpreadChild,
		jsxIdentifier: jsxIdentifier$2,
		jSXIdentifier: jsxIdentifier$2,
		jsxMemberExpression: jsxMemberExpression$1,
		jSXMemberExpression: jsxMemberExpression$1,
		jsxNamespacedName: jsxNamespacedName,
		jSXNamespacedName: jsxNamespacedName,
		jsxOpeningElement: jsxOpeningElement,
		jSXOpeningElement: jsxOpeningElement,
		jsxSpreadAttribute: jsxSpreadAttribute,
		jSXSpreadAttribute: jsxSpreadAttribute,
		jsxText: jsxText,
		jSXText: jsxText,
		jsxFragment: jsxFragment,
		jSXFragment: jsxFragment,
		jsxOpeningFragment: jsxOpeningFragment,
		jSXOpeningFragment: jsxOpeningFragment,
		jsxClosingFragment: jsxClosingFragment,
		jSXClosingFragment: jsxClosingFragment,
		noop: noop$1,
		placeholder: placeholder,
		v8IntrinsicIdentifier: v8IntrinsicIdentifier,
		argumentPlaceholder: argumentPlaceholder,
		bindExpression: bindExpression,
		importAttribute: importAttribute,
		decorator: decorator,
		doExpression: doExpression,
		exportDefaultSpecifier: exportDefaultSpecifier,
		recordExpression: recordExpression,
		tupleExpression: tupleExpression,
		decimalLiteral: decimalLiteral,
		moduleExpression: moduleExpression,
		topicReference: topicReference,
		pipelineTopicExpression: pipelineTopicExpression,
		pipelineBareFunction: pipelineBareFunction,
		pipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
		tsParameterProperty: tsParameterProperty,
		tSParameterProperty: tsParameterProperty,
		tsDeclareFunction: tsDeclareFunction,
		tSDeclareFunction: tsDeclareFunction,
		tsDeclareMethod: tsDeclareMethod,
		tSDeclareMethod: tsDeclareMethod,
		tsQualifiedName: tsQualifiedName,
		tSQualifiedName: tsQualifiedName,
		tsCallSignatureDeclaration: tsCallSignatureDeclaration,
		tSCallSignatureDeclaration: tsCallSignatureDeclaration,
		tsConstructSignatureDeclaration: tsConstructSignatureDeclaration,
		tSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
		tsPropertySignature: tsPropertySignature,
		tSPropertySignature: tsPropertySignature,
		tsMethodSignature: tsMethodSignature,
		tSMethodSignature: tsMethodSignature,
		tsIndexSignature: tsIndexSignature,
		tSIndexSignature: tsIndexSignature,
		tsAnyKeyword: tsAnyKeyword,
		tSAnyKeyword: tsAnyKeyword,
		tsBooleanKeyword: tsBooleanKeyword,
		tSBooleanKeyword: tsBooleanKeyword,
		tsBigIntKeyword: tsBigIntKeyword,
		tSBigIntKeyword: tsBigIntKeyword,
		tsIntrinsicKeyword: tsIntrinsicKeyword,
		tSIntrinsicKeyword: tsIntrinsicKeyword,
		tsNeverKeyword: tsNeverKeyword,
		tSNeverKeyword: tsNeverKeyword,
		tsNullKeyword: tsNullKeyword,
		tSNullKeyword: tsNullKeyword,
		tsNumberKeyword: tsNumberKeyword,
		tSNumberKeyword: tsNumberKeyword,
		tsObjectKeyword: tsObjectKeyword,
		tSObjectKeyword: tsObjectKeyword,
		tsStringKeyword: tsStringKeyword,
		tSStringKeyword: tsStringKeyword,
		tsSymbolKeyword: tsSymbolKeyword,
		tSSymbolKeyword: tsSymbolKeyword,
		tsUndefinedKeyword: tsUndefinedKeyword,
		tSUndefinedKeyword: tsUndefinedKeyword,
		tsUnknownKeyword: tsUnknownKeyword,
		tSUnknownKeyword: tsUnknownKeyword,
		tsVoidKeyword: tsVoidKeyword,
		tSVoidKeyword: tsVoidKeyword,
		tsThisType: tsThisType,
		tSThisType: tsThisType,
		tsFunctionType: tsFunctionType,
		tSFunctionType: tsFunctionType,
		tsConstructorType: tsConstructorType,
		tSConstructorType: tsConstructorType,
		tsTypeReference: tsTypeReference,
		tSTypeReference: tsTypeReference,
		tsTypePredicate: tsTypePredicate,
		tSTypePredicate: tsTypePredicate,
		tsTypeQuery: tsTypeQuery,
		tSTypeQuery: tsTypeQuery,
		tsTypeLiteral: tsTypeLiteral,
		tSTypeLiteral: tsTypeLiteral,
		tsArrayType: tsArrayType,
		tSArrayType: tsArrayType,
		tsTupleType: tsTupleType,
		tSTupleType: tsTupleType,
		tsOptionalType: tsOptionalType,
		tSOptionalType: tsOptionalType,
		tsRestType: tsRestType,
		tSRestType: tsRestType,
		tsNamedTupleMember: tsNamedTupleMember,
		tSNamedTupleMember: tsNamedTupleMember,
		tsUnionType: tsUnionType,
		tSUnionType: tsUnionType,
		tsIntersectionType: tsIntersectionType,
		tSIntersectionType: tsIntersectionType,
		tsConditionalType: tsConditionalType,
		tSConditionalType: tsConditionalType,
		tsInferType: tsInferType,
		tSInferType: tsInferType,
		tsParenthesizedType: tsParenthesizedType,
		tSParenthesizedType: tsParenthesizedType,
		tsTypeOperator: tsTypeOperator,
		tSTypeOperator: tsTypeOperator,
		tsIndexedAccessType: tsIndexedAccessType,
		tSIndexedAccessType: tsIndexedAccessType,
		tsMappedType: tsMappedType,
		tSMappedType: tsMappedType,
		tsLiteralType: tsLiteralType,
		tSLiteralType: tsLiteralType,
		tsExpressionWithTypeArguments: tsExpressionWithTypeArguments,
		tSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
		tsInterfaceDeclaration: tsInterfaceDeclaration,
		tSInterfaceDeclaration: tsInterfaceDeclaration,
		tsInterfaceBody: tsInterfaceBody,
		tSInterfaceBody: tsInterfaceBody,
		tsTypeAliasDeclaration: tsTypeAliasDeclaration,
		tSTypeAliasDeclaration: tsTypeAliasDeclaration,
		tsAsExpression: tsAsExpression,
		tSAsExpression: tsAsExpression,
		tsTypeAssertion: tsTypeAssertion,
		tSTypeAssertion: tsTypeAssertion,
		tsEnumDeclaration: tsEnumDeclaration,
		tSEnumDeclaration: tsEnumDeclaration,
		tsEnumMember: tsEnumMember,
		tSEnumMember: tsEnumMember,
		tsModuleDeclaration: tsModuleDeclaration,
		tSModuleDeclaration: tsModuleDeclaration,
		tsModuleBlock: tsModuleBlock,
		tSModuleBlock: tsModuleBlock,
		tsImportType: tsImportType,
		tSImportType: tsImportType,
		tsImportEqualsDeclaration: tsImportEqualsDeclaration,
		tSImportEqualsDeclaration: tsImportEqualsDeclaration,
		tsExternalModuleReference: tsExternalModuleReference,
		tSExternalModuleReference: tsExternalModuleReference,
		tsNonNullExpression: tsNonNullExpression,
		tSNonNullExpression: tsNonNullExpression,
		tsExportAssignment: tsExportAssignment,
		tSExportAssignment: tsExportAssignment,
		tsNamespaceExportDeclaration: tsNamespaceExportDeclaration,
		tSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
		tsTypeAnnotation: tsTypeAnnotation,
		tSTypeAnnotation: tsTypeAnnotation,
		tsTypeParameterInstantiation: tsTypeParameterInstantiation,
		tSTypeParameterInstantiation: tsTypeParameterInstantiation,
		tsTypeParameterDeclaration: tsTypeParameterDeclaration,
		tSTypeParameterDeclaration: tsTypeParameterDeclaration,
		tsTypeParameter: tsTypeParameter,
		tSTypeParameter: tsTypeParameter,
		numberLiteral: NumberLiteral,
		regexLiteral: RegexLiteral,
		restProperty: RestProperty$1,
		spreadProperty: SpreadProperty$1,
		ArrayExpression: arrayExpression$2,
		AssignmentExpression: assignmentExpression$c,
		BinaryExpression: binaryExpression$4,
		InterpreterDirective: interpreterDirective$1,
		Directive: directive$1,
		DirectiveLiteral: directiveLiteral$1,
		BlockStatement: blockStatement$6,
		BreakStatement: breakStatement,
		CallExpression: callExpression$e,
		CatchClause: catchClause,
		ConditionalExpression: conditionalExpression$3,
		ContinueStatement: continueStatement,
		DebuggerStatement: debuggerStatement,
		DoWhileStatement: doWhileStatement,
		EmptyStatement: emptyStatement$1,
		ExpressionStatement: expressionStatement$a,
		File: file$1,
		ForInStatement: forInStatement,
		ForStatement: forStatement,
		FunctionDeclaration: functionDeclaration,
		FunctionExpression: functionExpression$3,
		Identifier: identifier$j,
		IfStatement: ifStatement,
		LabeledStatement: labeledStatement,
		StringLiteral: stringLiteral$8,
		NumericLiteral: numericLiteral$8,
		NullLiteral: nullLiteral$2,
		BooleanLiteral: booleanLiteral$5,
		RegExpLiteral: regExpLiteral,
		LogicalExpression: logicalExpression$2,
		MemberExpression: memberExpression$b,
		NewExpression: newExpression,
		Program: program$3,
		ObjectExpression: objectExpression$4,
		ObjectMethod: objectMethod,
		ObjectProperty: objectProperty$2,
		RestElement: restElement$1,
		ReturnStatement: returnStatement$3,
		SequenceExpression: sequenceExpression$7,
		ParenthesizedExpression: parenthesizedExpression,
		SwitchCase: switchCase,
		SwitchStatement: switchStatement,
		ThisExpression: thisExpression$3,
		ThrowStatement: throwStatement,
		TryStatement: tryStatement,
		UnaryExpression: unaryExpression$7,
		UpdateExpression: updateExpression,
		VariableDeclaration: variableDeclaration$8,
		VariableDeclarator: variableDeclarator$8,
		WhileStatement: whileStatement,
		WithStatement: withStatement,
		AssignmentPattern: assignmentPattern,
		ArrayPattern: arrayPattern,
		ArrowFunctionExpression: arrowFunctionExpression$4,
		ClassBody: classBody,
		ClassExpression: classExpression,
		ClassDeclaration: classDeclaration,
		ExportAllDeclaration: exportAllDeclaration,
		ExportDefaultDeclaration: exportDefaultDeclaration,
		ExportNamedDeclaration: exportNamedDeclaration$2,
		ExportSpecifier: exportSpecifier$2,
		ForOfStatement: forOfStatement,
		ImportDeclaration: importDeclaration$1,
		ImportDefaultSpecifier: importDefaultSpecifier$1,
		ImportNamespaceSpecifier: importNamespaceSpecifier$1,
		ImportSpecifier: importSpecifier$1,
		MetaProperty: metaProperty$1,
		ClassMethod: classMethod,
		ObjectPattern: objectPattern,
		SpreadElement: spreadElement$2,
		Super: _super$1,
		TaggedTemplateExpression: taggedTemplateExpression,
		TemplateElement: templateElement,
		TemplateLiteral: templateLiteral,
		YieldExpression: yieldExpression$2,
		AwaitExpression: awaitExpression$1,
		Import: _import,
		BigIntLiteral: bigIntLiteral,
		ExportNamespaceSpecifier: exportNamespaceSpecifier,
		OptionalMemberExpression: optionalMemberExpression$2,
		OptionalCallExpression: optionalCallExpression$2,
		ClassProperty: classProperty,
		ClassPrivateProperty: classPrivateProperty,
		ClassPrivateMethod: classPrivateMethod,
		PrivateName: privateName,
		StaticBlock: staticBlock$1,
		AnyTypeAnnotation: anyTypeAnnotation$2,
		ArrayTypeAnnotation: arrayTypeAnnotation$1,
		BooleanTypeAnnotation: booleanTypeAnnotation$1,
		BooleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
		NullLiteralTypeAnnotation: nullLiteralTypeAnnotation$1,
		ClassImplements: classImplements,
		DeclareClass: declareClass,
		DeclareFunction: declareFunction,
		DeclareInterface: declareInterface,
		DeclareModule: declareModule,
		DeclareModuleExports: declareModuleExports,
		DeclareTypeAlias: declareTypeAlias,
		DeclareOpaqueType: declareOpaqueType,
		DeclareVariable: declareVariable,
		DeclareExportDeclaration: declareExportDeclaration,
		DeclareExportAllDeclaration: declareExportAllDeclaration,
		DeclaredPredicate: declaredPredicate,
		ExistsTypeAnnotation: existsTypeAnnotation,
		FunctionTypeAnnotation: functionTypeAnnotation,
		FunctionTypeParam: functionTypeParam,
		GenericTypeAnnotation: genericTypeAnnotation$1,
		InferredPredicate: inferredPredicate,
		InterfaceExtends: interfaceExtends,
		InterfaceDeclaration: interfaceDeclaration,
		InterfaceTypeAnnotation: interfaceTypeAnnotation,
		IntersectionTypeAnnotation: intersectionTypeAnnotation,
		MixedTypeAnnotation: mixedTypeAnnotation,
		EmptyTypeAnnotation: emptyTypeAnnotation,
		NullableTypeAnnotation: nullableTypeAnnotation,
		NumberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
		NumberTypeAnnotation: numberTypeAnnotation$2,
		ObjectTypeAnnotation: objectTypeAnnotation,
		ObjectTypeInternalSlot: objectTypeInternalSlot,
		ObjectTypeCallProperty: objectTypeCallProperty,
		ObjectTypeIndexer: objectTypeIndexer,
		ObjectTypeProperty: objectTypeProperty,
		ObjectTypeSpreadProperty: objectTypeSpreadProperty,
		OpaqueType: opaqueType,
		QualifiedTypeIdentifier: qualifiedTypeIdentifier,
		StringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
		StringTypeAnnotation: stringTypeAnnotation$2,
		SymbolTypeAnnotation: symbolTypeAnnotation,
		ThisTypeAnnotation: thisTypeAnnotation,
		TupleTypeAnnotation: tupleTypeAnnotation$1,
		TypeofTypeAnnotation: typeofTypeAnnotation,
		TypeAlias: typeAlias,
		TypeAnnotation: typeAnnotation,
		TypeCastExpression: typeCastExpression,
		TypeParameter: typeParameter,
		TypeParameterDeclaration: typeParameterDeclaration,
		TypeParameterInstantiation: typeParameterInstantiation,
		UnionTypeAnnotation: unionTypeAnnotation$1,
		Variance: variance,
		VoidTypeAnnotation: voidTypeAnnotation$3,
		EnumDeclaration: enumDeclaration,
		EnumBooleanBody: enumBooleanBody,
		EnumNumberBody: enumNumberBody,
		EnumStringBody: enumStringBody,
		EnumSymbolBody: enumSymbolBody,
		EnumBooleanMember: enumBooleanMember,
		EnumNumberMember: enumNumberMember,
		EnumStringMember: enumStringMember,
		EnumDefaultedMember: enumDefaultedMember,
		IndexedAccessType: indexedAccessType,
		OptionalIndexedAccessType: optionalIndexedAccessType,
		JSXAttribute: jsxAttribute,
		JSXClosingElement: jsxClosingElement,
		JSXElement: jsxElement,
		JSXEmptyExpression: jsxEmptyExpression,
		JSXExpressionContainer: jsxExpressionContainer$1,
		JSXSpreadChild: jsxSpreadChild,
		JSXIdentifier: jsxIdentifier$2,
		JSXMemberExpression: jsxMemberExpression$1,
		JSXNamespacedName: jsxNamespacedName,
		JSXOpeningElement: jsxOpeningElement,
		JSXSpreadAttribute: jsxSpreadAttribute,
		JSXText: jsxText,
		JSXFragment: jsxFragment,
		JSXOpeningFragment: jsxOpeningFragment,
		JSXClosingFragment: jsxClosingFragment,
		Noop: noop$1,
		Placeholder: placeholder,
		V8IntrinsicIdentifier: v8IntrinsicIdentifier,
		ArgumentPlaceholder: argumentPlaceholder,
		BindExpression: bindExpression,
		ImportAttribute: importAttribute,
		Decorator: decorator,
		DoExpression: doExpression,
		ExportDefaultSpecifier: exportDefaultSpecifier,
		RecordExpression: recordExpression,
		TupleExpression: tupleExpression,
		DecimalLiteral: decimalLiteral,
		ModuleExpression: moduleExpression,
		TopicReference: topicReference,
		PipelineTopicExpression: pipelineTopicExpression,
		PipelineBareFunction: pipelineBareFunction,
		PipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
		TSParameterProperty: tsParameterProperty,
		TSDeclareFunction: tsDeclareFunction,
		TSDeclareMethod: tsDeclareMethod,
		TSQualifiedName: tsQualifiedName,
		TSCallSignatureDeclaration: tsCallSignatureDeclaration,
		TSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
		TSPropertySignature: tsPropertySignature,
		TSMethodSignature: tsMethodSignature,
		TSIndexSignature: tsIndexSignature,
		TSAnyKeyword: tsAnyKeyword,
		TSBooleanKeyword: tsBooleanKeyword,
		TSBigIntKeyword: tsBigIntKeyword,
		TSIntrinsicKeyword: tsIntrinsicKeyword,
		TSNeverKeyword: tsNeverKeyword,
		TSNullKeyword: tsNullKeyword,
		TSNumberKeyword: tsNumberKeyword,
		TSObjectKeyword: tsObjectKeyword,
		TSStringKeyword: tsStringKeyword,
		TSSymbolKeyword: tsSymbolKeyword,
		TSUndefinedKeyword: tsUndefinedKeyword,
		TSUnknownKeyword: tsUnknownKeyword,
		TSVoidKeyword: tsVoidKeyword,
		TSThisType: tsThisType,
		TSFunctionType: tsFunctionType,
		TSConstructorType: tsConstructorType,
		TSTypeReference: tsTypeReference,
		TSTypePredicate: tsTypePredicate,
		TSTypeQuery: tsTypeQuery,
		TSTypeLiteral: tsTypeLiteral,
		TSArrayType: tsArrayType,
		TSTupleType: tsTupleType,
		TSOptionalType: tsOptionalType,
		TSRestType: tsRestType,
		TSNamedTupleMember: tsNamedTupleMember,
		TSUnionType: tsUnionType,
		TSIntersectionType: tsIntersectionType,
		TSConditionalType: tsConditionalType,
		TSInferType: tsInferType,
		TSParenthesizedType: tsParenthesizedType,
		TSTypeOperator: tsTypeOperator,
		TSIndexedAccessType: tsIndexedAccessType,
		TSMappedType: tsMappedType,
		TSLiteralType: tsLiteralType,
		TSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
		TSInterfaceDeclaration: tsInterfaceDeclaration,
		TSInterfaceBody: tsInterfaceBody,
		TSTypeAliasDeclaration: tsTypeAliasDeclaration,
		TSAsExpression: tsAsExpression,
		TSTypeAssertion: tsTypeAssertion,
		TSEnumDeclaration: tsEnumDeclaration,
		TSEnumMember: tsEnumMember,
		TSModuleDeclaration: tsModuleDeclaration,
		TSModuleBlock: tsModuleBlock,
		TSImportType: tsImportType,
		TSImportEqualsDeclaration: tsImportEqualsDeclaration,
		TSExternalModuleReference: tsExternalModuleReference,
		TSNonNullExpression: tsNonNullExpression,
		TSExportAssignment: tsExportAssignment,
		TSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
		TSTypeAnnotation: tsTypeAnnotation,
		TSTypeParameterInstantiation: tsTypeParameterInstantiation,
		TSTypeParameterDeclaration: tsTypeParameterDeclaration,
		TSTypeParameter: tsTypeParameter,
		NumberLiteral: NumberLiteral,
		RegexLiteral: RegexLiteral,
		RestProperty: RestProperty$1,
		SpreadProperty: SpreadProperty$1,
		STANDARDIZED_TYPES: STANDARDIZED_TYPES,
		EXPRESSION_TYPES: EXPRESSION_TYPES,
		BINARY_TYPES: BINARY_TYPES,
		SCOPABLE_TYPES: SCOPABLE_TYPES,
		BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
		BLOCK_TYPES: BLOCK_TYPES,
		STATEMENT_TYPES: STATEMENT_TYPES,
		TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
		COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
		CONDITIONAL_TYPES: CONDITIONAL_TYPES,
		LOOP_TYPES: LOOP_TYPES,
		WHILE_TYPES: WHILE_TYPES,
		EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
		FOR_TYPES: FOR_TYPES,
		FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
		FUNCTION_TYPES: FUNCTION_TYPES$1,
		FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
		PUREISH_TYPES: PUREISH_TYPES,
		DECLARATION_TYPES: DECLARATION_TYPES,
		PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
		LVAL_TYPES: LVAL_TYPES,
		TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
		LITERAL_TYPES: LITERAL_TYPES,
		IMMUTABLE_TYPES: IMMUTABLE_TYPES,
		USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
		METHOD_TYPES: METHOD_TYPES,
		OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
		PROPERTY_TYPES: PROPERTY_TYPES,
		UNARYLIKE_TYPES: UNARYLIKE_TYPES,
		PATTERN_TYPES: PATTERN_TYPES,
		CLASS_TYPES: CLASS_TYPES,
		MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
		EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
		MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
		PRIVATE_TYPES: PRIVATE_TYPES,
		FLOW_TYPES: FLOW_TYPES,
		FLOWTYPE_TYPES: FLOWTYPE_TYPES,
		FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
		FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
		FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
		ENUMBODY_TYPES: ENUMBODY_TYPES,
		ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
		JSX_TYPES: JSX_TYPES,
		MISCELLANEOUS_TYPES: MISCELLANEOUS_TYPES,
		TYPESCRIPT_TYPES: TYPESCRIPT_TYPES,
		TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
		TSTYPE_TYPES: TSTYPE_TYPES,
		TSBASETYPE_TYPES: TSBASETYPE_TYPES,
		STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS$1,
		FLATTENABLE_KEYS: FLATTENABLE_KEYS,
		FOR_INIT_KEYS: FOR_INIT_KEYS,
		COMMENT_KEYS: COMMENT_KEYS,
		LOGICAL_OPERATORS: LOGICAL_OPERATORS$2,
		UPDATE_OPERATORS: UPDATE_OPERATORS,
		BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS$1,
		EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
		COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
		BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS$1,
		NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS$1,
		BINARY_OPERATORS: BINARY_OPERATORS,
		ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
		BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS$1,
		NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS$1,
		STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS$1,
		UNARY_OPERATORS: UNARY_OPERATORS,
		INHERIT_KEYS: INHERIT_KEYS,
		BLOCK_SCOPED_SYMBOL: BLOCK_SCOPED_SYMBOL,
		NOT_LOCAL_BINDING: NOT_LOCAL_BINDING$2,
		VISITOR_KEYS: VISITOR_KEYS$6,
		ALIAS_KEYS: ALIAS_KEYS,
		FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$3,
		NODE_FIELDS: NODE_FIELDS,
		BUILDER_KEYS: BUILDER_KEYS,
		DEPRECATED_KEYS: DEPRECATED_KEYS$1,
		NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
		PLACEHOLDERS: PLACEHOLDERS,
		PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
		PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
		TYPES: TYPES$1,
		isArrayExpression: isArrayExpression$2,
		isAssignmentExpression: isAssignmentExpression$3,
		isBinaryExpression: isBinaryExpression$1,
		isInterpreterDirective: isInterpreterDirective,
		isDirective: isDirective,
		isDirectiveLiteral: isDirectiveLiteral,
		isBlockStatement: isBlockStatement$2,
		isBreakStatement: isBreakStatement,
		isCallExpression: isCallExpression$6,
		isCatchClause: isCatchClause,
		isConditionalExpression: isConditionalExpression$1,
		isContinueStatement: isContinueStatement,
		isDebuggerStatement: isDebuggerStatement,
		isDoWhileStatement: isDoWhileStatement,
		isEmptyStatement: isEmptyStatement$1,
		isExpressionStatement: isExpressionStatement$4,
		isFile: isFile$1,
		isForInStatement: isForInStatement$1,
		isForStatement: isForStatement$3,
		isFunctionDeclaration: isFunctionDeclaration$1,
		isFunctionExpression: isFunctionExpression$1,
		isIdentifier: isIdentifier$g,
		isIfStatement: isIfStatement$2,
		isLabeledStatement: isLabeledStatement,
		isStringLiteral: isStringLiteral$7,
		isNumericLiteral: isNumericLiteral,
		isNullLiteral: isNullLiteral$1,
		isBooleanLiteral: isBooleanLiteral,
		isRegExpLiteral: isRegExpLiteral$1,
		isLogicalExpression: isLogicalExpression$1,
		isMemberExpression: isMemberExpression$8,
		isNewExpression: isNewExpression$4,
		isProgram: isProgram$2,
		isObjectExpression: isObjectExpression$3,
		isObjectMethod: isObjectMethod$2,
		isObjectProperty: isObjectProperty$4,
		isRestElement: isRestElement$2,
		isReturnStatement: isReturnStatement$1,
		isSequenceExpression: isSequenceExpression$1,
		isParenthesizedExpression: isParenthesizedExpression$1,
		isSwitchCase: isSwitchCase,
		isSwitchStatement: isSwitchStatement$1,
		isThisExpression: isThisExpression$2,
		isThrowStatement: isThrowStatement$1,
		isTryStatement: isTryStatement,
		isUnaryExpression: isUnaryExpression$1,
		isUpdateExpression: isUpdateExpression$1,
		isVariableDeclaration: isVariableDeclaration$3,
		isVariableDeclarator: isVariableDeclarator$2,
		isWhileStatement: isWhileStatement$1,
		isWithStatement: isWithStatement,
		isAssignmentPattern: isAssignmentPattern$4,
		isArrayPattern: isArrayPattern,
		isArrowFunctionExpression: isArrowFunctionExpression$1,
		isClassBody: isClassBody$1,
		isClassExpression: isClassExpression$1,
		isClassDeclaration: isClassDeclaration$3,
		isExportAllDeclaration: isExportAllDeclaration$1,
		isExportDefaultDeclaration: isExportDefaultDeclaration$3,
		isExportNamedDeclaration: isExportNamedDeclaration$2,
		isExportSpecifier: isExportSpecifier,
		isForOfStatement: isForOfStatement$1,
		isImportDeclaration: isImportDeclaration$2,
		isImportDefaultSpecifier: isImportDefaultSpecifier$1,
		isImportNamespaceSpecifier: isImportNamespaceSpecifier$1,
		isImportSpecifier: isImportSpecifier$1,
		isMetaProperty: isMetaProperty,
		isClassMethod: isClassMethod$1,
		isObjectPattern: isObjectPattern$1,
		isSpreadElement: isSpreadElement$1,
		isSuper: isSuper$2,
		isTaggedTemplateExpression: isTaggedTemplateExpression$2,
		isTemplateElement: isTemplateElement,
		isTemplateLiteral: isTemplateLiteral$2,
		isYieldExpression: isYieldExpression$1,
		isAwaitExpression: isAwaitExpression$1,
		isImport: isImport,
		isBigIntLiteral: isBigIntLiteral,
		isExportNamespaceSpecifier: isExportNamespaceSpecifier$1,
		isOptionalMemberExpression: isOptionalMemberExpression$3,
		isOptionalCallExpression: isOptionalCallExpression$3,
		isClassProperty: isClassProperty,
		isClassPrivateProperty: isClassPrivateProperty,
		isClassPrivateMethod: isClassPrivateMethod,
		isPrivateName: isPrivateName$1,
		isStaticBlock: isStaticBlock,
		isAnyTypeAnnotation: isAnyTypeAnnotation$1,
		isArrayTypeAnnotation: isArrayTypeAnnotation$1,
		isBooleanTypeAnnotation: isBooleanTypeAnnotation$1,
		isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
		isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
		isClassImplements: isClassImplements,
		isDeclareClass: isDeclareClass,
		isDeclareFunction: isDeclareFunction,
		isDeclareInterface: isDeclareInterface,
		isDeclareModule: isDeclareModule,
		isDeclareModuleExports: isDeclareModuleExports,
		isDeclareTypeAlias: isDeclareTypeAlias,
		isDeclareOpaqueType: isDeclareOpaqueType,
		isDeclareVariable: isDeclareVariable,
		isDeclareExportDeclaration: isDeclareExportDeclaration$1,
		isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
		isDeclaredPredicate: isDeclaredPredicate,
		isExistsTypeAnnotation: isExistsTypeAnnotation,
		isFunctionTypeAnnotation: isFunctionTypeAnnotation,
		isFunctionTypeParam: isFunctionTypeParam,
		isGenericTypeAnnotation: isGenericTypeAnnotation$1,
		isInferredPredicate: isInferredPredicate,
		isInterfaceExtends: isInterfaceExtends,
		isInterfaceDeclaration: isInterfaceDeclaration,
		isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
		isIntersectionTypeAnnotation: isIntersectionTypeAnnotation$1,
		isMixedTypeAnnotation: isMixedTypeAnnotation$1,
		isEmptyTypeAnnotation: isEmptyTypeAnnotation$1,
		isNullableTypeAnnotation: isNullableTypeAnnotation$1,
		isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
		isNumberTypeAnnotation: isNumberTypeAnnotation$1,
		isObjectTypeAnnotation: isObjectTypeAnnotation,
		isObjectTypeInternalSlot: isObjectTypeInternalSlot,
		isObjectTypeCallProperty: isObjectTypeCallProperty,
		isObjectTypeIndexer: isObjectTypeIndexer,
		isObjectTypeProperty: isObjectTypeProperty,
		isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
		isOpaqueType: isOpaqueType,
		isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
		isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
		isStringTypeAnnotation: isStringTypeAnnotation$1,
		isSymbolTypeAnnotation: isSymbolTypeAnnotation,
		isThisTypeAnnotation: isThisTypeAnnotation,
		isTupleTypeAnnotation: isTupleTypeAnnotation,
		isTypeofTypeAnnotation: isTypeofTypeAnnotation,
		isTypeAlias: isTypeAlias,
		isTypeAnnotation: isTypeAnnotation$2,
		isTypeCastExpression: isTypeCastExpression$1,
		isTypeParameter: isTypeParameter,
		isTypeParameterDeclaration: isTypeParameterDeclaration,
		isTypeParameterInstantiation: isTypeParameterInstantiation,
		isUnionTypeAnnotation: isUnionTypeAnnotation$2,
		isVariance: isVariance,
		isVoidTypeAnnotation: isVoidTypeAnnotation$1,
		isEnumDeclaration: isEnumDeclaration,
		isEnumBooleanBody: isEnumBooleanBody,
		isEnumNumberBody: isEnumNumberBody,
		isEnumStringBody: isEnumStringBody,
		isEnumSymbolBody: isEnumSymbolBody,
		isEnumBooleanMember: isEnumBooleanMember,
		isEnumNumberMember: isEnumNumberMember,
		isEnumStringMember: isEnumStringMember,
		isEnumDefaultedMember: isEnumDefaultedMember,
		isIndexedAccessType: isIndexedAccessType$1,
		isOptionalIndexedAccessType: isOptionalIndexedAccessType,
		isJSXAttribute: isJSXAttribute,
		isJSXClosingElement: isJSXClosingElement,
		isJSXElement: isJSXElement,
		isJSXEmptyExpression: isJSXEmptyExpression,
		isJSXExpressionContainer: isJSXExpressionContainer$1,
		isJSXSpreadChild: isJSXSpreadChild,
		isJSXIdentifier: isJSXIdentifier$3,
		isJSXMemberExpression: isJSXMemberExpression$2,
		isJSXNamespacedName: isJSXNamespacedName$1,
		isJSXOpeningElement: isJSXOpeningElement,
		isJSXSpreadAttribute: isJSXSpreadAttribute$1,
		isJSXText: isJSXText,
		isJSXFragment: isJSXFragment,
		isJSXOpeningFragment: isJSXOpeningFragment,
		isJSXClosingFragment: isJSXClosingFragment,
		isNoop: isNoop,
		isPlaceholder: isPlaceholder$1,
		isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
		isArgumentPlaceholder: isArgumentPlaceholder,
		isBindExpression: isBindExpression,
		isImportAttribute: isImportAttribute,
		isDecorator: isDecorator,
		isDoExpression: isDoExpression,
		isExportDefaultSpecifier: isExportDefaultSpecifier$1,
		isRecordExpression: isRecordExpression,
		isTupleExpression: isTupleExpression,
		isDecimalLiteral: isDecimalLiteral,
		isModuleExpression: isModuleExpression,
		isTopicReference: isTopicReference,
		isPipelineTopicExpression: isPipelineTopicExpression,
		isPipelineBareFunction: isPipelineBareFunction,
		isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
		isTSParameterProperty: isTSParameterProperty,
		isTSDeclareFunction: isTSDeclareFunction,
		isTSDeclareMethod: isTSDeclareMethod,
		isTSQualifiedName: isTSQualifiedName,
		isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
		isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
		isTSPropertySignature: isTSPropertySignature,
		isTSMethodSignature: isTSMethodSignature,
		isTSIndexSignature: isTSIndexSignature,
		isTSAnyKeyword: isTSAnyKeyword,
		isTSBooleanKeyword: isTSBooleanKeyword,
		isTSBigIntKeyword: isTSBigIntKeyword,
		isTSIntrinsicKeyword: isTSIntrinsicKeyword,
		isTSNeverKeyword: isTSNeverKeyword,
		isTSNullKeyword: isTSNullKeyword,
		isTSNumberKeyword: isTSNumberKeyword,
		isTSObjectKeyword: isTSObjectKeyword,
		isTSStringKeyword: isTSStringKeyword,
		isTSSymbolKeyword: isTSSymbolKeyword,
		isTSUndefinedKeyword: isTSUndefinedKeyword,
		isTSUnknownKeyword: isTSUnknownKeyword,
		isTSVoidKeyword: isTSVoidKeyword,
		isTSThisType: isTSThisType,
		isTSFunctionType: isTSFunctionType,
		isTSConstructorType: isTSConstructorType,
		isTSTypeReference: isTSTypeReference,
		isTSTypePredicate: isTSTypePredicate,
		isTSTypeQuery: isTSTypeQuery,
		isTSTypeLiteral: isTSTypeLiteral,
		isTSArrayType: isTSArrayType$1,
		isTSTupleType: isTSTupleType,
		isTSOptionalType: isTSOptionalType$1,
		isTSRestType: isTSRestType$1,
		isTSNamedTupleMember: isTSNamedTupleMember,
		isTSUnionType: isTSUnionType$1,
		isTSIntersectionType: isTSIntersectionType$1,
		isTSConditionalType: isTSConditionalType,
		isTSInferType: isTSInferType,
		isTSParenthesizedType: isTSParenthesizedType,
		isTSTypeOperator: isTSTypeOperator,
		isTSIndexedAccessType: isTSIndexedAccessType,
		isTSMappedType: isTSMappedType,
		isTSLiteralType: isTSLiteralType,
		isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
		isTSInterfaceDeclaration: isTSInterfaceDeclaration,
		isTSInterfaceBody: isTSInterfaceBody,
		isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
		isTSAsExpression: isTSAsExpression$2,
		isTSTypeAssertion: isTSTypeAssertion$2,
		isTSEnumDeclaration: isTSEnumDeclaration,
		isTSEnumMember: isTSEnumMember,
		isTSModuleDeclaration: isTSModuleDeclaration,
		isTSModuleBlock: isTSModuleBlock,
		isTSImportType: isTSImportType,
		isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
		isTSExternalModuleReference: isTSExternalModuleReference,
		isTSNonNullExpression: isTSNonNullExpression$2,
		isTSExportAssignment: isTSExportAssignment,
		isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
		isTSTypeAnnotation: isTSTypeAnnotation$2,
		isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
		isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
		isTSTypeParameter: isTSTypeParameter,
		isStandardized: isStandardized,
		isExpression: isExpression$4,
		isBinary: isBinary$3,
		isScopable: isScopable,
		isBlockParent: isBlockParent,
		isBlock: isBlock,
		isStatement: isStatement$7,
		isTerminatorless: isTerminatorless,
		isCompletionStatement: isCompletionStatement,
		isConditional: isConditional$1,
		isLoop: isLoop$1,
		isWhile: isWhile,
		isExpressionWrapper: isExpressionWrapper,
		isFor: isFor$2,
		isForXStatement: isForXStatement$1,
		isFunction: isFunction$4,
		isFunctionParent: isFunctionParent,
		isPureish: isPureish$2,
		isDeclaration: isDeclaration$1,
		isPatternLike: isPatternLike,
		isLVal: isLVal,
		isTSEntityName: isTSEntityName,
		isLiteral: isLiteral$7,
		isUserWhitespacable: isUserWhitespacable,
		isMethod: isMethod$1,
		isObjectMember: isObjectMember,
		isProperty: isProperty$2,
		isUnaryLike: isUnaryLike$1,
		isPattern: isPattern,
		isClass: isClass$1,
		isModuleDeclaration: isModuleDeclaration$1,
		isExportDeclaration: isExportDeclaration$2,
		isModuleSpecifier: isModuleSpecifier$1,
		isPrivate: isPrivate,
		isFlow: isFlow$1,
		isFlowType: isFlowType,
		isFlowBaseAnnotation: isFlowBaseAnnotation$1,
		isFlowDeclaration: isFlowDeclaration,
		isFlowPredicate: isFlowPredicate,
		isEnumBody: isEnumBody,
		isEnumMember: isEnumMember,
		isJSX: isJSX,
		isMiscellaneous: isMiscellaneous,
		isTypeScript: isTypeScript,
		isTSTypeElement: isTSTypeElement,
		isTSType: isTSType,
		isTSBaseType: isTSBaseType,
		isNumberLiteral: isNumberLiteral,
		isRegexLiteral: isRegexLiteral,
		isRestProperty: isRestProperty,
		isSpreadProperty: isSpreadProperty
	});

	var isBinding = isBinding$1,
	    isBlockScoped$1 = isBlockScoped$2,
	    isExportDeclaration$1 = isExportDeclaration$2,
	    isExpression$3 = isExpression$4,
	    isFlow = isFlow$1,
	    isForStatement$2 = isForStatement$3,
	    isForXStatement = isForXStatement$1,
	    isIdentifier$f = isIdentifier$g,
	    isImportDeclaration$1 = isImportDeclaration$2,
	    isImportSpecifier = isImportSpecifier$1,
	    isJSXIdentifier$2 = isJSXIdentifier$3,
	    isJSXMemberExpression$1 = isJSXMemberExpression$2,
	    isMemberExpression$7 = isMemberExpression$8,
	    isReferenced$1 = isReferenced$2,
	    isScope = isScope$1,
	    isStatement$6 = isStatement$7,
	    isVar$1 = isVar$2,
	    isVariableDeclaration$2 = isVariableDeclaration$3,
	    react$2 = react$3;
	var isCompatTag = react$2.isCompatTag;
	var ReferencedIdentifier = {
	  types: ["Identifier", "JSXIdentifier"],
	  checkPath: function checkPath(path, opts) {
	    var node = path.node,
	        parent = path.parent;

	    if (!isIdentifier$f(node, opts) && !isJSXMemberExpression$1(parent, opts)) {
	      if (isJSXIdentifier$2(node, opts)) {
	        if (isCompatTag(node.name)) return false;
	      } else {
	        return false;
	      }
	    }

	    return isReferenced$1(node, parent, path.parentPath.parent);
	  }
	};
	var ReferencedMemberExpression = {
	  types: ["MemberExpression"],
	  checkPath: function checkPath(_ref) {
	    var node = _ref.node,
	        parent = _ref.parent;
	    return isMemberExpression$7(node) && isReferenced$1(node, parent);
	  }
	};
	var BindingIdentifier = {
	  types: ["Identifier"],
	  checkPath: function checkPath(path) {
	    var node = path.node,
	        parent = path.parent;
	    var grandparent = path.parentPath.parent;
	    return isIdentifier$f(node) && isBinding(node, parent, grandparent);
	  }
	};
	var Statement = {
	  types: ["Statement"],
	  checkPath: function checkPath(_ref2) {
	    var node = _ref2.node,
	        parent = _ref2.parent;

	    if (isStatement$6(node)) {
	      if (isVariableDeclaration$2(node)) {
	        if (isForXStatement(parent, {
	          left: node
	        })) return false;
	        if (isForStatement$2(parent, {
	          init: node
	        })) return false;
	      }

	      return true;
	    } else {
	      return false;
	    }
	  }
	};
	var Expression = {
	  types: ["Expression"],
	  checkPath: function checkPath(path) {
	    if (path.isIdentifier()) {
	      return path.isReferencedIdentifier();
	    } else {
	      return isExpression$3(path.node);
	    }
	  }
	};
	var Scope$2 = {
	  types: ["Scopable", "Pattern"],
	  checkPath: function checkPath(path) {
	    return isScope(path.node, path.parent);
	  }
	};
	var Referenced = {
	  checkPath: function checkPath(path) {
	    return isReferenced$1(path.node, path.parent);
	  }
	};
	var BlockScoped = {
	  checkPath: function checkPath(path) {
	    return isBlockScoped$1(path.node);
	  }
	};
	var Var = {
	  types: ["VariableDeclaration"],
	  checkPath: function checkPath(path) {
	    return isVar$1(path.node);
	  }
	};
	var User = {
	  checkPath: function checkPath(path) {
	    return path.node && !!path.node.loc;
	  }
	};
	var Generated = {
	  checkPath: function checkPath(path) {
	    return !path.isUser();
	  }
	};
	var Pure = {
	  checkPath: function checkPath(path, opts) {
	    return path.scope.isPure(path.node, opts);
	  }
	};
	var Flow = {
	  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
	  checkPath: function checkPath(_ref3) {
	    var node = _ref3.node;

	    if (isFlow(node)) {
	      return true;
	    } else if (isImportDeclaration$1(node)) {
	      return node.importKind === "type" || node.importKind === "typeof";
	    } else if (isExportDeclaration$1(node)) {
	      return node.exportKind === "type";
	    } else if (isImportSpecifier(node)) {
	      return node.importKind === "type" || node.importKind === "typeof";
	    } else {
	      return false;
	    }
	  }
	};
	var RestProperty = {
	  types: ["RestElement"],
	  checkPath: function checkPath(path) {
	    return path.parentPath && path.parentPath.isObjectPattern();
	  }
	};
	var SpreadProperty = {
	  types: ["RestElement"],
	  checkPath: function checkPath(path) {
	    return path.parentPath && path.parentPath.isObjectExpression();
	  }
	};
	var ExistentialTypeParam = {
	  types: ["ExistsTypeAnnotation"]
	};
	var NumericLiteralTypeAnnotation = {
	  types: ["NumberLiteralTypeAnnotation"]
	};
	var ForAwaitStatement = {
	  types: ["ForOfStatement"],
	  checkPath: function checkPath(_ref4) {
	    var node = _ref4.node;
	    return node["await"] === true;
	  }
	};

	var virtualTypes = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ReferencedIdentifier: ReferencedIdentifier,
		ReferencedMemberExpression: ReferencedMemberExpression,
		BindingIdentifier: BindingIdentifier,
		Statement: Statement,
		Expression: Expression,
		Scope: Scope$2,
		Referenced: Referenced,
		BlockScoped: BlockScoped,
		Var: Var,
		User: User,
		Generated: Generated,
		Pure: Pure,
		Flow: Flow,
		RestProperty: RestProperty,
		SpreadProperty: SpreadProperty,
		ExistentialTypeParam: ExistentialTypeParam,
		NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
		ForAwaitStatement: ForAwaitStatement
	});

	var s = 1000;
	var m$1 = s * 60;
	var h = m$1 * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	var ms = function ms(val, options) {
	  options = options || {};
	  var type = typeof val;

	  if (type === 'string' && val.length > 0) {
	    return parse$6(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options["long"] ? fmtLong(val) : fmtShort(val);
	  }

	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
	};

	function parse$6(str) {
	  str = String(str);

	  if (str.length > 100) {
	    return;
	  }

	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

	  if (!match) {
	    return;
	  }

	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();

	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;

	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;

	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;

	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;

	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m$1;

	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;

	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;

	    default:
	      return undefined;
	  }
	}

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);

	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }

	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }

	  if (msAbs >= m$1) {
	    return Math.round(ms / m$1) + 'm';
	  }

	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }

	  return ms + 'ms';
	}

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);

	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }

	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }

	  if (msAbs >= m$1) {
	    return plural(ms, msAbs, m$1, 'minute');
	  }

	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }

	  return ms + ' ms';
	}

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}

	function setup$1(env) {
	  createDebug.debug = createDebug;
	  createDebug["default"] = createDebug;
	  createDebug.coerce = coerce;
	  createDebug.disable = disable;
	  createDebug.enable = enable;
	  createDebug.enabled = enabled;
	  createDebug.humanize = ms;
	  createDebug.destroy = destroy;
	  Object.keys(env).forEach(function (key) {
	    createDebug[key] = env[key];
	  });
	  createDebug.names = [];
	  createDebug.skips = [];
	  createDebug.formatters = {};

	  function selectColor(namespace) {
	    var hash = 0;

	    for (var i = 0; i < namespace.length; i++) {
	      hash = (hash << 5) - hash + namespace.charCodeAt(i);
	      hash |= 0;
	    }

	    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	  }

	  createDebug.selectColor = selectColor;

	  function createDebug(namespace) {
	    var prevTime;
	    var enableOverride = null;
	    var namespacesCache;
	    var enabledCache;

	    function debug() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      if (!debug.enabled) {
	        return;
	      }

	      var self = debug;
	      var curr = Number(new Date());
	      var ms = curr - (prevTime || curr);
	      self.diff = ms;
	      self.prev = prevTime;
	      self.curr = curr;
	      prevTime = curr;
	      args[0] = createDebug.coerce(args[0]);

	      if (typeof args[0] !== 'string') {
	        args.unshift('%O');
	      }

	      var index = 0;
	      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
	        if (match === '%%') {
	          return '%';
	        }

	        index++;
	        var formatter = createDebug.formatters[format];

	        if (typeof formatter === 'function') {
	          var val = args[index];
	          match = formatter.call(self, val);
	          args.splice(index, 1);
	          index--;
	        }

	        return match;
	      });
	      createDebug.formatArgs.call(self, args);
	      var logFn = self.log || createDebug.log;
	      logFn.apply(self, args);
	    }

	    debug.namespace = namespace;
	    debug.useColors = createDebug.useColors();
	    debug.color = createDebug.selectColor(namespace);
	    debug.extend = extend;
	    debug.destroy = createDebug.destroy;
	    Object.defineProperty(debug, 'enabled', {
	      enumerable: true,
	      configurable: false,
	      get: function get() {
	        if (enableOverride !== null) {
	          return enableOverride;
	        }

	        if (namespacesCache !== createDebug.namespaces) {
	          namespacesCache = createDebug.namespaces;
	          enabledCache = createDebug.enabled(namespace);
	        }

	        return enabledCache;
	      },
	      set: function set(v) {
	        enableOverride = v;
	      }
	    });

	    if (typeof createDebug.init === 'function') {
	      createDebug.init(debug);
	    }

	    return debug;
	  }

	  function extend(namespace, delimiter) {
	    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
	    newDebug.log = this.log;
	    return newDebug;
	  }

	  function enable(namespaces) {
	    createDebug.save(namespaces);
	    createDebug.namespaces = namespaces;
	    createDebug.names = [];
	    createDebug.skips = [];
	    var i;
	    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	    var len = split.length;

	    for (i = 0; i < len; i++) {
	      if (!split[i]) {
	        continue;
	      }

	      namespaces = split[i].replace(/\*/g, '.*?');

	      if (namespaces[0] === '-') {
	        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	      } else {
	        createDebug.names.push(new RegExp('^' + namespaces + '$'));
	      }
	    }
	  }

	  function disable() {
	    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
	      return '-' + namespace;
	    }))).join(',');
	    createDebug.enable('');
	    return namespaces;
	  }

	  function enabled(name) {
	    if (name[name.length - 1] === '*') {
	      return true;
	    }

	    var i;
	    var len;

	    for (i = 0, len = createDebug.skips.length; i < len; i++) {
	      if (createDebug.skips[i].test(name)) {
	        return false;
	      }
	    }

	    for (i = 0, len = createDebug.names.length; i < len; i++) {
	      if (createDebug.names[i].test(name)) {
	        return true;
	      }
	    }

	    return false;
	  }

	  function toNamespace(regexp) {
	    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
	  }

	  function coerce(val) {
	    if (val instanceof Error) {
	      return val.stack || val.message;
	    }

	    return val;
	  }

	  function destroy() {
	    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	  }

	  createDebug.enable(createDebug.load());
	  return createDebug;
	}

	var common = setup$1;

	var browser$3 = createCommonjsModule(function (module, exports) {
	  exports.formatArgs = formatArgs;
	  exports.save = save;
	  exports.load = load;
	  exports.useColors = useColors;
	  exports.storage = localstorage();

	  exports.destroy = function () {
	    var warned = false;
	    return function () {
	      if (!warned) {
	        warned = true;
	        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	      }
	    };
	  }();

	  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

	  function useColors() {
	    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
	      return true;
	    }

	    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	      return false;
	    }

	    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	  }

	  function formatArgs(args) {
	    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

	    if (!this.useColors) {
	      return;
	    }

	    var c = 'color: ' + this.color;
	    args.splice(1, 0, c, 'color: inherit');
	    var index = 0;
	    var lastC = 0;
	    args[0].replace(/%[a-zA-Z%]/g, function (match) {
	      if (match === '%%') {
	        return;
	      }

	      index++;

	      if (match === '%c') {
	        lastC = index;
	      }
	    });
	    args.splice(lastC, 0, c);
	  }

	  exports.log = console.debug || console.log || function () {};

	  function save(namespaces) {
	    try {
	      if (namespaces) {
	        exports.storage.setItem('debug', namespaces);
	      } else {
	        exports.storage.removeItem('debug');
	      }
	    } catch (error) {}
	  }

	  function load() {
	    var r;

	    try {
	      r = exports.storage.getItem('debug');
	    } catch (error) {}

	    if (!r && typeof browser$4 !== 'undefined' && 'env' in browser$4) {
	      r = browser$4.env.DEBUG;
	    }

	    return r;
	  }

	  function localstorage() {
	    try {
	      return localStorage;
	    } catch (error) {}
	  }

	  module.exports = common(exports);
	  var formatters = module.exports.formatters;

	  formatters.j = function (v) {
	    try {
	      return JSON.stringify(v);
	    } catch (error) {
	      return '[UnexpectedJSONParseError]: ' + error.message;
	    }
	  };
	}, "/$$rollup_base$$/node_modules/debug/src");

	var Binding = function () {
	  function Binding(_ref) {
	    var identifier = _ref.identifier,
	        scope = _ref.scope,
	        path = _ref.path,
	        kind = _ref.kind;
	    this.identifier = void 0;
	    this.scope = void 0;
	    this.path = void 0;
	    this.kind = void 0;
	    this.constantViolations = [];
	    this.constant = true;
	    this.referencePaths = [];
	    this.referenced = false;
	    this.references = 0;
	    this.identifier = identifier;
	    this.scope = scope;
	    this.path = path;
	    this.kind = kind;
	    this.clearValue();
	  }

	  var _proto = Binding.prototype;

	  _proto.deoptValue = function deoptValue() {
	    this.clearValue();
	    this.hasDeoptedValue = true;
	  };

	  _proto.setValue = function setValue(value) {
	    if (this.hasDeoptedValue) return;
	    this.hasValue = true;
	    this.value = value;
	  };

	  _proto.clearValue = function clearValue() {
	    this.hasDeoptedValue = false;
	    this.hasValue = false;
	    this.value = null;
	  };

	  _proto.reassign = function reassign(path) {
	    this.constant = false;

	    if (this.constantViolations.indexOf(path) !== -1) {
	      return;
	    }

	    this.constantViolations.push(path);
	  };

	  _proto.reference = function reference(path) {
	    if (this.referencePaths.indexOf(path) !== -1) {
	      return;
	    }

	    this.referenced = true;
	    this.references++;
	    this.referencePaths.push(path);
	  };

	  _proto.dereference = function dereference() {
	    this.references--;
	    this.referenced = !!this.references;
	  };

	  return Binding;
	}();

	var cloneNode$h = cloneNode$i,
	    exportNamedDeclaration$1 = exportNamedDeclaration$2,
	    exportSpecifier$1 = exportSpecifier$2,
	    identifier$i = identifier$j,
	    variableDeclaration$7 = variableDeclaration$8,
	    variableDeclarator$7 = variableDeclarator$8;
	function splitExportDeclaration(exportDeclaration) {
	  if (!exportDeclaration.isExportDeclaration()) {
	    throw new Error("Only export declarations can be split.");
	  }

	  var isDefault = exportDeclaration.isExportDefaultDeclaration();
	  var declaration = exportDeclaration.get("declaration");
	  var isClassDeclaration = declaration.isClassDeclaration();

	  if (isDefault) {
	    var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
	    var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
	    var id = declaration.node.id;
	    var needBindingRegistration = false;

	    if (!id) {
	      needBindingRegistration = true;
	      id = scope.generateUidIdentifier("default");

	      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
	        declaration.node.id = cloneNode$h(id);
	      }
	    }

	    var updatedDeclaration = standaloneDeclaration ? declaration : variableDeclaration$7("var", [variableDeclarator$7(cloneNode$h(id), declaration.node)]);
	    var updatedExportDeclaration = exportNamedDeclaration$1(null, [exportSpecifier$1(cloneNode$h(id), identifier$i("default"))]);
	    exportDeclaration.insertAfter(updatedExportDeclaration);
	    exportDeclaration.replaceWith(updatedDeclaration);

	    if (needBindingRegistration) {
	      scope.registerDeclaration(exportDeclaration);
	    }

	    return exportDeclaration;
	  }

	  if (exportDeclaration.get("specifiers").length > 0) {
	    throw new Error("It doesn't make sense to split exported specifiers.");
	  }

	  var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
	  var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
	    return exportSpecifier$1(identifier$i(name), identifier$i(name));
	  });
	  var aliasDeclar = exportNamedDeclaration$1(null, specifiers);
	  exportDeclaration.insertAfter(aliasDeclar);
	  exportDeclaration.replaceWith(declaration.node);
	  return exportDeclaration;
	}

	var VISITOR_KEYS$5 = VISITOR_KEYS$6;
	var renameVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
	    var node = _ref.node;

	    if (node.name === state.oldName) {
	      node.name = state.newName;
	    }
	  },
	  Scope: function Scope(path, state) {
	    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
	      skipAllButComputedMethodKey(path);
	    }
	  },
	  "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {
	    if (path.isVariableDeclaration()) return;
	    var ids = path.getOuterBindingIdentifiers();

	    for (var name in ids) {
	      if (name === state.oldName) ids[name].name = state.newName;
	    }
	  }
	};

	var Renamer = function () {
	  function Renamer(binding, oldName, newName) {
	    this.newName = newName;
	    this.oldName = oldName;
	    this.binding = binding;
	  }

	  var _proto = Renamer.prototype;

	  _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
	    var maybeExportDeclar = parentDeclar.parentPath;

	    if (!maybeExportDeclar.isExportDeclaration()) {
	      return;
	    }

	    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
	      return;
	    }

	    splitExportDeclaration(maybeExportDeclar);
	  };

	  _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
	    return;
	  };

	  _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
	    return;
	  };

	  _proto.rename = function rename(block) {
	    var _this = this;

	    var binding = this.binding,
	        oldName = this.oldName,
	        newName = this.newName;
	    var scope = binding.scope,
	        path = binding.path;
	    var parentDeclar = path.find(function (path) {
	      return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
	    });

	    if (parentDeclar) {
	      var bindingIds = parentDeclar.getOuterBindingIdentifiers();

	      if (bindingIds[oldName] === binding.identifier) {
	        this.maybeConvertFromExportDeclaration(parentDeclar);
	      }
	    }

	    var blockToTraverse = block || scope.block;

	    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
	      blockToTraverse.cases.forEach(function (c) {
	        scope.traverse(c, renameVisitor, _this);
	      });
	    } else {
	      scope.traverse(blockToTraverse, renameVisitor, this);
	    }

	    if (!block) {
	      scope.removeOwnBinding(oldName);
	      scope.bindings[newName] = binding;
	      this.binding.identifier.name = newName;
	    }

	    if (parentDeclar) {
	      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
	      this.maybeConvertFromClassFunctionExpression(parentDeclar);
	    }
	  };

	  return Renamer;
	}();

	function skipAllButComputedMethodKey(path) {
	  if (!path.isMethod() || !path.node.computed) {
	    path.skip();
	    return;
	  }

	  var keys = VISITOR_KEYS$5[path.type];

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    if (key !== "key") path.skipKey(key);
	  }
	}

	var builtin = {
		"Array": false,
		"ArrayBuffer": false,
		Atomics: false,
		BigInt: false,
		BigInt64Array: false,
		BigUint64Array: false,
		"Boolean": false,
		constructor: false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		globalThis: false,
		hasOwnProperty: false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		isPrototypeOf: false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		propertyIsEnumerable: false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		SharedArrayBuffer: false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		toLocaleString: false,
		toString: false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		valueOf: false,
		"WeakMap": false,
		"WeakSet": false
	};
	var es5 = {
		"Array": false,
		"Boolean": false,
		constructor: false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Function": false,
		hasOwnProperty: false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		isPrototypeOf: false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		propertyIsEnumerable: false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		toLocaleString: false,
		toString: false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		valueOf: false
	};
	var es2015 = {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		constructor: false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		hasOwnProperty: false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		isPrototypeOf: false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		propertyIsEnumerable: false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		toLocaleString: false,
		toString: false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		valueOf: false,
		"WeakMap": false,
		"WeakSet": false
	};
	var es2017 = {
		"Array": false,
		"ArrayBuffer": false,
		Atomics: false,
		"Boolean": false,
		constructor: false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		hasOwnProperty: false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		isPrototypeOf: false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		propertyIsEnumerable: false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		SharedArrayBuffer: false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		toLocaleString: false,
		toString: false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		valueOf: false,
		"WeakMap": false,
		"WeakSet": false
	};
	var browser$2 = {
		AbortController: false,
		AbortSignal: false,
		addEventListener: false,
		alert: false,
		AnalyserNode: false,
		Animation: false,
		AnimationEffectReadOnly: false,
		AnimationEffectTiming: false,
		AnimationEffectTimingReadOnly: false,
		AnimationEvent: false,
		AnimationPlaybackEvent: false,
		AnimationTimeline: false,
		applicationCache: false,
		ApplicationCache: false,
		ApplicationCacheErrorEvent: false,
		atob: false,
		Attr: false,
		Audio: false,
		AudioBuffer: false,
		AudioBufferSourceNode: false,
		AudioContext: false,
		AudioDestinationNode: false,
		AudioListener: false,
		AudioNode: false,
		AudioParam: false,
		AudioProcessingEvent: false,
		AudioScheduledSourceNode: false,
		"AudioWorkletGlobalScope ": false,
		AudioWorkletNode: false,
		AudioWorkletProcessor: false,
		BarProp: false,
		BaseAudioContext: false,
		BatteryManager: false,
		BeforeUnloadEvent: false,
		BiquadFilterNode: false,
		Blob: false,
		BlobEvent: false,
		blur: false,
		BroadcastChannel: false,
		btoa: false,
		BudgetService: false,
		ByteLengthQueuingStrategy: false,
		Cache: false,
		caches: false,
		CacheStorage: false,
		cancelAnimationFrame: false,
		cancelIdleCallback: false,
		CanvasCaptureMediaStreamTrack: false,
		CanvasGradient: false,
		CanvasPattern: false,
		CanvasRenderingContext2D: false,
		ChannelMergerNode: false,
		ChannelSplitterNode: false,
		CharacterData: false,
		clearInterval: false,
		clearTimeout: false,
		clientInformation: false,
		ClipboardEvent: false,
		close: false,
		closed: false,
		CloseEvent: false,
		Comment: false,
		CompositionEvent: false,
		confirm: false,
		console: false,
		ConstantSourceNode: false,
		ConvolverNode: false,
		CountQueuingStrategy: false,
		createImageBitmap: false,
		Credential: false,
		CredentialsContainer: false,
		crypto: false,
		Crypto: false,
		CryptoKey: false,
		CSS: false,
		CSSConditionRule: false,
		CSSFontFaceRule: false,
		CSSGroupingRule: false,
		CSSImportRule: false,
		CSSKeyframeRule: false,
		CSSKeyframesRule: false,
		CSSMediaRule: false,
		CSSNamespaceRule: false,
		CSSPageRule: false,
		CSSRule: false,
		CSSRuleList: false,
		CSSStyleDeclaration: false,
		CSSStyleRule: false,
		CSSStyleSheet: false,
		CSSSupportsRule: false,
		CustomElementRegistry: false,
		customElements: false,
		CustomEvent: false,
		DataTransfer: false,
		DataTransferItem: false,
		DataTransferItemList: false,
		defaultstatus: false,
		defaultStatus: false,
		DelayNode: false,
		DeviceMotionEvent: false,
		DeviceOrientationEvent: false,
		devicePixelRatio: false,
		dispatchEvent: false,
		document: false,
		Document: false,
		DocumentFragment: false,
		DocumentType: false,
		DOMError: false,
		DOMException: false,
		DOMImplementation: false,
		DOMMatrix: false,
		DOMMatrixReadOnly: false,
		DOMParser: false,
		DOMPoint: false,
		DOMPointReadOnly: false,
		DOMQuad: false,
		DOMRect: false,
		DOMRectReadOnly: false,
		DOMStringList: false,
		DOMStringMap: false,
		DOMTokenList: false,
		DragEvent: false,
		DynamicsCompressorNode: false,
		Element: false,
		ErrorEvent: false,
		event: false,
		Event: false,
		EventSource: false,
		EventTarget: false,
		external: false,
		fetch: false,
		File: false,
		FileList: false,
		FileReader: false,
		find: false,
		focus: false,
		FocusEvent: false,
		FontFace: false,
		FontFaceSetLoadEvent: false,
		FormData: false,
		frameElement: false,
		frames: false,
		GainNode: false,
		Gamepad: false,
		GamepadButton: false,
		GamepadEvent: false,
		getComputedStyle: false,
		getSelection: false,
		HashChangeEvent: false,
		Headers: false,
		history: false,
		History: false,
		HTMLAllCollection: false,
		HTMLAnchorElement: false,
		HTMLAreaElement: false,
		HTMLAudioElement: false,
		HTMLBaseElement: false,
		HTMLBodyElement: false,
		HTMLBRElement: false,
		HTMLButtonElement: false,
		HTMLCanvasElement: false,
		HTMLCollection: false,
		HTMLContentElement: false,
		HTMLDataElement: false,
		HTMLDataListElement: false,
		HTMLDetailsElement: false,
		HTMLDialogElement: false,
		HTMLDirectoryElement: false,
		HTMLDivElement: false,
		HTMLDListElement: false,
		HTMLDocument: false,
		HTMLElement: false,
		HTMLEmbedElement: false,
		HTMLFieldSetElement: false,
		HTMLFontElement: false,
		HTMLFormControlsCollection: false,
		HTMLFormElement: false,
		HTMLFrameElement: false,
		HTMLFrameSetElement: false,
		HTMLHeadElement: false,
		HTMLHeadingElement: false,
		HTMLHRElement: false,
		HTMLHtmlElement: false,
		HTMLIFrameElement: false,
		HTMLImageElement: false,
		HTMLInputElement: false,
		HTMLLabelElement: false,
		HTMLLegendElement: false,
		HTMLLIElement: false,
		HTMLLinkElement: false,
		HTMLMapElement: false,
		HTMLMarqueeElement: false,
		HTMLMediaElement: false,
		HTMLMenuElement: false,
		HTMLMetaElement: false,
		HTMLMeterElement: false,
		HTMLModElement: false,
		HTMLObjectElement: false,
		HTMLOListElement: false,
		HTMLOptGroupElement: false,
		HTMLOptionElement: false,
		HTMLOptionsCollection: false,
		HTMLOutputElement: false,
		HTMLParagraphElement: false,
		HTMLParamElement: false,
		HTMLPictureElement: false,
		HTMLPreElement: false,
		HTMLProgressElement: false,
		HTMLQuoteElement: false,
		HTMLScriptElement: false,
		HTMLSelectElement: false,
		HTMLShadowElement: false,
		HTMLSlotElement: false,
		HTMLSourceElement: false,
		HTMLSpanElement: false,
		HTMLStyleElement: false,
		HTMLTableCaptionElement: false,
		HTMLTableCellElement: false,
		HTMLTableColElement: false,
		HTMLTableElement: false,
		HTMLTableRowElement: false,
		HTMLTableSectionElement: false,
		HTMLTemplateElement: false,
		HTMLTextAreaElement: false,
		HTMLTimeElement: false,
		HTMLTitleElement: false,
		HTMLTrackElement: false,
		HTMLUListElement: false,
		HTMLUnknownElement: false,
		HTMLVideoElement: false,
		IDBCursor: false,
		IDBCursorWithValue: false,
		IDBDatabase: false,
		IDBFactory: false,
		IDBIndex: false,
		IDBKeyRange: false,
		IDBObjectStore: false,
		IDBOpenDBRequest: false,
		IDBRequest: false,
		IDBTransaction: false,
		IDBVersionChangeEvent: false,
		IdleDeadline: false,
		IIRFilterNode: false,
		Image: false,
		ImageBitmap: false,
		ImageBitmapRenderingContext: false,
		ImageCapture: false,
		ImageData: false,
		indexedDB: false,
		innerHeight: false,
		innerWidth: false,
		InputEvent: false,
		IntersectionObserver: false,
		IntersectionObserverEntry: false,
		"Intl": false,
		isSecureContext: false,
		KeyboardEvent: false,
		KeyframeEffect: false,
		KeyframeEffectReadOnly: false,
		length: false,
		localStorage: false,
		location: true,
		Location: false,
		locationbar: false,
		matchMedia: false,
		MediaDeviceInfo: false,
		MediaDevices: false,
		MediaElementAudioSourceNode: false,
		MediaEncryptedEvent: false,
		MediaError: false,
		MediaKeyMessageEvent: false,
		MediaKeySession: false,
		MediaKeyStatusMap: false,
		MediaKeySystemAccess: false,
		MediaList: false,
		MediaQueryList: false,
		MediaQueryListEvent: false,
		MediaRecorder: false,
		MediaSettingsRange: false,
		MediaSource: false,
		MediaStream: false,
		MediaStreamAudioDestinationNode: false,
		MediaStreamAudioSourceNode: false,
		MediaStreamEvent: false,
		MediaStreamTrack: false,
		MediaStreamTrackEvent: false,
		menubar: false,
		MessageChannel: false,
		MessageEvent: false,
		MessagePort: false,
		MIDIAccess: false,
		MIDIConnectionEvent: false,
		MIDIInput: false,
		MIDIInputMap: false,
		MIDIMessageEvent: false,
		MIDIOutput: false,
		MIDIOutputMap: false,
		MIDIPort: false,
		MimeType: false,
		MimeTypeArray: false,
		MouseEvent: false,
		moveBy: false,
		moveTo: false,
		MutationEvent: false,
		MutationObserver: false,
		MutationRecord: false,
		name: false,
		NamedNodeMap: false,
		NavigationPreloadManager: false,
		navigator: false,
		Navigator: false,
		NetworkInformation: false,
		Node: false,
		NodeFilter: false,
		NodeIterator: false,
		NodeList: false,
		Notification: false,
		OfflineAudioCompletionEvent: false,
		OfflineAudioContext: false,
		offscreenBuffering: false,
		OffscreenCanvas: true,
		onabort: true,
		onafterprint: true,
		onanimationend: true,
		onanimationiteration: true,
		onanimationstart: true,
		onappinstalled: true,
		onauxclick: true,
		onbeforeinstallprompt: true,
		onbeforeprint: true,
		onbeforeunload: true,
		onblur: true,
		oncancel: true,
		oncanplay: true,
		oncanplaythrough: true,
		onchange: true,
		onclick: true,
		onclose: true,
		oncontextmenu: true,
		oncuechange: true,
		ondblclick: true,
		ondevicemotion: true,
		ondeviceorientation: true,
		ondeviceorientationabsolute: true,
		ondrag: true,
		ondragend: true,
		ondragenter: true,
		ondragleave: true,
		ondragover: true,
		ondragstart: true,
		ondrop: true,
		ondurationchange: true,
		onemptied: true,
		onended: true,
		onerror: true,
		onfocus: true,
		ongotpointercapture: true,
		onhashchange: true,
		oninput: true,
		oninvalid: true,
		onkeydown: true,
		onkeypress: true,
		onkeyup: true,
		onlanguagechange: true,
		onload: true,
		onloadeddata: true,
		onloadedmetadata: true,
		onloadstart: true,
		onlostpointercapture: true,
		onmessage: true,
		onmessageerror: true,
		onmousedown: true,
		onmouseenter: true,
		onmouseleave: true,
		onmousemove: true,
		onmouseout: true,
		onmouseover: true,
		onmouseup: true,
		onmousewheel: true,
		onoffline: true,
		ononline: true,
		onpagehide: true,
		onpageshow: true,
		onpause: true,
		onplay: true,
		onplaying: true,
		onpointercancel: true,
		onpointerdown: true,
		onpointerenter: true,
		onpointerleave: true,
		onpointermove: true,
		onpointerout: true,
		onpointerover: true,
		onpointerup: true,
		onpopstate: true,
		onprogress: true,
		onratechange: true,
		onrejectionhandled: true,
		onreset: true,
		onresize: true,
		onscroll: true,
		onsearch: true,
		onseeked: true,
		onseeking: true,
		onselect: true,
		onstalled: true,
		onstorage: true,
		onsubmit: true,
		onsuspend: true,
		ontimeupdate: true,
		ontoggle: true,
		ontransitionend: true,
		onunhandledrejection: true,
		onunload: true,
		onvolumechange: true,
		onwaiting: true,
		onwheel: true,
		open: false,
		openDatabase: false,
		opener: false,
		Option: false,
		origin: false,
		OscillatorNode: false,
		outerHeight: false,
		outerWidth: false,
		PageTransitionEvent: false,
		pageXOffset: false,
		pageYOffset: false,
		PannerNode: false,
		parent: false,
		Path2D: false,
		PaymentAddress: false,
		PaymentRequest: false,
		PaymentRequestUpdateEvent: false,
		PaymentResponse: false,
		performance: false,
		Performance: false,
		PerformanceEntry: false,
		PerformanceLongTaskTiming: false,
		PerformanceMark: false,
		PerformanceMeasure: false,
		PerformanceNavigation: false,
		PerformanceNavigationTiming: false,
		PerformanceObserver: false,
		PerformanceObserverEntryList: false,
		PerformancePaintTiming: false,
		PerformanceResourceTiming: false,
		PerformanceTiming: false,
		PeriodicWave: false,
		Permissions: false,
		PermissionStatus: false,
		personalbar: false,
		PhotoCapabilities: false,
		Plugin: false,
		PluginArray: false,
		PointerEvent: false,
		PopStateEvent: false,
		postMessage: false,
		Presentation: false,
		PresentationAvailability: false,
		PresentationConnection: false,
		PresentationConnectionAvailableEvent: false,
		PresentationConnectionCloseEvent: false,
		PresentationConnectionList: false,
		PresentationReceiver: false,
		PresentationRequest: false,
		print: false,
		ProcessingInstruction: false,
		ProgressEvent: false,
		PromiseRejectionEvent: false,
		prompt: false,
		PushManager: false,
		PushSubscription: false,
		PushSubscriptionOptions: false,
		queueMicrotask: false,
		RadioNodeList: false,
		Range: false,
		ReadableStream: false,
		registerProcessor: false,
		RemotePlayback: false,
		removeEventListener: false,
		Request: false,
		requestAnimationFrame: false,
		requestIdleCallback: false,
		resizeBy: false,
		ResizeObserver: false,
		ResizeObserverEntry: false,
		resizeTo: false,
		Response: false,
		RTCCertificate: false,
		RTCDataChannel: false,
		RTCDataChannelEvent: false,
		RTCDtlsTransport: false,
		RTCIceCandidate: false,
		RTCIceGatherer: false,
		RTCIceTransport: false,
		RTCPeerConnection: false,
		RTCPeerConnectionIceEvent: false,
		RTCRtpContributingSource: false,
		RTCRtpReceiver: false,
		RTCRtpSender: false,
		RTCSctpTransport: false,
		RTCSessionDescription: false,
		RTCStatsReport: false,
		RTCTrackEvent: false,
		screen: false,
		Screen: false,
		screenLeft: false,
		ScreenOrientation: false,
		screenTop: false,
		screenX: false,
		screenY: false,
		ScriptProcessorNode: false,
		scroll: false,
		scrollbars: false,
		scrollBy: false,
		scrollTo: false,
		scrollX: false,
		scrollY: false,
		SecurityPolicyViolationEvent: false,
		Selection: false,
		self: false,
		ServiceWorker: false,
		ServiceWorkerContainer: false,
		ServiceWorkerRegistration: false,
		sessionStorage: false,
		setInterval: false,
		setTimeout: false,
		ShadowRoot: false,
		SharedWorker: false,
		SourceBuffer: false,
		SourceBufferList: false,
		speechSynthesis: false,
		SpeechSynthesisEvent: false,
		SpeechSynthesisUtterance: false,
		StaticRange: false,
		status: false,
		statusbar: false,
		StereoPannerNode: false,
		stop: false,
		Storage: false,
		StorageEvent: false,
		StorageManager: false,
		styleMedia: false,
		StyleSheet: false,
		StyleSheetList: false,
		SubtleCrypto: false,
		SVGAElement: false,
		SVGAngle: false,
		SVGAnimatedAngle: false,
		SVGAnimatedBoolean: false,
		SVGAnimatedEnumeration: false,
		SVGAnimatedInteger: false,
		SVGAnimatedLength: false,
		SVGAnimatedLengthList: false,
		SVGAnimatedNumber: false,
		SVGAnimatedNumberList: false,
		SVGAnimatedPreserveAspectRatio: false,
		SVGAnimatedRect: false,
		SVGAnimatedString: false,
		SVGAnimatedTransformList: false,
		SVGAnimateElement: false,
		SVGAnimateMotionElement: false,
		SVGAnimateTransformElement: false,
		SVGAnimationElement: false,
		SVGCircleElement: false,
		SVGClipPathElement: false,
		SVGComponentTransferFunctionElement: false,
		SVGDefsElement: false,
		SVGDescElement: false,
		SVGDiscardElement: false,
		SVGElement: false,
		SVGEllipseElement: false,
		SVGFEBlendElement: false,
		SVGFEColorMatrixElement: false,
		SVGFEComponentTransferElement: false,
		SVGFECompositeElement: false,
		SVGFEConvolveMatrixElement: false,
		SVGFEDiffuseLightingElement: false,
		SVGFEDisplacementMapElement: false,
		SVGFEDistantLightElement: false,
		SVGFEDropShadowElement: false,
		SVGFEFloodElement: false,
		SVGFEFuncAElement: false,
		SVGFEFuncBElement: false,
		SVGFEFuncGElement: false,
		SVGFEFuncRElement: false,
		SVGFEGaussianBlurElement: false,
		SVGFEImageElement: false,
		SVGFEMergeElement: false,
		SVGFEMergeNodeElement: false,
		SVGFEMorphologyElement: false,
		SVGFEOffsetElement: false,
		SVGFEPointLightElement: false,
		SVGFESpecularLightingElement: false,
		SVGFESpotLightElement: false,
		SVGFETileElement: false,
		SVGFETurbulenceElement: false,
		SVGFilterElement: false,
		SVGForeignObjectElement: false,
		SVGGElement: false,
		SVGGeometryElement: false,
		SVGGradientElement: false,
		SVGGraphicsElement: false,
		SVGImageElement: false,
		SVGLength: false,
		SVGLengthList: false,
		SVGLinearGradientElement: false,
		SVGLineElement: false,
		SVGMarkerElement: false,
		SVGMaskElement: false,
		SVGMatrix: false,
		SVGMetadataElement: false,
		SVGMPathElement: false,
		SVGNumber: false,
		SVGNumberList: false,
		SVGPathElement: false,
		SVGPatternElement: false,
		SVGPoint: false,
		SVGPointList: false,
		SVGPolygonElement: false,
		SVGPolylineElement: false,
		SVGPreserveAspectRatio: false,
		SVGRadialGradientElement: false,
		SVGRect: false,
		SVGRectElement: false,
		SVGScriptElement: false,
		SVGSetElement: false,
		SVGStopElement: false,
		SVGStringList: false,
		SVGStyleElement: false,
		SVGSVGElement: false,
		SVGSwitchElement: false,
		SVGSymbolElement: false,
		SVGTextContentElement: false,
		SVGTextElement: false,
		SVGTextPathElement: false,
		SVGTextPositioningElement: false,
		SVGTitleElement: false,
		SVGTransform: false,
		SVGTransformList: false,
		SVGTSpanElement: false,
		SVGUnitTypes: false,
		SVGUseElement: false,
		SVGViewElement: false,
		TaskAttributionTiming: false,
		Text: false,
		TextDecoder: false,
		TextEncoder: false,
		TextEvent: false,
		TextMetrics: false,
		TextTrack: false,
		TextTrackCue: false,
		TextTrackCueList: false,
		TextTrackList: false,
		TimeRanges: false,
		toolbar: false,
		top: false,
		Touch: false,
		TouchEvent: false,
		TouchList: false,
		TrackEvent: false,
		TransitionEvent: false,
		TreeWalker: false,
		UIEvent: false,
		URL: false,
		URLSearchParams: false,
		ValidityState: false,
		visualViewport: false,
		VisualViewport: false,
		VTTCue: false,
		WaveShaperNode: false,
		WebAssembly: false,
		WebGL2RenderingContext: false,
		WebGLActiveInfo: false,
		WebGLBuffer: false,
		WebGLContextEvent: false,
		WebGLFramebuffer: false,
		WebGLProgram: false,
		WebGLQuery: false,
		WebGLRenderbuffer: false,
		WebGLRenderingContext: false,
		WebGLSampler: false,
		WebGLShader: false,
		WebGLShaderPrecisionFormat: false,
		WebGLSync: false,
		WebGLTexture: false,
		WebGLTransformFeedback: false,
		WebGLUniformLocation: false,
		WebGLVertexArrayObject: false,
		WebSocket: false,
		WheelEvent: false,
		window: false,
		Window: false,
		Worker: false,
		WritableStream: false,
		XMLDocument: false,
		XMLHttpRequest: false,
		XMLHttpRequestEventTarget: false,
		XMLHttpRequestUpload: false,
		XMLSerializer: false,
		XPathEvaluator: false,
		XPathExpression: false,
		XPathResult: false,
		XSLTProcessor: false
	};
	var worker = {
		addEventListener: false,
		applicationCache: false,
		atob: false,
		Blob: false,
		BroadcastChannel: false,
		btoa: false,
		Cache: false,
		caches: false,
		clearInterval: false,
		clearTimeout: false,
		close: true,
		console: false,
		fetch: false,
		FileReaderSync: false,
		FormData: false,
		Headers: false,
		IDBCursor: false,
		IDBCursorWithValue: false,
		IDBDatabase: false,
		IDBFactory: false,
		IDBIndex: false,
		IDBKeyRange: false,
		IDBObjectStore: false,
		IDBOpenDBRequest: false,
		IDBRequest: false,
		IDBTransaction: false,
		IDBVersionChangeEvent: false,
		ImageData: false,
		importScripts: true,
		indexedDB: false,
		location: false,
		MessageChannel: false,
		MessagePort: false,
		name: false,
		navigator: false,
		Notification: false,
		onclose: true,
		onconnect: true,
		onerror: true,
		onlanguagechange: true,
		onmessage: true,
		onoffline: true,
		ononline: true,
		onrejectionhandled: true,
		onunhandledrejection: true,
		performance: false,
		Performance: false,
		PerformanceEntry: false,
		PerformanceMark: false,
		PerformanceMeasure: false,
		PerformanceNavigation: false,
		PerformanceResourceTiming: false,
		PerformanceTiming: false,
		postMessage: true,
		"Promise": false,
		queueMicrotask: false,
		removeEventListener: false,
		Request: false,
		Response: false,
		self: true,
		ServiceWorkerRegistration: false,
		setInterval: false,
		setTimeout: false,
		TextDecoder: false,
		TextEncoder: false,
		URL: false,
		URLSearchParams: false,
		WebSocket: false,
		Worker: false,
		WorkerGlobalScope: false,
		XMLHttpRequest: false
	};
	var node$1 = {
		__dirname: false,
		__filename: false,
		Buffer: false,
		clearImmediate: false,
		clearInterval: false,
		clearTimeout: false,
		console: false,
		exports: true,
		global: false,
		"Intl": false,
		module: false,
		process: false,
		queueMicrotask: false,
		require: false,
		setImmediate: false,
		setInterval: false,
		setTimeout: false,
		TextDecoder: false,
		TextEncoder: false,
		URL: false,
		URLSearchParams: false
	};
	var commonjs = {
		exports: true,
		global: false,
		module: false,
		require: false
	};
	var amd = {
		define: false,
		require: false
	};
	var mocha = {
		after: false,
		afterEach: false,
		before: false,
		beforeEach: false,
		context: false,
		describe: false,
		it: false,
		mocha: false,
		run: false,
		setup: false,
		specify: false,
		suite: false,
		suiteSetup: false,
		suiteTeardown: false,
		teardown: false,
		test: false,
		xcontext: false,
		xdescribe: false,
		xit: false,
		xspecify: false
	};
	var jasmine = {
		afterAll: false,
		afterEach: false,
		beforeAll: false,
		beforeEach: false,
		describe: false,
		expect: false,
		fail: false,
		fdescribe: false,
		fit: false,
		it: false,
		jasmine: false,
		pending: false,
		runs: false,
		spyOn: false,
		spyOnProperty: false,
		waits: false,
		waitsFor: false,
		xdescribe: false,
		xit: false
	};
	var jest = {
		afterAll: false,
		afterEach: false,
		beforeAll: false,
		beforeEach: false,
		describe: false,
		expect: false,
		fdescribe: false,
		fit: false,
		it: false,
		jest: false,
		pit: false,
		require: false,
		test: false,
		xdescribe: false,
		xit: false,
		xtest: false
	};
	var qunit = {
		asyncTest: false,
		deepEqual: false,
		equal: false,
		expect: false,
		module: false,
		notDeepEqual: false,
		notEqual: false,
		notOk: false,
		notPropEqual: false,
		notStrictEqual: false,
		ok: false,
		propEqual: false,
		QUnit: false,
		raises: false,
		start: false,
		stop: false,
		strictEqual: false,
		test: false,
		throws: false
	};
	var phantomjs = {
		console: true,
		exports: true,
		phantom: true,
		require: true,
		WebPage: true
	};
	var couch = {
		emit: false,
		exports: false,
		getRow: false,
		log: false,
		module: false,
		provides: false,
		require: false,
		respond: false,
		send: false,
		start: false,
		sum: false
	};
	var rhino = {
		defineClass: false,
		deserialize: false,
		gc: false,
		help: false,
		importClass: false,
		importPackage: false,
		java: false,
		load: false,
		loadClass: false,
		Packages: false,
		print: false,
		quit: false,
		readFile: false,
		readUrl: false,
		runCommand: false,
		seal: false,
		serialize: false,
		spawn: false,
		sync: false,
		toint32: false,
		version: false
	};
	var nashorn = {
		__DIR__: false,
		__FILE__: false,
		__LINE__: false,
		com: false,
		edu: false,
		exit: false,
		java: false,
		Java: false,
		javafx: false,
		JavaImporter: false,
		javax: false,
		JSAdapter: false,
		load: false,
		loadWithNewGlobal: false,
		org: false,
		Packages: false,
		print: false,
		quit: false
	};
	var wsh = {
		ActiveXObject: true,
		Enumerator: true,
		GetObject: true,
		ScriptEngine: true,
		ScriptEngineBuildVersion: true,
		ScriptEngineMajorVersion: true,
		ScriptEngineMinorVersion: true,
		VBArray: true,
		WScript: true,
		WSH: true,
		XDomainRequest: true
	};
	var jquery = {
		$: false,
		jQuery: false
	};
	var yui = {
		YAHOO: false,
		YAHOO_config: false,
		YUI: false,
		YUI_config: false
	};
	var shelljs = {
		cat: false,
		cd: false,
		chmod: false,
		config: false,
		cp: false,
		dirs: false,
		echo: false,
		env: false,
		error: false,
		exec: false,
		exit: false,
		find: false,
		grep: false,
		ln: false,
		ls: false,
		mkdir: false,
		mv: false,
		popd: false,
		pushd: false,
		pwd: false,
		rm: false,
		sed: false,
		set: false,
		target: false,
		tempdir: false,
		test: false,
		touch: false,
		which: false
	};
	var prototypejs = {
		$: false,
		$$: false,
		$A: false,
		$break: false,
		$continue: false,
		$F: false,
		$H: false,
		$R: false,
		$w: false,
		Abstract: false,
		Ajax: false,
		Autocompleter: false,
		Builder: false,
		Class: false,
		Control: false,
		Draggable: false,
		Draggables: false,
		Droppables: false,
		Effect: false,
		Element: false,
		Enumerable: false,
		Event: false,
		Field: false,
		Form: false,
		Hash: false,
		Insertion: false,
		ObjectRange: false,
		PeriodicalExecuter: false,
		Position: false,
		Prototype: false,
		Scriptaculous: false,
		Selector: false,
		Sortable: false,
		SortableObserver: false,
		Sound: false,
		Template: false,
		Toggle: false,
		Try: false
	};
	var meteor = {
		_: false,
		$: false,
		Accounts: false,
		AccountsClient: false,
		AccountsCommon: false,
		AccountsServer: false,
		App: false,
		Assets: false,
		Blaze: false,
		check: false,
		Cordova: false,
		DDP: false,
		DDPRateLimiter: false,
		DDPServer: false,
		Deps: false,
		EJSON: false,
		Email: false,
		HTTP: false,
		Log: false,
		Match: false,
		Meteor: false,
		Mongo: false,
		MongoInternals: false,
		Npm: false,
		Package: false,
		Plugin: false,
		process: false,
		Random: false,
		ReactiveDict: false,
		ReactiveVar: false,
		Router: false,
		ServiceConfiguration: false,
		Session: false,
		share: false,
		Spacebars: false,
		Template: false,
		Tinytest: false,
		Tracker: false,
		UI: false,
		Utils: false,
		WebApp: false,
		WebAppInternals: false
	};
	var mongo = {
		_isWindows: false,
		_rand: false,
		BulkWriteResult: false,
		cat: false,
		cd: false,
		connect: false,
		db: false,
		getHostName: false,
		getMemInfo: false,
		hostname: false,
		ISODate: false,
		listFiles: false,
		load: false,
		ls: false,
		md5sumFile: false,
		mkdir: false,
		Mongo: false,
		NumberInt: false,
		NumberLong: false,
		ObjectId: false,
		PlanCache: false,
		print: false,
		printjson: false,
		pwd: false,
		quit: false,
		removeFile: false,
		rs: false,
		sh: false,
		UUID: false,
		version: false,
		WriteResult: false
	};
	var applescript = {
		$: false,
		Application: false,
		Automation: false,
		console: false,
		delay: false,
		Library: false,
		ObjC: false,
		ObjectSpecifier: false,
		Path: false,
		Progress: false,
		Ref: false
	};
	var serviceworker = {
		addEventListener: false,
		applicationCache: false,
		atob: false,
		Blob: false,
		BroadcastChannel: false,
		btoa: false,
		Cache: false,
		caches: false,
		CacheStorage: false,
		clearInterval: false,
		clearTimeout: false,
		Client: false,
		clients: false,
		Clients: false,
		close: true,
		console: false,
		ExtendableEvent: false,
		ExtendableMessageEvent: false,
		fetch: false,
		FetchEvent: false,
		FileReaderSync: false,
		FormData: false,
		Headers: false,
		IDBCursor: false,
		IDBCursorWithValue: false,
		IDBDatabase: false,
		IDBFactory: false,
		IDBIndex: false,
		IDBKeyRange: false,
		IDBObjectStore: false,
		IDBOpenDBRequest: false,
		IDBRequest: false,
		IDBTransaction: false,
		IDBVersionChangeEvent: false,
		ImageData: false,
		importScripts: false,
		indexedDB: false,
		location: false,
		MessageChannel: false,
		MessagePort: false,
		name: false,
		navigator: false,
		Notification: false,
		onclose: true,
		onconnect: true,
		onerror: true,
		onfetch: true,
		oninstall: true,
		onlanguagechange: true,
		onmessage: true,
		onmessageerror: true,
		onnotificationclick: true,
		onnotificationclose: true,
		onoffline: true,
		ononline: true,
		onpush: true,
		onpushsubscriptionchange: true,
		onrejectionhandled: true,
		onsync: true,
		onunhandledrejection: true,
		performance: false,
		Performance: false,
		PerformanceEntry: false,
		PerformanceMark: false,
		PerformanceMeasure: false,
		PerformanceNavigation: false,
		PerformanceResourceTiming: false,
		PerformanceTiming: false,
		postMessage: true,
		"Promise": false,
		queueMicrotask: false,
		registration: false,
		removeEventListener: false,
		Request: false,
		Response: false,
		self: false,
		ServiceWorker: false,
		ServiceWorkerContainer: false,
		ServiceWorkerGlobalScope: false,
		ServiceWorkerMessageEvent: false,
		ServiceWorkerRegistration: false,
		setInterval: false,
		setTimeout: false,
		skipWaiting: false,
		TextDecoder: false,
		TextEncoder: false,
		URL: false,
		URLSearchParams: false,
		WebSocket: false,
		WindowClient: false,
		Worker: false,
		WorkerGlobalScope: false,
		XMLHttpRequest: false
	};
	var atomtest = {
		advanceClock: false,
		fakeClearInterval: false,
		fakeClearTimeout: false,
		fakeSetInterval: false,
		fakeSetTimeout: false,
		resetTimeouts: false,
		waitsForPromise: false
	};
	var embertest = {
		andThen: false,
		click: false,
		currentPath: false,
		currentRouteName: false,
		currentURL: false,
		fillIn: false,
		find: false,
		findAll: false,
		findWithAssert: false,
		keyEvent: false,
		pauseTest: false,
		resumeTest: false,
		triggerEvent: false,
		visit: false,
		wait: false
	};
	var protractor = {
		$: false,
		$$: false,
		browser: false,
		by: false,
		By: false,
		DartObject: false,
		element: false,
		protractor: false
	};
	var webextensions = {
		browser: false,
		chrome: false,
		opr: false
	};
	var greasemonkey = {
		cloneInto: false,
		createObjectIn: false,
		exportFunction: false,
		GM: false,
		GM_addStyle: false,
		GM_deleteValue: false,
		GM_getResourceText: false,
		GM_getResourceURL: false,
		GM_getValue: false,
		GM_info: false,
		GM_listValues: false,
		GM_log: false,
		GM_openInTab: false,
		GM_registerMenuCommand: false,
		GM_setClipboard: false,
		GM_setValue: false,
		GM_xmlhttpRequest: false,
		unsafeWindow: false
	};
	var devtools = {
		$: false,
		$_: false,
		$$: false,
		$0: false,
		$1: false,
		$2: false,
		$3: false,
		$4: false,
		$x: false,
		chrome: false,
		clear: false,
		copy: false,
		debug: false,
		dir: false,
		dirxml: false,
		getEventListeners: false,
		inspect: false,
		keys: false,
		monitor: false,
		monitorEvents: false,
		profile: false,
		profileEnd: false,
		queryObjects: false,
		table: false,
		undebug: false,
		unmonitor: false,
		unmonitorEvents: false,
		values: false
	};
	var require$$0$7 = {
		builtin: builtin,
		es5: es5,
		es2015: es2015,
		es2017: es2017,
		browser: browser$2,
		worker: worker,
		node: node$1,
		commonjs: commonjs,
		amd: amd,
		mocha: mocha,
		jasmine: jasmine,
		jest: jest,
		qunit: qunit,
		phantomjs: phantomjs,
		couch: couch,
		rhino: rhino,
		nashorn: nashorn,
		wsh: wsh,
		jquery: jquery,
		yui: yui,
		shelljs: shelljs,
		prototypejs: prototypejs,
		meteor: meteor,
		mongo: mongo,
		applescript: applescript,
		serviceworker: serviceworker,
		atomtest: atomtest,
		embertest: embertest,
		protractor: protractor,
		"shared-node-browser": {
		clearInterval: false,
		clearTimeout: false,
		console: false,
		setInterval: false,
		setTimeout: false,
		URL: false,
		URLSearchParams: false
	},
		webextensions: webextensions,
		greasemonkey: greasemonkey,
		devtools: devtools
	};

	var globalsBABEL_8_BREAKINGFalse = require$$0$7;

	var globals = globalsBABEL_8_BREAKINGFalse;

	var path$3 = new WeakMap();
	var scope = new WeakMap();
	function clear() {
	  clearPath();
	  clearScope();
	}
	function clearPath() {
	  path$3 = new WeakMap();
	}
	function clearScope() {
	  scope = new WeakMap();
	}

	var cache$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get path () { return path$3; },
		get scope () { return scope; },
		clear: clear,
		clearPath: clearPath,
		clearScope: clearScope
	});

	var NOT_LOCAL_BINDING$1 = NOT_LOCAL_BINDING$2,
	    callExpression$d = callExpression$e,
	    cloneNode$g = cloneNode$i,
	    getBindingIdentifiers$1 = getBindingIdentifiers$2,
	    identifier$h = identifier$j,
	    isArrayExpression$1 = isArrayExpression$2,
	    isBinary$2 = isBinary$3,
	    isClass = isClass$1,
	    isClassBody = isClassBody$1,
	    isClassDeclaration$2 = isClassDeclaration$3,
	    isExportAllDeclaration = isExportAllDeclaration$1,
	    isExportDefaultDeclaration$2 = isExportDefaultDeclaration$3,
	    isExportNamedDeclaration$1 = isExportNamedDeclaration$2,
	    isFunctionDeclaration = isFunctionDeclaration$1,
	    isIdentifier$e = isIdentifier$g,
	    isImportDeclaration = isImportDeclaration$2,
	    isLiteral$6 = isLiteral$7,
	    isMethod = isMethod$1,
	    isModuleDeclaration = isModuleDeclaration$1,
	    isModuleSpecifier = isModuleSpecifier$1,
	    isObjectExpression$2 = isObjectExpression$3,
	    isProperty$1 = isProperty$2,
	    isPureish$1 = isPureish$2,
	    isSuper$1 = isSuper$2,
	    isTaggedTemplateExpression$1 = isTaggedTemplateExpression$2,
	    isTemplateLiteral$1 = isTemplateLiteral$2,
	    isThisExpression$1 = isThisExpression$2,
	    isUnaryExpression = isUnaryExpression$1,
	    isVariableDeclaration$1 = isVariableDeclaration$3,
	    matchesPattern$1 = matchesPattern$2,
	    memberExpression$a = memberExpression$b,
	    numericLiteral$7 = numericLiteral$8,
	    toIdentifier = toIdentifier$1,
	    unaryExpression$6 = unaryExpression$7,
	    variableDeclaration$6 = variableDeclaration$8,
	    variableDeclarator$6 = variableDeclarator$8;

	function gatherNodeParts(node, parts) {
	  switch (node == null ? void 0 : node.type) {
	    default:
	      if (isModuleDeclaration(node)) {
	        if ((isExportAllDeclaration(node) || isExportNamedDeclaration$1(node) || isImportDeclaration(node)) && node.source) {
	          gatherNodeParts(node.source, parts);
	        } else if ((isExportNamedDeclaration$1(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
	          for (var _iterator = _createForOfIteratorHelperLoose(node.specifiers), _step; !(_step = _iterator()).done;) {
	            var e = _step.value;
	            gatherNodeParts(e, parts);
	          }
	        } else if ((isExportDefaultDeclaration$2(node) || isExportNamedDeclaration$1(node)) && node.declaration) {
	          gatherNodeParts(node.declaration, parts);
	        }
	      } else if (isModuleSpecifier(node)) {
	        gatherNodeParts(node.local, parts);
	      } else if (isLiteral$6(node)) {
	        parts.push(node.value);
	      }

	      break;

	    case "MemberExpression":
	    case "OptionalMemberExpression":
	    case "JSXMemberExpression":
	      gatherNodeParts(node.object, parts);
	      gatherNodeParts(node.property, parts);
	      break;

	    case "Identifier":
	    case "JSXIdentifier":
	      parts.push(node.name);
	      break;

	    case "CallExpression":
	    case "OptionalCallExpression":
	    case "NewExpression":
	      gatherNodeParts(node.callee, parts);
	      break;

	    case "ObjectExpression":
	    case "ObjectPattern":
	      for (var _iterator2 = _createForOfIteratorHelperLoose(node.properties), _step2; !(_step2 = _iterator2()).done;) {
	        var _e = _step2.value;
	        gatherNodeParts(_e, parts);
	      }

	      break;

	    case "SpreadElement":
	    case "RestElement":
	      gatherNodeParts(node.argument, parts);
	      break;

	    case "ObjectProperty":
	    case "ObjectMethod":
	    case "ClassProperty":
	    case "ClassMethod":
	    case "ClassPrivateProperty":
	    case "ClassPrivateMethod":
	      gatherNodeParts(node.key, parts);
	      break;

	    case "ThisExpression":
	      parts.push("this");
	      break;

	    case "Super":
	      parts.push("super");
	      break;

	    case "Import":
	      parts.push("import");
	      break;

	    case "DoExpression":
	      parts.push("do");
	      break;

	    case "YieldExpression":
	      parts.push("yield");
	      gatherNodeParts(node.argument, parts);
	      break;

	    case "AwaitExpression":
	      parts.push("await");
	      gatherNodeParts(node.argument, parts);
	      break;

	    case "AssignmentExpression":
	      gatherNodeParts(node.left, parts);
	      break;

	    case "VariableDeclarator":
	      gatherNodeParts(node.id, parts);
	      break;

	    case "FunctionExpression":
	    case "FunctionDeclaration":
	    case "ClassExpression":
	    case "ClassDeclaration":
	      gatherNodeParts(node.id, parts);
	      break;

	    case "PrivateName":
	      gatherNodeParts(node.id, parts);
	      break;

	    case "ParenthesizedExpression":
	      gatherNodeParts(node.expression, parts);
	      break;

	    case "UnaryExpression":
	    case "UpdateExpression":
	      gatherNodeParts(node.argument, parts);
	      break;

	    case "MetaProperty":
	      gatherNodeParts(node.meta, parts);
	      gatherNodeParts(node.property, parts);
	      break;

	    case "JSXElement":
	      gatherNodeParts(node.openingElement, parts);
	      break;

	    case "JSXOpeningElement":
	      parts.push(node.name);
	      break;

	    case "JSXFragment":
	      gatherNodeParts(node.openingFragment, parts);
	      break;

	    case "JSXOpeningFragment":
	      parts.push("Fragment");
	      break;

	    case "JSXNamespacedName":
	      gatherNodeParts(node.namespace, parts);
	      gatherNodeParts(node.name, parts);
	      break;
	  }
	}

	var collectorVisitor = {
	  ForStatement: function ForStatement(path) {
	    var declar = path.get("init");

	    if (declar.isVar()) {
	      var scope = path.scope;
	      var parentScope = scope.getFunctionParent() || scope.getProgramParent();
	      parentScope.registerBinding("var", declar);
	    }
	  },
	  Declaration: function Declaration(path) {
	    if (path.isBlockScoped()) return;
	    if (path.isImportDeclaration()) return;
	    if (path.isExportDeclaration()) return;
	    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
	    parent.registerDeclaration(path);
	  },
	  ImportDeclaration: function ImportDeclaration(path) {
	    var parent = path.scope.getBlockParent();
	    parent.registerDeclaration(path);
	  },
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    state.references.push(path);
	  },
	  ForXStatement: function ForXStatement(path, state) {
	    var left = path.get("left");

	    if (left.isPattern() || left.isIdentifier()) {
	      state.constantViolations.push(path);
	    } else if (left.isVar()) {
	      var scope = path.scope;
	      var parentScope = scope.getFunctionParent() || scope.getProgramParent();
	      parentScope.registerBinding("var", left);
	    }
	  },
	  ExportDeclaration: {
	    exit: function exit(path) {
	      var node = path.node,
	          scope = path.scope;
	      if (isExportAllDeclaration(node)) return;
	      var declar = node.declaration;

	      if (isClassDeclaration$2(declar) || isFunctionDeclaration(declar)) {
	        var id = declar.id;
	        if (!id) return;
	        var binding = scope.getBinding(id.name);
	        binding == null ? void 0 : binding.reference(path);
	      } else if (isVariableDeclaration$1(declar)) {
	        for (var _iterator3 = _createForOfIteratorHelperLoose(declar.declarations), _step3; !(_step3 = _iterator3()).done;) {
	          var decl = _step3.value;

	          for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers$1(decl)); _i < _Object$keys.length; _i++) {
	            var _name = _Object$keys[_i];

	            var _binding = scope.getBinding(_name);

	            _binding == null ? void 0 : _binding.reference(path);
	          }
	        }
	      }
	    }
	  },
	  LabeledStatement: function LabeledStatement(path) {
	    path.scope.getBlockParent().registerDeclaration(path);
	  },
	  AssignmentExpression: function AssignmentExpression(path, state) {
	    state.assignments.push(path);
	  },
	  UpdateExpression: function UpdateExpression(path, state) {
	    state.constantViolations.push(path);
	  },
	  UnaryExpression: function UnaryExpression(path, state) {
	    if (path.node.operator === "delete") {
	      state.constantViolations.push(path);
	    }
	  },
	  BlockScoped: function BlockScoped(path) {
	    var scope = path.scope;
	    if (scope.path === path) scope = scope.parent;
	    var parent = scope.getBlockParent();
	    parent.registerDeclaration(path);

	    if (path.isClassDeclaration() && path.node.id) {
	      var id = path.node.id;
	      var _name2 = id.name;
	      path.scope.bindings[_name2] = path.scope.parent.getBinding(_name2);
	    }
	  },
	  CatchClause: function CatchClause(path) {
	    path.scope.registerBinding("let", path);
	  },
	  Function: function Function(path) {
	    var params = path.get("params");

	    for (var _iterator4 = _createForOfIteratorHelperLoose(params), _step4; !(_step4 = _iterator4()).done;) {
	      var param = _step4.value;
	      path.scope.registerBinding("param", param);
	    }

	    if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING$1]) {
	      path.scope.registerBinding("local", path.get("id"), path);
	    }
	  },
	  ClassExpression: function ClassExpression(path) {
	    if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING$1]) {
	      path.scope.registerBinding("local", path);
	    }
	  }
	};
	var uid = 0;

	var Scope$1 = function () {
	  function Scope(path) {
	    this.uid = void 0;
	    this.path = void 0;
	    this.block = void 0;
	    this.labels = void 0;
	    this.inited = void 0;
	    this.bindings = void 0;
	    this.references = void 0;
	    this.globals = void 0;
	    this.uids = void 0;
	    this.data = void 0;
	    this.crawling = void 0;
	    var node = path.node;
	    var cached = scope.get(node);

	    if ((cached == null ? void 0 : cached.path) === path) {
	      return cached;
	    }

	    scope.set(node, this);
	    this.uid = uid++;
	    this.block = node;
	    this.path = path;
	    this.labels = new Map();
	    this.inited = false;
	  }

	  var _proto = Scope.prototype;

	  _proto.traverse = function traverse$1(node, opts, state) {
	    traverse(node, opts, this, state, this.path);
	  };

	  _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
	    var id = this.generateUidIdentifier(name);
	    this.push({
	      id: id
	    });
	    return cloneNode$g(id);
	  };

	  _proto.generateUidIdentifier = function generateUidIdentifier(name) {
	    return identifier$h(this.generateUid(name));
	  };

	  _proto.generateUid = function generateUid(name) {
	    if (name === void 0) {
	      name = "temp";
	    }

	    name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
	    var uid;
	    var i = 1;

	    do {
	      uid = this._generateUid(name, i);
	      i++;
	    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

	    var program = this.getProgramParent();
	    program.references[uid] = true;
	    program.uids[uid] = true;
	    return uid;
	  };

	  _proto._generateUid = function _generateUid(name, i) {
	    var id = name;
	    if (i > 1) id += i;
	    return "_" + id;
	  };

	  _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
	    var parts = [];
	    gatherNodeParts(node, parts);
	    var id = parts.join("$");
	    id = id.replace(/^_/, "") || defaultName || "ref";
	    return this.generateUid(id.slice(0, 20));
	  };

	  _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
	    return identifier$h(this.generateUidBasedOnNode(node, defaultName));
	  };

	  _proto.isStatic = function isStatic(node) {
	    if (isThisExpression$1(node) || isSuper$1(node)) {
	      return true;
	    }

	    if (isIdentifier$e(node)) {
	      var binding = this.getBinding(node.name);

	      if (binding) {
	        return binding.constant;
	      } else {
	        return this.hasBinding(node.name);
	      }
	    }

	    return false;
	  };

	  _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
	    if (this.isStatic(node)) {
	      return null;
	    } else {
	      var id = this.generateUidIdentifierBasedOnNode(node);

	      if (!dontPush) {
	        this.push({
	          id: id
	        });
	        return cloneNode$g(id);
	      }

	      return id;
	    }
	  };

	  _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
	    if (kind === "param") return;
	    if (local.kind === "local") return;
	    var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

	    if (duplicate) {
	      throw this.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
	    }
	  };

	  _proto.rename = function rename(oldName, newName, block) {
	    var binding = this.getBinding(oldName);

	    if (binding) {
	      newName = newName || this.generateUidIdentifier(oldName).name;
	      return new Renamer(binding, oldName, newName).rename(block);
	    }
	  };

	  _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
	    if (map[oldName]) {
	      map[newName] = value;
	      map[oldName] = null;
	    }
	  };

	  _proto.dump = function dump() {
	    var sep = "-".repeat(60);
	    console.log(sep);
	    var scope = this;

	    do {
	      console.log("#", scope.block.type);

	      for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
	        var _name3 = _Object$keys2[_i2];
	        var binding = scope.bindings[_name3];
	        console.log(" -", _name3, {
	          constant: binding.constant,
	          references: binding.references,
	          violations: binding.constantViolations.length,
	          kind: binding.kind
	        });
	      }
	    } while (scope = scope.parent);

	    console.log(sep);
	  };

	  _proto.toArray = function toArray(node, i, arrayLikeIsIterable) {
	    if (isIdentifier$e(node)) {
	      var binding = this.getBinding(node.name);

	      if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
	        return node;
	      }
	    }

	    if (isArrayExpression$1(node)) {
	      return node;
	    }

	    if (isIdentifier$e(node, {
	      name: "arguments"
	    })) {
	      return callExpression$d(memberExpression$a(memberExpression$a(memberExpression$a(identifier$h("Array"), identifier$h("prototype")), identifier$h("slice")), identifier$h("call")), [node]);
	    }

	    var helperName;
	    var args = [node];

	    if (i === true) {
	      helperName = "toConsumableArray";
	    } else if (i) {
	      args.push(numericLiteral$7(i));
	      helperName = "slicedToArray";
	    } else {
	      helperName = "toArray";
	    }

	    if (arrayLikeIsIterable) {
	      args.unshift(this.hub.addHelper(helperName));
	      helperName = "maybeArrayLike";
	    }

	    return callExpression$d(this.hub.addHelper(helperName), args);
	  };

	  _proto.hasLabel = function hasLabel(name) {
	    return !!this.getLabel(name);
	  };

	  _proto.getLabel = function getLabel(name) {
	    return this.labels.get(name);
	  };

	  _proto.registerLabel = function registerLabel(path) {
	    this.labels.set(path.node.label.name, path);
	  };

	  _proto.registerDeclaration = function registerDeclaration(path) {
	    if (path.isLabeledStatement()) {
	      this.registerLabel(path);
	    } else if (path.isFunctionDeclaration()) {
	      this.registerBinding("hoisted", path.get("id"), path);
	    } else if (path.isVariableDeclaration()) {
	      var declarations = path.get("declarations");

	      for (var _iterator5 = _createForOfIteratorHelperLoose(declarations), _step5; !(_step5 = _iterator5()).done;) {
	        var declar = _step5.value;
	        this.registerBinding(path.node.kind, declar);
	      }
	    } else if (path.isClassDeclaration()) {
	      if (path.node.declare) return;
	      this.registerBinding("let", path);
	    } else if (path.isImportDeclaration()) {
	      var specifiers = path.get("specifiers");

	      for (var _iterator6 = _createForOfIteratorHelperLoose(specifiers), _step6; !(_step6 = _iterator6()).done;) {
	        var specifier = _step6.value;
	        this.registerBinding("module", specifier);
	      }
	    } else if (path.isExportDeclaration()) {
	      var _declar = path.get("declaration");

	      if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
	        this.registerDeclaration(_declar);
	      }
	    } else {
	      this.registerBinding("unknown", path);
	    }
	  };

	  _proto.buildUndefinedNode = function buildUndefinedNode() {
	    return unaryExpression$6("void", numericLiteral$7(0), true);
	  };

	  _proto.registerConstantViolation = function registerConstantViolation(path) {
	    var ids = path.getBindingIdentifiers();

	    for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
	      var _name4 = _Object$keys3[_i3];
	      var binding = this.getBinding(_name4);
	      if (binding) binding.reassign(path);
	    }
	  };

	  _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
	    if (bindingPath === void 0) {
	      bindingPath = path;
	    }

	    if (!kind) throw new ReferenceError("no `kind`");

	    if (path.isVariableDeclaration()) {
	      var declarators = path.get("declarations");

	      for (var _iterator7 = _createForOfIteratorHelperLoose(declarators), _step7; !(_step7 = _iterator7()).done;) {
	        var declar = _step7.value;
	        this.registerBinding(kind, declar);
	      }

	      return;
	    }

	    var parent = this.getProgramParent();
	    var ids = path.getOuterBindingIdentifiers(true);

	    for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
	      var _name5 = _Object$keys4[_i4];
	      parent.references[_name5] = true;

	      for (var _iterator8 = _createForOfIteratorHelperLoose(ids[_name5]), _step8; !(_step8 = _iterator8()).done;) {
	        var id = _step8.value;
	        var local = this.getOwnBinding(_name5);

	        if (local) {
	          if (local.identifier === id) continue;
	          this.checkBlockScopedCollisions(local, kind, _name5, id);
	        }

	        if (local) {
	          this.registerConstantViolation(bindingPath);
	        } else {
	          this.bindings[_name5] = new Binding({
	            identifier: id,
	            scope: this,
	            path: bindingPath,
	            kind: kind
	          });
	        }
	      }
	    }
	  };

	  _proto.addGlobal = function addGlobal(node) {
	    this.globals[node.name] = node;
	  };

	  _proto.hasUid = function hasUid(name) {
	    var scope = this;

	    do {
	      if (scope.uids[name]) return true;
	    } while (scope = scope.parent);

	    return false;
	  };

	  _proto.hasGlobal = function hasGlobal(name) {
	    var scope = this;

	    do {
	      if (scope.globals[name]) return true;
	    } while (scope = scope.parent);

	    return false;
	  };

	  _proto.hasReference = function hasReference(name) {
	    return !!this.getProgramParent().references[name];
	  };

	  _proto.isPure = function isPure(node, constantsOnly) {
	    if (isIdentifier$e(node)) {
	      var binding = this.getBinding(node.name);
	      if (!binding) return false;
	      if (constantsOnly) return binding.constant;
	      return true;
	    } else if (isClass(node)) {
	      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
	        return false;
	      }

	      return this.isPure(node.body, constantsOnly);
	    } else if (isClassBody(node)) {
	      for (var _iterator9 = _createForOfIteratorHelperLoose(node.body), _step9; !(_step9 = _iterator9()).done;) {
	        var method = _step9.value;
	        if (!this.isPure(method, constantsOnly)) return false;
	      }

	      return true;
	    } else if (isBinary$2(node)) {
	      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
	    } else if (isArrayExpression$1(node)) {
	      for (var _iterator10 = _createForOfIteratorHelperLoose(node.elements), _step10; !(_step10 = _iterator10()).done;) {
	        var elem = _step10.value;
	        if (!this.isPure(elem, constantsOnly)) return false;
	      }

	      return true;
	    } else if (isObjectExpression$2(node)) {
	      for (var _iterator11 = _createForOfIteratorHelperLoose(node.properties), _step11; !(_step11 = _iterator11()).done;) {
	        var prop = _step11.value;
	        if (!this.isPure(prop, constantsOnly)) return false;
	      }

	      return true;
	    } else if (isMethod(node)) {
	      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
	      if (node.kind === "get" || node.kind === "set") return false;
	      return true;
	    } else if (isProperty$1(node)) {
	      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
	      return this.isPure(node.value, constantsOnly);
	    } else if (isUnaryExpression(node)) {
	      return this.isPure(node.argument, constantsOnly);
	    } else if (isTaggedTemplateExpression$1(node)) {
	      return matchesPattern$1(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
	    } else if (isTemplateLiteral$1(node)) {
	      for (var _iterator12 = _createForOfIteratorHelperLoose(node.expressions), _step12; !(_step12 = _iterator12()).done;) {
	        var expression = _step12.value;
	        if (!this.isPure(expression, constantsOnly)) return false;
	      }

	      return true;
	    } else {
	      return isPureish$1(node);
	    }
	  };

	  _proto.setData = function setData(key, val) {
	    return this.data[key] = val;
	  };

	  _proto.getData = function getData(key) {
	    var scope = this;

	    do {
	      var data = scope.data[key];
	      if (data != null) return data;
	    } while (scope = scope.parent);
	  };

	  _proto.removeData = function removeData(key) {
	    var scope = this;

	    do {
	      var data = scope.data[key];
	      if (data != null) scope.data[key] = null;
	    } while (scope = scope.parent);
	  };

	  _proto.init = function init() {
	    if (!this.inited) {
	      this.inited = true;
	      this.crawl();
	    }
	  };

	  _proto.crawl = function crawl() {
	    var path = this.path;
	    this.references = Object.create(null);
	    this.bindings = Object.create(null);
	    this.globals = Object.create(null);
	    this.uids = Object.create(null);
	    this.data = Object.create(null);
	    var programParent = this.getProgramParent();
	    if (programParent.crawling) return;
	    var state = {
	      references: [],
	      constantViolations: [],
	      assignments: []
	    };
	    this.crawling = true;

	    if (path.type !== "Program" && collectorVisitor._exploded) {
	      for (var _iterator13 = _createForOfIteratorHelperLoose(collectorVisitor.enter), _step13; !(_step13 = _iterator13()).done;) {
	        var _visit = _step13.value;

	        _visit(path, state);
	      }

	      var typeVisitors = collectorVisitor[path.type];

	      if (typeVisitors) {
	        for (var _iterator14 = _createForOfIteratorHelperLoose(typeVisitors.enter), _step14; !(_step14 = _iterator14()).done;) {
	          var visit = _step14.value;
	          visit(path, state);
	        }
	      }
	    }

	    path.traverse(collectorVisitor, state);
	    this.crawling = false;

	    for (var _iterator15 = _createForOfIteratorHelperLoose(state.assignments), _step15; !(_step15 = _iterator15()).done;) {
	      var _path = _step15.value;

	      var ids = _path.getBindingIdentifiers();

	      for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
	        var _name6 = _Object$keys5[_i5];
	        if (_path.scope.getBinding(_name6)) continue;
	        programParent.addGlobal(ids[_name6]);
	      }

	      _path.scope.registerConstantViolation(_path);
	    }

	    for (var _iterator16 = _createForOfIteratorHelperLoose(state.references), _step16; !(_step16 = _iterator16()).done;) {
	      var ref = _step16.value;
	      var binding = ref.scope.getBinding(ref.node.name);

	      if (binding) {
	        binding.reference(ref);
	      } else {
	        programParent.addGlobal(ref.node);
	      }
	    }

	    for (var _iterator17 = _createForOfIteratorHelperLoose(state.constantViolations), _step17; !(_step17 = _iterator17()).done;) {
	      var _path2 = _step17.value;

	      _path2.scope.registerConstantViolation(_path2);
	    }
	  };

	  _proto.push = function push(opts) {
	    var path = this.path;

	    if (!path.isBlockStatement() && !path.isProgram()) {
	      path = this.getBlockParent().path;
	    }

	    if (path.isSwitchStatement()) {
	      path = (this.getFunctionParent() || this.getProgramParent()).path;
	    }

	    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
	      path.ensureBlock();
	      path = path.get("body");
	    }

	    var unique = opts.unique;
	    var kind = opts.kind || "var";
	    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
	    var dataKey = "declaration:" + kind + ":" + blockHoist;
	    var declarPath = !unique && path.getData(dataKey);

	    if (!declarPath) {
	      var declar = variableDeclaration$6(kind, []);
	      declar._blockHoist = blockHoist;

	      var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

	      var _path$unshiftContaine2 = _slicedToArray$1(_path$unshiftContaine, 1);

	      declarPath = _path$unshiftContaine2[0];
	      if (!unique) path.setData(dataKey, declarPath);
	    }

	    var declarator = variableDeclarator$6(opts.id, opts.init);
	    declarPath.node.declarations.push(declarator);
	    this.registerBinding(kind, declarPath.get("declarations").pop());
	  };

	  _proto.getProgramParent = function getProgramParent() {
	    var scope = this;

	    do {
	      if (scope.path.isProgram()) {
	        return scope;
	      }
	    } while (scope = scope.parent);

	    throw new Error("Couldn't find a Program");
	  };

	  _proto.getFunctionParent = function getFunctionParent() {
	    var scope = this;

	    do {
	      if (scope.path.isFunctionParent()) {
	        return scope;
	      }
	    } while (scope = scope.parent);

	    return null;
	  };

	  _proto.getBlockParent = function getBlockParent() {
	    var scope = this;

	    do {
	      if (scope.path.isBlockParent()) {
	        return scope;
	      }
	    } while (scope = scope.parent);

	    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
	  };

	  _proto.getAllBindings = function getAllBindings() {
	    var ids = Object.create(null);
	    var scope = this;

	    do {
	      for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
	        var key = _Object$keys6[_i6];

	        if (key in ids === false) {
	          ids[key] = scope.bindings[key];
	        }
	      }

	      scope = scope.parent;
	    } while (scope);

	    return ids;
	  };

	  _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
	    var ids = Object.create(null);

	    for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
	      kinds[_key] = arguments[_key];
	    }

	    for (var _i7 = 0, _kinds = kinds; _i7 < _kinds.length; _i7++) {
	      var kind = _kinds[_i7];
	      var scope = this;

	      do {
	        for (var _i8 = 0, _Object$keys7 = Object.keys(scope.bindings); _i8 < _Object$keys7.length; _i8++) {
	          var _name7 = _Object$keys7[_i8];
	          var binding = scope.bindings[_name7];
	          if (binding.kind === kind) ids[_name7] = binding;
	        }

	        scope = scope.parent;
	      } while (scope);
	    }

	    return ids;
	  };

	  _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
	    return this.getBindingIdentifier(name) === node;
	  };

	  _proto.getBinding = function getBinding(name) {
	    var scope = this;
	    var previousPath;

	    do {
	      var binding = scope.getOwnBinding(name);

	      if (binding) {
	        var _previousPath;

	        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") ; else {
	          return binding;
	        }
	      } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
	        break;
	      }

	      previousPath = scope.path;
	    } while (scope = scope.parent);
	  };

	  _proto.getOwnBinding = function getOwnBinding(name) {
	    return this.bindings[name];
	  };

	  _proto.getBindingIdentifier = function getBindingIdentifier(name) {
	    var _this$getBinding;

	    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
	  };

	  _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
	    var binding = this.bindings[name];
	    return binding == null ? void 0 : binding.identifier;
	  };

	  _proto.hasOwnBinding = function hasOwnBinding(name) {
	    return !!this.getOwnBinding(name);
	  };

	  _proto.hasBinding = function hasBinding(name, noGlobals) {
	    if (!name) return false;
	    if (this.hasOwnBinding(name)) return true;
	    if (this.parentHasBinding(name, noGlobals)) return true;
	    if (this.hasUid(name)) return true;
	    if (!noGlobals && Scope.globals.includes(name)) return true;
	    if (!noGlobals && Scope.contextVariables.includes(name)) return true;
	    return false;
	  };

	  _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {
	    var _this$parent;

	    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
	  };

	  _proto.moveBindingTo = function moveBindingTo(name, scope) {
	    var info = this.getBinding(name);

	    if (info) {
	      info.scope.removeOwnBinding(name);
	      info.scope = scope;
	      scope.bindings[name] = info;
	    }
	  };

	  _proto.removeOwnBinding = function removeOwnBinding(name) {
	    delete this.bindings[name];
	  };

	  _proto.removeBinding = function removeBinding(name) {
	    var _this$getBinding2;

	    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
	    var scope = this;

	    do {
	      if (scope.uids[name]) {
	        scope.uids[name] = false;
	      }
	    } while (scope = scope.parent);
	  };

	  _createClass(Scope, [{
	    key: "parent",
	    get: function get() {
	      var _parent;

	      var parent,
	          path = this.path;

	      do {
	        var isKey = path.key === "key";
	        path = path.parentPath;
	        if (isKey && path.isMethod()) path = path.parentPath;
	        if (path && path.isScope()) parent = path;
	      } while (path && !parent);

	      return (_parent = parent) == null ? void 0 : _parent.scope;
	    }
	  }, {
	    key: "parentBlock",
	    get: function get() {
	      return this.path.parent;
	    }
	  }, {
	    key: "hub",
	    get: function get() {
	      return this.path.hub;
	    }
	  }]);

	  return Scope;
	}();

	Scope$1.globals = Object.keys(globals.builtin);
	Scope$1.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	var encode$1 = function encode(number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }

	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	var decode$1 = function decode(charCode) {
	  var bigA = 65;
	  var bigZ = 90;
	  var littleA = 97;
	  var littleZ = 122;
	  var zero = 48;
	  var nine = 57;
	  var plus = 43;
	  var slash = 47;
	  var littleOffset = 26;
	  var numberOffset = 52;

	  if (bigA <= charCode && charCode <= bigZ) {
	    return charCode - bigA;
	  }

	  if (littleA <= charCode && charCode <= littleZ) {
	    return charCode - littleA + littleOffset;
	  }

	  if (zero <= charCode && charCode <= nine) {
	    return charCode - zero + numberOffset;
	  }

	  if (charCode == plus) {
	    return 62;
	  }

	  if (charCode == slash) {
	    return 63;
	  }

	  return -1;
	};

	var base64 = {
	  encode: encode$1,
	  decode: decode$1
	};

	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	function toVLQSigned(aValue) {
	  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}

	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative ? -shifted : shifted;
	}

	var encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;

	    if (vlq > 0) {
	      digit |= VLQ_CONTINUATION_BIT;
	    }

	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));

	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
	  encode: encode,
	  decode: decode
	};

	var util$5 = createCommonjsModule(function (module, exports) {
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }

	  exports.getArg = getArg;
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;

	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);

	    if (!match) {
	      return null;
	    }

	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }

	  exports.urlParse = urlParse;

	  function urlGenerate(aParsedUrl) {
	    var url = '';

	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }

	    url += '//';

	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }

	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }

	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port;
	    }

	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }

	    return url;
	  }

	  exports.urlGenerate = urlGenerate;

	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);

	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }

	      path = url.path;
	    }

	    var isAbsolute = exports.isAbsolute(path);
	    var parts = path.split(/\/+/);

	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];

	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }

	    path = parts.join('/');

	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }

	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }

	    return path;
	  }

	  exports.normalize = normalize;

	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }

	    if (aPath === "") {
	      aPath = ".";
	    }

	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);

	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }

	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }

	      return urlGenerate(aPathUrl);
	    }

	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }

	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }

	    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }

	    return joined;
	  }

	  exports.join = join;

	  exports.isAbsolute = function (aPath) {
	    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	  };

	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }

	    aRoot = aRoot.replace(/\/$/, '');
	    var level = 0;

	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");

	      if (index < 0) {
	        return aPath;
	      }

	      aRoot = aRoot.slice(0, index);

	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }

	      ++level;
	    }

	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }

	  exports.relative = relative;

	  var supportsNullProto = function () {
	    var obj = Object.create(null);
	    return !('__proto__' in obj);
	  }();

	  function identity(s) {
	    return s;
	  }

	  function toSetString(aStr) {
	    if (isProtoString(aStr)) {
	      return '$' + aStr;
	    }

	    return aStr;
	  }

	  exports.toSetString = supportsNullProto ? identity : toSetString;

	  function fromSetString(aStr) {
	    if (isProtoString(aStr)) {
	      return aStr.slice(1);
	    }

	    return aStr;
	  }

	  exports.fromSetString = supportsNullProto ? identity : fromSetString;

	  function isProtoString(s) {
	    if (!s) {
	      return false;
	    }

	    var length = s.length;

	    if (length < 9) {
	      return false;
	    }

	    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
	      return false;
	    }

	    for (var i = length - 10; i >= 0; i--) {
	      if (s.charCodeAt(i) !== 36) {
	        return false;
	      }
	    }

	    return true;
	  }

	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return mappingA.name - mappingB.name;
	  }

	  exports.compareByOriginalPositions = compareByOriginalPositions;

	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }

	    cmp = mappingA.source - mappingB.source;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return mappingA.name - mappingB.name;
	  }

	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }

	    if (aStr1 > aStr2) {
	      return 1;
	    }

	    return -1;
	  }

	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = strcmp(mappingA.source, mappingB.source);

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;

	    if (cmp !== 0) {
	      return cmp;
	    }

	    return strcmp(mappingA.name, mappingB.name);
	  }

	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	}, "/$$rollup_base$$/node_modules/source-map/lib");

	var has$b = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	function ArraySet$2() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet$2();

	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }

	  return set;
	};

	ArraySet$2.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util$5.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has$b.call(this._set, sStr);
	  var idx = this._array.length;

	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }

	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	ArraySet$2.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util$5.toSetString(aStr);
	    return has$b.call(this._set, sStr);
	  }
	};

	ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);

	    if (idx >= 0) {
	      return idx;
	    }
	  } else {
	    var sStr = util$5.toSetString(aStr);

	    if (has$b.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }

	  throw new Error('No element indexed by ' + aIdx);
	};

	ArraySet$2.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet$2;
	var arraySet = {
	  ArraySet: ArraySet_1
	};

	function generatedPositionAfter(mappingA, mappingB) {
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA || util$5.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	function MappingList$1() {
	  this._array = [];
	  this._sorted = true;
	  this._last = {
	    generatedLine: -1,
	    generatedColumn: 0
	  };
	}

	MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
	  this._array.forEach(aCallback, aThisArg);
	};

	MappingList$1.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;

	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;

	    this._array.push(aMapping);
	  }
	};

	MappingList$1.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util$5.compareByGeneratedPositionsInflated);

	    this._sorted = true;
	  }

	  return this._array;
	};

	var MappingList_1 = MappingList$1;
	var mappingList = {
	  MappingList: MappingList_1
	};

	var ArraySet$1 = arraySet.ArraySet;
	var MappingList = mappingList.MappingList;

	function SourceMapGenerator$2(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }

	  this._file = util$5.getArg(aArgs, 'file', null);
	  this._sourceRoot = util$5.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util$5.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator$2.prototype._version = 3;

	SourceMapGenerator$2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	  var sourceRoot = aSourceMapConsumer.sourceRoot;
	  var generator = new SourceMapGenerator$2({
	    file: aSourceMapConsumer.file,
	    sourceRoot: sourceRoot
	  });
	  aSourceMapConsumer.eachMapping(function (mapping) {
	    var newMapping = {
	      generated: {
	        line: mapping.generatedLine,
	        column: mapping.generatedColumn
	      }
	    };

	    if (mapping.source != null) {
	      newMapping.source = mapping.source;

	      if (sourceRoot != null) {
	        newMapping.source = util$5.relative(sourceRoot, newMapping.source);
	      }

	      newMapping.original = {
	        line: mapping.originalLine,
	        column: mapping.originalColumn
	      };

	      if (mapping.name != null) {
	        newMapping.name = mapping.name;
	      }
	    }

	    generator.addMapping(newMapping);
	  });
	  aSourceMapConsumer.sources.forEach(function (sourceFile) {
	    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

	    if (content != null) {
	      generator.setSourceContent(sourceFile, content);
	    }
	  });
	  return generator;
	};

	SourceMapGenerator$2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
	  var generated = util$5.getArg(aArgs, 'generated');
	  var original = util$5.getArg(aArgs, 'original', null);
	  var source = util$5.getArg(aArgs, 'source', null);
	  var name = util$5.getArg(aArgs, 'name', null);

	  if (!this._skipValidation) {
	    this._validateMapping(generated, original, source, name);
	  }

	  if (source != null) {
	    source = String(source);

	    if (!this._sources.has(source)) {
	      this._sources.add(source);
	    }
	  }

	  if (name != null) {
	    name = String(name);

	    if (!this._names.has(name)) {
	      this._names.add(name);
	    }
	  }

	  this._mappings.add({
	    generatedLine: generated.line,
	    generatedColumn: generated.column,
	    originalLine: original != null && original.line,
	    originalColumn: original != null && original.column,
	    source: source,
	    name: name
	  });
	};

	SourceMapGenerator$2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	  var source = aSourceFile;

	  if (this._sourceRoot != null) {
	    source = util$5.relative(this._sourceRoot, source);
	  }

	  if (aSourceContent != null) {
	    if (!this._sourcesContents) {
	      this._sourcesContents = Object.create(null);
	    }

	    this._sourcesContents[util$5.toSetString(source)] = aSourceContent;
	  } else if (this._sourcesContents) {
	    delete this._sourcesContents[util$5.toSetString(source)];

	    if (Object.keys(this._sourcesContents).length === 0) {
	      this._sourcesContents = null;
	    }
	  }
	};

	SourceMapGenerator$2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	  var sourceFile = aSourceFile;

	  if (aSourceFile == null) {
	    if (aSourceMapConsumer.file == null) {
	      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
	    }

	    sourceFile = aSourceMapConsumer.file;
	  }

	  var sourceRoot = this._sourceRoot;

	  if (sourceRoot != null) {
	    sourceFile = util$5.relative(sourceRoot, sourceFile);
	  }

	  var newSources = new ArraySet$1();
	  var newNames = new ArraySet$1();

	  this._mappings.unsortedForEach(function (mapping) {
	    if (mapping.source === sourceFile && mapping.originalLine != null) {
	      var original = aSourceMapConsumer.originalPositionFor({
	        line: mapping.originalLine,
	        column: mapping.originalColumn
	      });

	      if (original.source != null) {
	        mapping.source = original.source;

	        if (aSourceMapPath != null) {
	          mapping.source = util$5.join(aSourceMapPath, mapping.source);
	        }

	        if (sourceRoot != null) {
	          mapping.source = util$5.relative(sourceRoot, mapping.source);
	        }

	        mapping.originalLine = original.line;
	        mapping.originalColumn = original.column;

	        if (original.name != null) {
	          mapping.name = original.name;
	        }
	      }
	    }

	    var source = mapping.source;

	    if (source != null && !newSources.has(source)) {
	      newSources.add(source);
	    }

	    var name = mapping.name;

	    if (name != null && !newNames.has(name)) {
	      newNames.add(name);
	    }
	  }, this);

	  this._sources = newSources;
	  this._names = newNames;
	  aSourceMapConsumer.sources.forEach(function (sourceFile) {
	    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

	    if (content != null) {
	      if (aSourceMapPath != null) {
	        sourceFile = util$5.join(aSourceMapPath, sourceFile);
	      }

	      if (sourceRoot != null) {
	        sourceFile = util$5.relative(sourceRoot, sourceFile);
	      }

	      this.setSourceContent(sourceFile, content);
	    }
	  }, this);
	};

	SourceMapGenerator$2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
	  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
	  }

	  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
	    return;
	  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
	    return;
	  } else {
	    throw new Error('Invalid mapping: ' + JSON.stringify({
	      generated: aGenerated,
	      source: aSource,
	      original: aOriginal,
	      name: aName
	    }));
	  }
	};

	SourceMapGenerator$2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
	  var previousGeneratedColumn = 0;
	  var previousGeneratedLine = 1;
	  var previousOriginalColumn = 0;
	  var previousOriginalLine = 0;
	  var previousName = 0;
	  var previousSource = 0;
	  var result = '';
	  var next;
	  var mapping;
	  var nameIdx;
	  var sourceIdx;

	  var mappings = this._mappings.toArray();

	  for (var i = 0, len = mappings.length; i < len; i++) {
	    mapping = mappings[i];
	    next = '';

	    if (mapping.generatedLine !== previousGeneratedLine) {
	      previousGeneratedColumn = 0;

	      while (mapping.generatedLine !== previousGeneratedLine) {
	        next += ';';
	        previousGeneratedLine++;
	      }
	    } else {
	      if (i > 0) {
	        if (!util$5.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	          continue;
	        }

	        next += ',';
	      }
	    }

	    next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
	    previousGeneratedColumn = mapping.generatedColumn;

	    if (mapping.source != null) {
	      sourceIdx = this._sources.indexOf(mapping.source);
	      next += base64Vlq.encode(sourceIdx - previousSource);
	      previousSource = sourceIdx;
	      next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
	      previousOriginalLine = mapping.originalLine - 1;
	      next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
	      previousOriginalColumn = mapping.originalColumn;

	      if (mapping.name != null) {
	        nameIdx = this._names.indexOf(mapping.name);
	        next += base64Vlq.encode(nameIdx - previousName);
	        previousName = nameIdx;
	      }
	    }

	    result += next;
	  }

	  return result;
	};

	SourceMapGenerator$2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	  return aSources.map(function (source) {
	    if (!this._sourcesContents) {
	      return null;
	    }

	    if (aSourceRoot != null) {
	      source = util$5.relative(aSourceRoot, source);
	    }

	    var key = util$5.toSetString(source);
	    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
	  }, this);
	};

	SourceMapGenerator$2.prototype.toJSON = function SourceMapGenerator_toJSON() {
	  var map = {
	    version: this._version,
	    sources: this._sources.toArray(),
	    names: this._names.toArray(),
	    mappings: this._serializeMappings()
	  };

	  if (this._file != null) {
	    map.file = this._file;
	  }

	  if (this._sourceRoot != null) {
	    map.sourceRoot = this._sourceRoot;
	  }

	  if (this._sourcesContents) {
	    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	  }

	  return map;
	};

	SourceMapGenerator$2.prototype.toString = function SourceMapGenerator_toString() {
	  return JSON.stringify(this.toJSON());
	};

	var SourceMapGenerator_1 = SourceMapGenerator$2;
	var sourceMapGenerator = {
	  SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;

	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);

	    if (cmp === 0) {
	      return mid;
	    } else if (cmp > 0) {
	      if (aHigh - mid > 1) {
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }

	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    } else {
	      if (mid - aLow > 1) {
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }

	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }

	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }

	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

	    if (index < 0) {
	      return -1;
	    }

	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }

	      --index;
	    }

	    return index;
	  };
	}, "/$$rollup_base$$/node_modules/source-map/lib");

	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	function randomIntInRange(low, high) {
	  return Math.round(low + Math.random() * (high - low));
	}

	function doQuickSort(ary, comparator, p, r) {
	  if (p < r) {
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	var quickSort_1 = function quickSort_1(ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort$1 = {
	  quickSort: quickSort_1
	};

	var ArraySet = arraySet.ArraySet;
	var quickSort = quickSort$1.quickSort;

	function SourceMapConsumer$1(aSourceMap) {
	  var sourceMap = aSourceMap;

	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer$1.fromSourceMap = function (aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	SourceMapConsumer$1.prototype._version = 3;
	SourceMapConsumer$1.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
	  get: function get() {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});
	SourceMapConsumer$1.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
	  get: function get() {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	  var c = aStr.charAt(index);
	  return c === ";" || c === ",";
	};

	SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	  throw new Error("Subclasses must implement _parseMappings");
	};

	SourceMapConsumer$1.GENERATED_ORDER = 1;
	SourceMapConsumer$1.ORIGINAL_ORDER = 2;
	SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

	SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	  var context = aContext || null;
	  var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
	  var mappings;

	  switch (order) {
	    case SourceMapConsumer$1.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;

	    case SourceMapConsumer$1.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;

	    default:
	      throw new Error("Unknown order of iteration.");
	  }

	  var sourceRoot = this.sourceRoot;
	  mappings.map(function (mapping) {
	    var source = mapping.source === null ? null : this._sources.at(mapping.source);

	    if (source != null && sourceRoot != null) {
	      source = util$5.join(sourceRoot, source);
	    }

	    return {
	      source: source,
	      generatedLine: mapping.generatedLine,
	      generatedColumn: mapping.generatedColumn,
	      originalLine: mapping.originalLine,
	      originalColumn: mapping.originalColumn,
	      name: mapping.name === null ? null : this._names.at(mapping.name)
	    };
	  }, this).forEach(aCallback, context);
	};

	SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	  var line = util$5.getArg(aArgs, 'line');
	  var needle = {
	    source: util$5.getArg(aArgs, 'source'),
	    originalLine: line,
	    originalColumn: util$5.getArg(aArgs, 'column', 0)
	  };

	  if (this.sourceRoot != null) {
	    needle.source = util$5.relative(this.sourceRoot, needle.source);
	  }

	  if (!this._sources.has(needle.source)) {
	    return [];
	  }

	  needle.source = this._sources.indexOf(needle.source);
	  var mappings = [];

	  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$5.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

	  if (index >= 0) {
	    var mapping = this._originalMappings[index];

	    if (aArgs.column === undefined) {
	      var originalLine = mapping.originalLine;

	      while (mapping && mapping.originalLine === originalLine) {
	        mappings.push({
	          line: util$5.getArg(mapping, 'generatedLine', null),
	          column: util$5.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util$5.getArg(mapping, 'lastGeneratedColumn', null)
	        });
	        mapping = this._originalMappings[++index];
	      }
	    } else {
	      var originalColumn = mapping.originalColumn;

	      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
	        mappings.push({
	          line: util$5.getArg(mapping, 'generatedLine', null),
	          column: util$5.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util$5.getArg(mapping, 'lastGeneratedColumn', null)
	        });
	        mapping = this._originalMappings[++index];
	      }
	    }
	  }

	  return mappings;
	};

	var SourceMapConsumer_1 = SourceMapConsumer$1;

	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;

	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util$5.getArg(sourceMap, 'version');
	  var sources = util$5.getArg(sourceMap, 'sources');
	  var names = util$5.getArg(sourceMap, 'names', []);
	  var sourceRoot = util$5.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util$5.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util$5.getArg(sourceMap, 'mappings');
	  var file = util$5.getArg(sourceMap, 'file', null);

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources.map(String).map(util$5.normalize).map(function (source) {
	    return sourceRoot && util$5.isAbsolute(sourceRoot) && util$5.isAbsolute(source) ? util$5.relative(sourceRoot, source) : source;
	  });
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
	  var smc = Object.create(BasicSourceMapConsumer.prototype);
	  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	  smc.sourceRoot = aSourceMap._sourceRoot;
	  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
	  smc.file = aSourceMap._file;

	  var generatedMappings = aSourceMap._mappings.toArray().slice();

	  var destGeneratedMappings = smc.__generatedMappings = [];
	  var destOriginalMappings = smc.__originalMappings = [];

	  for (var i = 0, length = generatedMappings.length; i < length; i++) {
	    var srcMapping = generatedMappings[i];
	    var destMapping = new Mapping();
	    destMapping.generatedLine = srcMapping.generatedLine;
	    destMapping.generatedColumn = srcMapping.generatedColumn;

	    if (srcMapping.source) {
	      destMapping.source = sources.indexOf(srcMapping.source);
	      destMapping.originalLine = srcMapping.originalLine;
	      destMapping.originalColumn = srcMapping.originalColumn;

	      if (srcMapping.name) {
	        destMapping.name = names.indexOf(srcMapping.name);
	      }

	      destOriginalMappings.push(destMapping);
	    }

	    destGeneratedMappings.push(destMapping);
	  }

	  quickSort(smc.__originalMappings, util$5.compareByOriginalPositions);
	  return smc;
	};

	BasicSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function get() {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util$5.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	  var generatedLine = 1;
	  var previousGeneratedColumn = 0;
	  var previousOriginalLine = 0;
	  var previousOriginalColumn = 0;
	  var previousSource = 0;
	  var previousName = 0;
	  var length = aStr.length;
	  var index = 0;
	  var cachedSegments = {};
	  var temp = {};
	  var originalMappings = [];
	  var generatedMappings = [];
	  var mapping, str, segment, end, value;

	  while (index < length) {
	    if (aStr.charAt(index) === ';') {
	      generatedLine++;
	      index++;
	      previousGeneratedColumn = 0;
	    } else if (aStr.charAt(index) === ',') {
	      index++;
	    } else {
	      mapping = new Mapping();
	      mapping.generatedLine = generatedLine;

	      for (end = index; end < length; end++) {
	        if (this._charIsMappingSeparator(aStr, end)) {
	          break;
	        }
	      }

	      str = aStr.slice(index, end);
	      segment = cachedSegments[str];

	      if (segment) {
	        index += str.length;
	      } else {
	        segment = [];

	        while (index < end) {
	          base64Vlq.decode(aStr, index, temp);
	          value = temp.value;
	          index = temp.rest;
	          segment.push(value);
	        }

	        if (segment.length === 2) {
	          throw new Error('Found a source, but no line and column');
	        }

	        if (segment.length === 3) {
	          throw new Error('Found a source and line, but no column');
	        }

	        cachedSegments[str] = segment;
	      }

	      mapping.generatedColumn = previousGeneratedColumn + segment[0];
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (segment.length > 1) {
	        mapping.source = previousSource + segment[1];
	        previousSource += segment[1];
	        mapping.originalLine = previousOriginalLine + segment[2];
	        previousOriginalLine = mapping.originalLine;
	        mapping.originalLine += 1;
	        mapping.originalColumn = previousOriginalColumn + segment[3];
	        previousOriginalColumn = mapping.originalColumn;

	        if (segment.length > 4) {
	          mapping.name = previousName + segment[4];
	          previousName += segment[4];
	        }
	      }

	      generatedMappings.push(mapping);

	      if (typeof mapping.originalLine === 'number') {
	        originalMappings.push(mapping);
	      }
	    }
	  }

	  quickSort(generatedMappings, util$5.compareByGeneratedPositionsDeflated);
	  this.__generatedMappings = generatedMappings;
	  quickSort(originalMappings, util$5.compareByOriginalPositions);
	  this.__originalMappings = originalMappings;
	};

	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
	  if (aNeedle[aLineName] <= 0) {
	    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
	  }

	  if (aNeedle[aColumnName] < 0) {
	    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
	  }

	  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};

	BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
	  for (var index = 0; index < this._generatedMappings.length; ++index) {
	    var mapping = this._generatedMappings[index];

	    if (index + 1 < this._generatedMappings.length) {
	      var nextMapping = this._generatedMappings[index + 1];

	      if (mapping.generatedLine === nextMapping.generatedLine) {
	        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	        continue;
	      }
	    }

	    mapping.lastGeneratedColumn = Infinity;
	  }
	};

	BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
	  var needle = {
	    generatedLine: util$5.getArg(aArgs, 'line'),
	    generatedColumn: util$5.getArg(aArgs, 'column')
	  };

	  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$5.compareByGeneratedPositionsDeflated, util$5.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

	  if (index >= 0) {
	    var mapping = this._generatedMappings[index];

	    if (mapping.generatedLine === needle.generatedLine) {
	      var source = util$5.getArg(mapping, 'source', null);

	      if (source !== null) {
	        source = this._sources.at(source);

	        if (this.sourceRoot != null) {
	          source = util$5.join(this.sourceRoot, source);
	        }
	      }

	      var name = util$5.getArg(mapping, 'name', null);

	      if (name !== null) {
	        name = this._names.at(name);
	      }

	      return {
	        source: source,
	        line: util$5.getArg(mapping, 'originalLine', null),
	        column: util$5.getArg(mapping, 'originalColumn', null),
	        name: name
	      };
	    }
	  }

	  return {
	    source: null,
	    line: null,
	    column: null,
	    name: null
	  };
	};

	BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
	  if (!this.sourcesContent) {
	    return false;
	  }

	  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
	    return sc == null;
	  });
	};

	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	  if (!this.sourcesContent) {
	    return null;
	  }

	  if (this.sourceRoot != null) {
	    aSource = util$5.relative(this.sourceRoot, aSource);
	  }

	  if (this._sources.has(aSource)) {
	    return this.sourcesContent[this._sources.indexOf(aSource)];
	  }

	  var url;

	  if (this.sourceRoot != null && (url = util$5.urlParse(this.sourceRoot))) {
	    var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

	    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
	      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
	    }

	    if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
	      return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	    }
	  }

	  if (nullOnMissing) {
	    return null;
	  } else {
	    throw new Error('"' + aSource + '" is not in the SourceMap.');
	  }
	};

	BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
	  var source = util$5.getArg(aArgs, 'source');

	  if (this.sourceRoot != null) {
	    source = util$5.relative(this.sourceRoot, source);
	  }

	  if (!this._sources.has(source)) {
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  }

	  source = this._sources.indexOf(source);
	  var needle = {
	    source: source,
	    originalLine: util$5.getArg(aArgs, 'line'),
	    originalColumn: util$5.getArg(aArgs, 'column')
	  };

	  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$5.compareByOriginalPositions, util$5.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

	  if (index >= 0) {
	    var mapping = this._originalMappings[index];

	    if (mapping.source === needle.source) {
	      return {
	        line: util$5.getArg(mapping, 'generatedLine', null),
	        column: util$5.getArg(mapping, 'generatedColumn', null),
	        lastColumn: util$5.getArg(mapping, 'lastGeneratedColumn', null)
	      };
	    }
	  }

	  return {
	    line: null,
	    column: null,
	    lastColumn: null
	  };
	};

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;

	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util$5.getArg(sourceMap, 'version');
	  var sections = util$5.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      throw new Error('Support for url field in sections not implemented.');
	    }

	    var offset = util$5.getArg(s, 'offset');
	    var offsetLine = util$5.getArg(offset, 'line');
	    var offsetColumn = util$5.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }

	    lastOffset = offset;
	    return {
	      generatedOffset: {
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer$1(util$5.getArg(s, 'map'))
	    };
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
	IndexedSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function get() {
	    var sources = [];

	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }

	    return sources;
	  }
	});

	IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	  var needle = {
	    generatedLine: util$5.getArg(aArgs, 'line'),
	    generatedColumn: util$5.getArg(aArgs, 'column')
	  };
	  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
	    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

	    if (cmp) {
	      return cmp;
	    }

	    return needle.generatedColumn - section.generatedOffset.generatedColumn;
	  });
	  var section = this._sections[sectionIndex];

	  if (!section) {
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  }

	  return section.consumer.originalPositionFor({
	    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
	    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
	    bias: aArgs.bias
	  });
	};

	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	  return this._sections.every(function (s) {
	    return s.consumer.hasContentsOfAllSources();
	  });
	};

	IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	  for (var i = 0; i < this._sections.length; i++) {
	    var section = this._sections[i];
	    var content = section.consumer.sourceContentFor(aSource, true);

	    if (content) {
	      return content;
	    }
	  }

	  if (nullOnMissing) {
	    return null;
	  } else {
	    throw new Error('"' + aSource + '" is not in the SourceMap.');
	  }
	};

	IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	  for (var i = 0; i < this._sections.length; i++) {
	    var section = this._sections[i];

	    if (section.consumer.sources.indexOf(util$5.getArg(aArgs, 'source')) === -1) {
	      continue;
	    }

	    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

	    if (generatedPosition) {
	      var ret = {
	        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
	        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
	      };
	      return ret;
	    }
	  }

	  return {
	    line: null,
	    column: null
	  };
	};

	IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	  this.__generatedMappings = [];
	  this.__originalMappings = [];

	  for (var i = 0; i < this._sections.length; i++) {
	    var section = this._sections[i];
	    var sectionMappings = section.consumer._generatedMappings;

	    for (var j = 0; j < sectionMappings.length; j++) {
	      var mapping = sectionMappings[j];

	      var source = section.consumer._sources.at(mapping.source);

	      if (section.consumer.sourceRoot !== null) {
	        source = util$5.join(section.consumer.sourceRoot, source);
	      }

	      this._sources.add(source);

	      source = this._sources.indexOf(source);

	      var name = section.consumer._names.at(mapping.name);

	      this._names.add(name);

	      name = this._names.indexOf(name);
	      var adjustedMapping = {
	        source: source,
	        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
	        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: name
	      };

	      this.__generatedMappings.push(adjustedMapping);

	      if (typeof adjustedMapping.originalLine === 'number') {
	        this.__originalMappings.push(adjustedMapping);
	      }
	    }
	  }

	  quickSort(this.__generatedMappings, util$5.compareByGeneratedPositionsDeflated);
	  quickSort(this.__originalMappings, util$5.compareByOriginalPositions);
	};

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
	var sourceMapConsumer = {
	  SourceMapConsumer: SourceMapConsumer_1,
	  BasicSourceMapConsumer: BasicSourceMapConsumer_1,
	  IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";

	function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	  var node = new SourceNode$1();
	  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	  var remainingLinesIndex = 0;

	  var shiftNextLine = function shiftNextLine() {
	    var lineContents = getNextLine();
	    var newLine = getNextLine() || "";
	    return lineContents + newLine;

	    function getNextLine() {
	      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
	    }
	  };

	  var lastGeneratedLine = 1,
	      lastGeneratedColumn = 0;
	  var lastMapping = null;
	  aSourceMapConsumer.eachMapping(function (mapping) {
	    if (lastMapping !== null) {
	      if (lastGeneratedLine < mapping.generatedLine) {
	        addMappingWithCode(lastMapping, shiftNextLine());
	        lastGeneratedLine++;
	        lastGeneratedColumn = 0;
	      } else {
	        var nextLine = remainingLines[remainingLinesIndex];
	        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	        addMappingWithCode(lastMapping, code);
	        lastMapping = mapping;
	        return;
	      }
	    }

	    while (lastGeneratedLine < mapping.generatedLine) {
	      node.add(shiftNextLine());
	      lastGeneratedLine++;
	    }

	    if (lastGeneratedColumn < mapping.generatedColumn) {
	      var nextLine = remainingLines[remainingLinesIndex];
	      node.add(nextLine.substr(0, mapping.generatedColumn));
	      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	      lastGeneratedColumn = mapping.generatedColumn;
	    }

	    lastMapping = mapping;
	  }, this);

	  if (remainingLinesIndex < remainingLines.length) {
	    if (lastMapping) {
	      addMappingWithCode(lastMapping, shiftNextLine());
	    }

	    node.add(remainingLines.splice(remainingLinesIndex).join(""));
	  }

	  aSourceMapConsumer.sources.forEach(function (sourceFile) {
	    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

	    if (content != null) {
	      if (aRelativePath != null) {
	        sourceFile = util$5.join(aRelativePath, sourceFile);
	      }

	      node.setSourceContent(sourceFile, content);
	    }
	  });
	  return node;

	  function addMappingWithCode(mapping, code) {
	    if (mapping === null || mapping.source === undefined) {
	      node.add(code);
	    } else {
	      var source = aRelativePath ? util$5.join(aRelativePath, mapping.source) : mapping.source;
	      node.add(new SourceNode$1(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
	    }
	  }
	};

	SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  } else {
	    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
	  }

	  return this;
	};

	SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length - 1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  } else {
	    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
	  }

	  return this;
	};

	SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;

	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];

	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    } else {
	      if (chunk !== '') {
	        aFn(chunk, {
	          source: this.source,
	          line: this.line,
	          column: this.column,
	          name: this.name
	        });
	      }
	    }
	  }
	};

	SourceNode$1.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;

	  if (len > 0) {
	    newChildren = [];

	    for (i = 0; i < len - 1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }

	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }

	  return this;
	};

	SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];

	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  } else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  } else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }

	  return this;
	};

	SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	  this.sourceContents[util$5.toSetString(aSourceFile)] = aSourceContent;
	};

	SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    if (this.children[i][isSourceNode]) {
	      this.children[i].walkSourceContents(aFn);
	    }
	  }

	  var sources = Object.keys(this.sourceContents);

	  for (var i = 0, len = sources.length; i < len; i++) {
	    aFn(util$5.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	  }
	};

	SourceNode$1.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;

	    if (original.source !== null && original.line !== null && original.column !== null) {
	      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }

	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }

	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;

	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });
	  return {
	    code: generated.code,
	    map: map
	  };
	};

	var SourceNode_1 = SourceNode$1;
	var sourceNode = {
	  SourceNode: SourceNode_1
	};

	var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
	var SourceNode = sourceNode.SourceNode;
	var sourceMap = {
	  SourceMapGenerator: SourceMapGenerator,
	  SourceMapConsumer: SourceMapConsumer,
	  SourceNode: SourceNode
	};

	var SourceMap = function () {
	  function SourceMap(opts, code) {
	    this._cachedMap = void 0;
	    this._code = void 0;
	    this._opts = void 0;
	    this._rawMappings = void 0;
	    this._lastGenLine = void 0;
	    this._lastSourceLine = void 0;
	    this._lastSourceColumn = void 0;
	    this._cachedMap = null;
	    this._code = code;
	    this._opts = opts;
	    this._rawMappings = [];
	  }

	  var _proto = SourceMap.prototype;

	  _proto.get = function get() {
	    if (!this._cachedMap) {
	      var map = this._cachedMap = new sourceMap.SourceMapGenerator({
	        sourceRoot: this._opts.sourceRoot
	      });
	      var code = this._code;

	      if (typeof code === "string") {
	        map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
	      } else if (typeof code === "object") {
	        Object.keys(code).forEach(function (sourceFileName) {
	          map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
	        });
	      }

	      this._rawMappings.forEach(function (mapping) {
	        return map.addMapping(mapping);
	      }, map);
	    }

	    return this._cachedMap.toJSON();
	  };

	  _proto.getRawMappings = function getRawMappings() {
	    return this._rawMappings.slice();
	  };

	  _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
	    if (this._lastGenLine !== generatedLine && line === null) return;

	    if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
	      return;
	    }

	    this._cachedMap = null;
	    this._lastGenLine = generatedLine;
	    this._lastSourceLine = line;
	    this._lastSourceColumn = column;

	    this._rawMappings.push({
	      name: identifierName || undefined,
	      generated: {
	        line: generatedLine,
	        column: generatedColumn
	      },
	      source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
	      original: line == null ? undefined : {
	        line: line,
	        column: column
	      }
	    });
	  };

	  return SourceMap;
	}();

	var SPACES_RE = /^[ \t]+$/;

	var Buffer = function () {
	  function Buffer(map) {
	    this._map = null;
	    this._buf = "";
	    this._last = 0;
	    this._queue = [];
	    this._position = {
	      line: 1,
	      column: 0
	    };
	    this._sourcePosition = {
	      identifierName: null,
	      line: null,
	      column: null,
	      filename: null
	    };
	    this._disallowedPop = null;
	    this._map = map;
	  }

	  var _proto = Buffer.prototype;

	  _proto.get = function get() {
	    this._flush();

	    var map = this._map;
	    var result = {
	      code: this._buf.trimRight(),
	      map: null,
	      rawMappings: map == null ? void 0 : map.getRawMappings()
	    };

	    if (map) {
	      Object.defineProperty(result, "map", {
	        configurable: true,
	        enumerable: true,
	        get: function get() {
	          return this.map = map.get();
	        },
	        set: function set(value) {
	          Object.defineProperty(this, "map", {
	            value: value,
	            writable: true
	          });
	        }
	      });
	    }

	    return result;
	  };

	  _proto.append = function append(str) {
	    this._flush();

	    var _this$_sourcePosition = this._sourcePosition,
	        line = _this$_sourcePosition.line,
	        column = _this$_sourcePosition.column,
	        filename = _this$_sourcePosition.filename,
	        identifierName = _this$_sourcePosition.identifierName,
	        force = _this$_sourcePosition.force;

	    this._append(str, line, column, identifierName, filename, force);
	  };

	  _proto.queue = function queue(str) {
	    if (str === "\n") {
	      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
	        this._queue.shift();
	      }
	    }

	    var _this$_sourcePosition2 = this._sourcePosition,
	        line = _this$_sourcePosition2.line,
	        column = _this$_sourcePosition2.column,
	        filename = _this$_sourcePosition2.filename,
	        identifierName = _this$_sourcePosition2.identifierName,
	        force = _this$_sourcePosition2.force;

	    this._queue.unshift([str, line, column, identifierName, filename, force]);
	  };

	  _proto._flush = function _flush() {
	    var item;

	    while (item = this._queue.pop()) {
	      this._append.apply(this, _toConsumableArray(item));
	    }
	  };

	  _proto._append = function _append(str, line, column, identifierName, filename, force) {
	    this._buf += str;
	    this._last = str.charCodeAt(str.length - 1);
	    var i = str.indexOf("\n");
	    var last = 0;

	    if (i !== 0) {
	      this._mark(line, column, identifierName, filename, force);
	    }

	    while (i !== -1) {
	      this._position.line++;
	      this._position.column = 0;
	      last = i + 1;

	      if (last < str.length) {
	        this._mark(++line, 0, identifierName, filename, force);
	      }

	      i = str.indexOf("\n", last);
	    }

	    this._position.column += str.length - last;
	  };

	  _proto._mark = function _mark(line, column, identifierName, filename, force) {
	    var _this$_map;

	    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
	  };

	  _proto.removeTrailingNewline = function removeTrailingNewline() {
	    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
	      this._queue.shift();
	    }
	  };

	  _proto.removeLastSemicolon = function removeLastSemicolon() {
	    if (this._queue.length > 0 && this._queue[0][0] === ";") {
	      this._queue.shift();
	    }
	  };

	  _proto.getLastChar = function getLastChar() {
	    var last;

	    if (this._queue.length > 0) {
	      var _str = this._queue[0][0];
	      last = _str.charCodeAt(0);
	    } else {
	      last = this._last;
	    }

	    return last;
	  };

	  _proto.endsWithCharAndNewline = function endsWithCharAndNewline() {
	    var queue = this._queue;

	    if (queue.length > 0) {
	      var last = queue[0][0];
	      var lastCp = last.charCodeAt(0);
	      if (lastCp !== 10) return;

	      if (queue.length > 1) {
	        var secondLast = queue[1][0];
	        return secondLast.charCodeAt(0);
	      } else {
	        return this._last;
	      }
	    }
	  };

	  _proto.hasContent = function hasContent() {
	    return this._queue.length > 0 || !!this._last;
	  };

	  _proto.exactSource = function exactSource(loc, cb) {
	    this.source("start", loc, true);
	    cb();
	    this.source("end", loc);

	    this._disallowPop("start", loc);
	  };

	  _proto.source = function source(prop, loc, force) {
	    if (prop && !loc) return;

	    this._normalizePosition(prop, loc, this._sourcePosition, force);
	  };

	  _proto.withSource = function withSource(prop, loc, cb) {
	    if (!this._map) return cb();
	    var originalLine = this._sourcePosition.line;
	    var originalColumn = this._sourcePosition.column;
	    var originalFilename = this._sourcePosition.filename;
	    var originalIdentifierName = this._sourcePosition.identifierName;
	    this.source(prop, loc);
	    cb();

	    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
	      this._sourcePosition.line = originalLine;
	      this._sourcePosition.column = originalColumn;
	      this._sourcePosition.filename = originalFilename;
	      this._sourcePosition.identifierName = originalIdentifierName;
	      this._sourcePosition.force = false;
	      this._disallowedPop = null;
	    }
	  };

	  _proto._disallowPop = function _disallowPop(prop, loc) {
	    if (prop && !loc) return;
	    this._disallowedPop = this._normalizePosition(prop, loc);
	  };

	  _proto._normalizePosition = function _normalizePosition(prop, loc, targetObj, force) {
	    var pos = loc ? loc[prop] : null;

	    if (targetObj === undefined) {
	      targetObj = {
	        identifierName: null,
	        line: null,
	        column: null,
	        filename: null,
	        force: false
	      };
	    }

	    var origLine = targetObj.line;
	    var origColumn = targetObj.column;
	    var origFilename = targetObj.filename;
	    targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;
	    targetObj.line = pos == null ? void 0 : pos.line;
	    targetObj.column = pos == null ? void 0 : pos.column;
	    targetObj.filename = loc == null ? void 0 : loc.filename;

	    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
	      targetObj.force = force;
	    }

	    return targetObj;
	  };

	  _proto.getCurrentColumn = function getCurrentColumn() {
	    var extra = this._queue.reduce(function (acc, item) {
	      return item[0] + acc;
	    }, "");

	    var lastIndex = extra.lastIndexOf("\n");
	    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
	  };

	  _proto.getCurrentLine = function getCurrentLine() {
	    var extra = this._queue.reduce(function (acc, item) {
	      return item[0] + acc;
	    }, "");

	    var count = 0;

	    for (var i = 0; i < extra.length; i++) {
	      if (extra[i] === "\n") count++;
	    }

	    return this._position.line + count;
	  };

	  return Buffer;
	}();

	var FLIPPED_ALIAS_KEYS$2 = FLIPPED_ALIAS_KEYS$3,
	    isArrayExpression = isArrayExpression$2,
	    isAssignmentExpression$2 = isAssignmentExpression$3,
	    isBinary$1 = isBinary$3,
	    isBlockStatement$1 = isBlockStatement$2,
	    isCallExpression$5 = isCallExpression$6,
	    isFunction$3 = isFunction$4,
	    isIdentifier$d = isIdentifier$g,
	    isLiteral$5 = isLiteral$7,
	    isMemberExpression$6 = isMemberExpression$8,
	    isObjectExpression$1 = isObjectExpression$3,
	    isOptionalCallExpression$2 = isOptionalCallExpression$3,
	    isOptionalMemberExpression$2 = isOptionalMemberExpression$3,
	    isStringLiteral$6 = isStringLiteral$7;

	function crawl(node, state) {
	  if (state === void 0) {
	    state = {};
	  }

	  if (isMemberExpression$6(node) || isOptionalMemberExpression$2(node)) {
	    crawl(node.object, state);
	    if (node.computed) crawl(node.property, state);
	  } else if (isBinary$1(node) || isAssignmentExpression$2(node)) {
	    crawl(node.left, state);
	    crawl(node.right, state);
	  } else if (isCallExpression$5(node) || isOptionalCallExpression$2(node)) {
	    state.hasCall = true;
	    crawl(node.callee, state);
	  } else if (isFunction$3(node)) {
	    state.hasFunction = true;
	  } else if (isIdentifier$d(node)) {
	    state.hasHelper = state.hasHelper || isHelper(node.callee);
	  }

	  return state;
	}

	function isHelper(node) {
	  if (isMemberExpression$6(node)) {
	    return isHelper(node.object) || isHelper(node.property);
	  } else if (isIdentifier$d(node)) {
	    return node.name === "require" || node.name[0] === "_";
	  } else if (isCallExpression$5(node)) {
	    return isHelper(node.callee);
	  } else if (isBinary$1(node) || isAssignmentExpression$2(node)) {
	    return isIdentifier$d(node.left) && isHelper(node.left) || isHelper(node.right);
	  } else {
	    return false;
	  }
	}

	function isType$1(node) {
	  return isLiteral$5(node) || isObjectExpression$1(node) || isArrayExpression(node) || isIdentifier$d(node) || isMemberExpression$6(node);
	}

	var nodes = {
	  AssignmentExpression: function (_AssignmentExpression) {
	    function AssignmentExpression(_x) {
	      return _AssignmentExpression.apply(this, arguments);
	    }

	    AssignmentExpression.toString = function () {
	      return _AssignmentExpression.toString();
	    };

	    return AssignmentExpression;
	  }(function (node) {
	    var state = crawl(node.right);

	    if (state.hasCall && state.hasHelper || state.hasFunction) {
	      return {
	        before: state.hasFunction,
	        after: true
	      };
	    }
	  }),
	  SwitchCase: function (_SwitchCase) {
	    function SwitchCase(_x2, _x3) {
	      return _SwitchCase.apply(this, arguments);
	    }

	    SwitchCase.toString = function () {
	      return _SwitchCase.toString();
	    };

	    return SwitchCase;
	  }(function (node, parent) {
	    return {
	      before: !!node.consequent.length || parent.cases[0] === node,
	      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
	    };
	  }),
	  LogicalExpression: function (_LogicalExpression) {
	    function LogicalExpression(_x4) {
	      return _LogicalExpression.apply(this, arguments);
	    }

	    LogicalExpression.toString = function () {
	      return _LogicalExpression.toString();
	    };

	    return LogicalExpression;
	  }(function (node) {
	    if (isFunction$3(node.left) || isFunction$3(node.right)) {
	      return {
	        after: true
	      };
	    }
	  }),
	  Literal: function (_Literal) {
	    function Literal(_x5) {
	      return _Literal.apply(this, arguments);
	    }

	    Literal.toString = function () {
	      return _Literal.toString();
	    };

	    return Literal;
	  }(function (node) {
	    if (isStringLiteral$6(node) && node.value === "use strict") {
	      return {
	        after: true
	      };
	    }
	  }),
	  CallExpression: function (_CallExpression) {
	    function CallExpression(_x6) {
	      return _CallExpression.apply(this, arguments);
	    }

	    CallExpression.toString = function () {
	      return _CallExpression.toString();
	    };

	    return CallExpression;
	  }(function (node) {
	    if (isFunction$3(node.callee) || isHelper(node)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  }),
	  OptionalCallExpression: function (_OptionalCallExpression) {
	    function OptionalCallExpression(_x7) {
	      return _OptionalCallExpression.apply(this, arguments);
	    }

	    OptionalCallExpression.toString = function () {
	      return _OptionalCallExpression.toString();
	    };

	    return OptionalCallExpression;
	  }(function (node) {
	    if (isFunction$3(node.callee)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  }),
	  VariableDeclaration: function (_VariableDeclaration) {
	    function VariableDeclaration(_x8) {
	      return _VariableDeclaration.apply(this, arguments);
	    }

	    VariableDeclaration.toString = function () {
	      return _VariableDeclaration.toString();
	    };

	    return VariableDeclaration;
	  }(function (node) {
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      var enabled = isHelper(declar.id) && !isType$1(declar.init);

	      if (!enabled) {
	        var state = crawl(declar.init);
	        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
	      }

	      if (enabled) {
	        return {
	          before: true,
	          after: true
	        };
	      }
	    }
	  }),
	  IfStatement: function (_IfStatement) {
	    function IfStatement(_x9) {
	      return _IfStatement.apply(this, arguments);
	    }

	    IfStatement.toString = function () {
	      return _IfStatement.toString();
	    };

	    return IfStatement;
	  }(function (node) {
	    if (isBlockStatement$1(node.consequent)) {
	      return {
	        before: true,
	        after: true
	      };
	    }
	  })
	};

	nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
	  if (parent.properties[0] === node) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeCallProperty = function (node, parent) {
	  var _parent$properties;

	  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeIndexer = function (node, parent) {
	  var _parent$properties2, _parent$callPropertie;

	  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
	    return {
	      before: true
	    };
	  }
	};

	nodes.ObjectTypeInternalSlot = function (node, parent) {
	  var _parent$properties3, _parent$callPropertie2, _parent$indexers;

	  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
	    return {
	      before: true
	    };
	  }
	};

	var list$1 = {
	  VariableDeclaration: function (_VariableDeclaration2) {
	    function VariableDeclaration(_x10) {
	      return _VariableDeclaration2.apply(this, arguments);
	    }

	    VariableDeclaration.toString = function () {
	      return _VariableDeclaration2.toString();
	    };

	    return VariableDeclaration;
	  }(function (node) {
	    return node.declarations.map(function (decl) {
	      return decl.init;
	    });
	  }),
	  ArrayExpression: function (_ArrayExpression) {
	    function ArrayExpression(_x11) {
	      return _ArrayExpression.apply(this, arguments);
	    }

	    ArrayExpression.toString = function () {
	      return _ArrayExpression.toString();
	    };

	    return ArrayExpression;
	  }(function (node) {
	    return node.elements;
	  }),
	  ObjectExpression: function (_ObjectExpression) {
	    function ObjectExpression(_x12) {
	      return _ObjectExpression.apply(this, arguments);
	    }

	    ObjectExpression.toString = function () {
	      return _ObjectExpression.toString();
	    };

	    return ObjectExpression;
	  }(function (node) {
	    return node.properties;
	  })
	};
	[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
	  var _ref2 = _slicedToArray$1(_ref, 2),
	      type = _ref2[0],
	      amounts = _ref2[1];

	  if (typeof amounts === "boolean") {
	    amounts = {
	      after: amounts,
	      before: amounts
	    };
	  }

	  [type].concat(FLIPPED_ALIAS_KEYS$2[type] || []).forEach(function (type) {
	    nodes[type] = function () {
	      return amounts;
	    };
	  });
	});

	var isArrayTypeAnnotation = isArrayTypeAnnotation$1,
	    isArrowFunctionExpression = isArrowFunctionExpression$1,
	    isAssignmentExpression$1 = isAssignmentExpression$3,
	    isAwaitExpression = isAwaitExpression$1,
	    isBinary = isBinary$3,
	    isBinaryExpression = isBinaryExpression$1,
	    isCallExpression$4 = isCallExpression$6,
	    isClassDeclaration$1 = isClassDeclaration$3,
	    isClassExpression = isClassExpression$1,
	    isConditional = isConditional$1,
	    isConditionalExpression = isConditionalExpression$1,
	    isExportDeclaration = isExportDeclaration$2,
	    isExportDefaultDeclaration$1 = isExportDefaultDeclaration$3,
	    isExpressionStatement$3 = isExpressionStatement$4,
	    isFor$1 = isFor$2,
	    isForInStatement = isForInStatement$1,
	    isForOfStatement = isForOfStatement$1,
	    isForStatement$1 = isForStatement$3,
	    isIfStatement$1 = isIfStatement$2,
	    isIndexedAccessType = isIndexedAccessType$1,
	    isIntersectionTypeAnnotation = isIntersectionTypeAnnotation$1,
	    isLogicalExpression = isLogicalExpression$1,
	    isMemberExpression$5 = isMemberExpression$8,
	    isNewExpression$3 = isNewExpression$4,
	    isNullableTypeAnnotation = isNullableTypeAnnotation$1,
	    isObjectPattern = isObjectPattern$1,
	    isOptionalCallExpression$1 = isOptionalCallExpression$3,
	    isOptionalMemberExpression$1 = isOptionalMemberExpression$3,
	    isReturnStatement = isReturnStatement$1,
	    isSequenceExpression = isSequenceExpression$1,
	    isSwitchStatement = isSwitchStatement$1,
	    isTSArrayType = isTSArrayType$1,
	    isTSAsExpression$1 = isTSAsExpression$2,
	    isTSIntersectionType = isTSIntersectionType$1,
	    isTSNonNullExpression$1 = isTSNonNullExpression$2,
	    isTSOptionalType = isTSOptionalType$1,
	    isTSRestType = isTSRestType$1,
	    isTSTypeAssertion$1 = isTSTypeAssertion$2,
	    isTSUnionType = isTSUnionType$1,
	    isTaggedTemplateExpression = isTaggedTemplateExpression$2,
	    isThrowStatement = isThrowStatement$1,
	    isTypeAnnotation$1 = isTypeAnnotation$2,
	    isUnaryLike = isUnaryLike$1,
	    isUnionTypeAnnotation$1 = isUnionTypeAnnotation$2,
	    isVariableDeclarator$1 = isVariableDeclarator$2,
	    isWhileStatement = isWhileStatement$1,
	    isYieldExpression = isYieldExpression$1;
	var PRECEDENCE = {
	  "||": 0,
	  "??": 0,
	  "&&": 1,
	  "|": 2,
	  "^": 3,
	  "&": 4,
	  "==": 5,
	  "===": 5,
	  "!=": 5,
	  "!==": 5,
	  "<": 6,
	  ">": 6,
	  "<=": 6,
	  ">=": 6,
	  "in": 6,
	  "instanceof": 6,
	  ">>": 7,
	  "<<": 7,
	  ">>>": 7,
	  "+": 8,
	  "-": 8,
	  "*": 9,
	  "/": 9,
	  "%": 9,
	  "**": 10
	};

	var isClassExtendsClause = function isClassExtendsClause(node, parent) {
	  return (isClassDeclaration$1(parent) || isClassExpression(parent)) && parent.superClass === node;
	};

	var hasPostfixPart = function hasPostfixPart(node, parent) {
	  return (isMemberExpression$5(parent) || isOptionalMemberExpression$1(parent)) && parent.object === node || (isCallExpression$4(parent) || isOptionalCallExpression$1(parent) || isNewExpression$3(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression$1(parent);
	};

	function NullableTypeAnnotation$1(node, parent) {
	  return isArrayTypeAnnotation(parent);
	}
	function FunctionTypeAnnotation$1(node, parent, printStack) {
	  return isUnionTypeAnnotation$1(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation$1(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
	}
	function UpdateExpression$2(node, parent) {
	  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
	}
	function ObjectExpression$2(node, parent, printStack) {
	  return isFirstInContext(printStack, {
	    expressionStatement: true,
	    arrowBody: true
	  });
	}
	function DoExpression$1(node, parent, printStack) {
	  return !node.async && isFirstInContext(printStack, {
	    expressionStatement: true
	  });
	}
	function Binary(node, parent) {
	  if (node.operator === "**" && isBinaryExpression(parent, {
	    operator: "**"
	  })) {
	    return parent.left === node;
	  }

	  if (isClassExtendsClause(node, parent)) {
	    return true;
	  }

	  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
	    return true;
	  }

	  if (isBinary(parent)) {
	    var parentOp = parent.operator;
	    var parentPos = PRECEDENCE[parentOp];
	    var nodeOp = node.operator;
	    var nodePos = PRECEDENCE[nodeOp];

	    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
	      return true;
	    }
	  }
	}
	function UnionTypeAnnotation$1(node, parent) {
	  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation$1(parent);
	}
	function OptionalIndexedAccessType$1(node, parent) {
	  return isIndexedAccessType(parent, {
	    objectType: node
	  });
	}
	function TSAsExpression$1() {
	  return true;
	}
	function TSTypeAssertion$1() {
	  return true;
	}
	function TSUnionType$1(node, parent) {
	  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
	}
	function TSInferType$1(node, parent) {
	  return isTSArrayType(parent) || isTSOptionalType(parent);
	}
	function BinaryExpression$1(node, parent) {
	  return node.operator === "in" && (isVariableDeclarator$1(parent) || isFor$1(parent));
	}
	function SequenceExpression$2(node, parent) {
	  if (isForStatement$1(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement$1(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement$3(parent) && parent.expression === node) {
	    return false;
	  }

	  return true;
	}
	function YieldExpression$1(node, parent) {
	  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
	}
	function ClassExpression(node, parent, printStack) {
	  return isFirstInContext(printStack, {
	    expressionStatement: true,
	    exportDefault: true
	  });
	}
	function UnaryLike(node, parent) {
	  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
	    operator: "**",
	    left: node
	  }) || isClassExtendsClause(node, parent);
	}
	function FunctionExpression$1(node, parent, printStack) {
	  return isFirstInContext(printStack, {
	    expressionStatement: true,
	    exportDefault: true
	  });
	}
	function ArrowFunctionExpression$1(node, parent) {
	  return isExportDeclaration(parent) || ConditionalExpression$2(node, parent);
	}
	function ConditionalExpression$2(node, parent) {
	  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
	    test: node
	  }) || isAwaitExpression(parent) || isTSTypeAssertion$1(parent) || isTSAsExpression$1(parent)) {
	    return true;
	  }

	  return UnaryLike(node, parent);
	}
	function OptionalMemberExpression$1(node, parent) {
	  return isCallExpression$4(parent, {
	    callee: node
	  }) || isMemberExpression$5(parent, {
	    object: node
	  });
	}
	function AssignmentExpression$2(node, parent) {
	  if (isObjectPattern(node.left)) {
	    return true;
	  } else {
	    return ConditionalExpression$2(node, parent);
	  }
	}
	function LogicalExpression$1(node, parent) {
	  switch (node.operator) {
	    case "||":
	      if (!isLogicalExpression(parent)) return false;
	      return parent.operator === "??" || parent.operator === "&&";

	    case "&&":
	      return isLogicalExpression(parent, {
	        operator: "??"
	      });

	    case "??":
	      return isLogicalExpression(parent) && parent.operator !== "??";
	  }
	}
	function Identifier$1(node, parent, printStack) {
	  if (node.name === "let") {
	    var isFollowedByBracket = isMemberExpression$5(parent, {
	      object: node,
	      computed: true
	    }) || isOptionalMemberExpression$1(parent, {
	      object: node,
	      computed: true,
	      optional: false
	    });
	    return isFirstInContext(printStack, {
	      expressionStatement: isFollowedByBracket,
	      forHead: isFollowedByBracket,
	      forInHead: isFollowedByBracket,
	      forOfHead: true
	    });
	  }

	  return node.name === "async" && isForOfStatement(parent) && node === parent.left;
	}

	function isFirstInContext(printStack, _ref) {
	  var _ref$expressionStatem = _ref.expressionStatement,
	      expressionStatement = _ref$expressionStatem === void 0 ? false : _ref$expressionStatem,
	      _ref$arrowBody = _ref.arrowBody,
	      arrowBody = _ref$arrowBody === void 0 ? false : _ref$arrowBody,
	      _ref$exportDefault = _ref.exportDefault,
	      exportDefault = _ref$exportDefault === void 0 ? false : _ref$exportDefault,
	      _ref$forHead = _ref.forHead,
	      forHead = _ref$forHead === void 0 ? false : _ref$forHead,
	      _ref$forInHead = _ref.forInHead,
	      forInHead = _ref$forInHead === void 0 ? false : _ref$forInHead,
	      _ref$forOfHead = _ref.forOfHead,
	      forOfHead = _ref$forOfHead === void 0 ? false : _ref$forOfHead;
	  var i = printStack.length - 1;
	  var node = printStack[i];
	  i--;
	  var parent = printStack[i];

	  while (i >= 0) {
	    if (expressionStatement && isExpressionStatement$3(parent, {
	      expression: node
	    }) || exportDefault && isExportDefaultDeclaration$1(parent, {
	      declaration: node
	    }) || arrowBody && isArrowFunctionExpression(parent, {
	      body: node
	    }) || forHead && isForStatement$1(parent, {
	      init: node
	    }) || forInHead && isForInStatement(parent, {
	      left: node
	    }) || forOfHead && isForOfStatement(parent, {
	      left: node
	    })) {
	      return true;
	    }

	    if (hasPostfixPart(node, parent) && !isNewExpression$3(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
	      test: node
	    }) || isBinary(parent, {
	      left: node
	    }) || isAssignmentExpression$1(parent, {
	      left: node
	    })) {
	      node = parent;
	      i--;
	      parent = printStack[i];
	    } else {
	      return false;
	    }
	  }

	  return false;
	}

	var parens = /*#__PURE__*/Object.freeze({
		__proto__: null,
		NullableTypeAnnotation: NullableTypeAnnotation$1,
		FunctionTypeAnnotation: FunctionTypeAnnotation$1,
		UpdateExpression: UpdateExpression$2,
		ObjectExpression: ObjectExpression$2,
		DoExpression: DoExpression$1,
		Binary: Binary,
		UnionTypeAnnotation: UnionTypeAnnotation$1,
		IntersectionTypeAnnotation: UnionTypeAnnotation$1,
		OptionalIndexedAccessType: OptionalIndexedAccessType$1,
		TSAsExpression: TSAsExpression$1,
		TSTypeAssertion: TSTypeAssertion$1,
		TSUnionType: TSUnionType$1,
		TSIntersectionType: TSUnionType$1,
		TSInferType: TSInferType$1,
		BinaryExpression: BinaryExpression$1,
		SequenceExpression: SequenceExpression$2,
		YieldExpression: YieldExpression$1,
		AwaitExpression: YieldExpression$1,
		ClassExpression: ClassExpression,
		UnaryLike: UnaryLike,
		FunctionExpression: FunctionExpression$1,
		ArrowFunctionExpression: ArrowFunctionExpression$1,
		ConditionalExpression: ConditionalExpression$2,
		OptionalMemberExpression: OptionalMemberExpression$1,
		OptionalCallExpression: OptionalMemberExpression$1,
		AssignmentExpression: AssignmentExpression$2,
		LogicalExpression: LogicalExpression$1,
		Identifier: Identifier$1
	});

	var FLIPPED_ALIAS_KEYS$1 = FLIPPED_ALIAS_KEYS$3,
	    isCallExpression$3 = isCallExpression$6,
	    isExpressionStatement$2 = isExpressionStatement$4,
	    isMemberExpression$4 = isMemberExpression$8,
	    isNewExpression$2 = isNewExpression$4;

	function expandAliases(obj) {
	  var newObj = {};

	  function add(type, func) {
	    var fn = newObj[type];
	    newObj[type] = fn ? function (node, parent, stack) {
	      var result = fn(node, parent, stack);
	      return result == null ? func(node, parent, stack) : result;
	    } : func;
	  }

	  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
	    var type = _Object$keys[_i];
	    var aliases = FLIPPED_ALIAS_KEYS$1[type];

	    if (aliases) {
	      for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
	        var alias = _step.value;
	        add(alias, obj[type]);
	      }
	    } else {
	      add(type, obj[type]);
	    }
	  }

	  return newObj;
	}

	var expandedParens = expandAliases(parens);
	var expandedWhitespaceNodes = expandAliases(nodes);
	var expandedWhitespaceList = expandAliases(list$1);

	function find$2(obj, node, parent, printStack) {
	  var fn = obj[node.type];
	  return fn ? fn(node, parent, printStack) : null;
	}

	function isOrHasCallExpression(node) {
	  if (isCallExpression$3(node)) {
	    return true;
	  }

	  return isMemberExpression$4(node) && isOrHasCallExpression(node.object);
	}

	function needsWhitespace(node, parent, type) {
	  if (!node) return 0;

	  if (isExpressionStatement$2(node)) {
	    node = node.expression;
	  }

	  var linesInfo = find$2(expandedWhitespaceNodes, node, parent);

	  if (!linesInfo) {
	    var items = find$2(expandedWhitespaceList, node, parent);

	    if (items) {
	      for (var i = 0; i < items.length; i++) {
	        linesInfo = needsWhitespace(items[i], node, type);
	        if (linesInfo) break;
	      }
	    }
	  }

	  if (typeof linesInfo === "object" && linesInfo !== null) {
	    return linesInfo[type] || 0;
	  }

	  return 0;
	}
	function needsWhitespaceBefore$1(node, parent) {
	  return needsWhitespace(node, parent, "before");
	}
	function needsWhitespaceAfter$1(node, parent) {
	  return needsWhitespace(node, parent, "after");
	}
	function needsParens$1(node, parent, printStack) {
	  if (!parent) return false;

	  if (isNewExpression$2(parent) && parent.callee === node) {
	    if (isOrHasCallExpression(node)) return true;
	  }

	  return find$2(expandedParens, node, parent, printStack);
	}

	function TaggedTemplateExpression$1(node) {
	  this.print(node.tag, node);
	  this.print(node.typeParameters, node);
	  this.print(node.quasi, node);
	}
	function TemplateElement(node, parent) {
	  var isFirst = parent.quasis[0] === node;
	  var isLast = parent.quasis[parent.quasis.length - 1] === node;
	  var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
	  this.token(value);
	}
	function TemplateLiteral$1(node) {
	  var quasis = node.quasis;

	  for (var i = 0; i < quasis.length; i++) {
	    this.print(quasis[i], node);

	    if (i + 1 < quasis.length) {
	      this.print(node.expressions[i], node);
	    }
	  }
	}

	var isCallExpression$2 = isCallExpression$6,
	    isLiteral$4 = isLiteral$7,
	    isMemberExpression$3 = isMemberExpression$8,
	    isNewExpression$1 = isNewExpression$4;
	function UnaryExpression$1(node) {
	  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
	    this.word(node.operator);
	    this.space();
	  } else {
	    this.token(node.operator);
	  }

	  this.print(node.argument, node);
	}
	function DoExpression(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	}
	function ParenthesizedExpression$1(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.token(")");
	}
	function UpdateExpression$1(node) {
	  if (node.prefix) {
	    this.token(node.operator);
	    this.print(node.argument, node);
	  } else {
	    this.startTerminatorless(true);
	    this.print(node.argument, node);
	    this.endTerminatorless();
	    this.token(node.operator);
	  }
	}
	function ConditionalExpression$1(node) {
	  this.print(node.test, node);
	  this.space();
	  this.token("?");
	  this.space();
	  this.print(node.consequent, node);
	  this.space();
	  this.token(":");
	  this.space();
	  this.print(node.alternate, node);
	}
	function NewExpression$1(node, parent) {
	  this.word("new");
	  this.space();
	  this.print(node.callee, node);

	  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression$2(parent, {
	    callee: node
	  }) && !isMemberExpression$3(parent) && !isNewExpression$1(parent)) {
	    return;
	  }

	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}
	function SequenceExpression$1(node) {
	  this.printList(node.expressions, node);
	}
	function ThisExpression() {
	  this.word("this");
	}
	function Super() {
	  this.word("super");
	}
	function Decorator(node) {
	  this.token("@");
	  this.print(node.expression, node);
	  this.newline();
	}
	function OptionalMemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && isMemberExpression$3(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  var computed = node.computed;

	  if (isLiteral$4(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (node.optional) {
	    this.token("?.");
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    if (!node.optional) {
	      this.token(".");
	    }

	    this.print(node.property, node);
	  }
	}
	function OptionalCallExpression(node) {
	  this.print(node.callee, node);
	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}
	function CallExpression$1(node) {
	  this.print(node.callee, node);
	  this.print(node.typeArguments, node);
	  this.print(node.typeParameters, node);
	  this.token("(");
	  this.printList(node.arguments, node);
	  this.token(")");
	}
	function Import() {
	  this.word("import");
	}

	function buildYieldAwait(keyword) {
	  return function (node) {
	    this.word(keyword);

	    if (node.delegate) {
	      this.token("*");
	    }

	    if (node.argument) {
	      this.space();
	      var terminatorState = this.startTerminatorless();
	      this.print(node.argument, node);
	      this.endTerminatorless(terminatorState);
	    }
	  };
	}

	var YieldExpression = buildYieldAwait("yield");
	var AwaitExpression = buildYieldAwait("await");
	function EmptyStatement() {
	  this.semicolon(true);
	}
	function ExpressionStatement(node) {
	  this.print(node.expression, node);
	  this.semicolon();
	}
	function AssignmentPattern(node) {
	  this.print(node.left, node);
	  if (node.left.optional) this.token("?");
	  this.print(node.left.typeAnnotation, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	}
	function AssignmentExpression$1(node, parent) {
	  var parens = this.inForStatementInitCounter && node.operator === "in" && !needsParens$1(node, parent);

	  if (parens) {
	    this.token("(");
	  }

	  this.print(node.left, node);
	  this.space();

	  if (node.operator === "in" || node.operator === "instanceof") {
	    this.word(node.operator);
	  } else {
	    this.token(node.operator);
	  }

	  this.space();
	  this.print(node.right, node);

	  if (parens) {
	    this.token(")");
	  }
	}
	function BindExpression(node) {
	  this.print(node.object, node);
	  this.token("::");
	  this.print(node.callee, node);
	}
	function MemberExpression(node) {
	  this.print(node.object, node);

	  if (!node.computed && isMemberExpression$3(node.property)) {
	    throw new TypeError("Got a MemberExpression for MemberExpression property");
	  }

	  var computed = node.computed;

	  if (isLiteral$4(node.property) && typeof node.property.value === "number") {
	    computed = true;
	  }

	  if (computed) {
	    this.token("[");
	    this.print(node.property, node);
	    this.token("]");
	  } else {
	    this.token(".");
	    this.print(node.property, node);
	  }
	}
	function MetaProperty(node) {
	  this.print(node.meta, node);
	  this.token(".");
	  this.print(node.property, node);
	}
	function PrivateName(node) {
	  this.token("#");
	  this.print(node.id, node);
	}
	function V8IntrinsicIdentifier(node) {
	  this.token("%");
	  this.word(node.name);
	}
	function ModuleExpression(node) {
	  this.word("module");
	  this.space();
	  this.token("{");

	  if (node.body.body.length === 0) {
	    this.token("}");
	  } else {
	    this.newline();
	    this.printSequence(node.body.body, node, {
	      indent: true
	    });
	    this.rightBrace();
	  }
	}

	var isFor = isFor$2,
	    isForStatement = isForStatement$3,
	    isIfStatement = isIfStatement$2,
	    isStatement$5 = isStatement$7;
	function WithStatement(node) {
	  this.word("with");
	  this.space();
	  this.token("(");
	  this.print(node.object, node);
	  this.token(")");
	  this.printBlock(node);
	}
	function IfStatement(node) {
	  this.word("if");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.space();
	  var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));

	  if (needsBlock) {
	    this.token("{");
	    this.newline();
	    this.indent();
	  }

	  this.printAndIndentOnComments(node.consequent, node);

	  if (needsBlock) {
	    this.dedent();
	    this.newline();
	    this.token("}");
	  }

	  if (node.alternate) {
	    if (this.endsWith(125)) this.space();
	    this.word("else");
	    this.space();
	    this.printAndIndentOnComments(node.alternate, node);
	  }
	}

	function getLastStatement(statement) {
	  if (!isStatement$5(statement.body)) return statement;
	  return getLastStatement(statement.body);
	}

	function ForStatement(node) {
	  this.word("for");
	  this.space();
	  this.token("(");
	  this.inForStatementInitCounter++;
	  this.print(node.init, node);
	  this.inForStatementInitCounter--;
	  this.token(";");

	  if (node.test) {
	    this.space();
	    this.print(node.test, node);
	  }

	  this.token(";");

	  if (node.update) {
	    this.space();
	    this.print(node.update, node);
	  }

	  this.token(")");
	  this.printBlock(node);
	}
	function WhileStatement(node) {
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.printBlock(node);
	}

	var buildForXStatement = function buildForXStatement(op) {
	  return function (node) {
	    this.word("for");
	    this.space();

	    if (op === "of" && node["await"]) {
	      this.word("await");
	      this.space();
	    }

	    this.token("(");
	    this.print(node.left, node);
	    this.space();
	    this.word(op);
	    this.space();
	    this.print(node.right, node);
	    this.token(")");
	    this.printBlock(node);
	  };
	};

	var ForInStatement = buildForXStatement("in");
	var ForOfStatement = buildForXStatement("of");
	function DoWhileStatement(node) {
	  this.word("do");
	  this.space();
	  this.print(node.body, node);
	  this.space();
	  this.word("while");
	  this.space();
	  this.token("(");
	  this.print(node.test, node);
	  this.token(")");
	  this.semicolon();
	}

	function buildLabelStatement(prefix, key) {
	  if (key === void 0) {
	    key = "label";
	  }

	  return function (node) {
	    this.word(prefix);
	    var label = node[key];

	    if (label) {
	      this.space();
	      var isLabel = key == "label";
	      var terminatorState = this.startTerminatorless(isLabel);
	      this.print(label, node);
	      this.endTerminatorless(terminatorState);
	    }

	    this.semicolon();
	  };
	}

	var ContinueStatement = buildLabelStatement("continue");
	var ReturnStatement = buildLabelStatement("return", "argument");
	var BreakStatement = buildLabelStatement("break");
	var ThrowStatement = buildLabelStatement("throw", "argument");
	function LabeledStatement(node) {
	  this.print(node.label, node);
	  this.token(":");
	  this.space();
	  this.print(node.body, node);
	}
	function TryStatement(node) {
	  this.word("try");
	  this.space();
	  this.print(node.block, node);
	  this.space();

	  if (node.handlers) {
	    this.print(node.handlers[0], node);
	  } else {
	    this.print(node.handler, node);
	  }

	  if (node.finalizer) {
	    this.space();
	    this.word("finally");
	    this.space();
	    this.print(node.finalizer, node);
	  }
	}
	function CatchClause(node) {
	  this.word("catch");
	  this.space();

	  if (node.param) {
	    this.token("(");
	    this.print(node.param, node);
	    this.print(node.param.typeAnnotation, node);
	    this.token(")");
	    this.space();
	  }

	  this.print(node.body, node);
	}
	function SwitchStatement(node) {
	  this.word("switch");
	  this.space();
	  this.token("(");
	  this.print(node.discriminant, node);
	  this.token(")");
	  this.space();
	  this.token("{");
	  this.printSequence(node.cases, node, {
	    indent: true,
	    addNewlines: function addNewlines(leading, cas) {
	      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
	    }
	  });
	  this.token("}");
	}
	function SwitchCase(node) {
	  if (node.test) {
	    this.word("case");
	    this.space();
	    this.print(node.test, node);
	    this.token(":");
	  } else {
	    this.word("default");
	    this.token(":");
	  }

	  if (node.consequent.length) {
	    this.newline();
	    this.printSequence(node.consequent, node, {
	      indent: true
	    });
	  }
	}
	function DebuggerStatement() {
	  this.word("debugger");
	  this.semicolon();
	}

	function variableDeclarationIndent() {
	  this.token(",");
	  this.newline();

	  if (this.endsWith(10)) {
	    for (var i = 0; i < 4; i++) {
	      this.space(true);
	    }
	  }
	}

	function constDeclarationIndent() {
	  this.token(",");
	  this.newline();

	  if (this.endsWith(10)) {
	    for (var i = 0; i < 6; i++) {
	      this.space(true);
	    }
	  }
	}

	function VariableDeclaration(node, parent) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word(node.kind);
	  this.space();
	  var hasInits = false;

	  if (!isFor(parent)) {
	    for (var _iterator = _createForOfIteratorHelperLoose(node.declarations), _step; !(_step = _iterator()).done;) {
	      var declar = _step.value;

	      if (declar.init) {
	        hasInits = true;
	      }
	    }
	  }

	  var separator;

	  if (hasInits) {
	    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
	  }

	  this.printList(node.declarations, node, {
	    separator: separator
	  });

	  if (isFor(parent)) {
	    if (isForStatement(parent)) {
	      if (parent.init === node) return;
	    } else {
	      if (parent.left === node) return;
	    }
	  }

	  this.semicolon();
	}
	function VariableDeclarator$1(node) {
	  this.print(node.id, node);
	  if (node.definite) this.token("!");
	  this.print(node.id.typeAnnotation, node);

	  if (node.init) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.init, node);
	  }
	}

	var isExportDefaultDeclaration = isExportDefaultDeclaration$3,
	    isExportNamedDeclaration = isExportNamedDeclaration$2;
	function ClassDeclaration(node, parent) {
	  if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
	    this.printJoin(node.decorators, node);
	  }

	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (node["abstract"]) {
	    this.word("abstract");
	    this.space();
	  }

	  this.word("class");
	  this.printInnerComments(node);

	  if (node.id) {
	    this.space();
	    this.print(node.id, node);
	  }

	  this.print(node.typeParameters, node);

	  if (node.superClass) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.superClass, node);
	    this.print(node.superTypeParameters, node);
	  }

	  if (node["implements"]) {
	    this.space();
	    this.word("implements");
	    this.space();
	    this.printList(node["implements"], node);
	  }

	  this.space();
	  this.print(node.body, node);
	}
	function ClassBody(node) {
	  this.token("{");
	  this.printInnerComments(node);

	  if (node.body.length === 0) {
	    this.token("}");
	  } else {
	    this.newline();
	    this.indent();
	    this.printSequence(node.body, node);
	    this.dedent();
	    if (!this.endsWith(10)) this.newline();
	    this.rightBrace();
	  }
	}
	function ClassProperty(node) {
	  this.printJoin(node.decorators, node);
	  this.source("end", node.key.loc);
	  this.tsPrintClassMemberModifiers(node, true);

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    this._variance(node);

	    this.print(node.key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  if (node.definite) {
	    this.token("!");
	  }

	  this.print(node.typeAnnotation, node);

	  if (node.value) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.value, node);
	  }

	  this.semicolon();
	}
	function ClassPrivateProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  this.print(node.key, node);
	  this.print(node.typeAnnotation, node);

	  if (node.value) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.value, node);
	  }

	  this.semicolon();
	}
	function ClassMethod(node) {
	  this._classMethodHead(node);

	  this.space();
	  this.print(node.body, node);
	}
	function ClassPrivateMethod(node) {
	  this._classMethodHead(node);

	  this.space();
	  this.print(node.body, node);
	}
	function _classMethodHead(node) {
	  this.printJoin(node.decorators, node);
	  this.source("end", node.key.loc);
	  this.tsPrintClassMemberModifiers(node, false);

	  this._methodHead(node);
	}
	function StaticBlock(node) {
	  this.word("static");
	  this.space();
	  this.token("{");

	  if (node.body.length === 0) {
	    this.token("}");
	  } else {
	    this.newline();
	    this.printSequence(node.body, node, {
	      indent: true
	    });
	    this.rightBrace();
	  }
	}

	var isIdentifier$c = isIdentifier$g;
	function _params(node) {
	  this.print(node.typeParameters, node);
	  this.token("(");

	  this._parameters(node.params, node);

	  this.token(")");
	  this.print(node.returnType, node);
	}
	function _parameters(parameters, parent) {
	  for (var i = 0; i < parameters.length; i++) {
	    this._param(parameters[i], parent);

	    if (i < parameters.length - 1) {
	      this.token(",");
	      this.space();
	    }
	  }
	}
	function _param(parameter, parent) {
	  this.printJoin(parameter.decorators, parameter);
	  this.print(parameter, parent);
	  if (parameter.optional) this.token("?");
	  this.print(parameter.typeAnnotation, parameter);
	}
	function _methodHead(node) {
	  var kind = node.kind;
	  var key = node.key;

	  if (kind === "get" || kind === "set") {
	    this.word(kind);
	    this.space();
	  }

	  if (node.async) {
	    this._catchUp("start", key.loc);

	    this.word("async");
	    this.space();
	  }

	  if (kind === "method" || kind === "init") {
	    if (node.generator) {
	      this.token("*");
	    }
	  }

	  if (node.computed) {
	    this.token("[");
	    this.print(key, node);
	    this.token("]");
	  } else {
	    this.print(key, node);
	  }

	  if (node.optional) {
	    this.token("?");
	  }

	  this._params(node);
	}
	function _predicate(node) {
	  if (node.predicate) {
	    if (!node.returnType) {
	      this.token(":");
	    }

	    this.space();
	    this.print(node.predicate, node);
	  }
	}
	function _functionHead(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  this.word("function");
	  if (node.generator) this.token("*");
	  this.printInnerComments(node);
	  this.space();

	  if (node.id) {
	    this.print(node.id, node);
	  }

	  this._params(node);

	  this._predicate(node);
	}
	function FunctionExpression(node) {
	  this._functionHead(node);

	  this.space();
	  this.print(node.body, node);
	}
	function ArrowFunctionExpression(node) {
	  if (node.async) {
	    this.word("async");
	    this.space();
	  }

	  var firstParam = node.params[0];

	  if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && isIdentifier$c(firstParam) && !hasTypesOrComments(node, firstParam)) {
	    this.print(firstParam, node);
	  } else {
	    this._params(node);
	  }

	  this._predicate(node);

	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.body, node);
	}

	function hasTypesOrComments(node, param) {
	  var _param$leadingComment, _param$trailingCommen;

	  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
	}

	var isClassDeclaration = isClassDeclaration$3,
	    isExportDefaultSpecifier = isExportDefaultSpecifier$1,
	    isExportNamespaceSpecifier = isExportNamespaceSpecifier$1,
	    isImportDefaultSpecifier = isImportDefaultSpecifier$1,
	    isImportNamespaceSpecifier = isImportNamespaceSpecifier$1,
	    isStatement$4 = isStatement$7;
	function ImportSpecifier(node) {
	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  this.print(node.imported, node);

	  if (node.local && node.local.name !== node.imported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.local, node);
	  }
	}
	function ImportDefaultSpecifier(node) {
	  this.print(node.local, node);
	}
	function ExportDefaultSpecifier(node) {
	  this.print(node.exported, node);
	}
	function ExportSpecifier(node) {
	  if (node.exportKind === "type") {
	    this.word("type");
	    this.space();
	  }

	  this.print(node.local, node);

	  if (node.exported && node.local.name !== node.exported.name) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(node.exported, node);
	  }
	}
	function ExportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.exported, node);
	}
	function ExportAllDeclaration(node) {
	  this.word("export");
	  this.space();

	  if (node.exportKind === "type") {
	    this.word("type");
	    this.space();
	  }

	  this.token("*");
	  this.space();
	  this.word("from");
	  this.space();
	  this.print(node.source, node);
	  this.printAssertions(node);
	  this.semicolon();
	}
	function ExportNamedDeclaration(node) {
	  if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}
	function ExportDefaultDeclaration(node) {
	  if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
	    this.printJoin(node.declaration.decorators, node);
	  }

	  this.word("export");
	  this.space();
	  this.word("default");
	  this.space();
	  ExportDeclaration.apply(this, arguments);
	}

	function ExportDeclaration(node) {
	  if (node.declaration) {
	    var declar = node.declaration;
	    this.print(declar, node);
	    if (!isStatement$4(declar)) this.semicolon();
	  } else {
	    if (node.exportKind === "type") {
	      this.word("type");
	      this.space();
	    }

	    var specifiers = node.specifiers.slice(0);
	    var hasSpecial = false;

	    for (;;) {
	      var first = specifiers[0];

	      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
	        hasSpecial = true;
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length || !specifiers.length && !hasSpecial) {
	      this.token("{");

	      if (specifiers.length) {
	        this.space();
	        this.printList(specifiers, node);
	        this.space();
	      }

	      this.token("}");
	    }

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	      this.printAssertions(node);
	    }

	    this.semicolon();
	  }
	}

	function ImportDeclaration(node) {
	  this.word("import");
	  this.space();

	  if (node.importKind === "type" || node.importKind === "typeof") {
	    this.word(node.importKind);
	    this.space();
	  }

	  var specifiers = node.specifiers.slice(0);

	  if (specifiers != null && specifiers.length) {
	    for (;;) {
	      var first = specifiers[0];

	      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
	        this.print(specifiers.shift(), node);

	        if (specifiers.length) {
	          this.token(",");
	          this.space();
	        }
	      } else {
	        break;
	      }
	    }

	    if (specifiers.length) {
	      this.token("{");
	      this.space();
	      this.printList(specifiers, node);
	      this.space();
	      this.token("}");
	    }

	    this.space();
	    this.word("from");
	    this.space();
	  }

	  this.print(node.source, node);
	  this.printAssertions(node);
	  {
	    var _node$attributes;

	    if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
	      this.space();
	      this.word("with");
	      this.space();
	      this.printList(node.attributes, node);
	    }
	  }
	  this.semicolon();
	}
	function ImportAttribute(node) {
	  this.print(node.key);
	  this.token(":");
	  this.space();
	  this.print(node.value);
	}
	function ImportNamespaceSpecifier(node) {
	  this.token("*");
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(node.local, node);
	}

	var byteLength_1 = byteLength;
	var toByteArray_1 = toByteArray;
	var fromByteArray_1 = fromByteArray;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens(b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4');
	  }

	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;
	  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
	  return [validLen, placeHoldersLen];
	}

	function byteLength(b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}

	function _byteLength(b64, validLen, placeHoldersLen) {
	  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}

	function toByteArray(b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
	  var curByte = 0;
	  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
	  var i;

	  for (i = 0; i < len; i += 4) {
	    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = tmp >> 16 & 0xFF;
	    arr[curByte++] = tmp >> 8 & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
	    arr[curByte++] = tmp >> 8 & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr;
	}

	function tripletToBase64(num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
	}

	function encodeChunk(uint8, start, end) {
	  var tmp;
	  var output = [];

	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }

	  return output.join('');
	}

	function fromByteArray(uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3;
	  var parts = [];
	  var maxChunkLength = 16383;

	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
	  }

	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
	  }

	  return parts.join('');
	}

	var base64Js = {
	  byteLength: byteLength_1,
	  toByteArray: toByteArray_1,
	  fromByteArray: fromByteArray_1
	};

	var read = function read(buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? nBytes - 1 : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];
	  i += d;
	  e = s & (1 << -nBits) - 1;
	  s >>= -nBits;
	  nBits += eLen;

	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;

	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : (s ? -1 : 1) * Infinity;
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }

	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	var write = function write(buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	  var i = isLE ? 0 : nBytes - 1;
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);

	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }

	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }

	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = e << mLen | m;
	  eLen += mLen;

	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};

	var ieee754 = {
	  read: read,
	  write: write
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */
	var buffer = createCommonjsModule(function (module, exports) {

	  exports.Buffer = Buffer;
	  exports.SlowBuffer = SlowBuffer;
	  exports.INSPECT_MAX_BYTES = 50;
	  var K_MAX_LENGTH = 0x7fffffff;
	  exports.kMaxLength = K_MAX_LENGTH;
	  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

	  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
	  }

	  function typedArraySupport() {
	    try {
	      var arr = new Uint8Array(1);
	      arr.__proto__ = {
	        __proto__: Uint8Array.prototype,
	        foo: function foo() {
	          return 42;
	        }
	      };
	      return arr.foo() === 42;
	    } catch (e) {
	      return false;
	    }
	  }

	  Object.defineProperty(Buffer.prototype, 'parent', {
	    enumerable: true,
	    get: function get() {
	      if (!Buffer.isBuffer(this)) return undefined;
	      return this.buffer;
	    }
	  });
	  Object.defineProperty(Buffer.prototype, 'offset', {
	    enumerable: true,
	    get: function get() {
	      if (!Buffer.isBuffer(this)) return undefined;
	      return this.byteOffset;
	    }
	  });

	  function createBuffer(length) {
	    if (length > K_MAX_LENGTH) {
	      throw new RangeError('The value "' + length + '" is invalid for option "size"');
	    }

	    var buf = new Uint8Array(length);
	    buf.__proto__ = Buffer.prototype;
	    return buf;
	  }

	  function Buffer(arg, encodingOrOffset, length) {
	    if (typeof arg === 'number') {
	      if (typeof encodingOrOffset === 'string') {
	        throw new TypeError('The "string" argument must be of type string. Received type number');
	      }

	      return allocUnsafe(arg);
	    }

	    return from(arg, encodingOrOffset, length);
	  }

	  if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true,
	      enumerable: false,
	      writable: false
	    });
	  }

	  Buffer.poolSize = 8192;

	  function from(value, encodingOrOffset, length) {
	    if (typeof value === 'string') {
	      return fromString(value, encodingOrOffset);
	    }

	    if (ArrayBuffer.isView(value)) {
	      return fromArrayLike(value);
	    }

	    if (value == null) {
	      throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
	    }

	    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
	      return fromArrayBuffer(value, encodingOrOffset, length);
	    }

	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type number');
	    }

	    var valueOf = value.valueOf && value.valueOf();

	    if (valueOf != null && valueOf !== value) {
	      return Buffer.from(valueOf, encodingOrOffset, length);
	    }

	    var b = fromObject(value);
	    if (b) return b;

	    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
	      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
	    }

	    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
	  }

	  Buffer.from = function (value, encodingOrOffset, length) {
	    return from(value, encodingOrOffset, length);
	  };

	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;

	  function assertSize(size) {
	    if (typeof size !== 'number') {
	      throw new TypeError('"size" argument must be of type number');
	    } else if (size < 0) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"');
	    }
	  }

	  function alloc(size, fill, encoding) {
	    assertSize(size);

	    if (size <= 0) {
	      return createBuffer(size);
	    }

	    if (fill !== undefined) {
	      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
	    }

	    return createBuffer(size);
	  }

	  Buffer.alloc = function (size, fill, encoding) {
	    return alloc(size, fill, encoding);
	  };

	  function allocUnsafe(size) {
	    assertSize(size);
	    return createBuffer(size < 0 ? 0 : checked(size) | 0);
	  }

	  Buffer.allocUnsafe = function (size) {
	    return allocUnsafe(size);
	  };

	  Buffer.allocUnsafeSlow = function (size) {
	    return allocUnsafe(size);
	  };

	  function fromString(string, encoding) {
	    if (typeof encoding !== 'string' || encoding === '') {
	      encoding = 'utf8';
	    }

	    if (!Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding);
	    }

	    var length = byteLength(string, encoding) | 0;
	    var buf = createBuffer(length);
	    var actual = buf.write(string, encoding);

	    if (actual !== length) {
	      buf = buf.slice(0, actual);
	    }

	    return buf;
	  }

	  function fromArrayLike(array) {
	    var length = array.length < 0 ? 0 : checked(array.length) | 0;
	    var buf = createBuffer(length);

	    for (var i = 0; i < length; i += 1) {
	      buf[i] = array[i] & 255;
	    }

	    return buf;
	  }

	  function fromArrayBuffer(array, byteOffset, length) {
	    if (byteOffset < 0 || array.byteLength < byteOffset) {
	      throw new RangeError('"offset" is outside of buffer bounds');
	    }

	    if (array.byteLength < byteOffset + (length || 0)) {
	      throw new RangeError('"length" is outside of buffer bounds');
	    }

	    var buf;

	    if (byteOffset === undefined && length === undefined) {
	      buf = new Uint8Array(array);
	    } else if (length === undefined) {
	      buf = new Uint8Array(array, byteOffset);
	    } else {
	      buf = new Uint8Array(array, byteOffset, length);
	    }

	    buf.__proto__ = Buffer.prototype;
	    return buf;
	  }

	  function fromObject(obj) {
	    if (Buffer.isBuffer(obj)) {
	      var len = checked(obj.length) | 0;
	      var buf = createBuffer(len);

	      if (buf.length === 0) {
	        return buf;
	      }

	      obj.copy(buf, 0, 0, len);
	      return buf;
	    }

	    if (obj.length !== undefined) {
	      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
	        return createBuffer(0);
	      }

	      return fromArrayLike(obj);
	    }

	    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
	      return fromArrayLike(obj.data);
	    }
	  }

	  function checked(length) {
	    if (length >= K_MAX_LENGTH) {
	      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
	    }

	    return length | 0;
	  }

	  function SlowBuffer(length) {
	    if (+length != length) {
	      length = 0;
	    }

	    return Buffer.alloc(+length);
	  }

	  Buffer.isBuffer = function isBuffer(b) {
	    return b != null && b._isBuffer === true && b !== Buffer.prototype;
	  };

	  Buffer.compare = function compare(a, b) {
	    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
	    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

	    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
	    }

	    if (a === b) return 0;
	    var x = a.length;
	    var y = b.length;

	    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	      if (a[i] !== b[i]) {
	        x = a[i];
	        y = b[i];
	        break;
	      }
	    }

	    if (x < y) return -1;
	    if (y < x) return 1;
	    return 0;
	  };

	  Buffer.isEncoding = function isEncoding(encoding) {
	    switch (String(encoding).toLowerCase()) {
	      case 'hex':
	      case 'utf8':
	      case 'utf-8':
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	      case 'base64':
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return true;

	      default:
	        return false;
	    }
	  };

	  Buffer.concat = function concat(list, length) {
	    if (!Array.isArray(list)) {
	      throw new TypeError('"list" argument must be an Array of Buffers');
	    }

	    if (list.length === 0) {
	      return Buffer.alloc(0);
	    }

	    var i;

	    if (length === undefined) {
	      length = 0;

	      for (i = 0; i < list.length; ++i) {
	        length += list[i].length;
	      }
	    }

	    var buffer = Buffer.allocUnsafe(length);
	    var pos = 0;

	    for (i = 0; i < list.length; ++i) {
	      var buf = list[i];

	      if (isInstance(buf, Uint8Array)) {
	        buf = Buffer.from(buf);
	      }

	      if (!Buffer.isBuffer(buf)) {
	        throw new TypeError('"list" argument must be an Array of Buffers');
	      }

	      buf.copy(buffer, pos);
	      pos += buf.length;
	    }

	    return buffer;
	  };

	  function byteLength(string, encoding) {
	    if (Buffer.isBuffer(string)) {
	      return string.length;
	    }

	    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
	      return string.byteLength;
	    }

	    if (typeof string !== 'string') {
	      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
	    }

	    var len = string.length;
	    var mustMatch = arguments.length > 2 && arguments[2] === true;
	    if (!mustMatch && len === 0) return 0;
	    var loweredCase = false;

	    for (;;) {
	      switch (encoding) {
	        case 'ascii':
	        case 'latin1':
	        case 'binary':
	          return len;

	        case 'utf8':
	        case 'utf-8':
	          return utf8ToBytes(string).length;

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return len * 2;

	        case 'hex':
	          return len >>> 1;

	        case 'base64':
	          return base64ToBytes(string).length;

	        default:
	          if (loweredCase) {
	            return mustMatch ? -1 : utf8ToBytes(string).length;
	          }

	          encoding = ('' + encoding).toLowerCase();
	          loweredCase = true;
	      }
	    }
	  }

	  Buffer.byteLength = byteLength;

	  function slowToString(encoding, start, end) {
	    var loweredCase = false;

	    if (start === undefined || start < 0) {
	      start = 0;
	    }

	    if (start > this.length) {
	      return '';
	    }

	    if (end === undefined || end > this.length) {
	      end = this.length;
	    }

	    if (end <= 0) {
	      return '';
	    }

	    end >>>= 0;
	    start >>>= 0;

	    if (end <= start) {
	      return '';
	    }

	    if (!encoding) encoding = 'utf8';

	    while (true) {
	      switch (encoding) {
	        case 'hex':
	          return hexSlice(this, start, end);

	        case 'utf8':
	        case 'utf-8':
	          return utf8Slice(this, start, end);

	        case 'ascii':
	          return asciiSlice(this, start, end);

	        case 'latin1':
	        case 'binary':
	          return latin1Slice(this, start, end);

	        case 'base64':
	          return base64Slice(this, start, end);

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return utf16leSlice(this, start, end);

	        default:
	          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	          encoding = (encoding + '').toLowerCase();
	          loweredCase = true;
	      }
	    }
	  }

	  Buffer.prototype._isBuffer = true;

	  function swap(b, n, m) {
	    var i = b[n];
	    b[n] = b[m];
	    b[m] = i;
	  }

	  Buffer.prototype.swap16 = function swap16() {
	    var len = this.length;

	    if (len % 2 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 16-bits');
	    }

	    for (var i = 0; i < len; i += 2) {
	      swap(this, i, i + 1);
	    }

	    return this;
	  };

	  Buffer.prototype.swap32 = function swap32() {
	    var len = this.length;

	    if (len % 4 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 32-bits');
	    }

	    for (var i = 0; i < len; i += 4) {
	      swap(this, i, i + 3);
	      swap(this, i + 1, i + 2);
	    }

	    return this;
	  };

	  Buffer.prototype.swap64 = function swap64() {
	    var len = this.length;

	    if (len % 8 !== 0) {
	      throw new RangeError('Buffer size must be a multiple of 64-bits');
	    }

	    for (var i = 0; i < len; i += 8) {
	      swap(this, i, i + 7);
	      swap(this, i + 1, i + 6);
	      swap(this, i + 2, i + 5);
	      swap(this, i + 3, i + 4);
	    }

	    return this;
	  };

	  Buffer.prototype.toString = function toString() {
	    var length = this.length;
	    if (length === 0) return '';
	    if (arguments.length === 0) return utf8Slice(this, 0, length);
	    return slowToString.apply(this, arguments);
	  };

	  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

	  Buffer.prototype.equals = function equals(b) {
	    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
	    if (this === b) return true;
	    return Buffer.compare(this, b) === 0;
	  };

	  Buffer.prototype.inspect = function inspect() {
	    var str = '';
	    var max = exports.INSPECT_MAX_BYTES;
	    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
	    if (this.length > max) str += ' ... ';
	    return '<Buffer ' + str + '>';
	  };

	  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
	    if (isInstance(target, Uint8Array)) {
	      target = Buffer.from(target, target.offset, target.byteLength);
	    }

	    if (!Buffer.isBuffer(target)) {
	      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
	    }

	    if (start === undefined) {
	      start = 0;
	    }

	    if (end === undefined) {
	      end = target ? target.length : 0;
	    }

	    if (thisStart === undefined) {
	      thisStart = 0;
	    }

	    if (thisEnd === undefined) {
	      thisEnd = this.length;
	    }

	    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	      throw new RangeError('out of range index');
	    }

	    if (thisStart >= thisEnd && start >= end) {
	      return 0;
	    }

	    if (thisStart >= thisEnd) {
	      return -1;
	    }

	    if (start >= end) {
	      return 1;
	    }

	    start >>>= 0;
	    end >>>= 0;
	    thisStart >>>= 0;
	    thisEnd >>>= 0;
	    if (this === target) return 0;
	    var x = thisEnd - thisStart;
	    var y = end - start;
	    var len = Math.min(x, y);
	    var thisCopy = this.slice(thisStart, thisEnd);
	    var targetCopy = target.slice(start, end);

	    for (var i = 0; i < len; ++i) {
	      if (thisCopy[i] !== targetCopy[i]) {
	        x = thisCopy[i];
	        y = targetCopy[i];
	        break;
	      }
	    }

	    if (x < y) return -1;
	    if (y < x) return 1;
	    return 0;
	  };

	  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
	    if (buffer.length === 0) return -1;

	    if (typeof byteOffset === 'string') {
	      encoding = byteOffset;
	      byteOffset = 0;
	    } else if (byteOffset > 0x7fffffff) {
	      byteOffset = 0x7fffffff;
	    } else if (byteOffset < -0x80000000) {
	      byteOffset = -0x80000000;
	    }

	    byteOffset = +byteOffset;

	    if (numberIsNaN(byteOffset)) {
	      byteOffset = dir ? 0 : buffer.length - 1;
	    }

	    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

	    if (byteOffset >= buffer.length) {
	      if (dir) return -1;else byteOffset = buffer.length - 1;
	    } else if (byteOffset < 0) {
	      if (dir) byteOffset = 0;else return -1;
	    }

	    if (typeof val === 'string') {
	      val = Buffer.from(val, encoding);
	    }

	    if (Buffer.isBuffer(val)) {
	      if (val.length === 0) {
	        return -1;
	      }

	      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
	    } else if (typeof val === 'number') {
	      val = val & 0xFF;

	      if (typeof Uint8Array.prototype.indexOf === 'function') {
	        if (dir) {
	          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
	        } else {
	          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
	        }
	      }

	      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
	    }

	    throw new TypeError('val must be string, number or Buffer');
	  }

	  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
	    var indexSize = 1;
	    var arrLength = arr.length;
	    var valLength = val.length;

	    if (encoding !== undefined) {
	      encoding = String(encoding).toLowerCase();

	      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
	        if (arr.length < 2 || val.length < 2) {
	          return -1;
	        }

	        indexSize = 2;
	        arrLength /= 2;
	        valLength /= 2;
	        byteOffset /= 2;
	      }
	    }

	    function read(buf, i) {
	      if (indexSize === 1) {
	        return buf[i];
	      } else {
	        return buf.readUInt16BE(i * indexSize);
	      }
	    }

	    var i;

	    if (dir) {
	      var foundIndex = -1;

	      for (i = byteOffset; i < arrLength; i++) {
	        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	          if (foundIndex === -1) foundIndex = i;
	          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
	        } else {
	          if (foundIndex !== -1) i -= i - foundIndex;
	          foundIndex = -1;
	        }
	      }
	    } else {
	      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

	      for (i = byteOffset; i >= 0; i--) {
	        var found = true;

	        for (var j = 0; j < valLength; j++) {
	          if (read(arr, i + j) !== read(val, j)) {
	            found = false;
	            break;
	          }
	        }

	        if (found) return i;
	      }
	    }

	    return -1;
	  }

	  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
	    return this.indexOf(val, byteOffset, encoding) !== -1;
	  };

	  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
	    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
	  };

	  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
	    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
	  };

	  function hexWrite(buf, string, offset, length) {
	    offset = Number(offset) || 0;
	    var remaining = buf.length - offset;

	    if (!length) {
	      length = remaining;
	    } else {
	      length = Number(length);

	      if (length > remaining) {
	        length = remaining;
	      }
	    }

	    var strLen = string.length;

	    if (length > strLen / 2) {
	      length = strLen / 2;
	    }

	    for (var i = 0; i < length; ++i) {
	      var parsed = parseInt(string.substr(i * 2, 2), 16);
	      if (numberIsNaN(parsed)) return i;
	      buf[offset + i] = parsed;
	    }

	    return i;
	  }

	  function utf8Write(buf, string, offset, length) {
	    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
	  }

	  function asciiWrite(buf, string, offset, length) {
	    return blitBuffer(asciiToBytes(string), buf, offset, length);
	  }

	  function latin1Write(buf, string, offset, length) {
	    return asciiWrite(buf, string, offset, length);
	  }

	  function base64Write(buf, string, offset, length) {
	    return blitBuffer(base64ToBytes(string), buf, offset, length);
	  }

	  function ucs2Write(buf, string, offset, length) {
	    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
	  }

	  Buffer.prototype.write = function write(string, offset, length, encoding) {
	    if (offset === undefined) {
	      encoding = 'utf8';
	      length = this.length;
	      offset = 0;
	    } else if (length === undefined && typeof offset === 'string') {
	      encoding = offset;
	      length = this.length;
	      offset = 0;
	    } else if (isFinite(offset)) {
	      offset = offset >>> 0;

	      if (isFinite(length)) {
	        length = length >>> 0;
	        if (encoding === undefined) encoding = 'utf8';
	      } else {
	        encoding = length;
	        length = undefined;
	      }
	    } else {
	      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
	    }

	    var remaining = this.length - offset;
	    if (length === undefined || length > remaining) length = remaining;

	    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
	      throw new RangeError('Attempt to write outside buffer bounds');
	    }

	    if (!encoding) encoding = 'utf8';
	    var loweredCase = false;

	    for (;;) {
	      switch (encoding) {
	        case 'hex':
	          return hexWrite(this, string, offset, length);

	        case 'utf8':
	        case 'utf-8':
	          return utf8Write(this, string, offset, length);

	        case 'ascii':
	          return asciiWrite(this, string, offset, length);

	        case 'latin1':
	        case 'binary':
	          return latin1Write(this, string, offset, length);

	        case 'base64':
	          return base64Write(this, string, offset, length);

	        case 'ucs2':
	        case 'ucs-2':
	        case 'utf16le':
	        case 'utf-16le':
	          return ucs2Write(this, string, offset, length);

	        default:
	          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	          encoding = ('' + encoding).toLowerCase();
	          loweredCase = true;
	      }
	    }
	  };

	  Buffer.prototype.toJSON = function toJSON() {
	    return {
	      type: 'Buffer',
	      data: Array.prototype.slice.call(this._arr || this, 0)
	    };
	  };

	  function base64Slice(buf, start, end) {
	    if (start === 0 && end === buf.length) {
	      return base64Js.fromByteArray(buf);
	    } else {
	      return base64Js.fromByteArray(buf.slice(start, end));
	    }
	  }

	  function utf8Slice(buf, start, end) {
	    end = Math.min(buf.length, end);
	    var res = [];
	    var i = start;

	    while (i < end) {
	      var firstByte = buf[i];
	      var codePoint = null;
	      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

	      if (i + bytesPerSequence <= end) {
	        var secondByte, thirdByte, fourthByte, tempCodePoint;

	        switch (bytesPerSequence) {
	          case 1:
	            if (firstByte < 0x80) {
	              codePoint = firstByte;
	            }

	            break;

	          case 2:
	            secondByte = buf[i + 1];

	            if ((secondByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

	              if (tempCodePoint > 0x7F) {
	                codePoint = tempCodePoint;
	              }
	            }

	            break;

	          case 3:
	            secondByte = buf[i + 1];
	            thirdByte = buf[i + 2];

	            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

	              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	                codePoint = tempCodePoint;
	              }
	            }

	            break;

	          case 4:
	            secondByte = buf[i + 1];
	            thirdByte = buf[i + 2];
	            fourthByte = buf[i + 3];

	            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

	              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	                codePoint = tempCodePoint;
	              }
	            }

	        }
	      }

	      if (codePoint === null) {
	        codePoint = 0xFFFD;
	        bytesPerSequence = 1;
	      } else if (codePoint > 0xFFFF) {
	        codePoint -= 0x10000;
	        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	        codePoint = 0xDC00 | codePoint & 0x3FF;
	      }

	      res.push(codePoint);
	      i += bytesPerSequence;
	    }

	    return decodeCodePointsArray(res);
	  }

	  var MAX_ARGUMENTS_LENGTH = 0x1000;

	  function decodeCodePointsArray(codePoints) {
	    var len = codePoints.length;

	    if (len <= MAX_ARGUMENTS_LENGTH) {
	      return String.fromCharCode.apply(String, codePoints);
	    }

	    var res = '';
	    var i = 0;

	    while (i < len) {
	      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
	    }

	    return res;
	  }

	  function asciiSlice(buf, start, end) {
	    var ret = '';
	    end = Math.min(buf.length, end);

	    for (var i = start; i < end; ++i) {
	      ret += String.fromCharCode(buf[i] & 0x7F);
	    }

	    return ret;
	  }

	  function latin1Slice(buf, start, end) {
	    var ret = '';
	    end = Math.min(buf.length, end);

	    for (var i = start; i < end; ++i) {
	      ret += String.fromCharCode(buf[i]);
	    }

	    return ret;
	  }

	  function hexSlice(buf, start, end) {
	    var len = buf.length;
	    if (!start || start < 0) start = 0;
	    if (!end || end < 0 || end > len) end = len;
	    var out = '';

	    for (var i = start; i < end; ++i) {
	      out += toHex(buf[i]);
	    }

	    return out;
	  }

	  function utf16leSlice(buf, start, end) {
	    var bytes = buf.slice(start, end);
	    var res = '';

	    for (var i = 0; i < bytes.length; i += 2) {
	      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	    }

	    return res;
	  }

	  Buffer.prototype.slice = function slice(start, end) {
	    var len = this.length;
	    start = ~~start;
	    end = end === undefined ? len : ~~end;

	    if (start < 0) {
	      start += len;
	      if (start < 0) start = 0;
	    } else if (start > len) {
	      start = len;
	    }

	    if (end < 0) {
	      end += len;
	      if (end < 0) end = 0;
	    } else if (end > len) {
	      end = len;
	    }

	    if (end < start) end = start;
	    var newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	    return newBuf;
	  };

	  function checkOffset(offset, ext, length) {
	    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
	    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
	  }

	  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var val = this[offset];
	    var mul = 1;
	    var i = 0;

	    while (++i < byteLength && (mul *= 0x100)) {
	      val += this[offset + i] * mul;
	    }

	    return val;
	  };

	  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      checkOffset(offset, byteLength, this.length);
	    }

	    var val = this[offset + --byteLength];
	    var mul = 1;

	    while (byteLength > 0 && (mul *= 0x100)) {
	      val += this[offset + --byteLength] * mul;
	    }

	    return val;
	  };

	  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 1, this.length);
	    return this[offset];
	  };

	  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    return this[offset] | this[offset + 1] << 8;
	  };

	  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    return this[offset] << 8 | this[offset + 1];
	  };

	  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
	  };

	  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	  };

	  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var val = this[offset];
	    var mul = 1;
	    var i = 0;

	    while (++i < byteLength && (mul *= 0x100)) {
	      val += this[offset + i] * mul;
	    }

	    mul *= 0x80;
	    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	    return val;
	  };

	  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;
	    if (!noAssert) checkOffset(offset, byteLength, this.length);
	    var i = byteLength;
	    var mul = 1;
	    var val = this[offset + --i];

	    while (i > 0 && (mul *= 0x100)) {
	      val += this[offset + --i] * mul;
	    }

	    mul *= 0x80;
	    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	    return val;
	  };

	  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 1, this.length);
	    if (!(this[offset] & 0x80)) return this[offset];
	    return (0xff - this[offset] + 1) * -1;
	  };

	  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    var val = this[offset] | this[offset + 1] << 8;
	    return val & 0x8000 ? val | 0xFFFF0000 : val;
	  };

	  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 2, this.length);
	    var val = this[offset + 1] | this[offset] << 8;
	    return val & 0x8000 ? val | 0xFFFF0000 : val;
	  };

	  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	  };

	  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	  };

	  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return ieee754.read(this, offset, true, 23, 4);
	  };

	  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 4, this.length);
	    return ieee754.read(this, offset, false, 23, 4);
	  };

	  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 8, this.length);
	    return ieee754.read(this, offset, true, 52, 8);
	  };

	  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
	    offset = offset >>> 0;
	    if (!noAssert) checkOffset(offset, 8, this.length);
	    return ieee754.read(this, offset, false, 52, 8);
	  };

	  function checkInt(buf, value, offset, ext, max, min) {
	    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
	    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
	    if (offset + ext > buf.length) throw new RangeError('Index out of range');
	  }

	  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	      checkInt(this, value, offset, byteLength, maxBytes, 0);
	    }

	    var mul = 1;
	    var i = 0;
	    this[offset] = value & 0xFF;

	    while (++i < byteLength && (mul *= 0x100)) {
	      this[offset + i] = value / mul & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    byteLength = byteLength >>> 0;

	    if (!noAssert) {
	      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	      checkInt(this, value, offset, byteLength, maxBytes, 0);
	    }

	    var i = byteLength - 1;
	    var mul = 1;
	    this[offset + i] = value & 0xFF;

	    while (--i >= 0 && (mul *= 0x100)) {
	      this[offset + i] = value / mul & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	    this[offset] = value & 0xff;
	    return offset + 1;
	  };

	  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    return offset + 2;
	  };

	  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	    return offset + 2;
	  };

	  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	    this[offset + 3] = value >>> 24;
	    this[offset + 2] = value >>> 16;
	    this[offset + 1] = value >>> 8;
	    this[offset] = value & 0xff;
	    return offset + 4;
	  };

	  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	    return offset + 4;
	  };

	  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      var limit = Math.pow(2, 8 * byteLength - 1);
	      checkInt(this, value, offset, byteLength, limit - 1, -limit);
	    }

	    var i = 0;
	    var mul = 1;
	    var sub = 0;
	    this[offset] = value & 0xFF;

	    while (++i < byteLength && (mul *= 0x100)) {
	      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	        sub = 1;
	      }

	      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      var limit = Math.pow(2, 8 * byteLength - 1);
	      checkInt(this, value, offset, byteLength, limit - 1, -limit);
	    }

	    var i = byteLength - 1;
	    var mul = 1;
	    var sub = 0;
	    this[offset + i] = value & 0xFF;

	    while (--i >= 0 && (mul *= 0x100)) {
	      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	        sub = 1;
	      }

	      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	    }

	    return offset + byteLength;
	  };

	  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	    if (value < 0) value = 0xff + value + 1;
	    this[offset] = value & 0xff;
	    return offset + 1;
	  };

	  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    return offset + 2;
	  };

	  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	    return offset + 2;
	  };

	  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    this[offset + 2] = value >>> 16;
	    this[offset + 3] = value >>> 24;
	    return offset + 4;
	  };

	  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
	    value = +value;
	    offset = offset >>> 0;
	    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	    if (value < 0) value = 0xffffffff + value + 1;
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	    return offset + 4;
	  };

	  function checkIEEE754(buf, value, offset, ext, max, min) {
	    if (offset + ext > buf.length) throw new RangeError('Index out of range');
	    if (offset < 0) throw new RangeError('Index out of range');
	  }

	  function writeFloat(buf, value, offset, littleEndian, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      checkIEEE754(buf, value, offset, 4);
	    }

	    ieee754.write(buf, value, offset, littleEndian, 23, 4);
	    return offset + 4;
	  }

	  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
	    return writeFloat(this, value, offset, true, noAssert);
	  };

	  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
	    return writeFloat(this, value, offset, false, noAssert);
	  };

	  function writeDouble(buf, value, offset, littleEndian, noAssert) {
	    value = +value;
	    offset = offset >>> 0;

	    if (!noAssert) {
	      checkIEEE754(buf, value, offset, 8);
	    }

	    ieee754.write(buf, value, offset, littleEndian, 52, 8);
	    return offset + 8;
	  }

	  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
	    return writeDouble(this, value, offset, true, noAssert);
	  };

	  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
	    return writeDouble(this, value, offset, false, noAssert);
	  };

	  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
	    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
	    if (!start) start = 0;
	    if (!end && end !== 0) end = this.length;
	    if (targetStart >= target.length) targetStart = target.length;
	    if (!targetStart) targetStart = 0;
	    if (end > 0 && end < start) end = start;
	    if (end === start) return 0;
	    if (target.length === 0 || this.length === 0) return 0;

	    if (targetStart < 0) {
	      throw new RangeError('targetStart out of bounds');
	    }

	    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
	    if (end < 0) throw new RangeError('sourceEnd out of bounds');
	    if (end > this.length) end = this.length;

	    if (target.length - targetStart < end - start) {
	      end = target.length - targetStart + start;
	    }

	    var len = end - start;

	    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
	      this.copyWithin(targetStart, start, end);
	    } else if (this === target && start < targetStart && targetStart < end) {
	      for (var i = len - 1; i >= 0; --i) {
	        target[i + targetStart] = this[i + start];
	      }
	    } else {
	      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
	    }

	    return len;
	  };

	  Buffer.prototype.fill = function fill(val, start, end, encoding) {
	    if (typeof val === 'string') {
	      if (typeof start === 'string') {
	        encoding = start;
	        start = 0;
	        end = this.length;
	      } else if (typeof end === 'string') {
	        encoding = end;
	        end = this.length;
	      }

	      if (encoding !== undefined && typeof encoding !== 'string') {
	        throw new TypeError('encoding must be a string');
	      }

	      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	        throw new TypeError('Unknown encoding: ' + encoding);
	      }

	      if (val.length === 1) {
	        var code = val.charCodeAt(0);

	        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
	          val = code;
	        }
	      }
	    } else if (typeof val === 'number') {
	      val = val & 255;
	    }

	    if (start < 0 || this.length < start || this.length < end) {
	      throw new RangeError('Out of range index');
	    }

	    if (end <= start) {
	      return this;
	    }

	    start = start >>> 0;
	    end = end === undefined ? this.length : end >>> 0;
	    if (!val) val = 0;
	    var i;

	    if (typeof val === 'number') {
	      for (i = start; i < end; ++i) {
	        this[i] = val;
	      }
	    } else {
	      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
	      var len = bytes.length;

	      if (len === 0) {
	        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
	      }

	      for (i = 0; i < end - start; ++i) {
	        this[i + start] = bytes[i % len];
	      }
	    }

	    return this;
	  };

	  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

	  function base64clean(str) {
	    str = str.split('=')[0];
	    str = str.trim().replace(INVALID_BASE64_RE, '');
	    if (str.length < 2) return '';

	    while (str.length % 4 !== 0) {
	      str = str + '=';
	    }

	    return str;
	  }

	  function toHex(n) {
	    if (n < 16) return '0' + n.toString(16);
	    return n.toString(16);
	  }

	  function utf8ToBytes(string, units) {
	    units = units || Infinity;
	    var codePoint;
	    var length = string.length;
	    var leadSurrogate = null;
	    var bytes = [];

	    for (var i = 0; i < length; ++i) {
	      codePoint = string.charCodeAt(i);

	      if (codePoint > 0xD7FF && codePoint < 0xE000) {
	        if (!leadSurrogate) {
	          if (codePoint > 0xDBFF) {
	            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	            continue;
	          } else if (i + 1 === length) {
	            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	            continue;
	          }

	          leadSurrogate = codePoint;
	          continue;
	        }

	        if (codePoint < 0xDC00) {
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          leadSurrogate = codePoint;
	          continue;
	        }

	        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	      } else if (leadSurrogate) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	      }

	      leadSurrogate = null;

	      if (codePoint < 0x80) {
	        if ((units -= 1) < 0) break;
	        bytes.push(codePoint);
	      } else if (codePoint < 0x800) {
	        if ((units -= 2) < 0) break;
	        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
	      } else if (codePoint < 0x10000) {
	        if ((units -= 3) < 0) break;
	        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	      } else if (codePoint < 0x110000) {
	        if ((units -= 4) < 0) break;
	        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	      } else {
	        throw new Error('Invalid code point');
	      }
	    }

	    return bytes;
	  }

	  function asciiToBytes(str) {
	    var byteArray = [];

	    for (var i = 0; i < str.length; ++i) {
	      byteArray.push(str.charCodeAt(i) & 0xFF);
	    }

	    return byteArray;
	  }

	  function utf16leToBytes(str, units) {
	    var c, hi, lo;
	    var byteArray = [];

	    for (var i = 0; i < str.length; ++i) {
	      if ((units -= 2) < 0) break;
	      c = str.charCodeAt(i);
	      hi = c >> 8;
	      lo = c % 256;
	      byteArray.push(lo);
	      byteArray.push(hi);
	    }

	    return byteArray;
	  }

	  function base64ToBytes(str) {
	    return base64Js.toByteArray(base64clean(str));
	  }

	  function blitBuffer(src, dst, offset, length) {
	    for (var i = 0; i < length; ++i) {
	      if (i + offset >= dst.length || i >= src.length) break;
	      dst[i + offset] = src[i];
	    }

	    return i;
	  }

	  function isInstance(obj, type) {
	    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
	  }

	  function numberIsNaN(obj) {
	    return obj !== obj;
	  }
	}, "/$$rollup_base$$/node_modules/buffer");

	var object = {};
	var hasOwnProperty$2 = object.hasOwnProperty;

	var forOwn = function forOwn(object, callback) {
	  for (var key in object) {
	    if (hasOwnProperty$2.call(object, key)) {
	      callback(key, object[key]);
	    }
	  }
	};

	var extend = function extend(destination, source) {
	  if (!source) {
	    return destination;
	  }

	  forOwn(source, function (key, value) {
	    destination[key] = value;
	  });
	  return destination;
	};

	var forEach = function forEach(array, callback) {
	  var length = array.length;
	  var index = -1;

	  while (++index < length) {
	    callback(array[index]);
	  }
	};

	var toString = object.toString;
	var isArray$1 = Array.isArray;
	var isBuffer = buffer.Buffer.isBuffer;

	var isObject = function isObject(value) {
	  return toString.call(value) == '[object Object]';
	};

	var isString = function isString(value) {
	  return typeof value == 'string' || toString.call(value) == '[object String]';
	};

	var isNumber = function isNumber(value) {
	  return typeof value == 'number' || toString.call(value) == '[object Number]';
	};

	var isFunction$2 = function isFunction(value) {
	  return typeof value == 'function';
	};

	var isMap = function isMap(value) {
	  return toString.call(value) == '[object Map]';
	};

	var isSet = function isSet(value) {
	  return toString.call(value) == '[object Set]';
	};

	var singleEscapes = {
	  '"': '\\"',
	  '\'': '\\\'',
	  '\\': '\\\\',
	  '\b': '\\b',
	  '\f': '\\f',
	  '\n': '\\n',
	  '\r': '\\r',
	  '\t': '\\t'
	};
	var regexSingleEscape = /["'\\\b\f\n\r\t]/;
	var regexDigit = /[0-9]/;
	var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

	var jsesc$1 = function jsesc(argument, options) {
	  var increaseIndentation = function increaseIndentation() {
	    oldIndent = indent;
	    ++options.indentLevel;
	    indent = options.indent.repeat(options.indentLevel);
	  };

	  var defaults = {
	    'escapeEverything': false,
	    'minimal': false,
	    'isScriptContext': false,
	    'quotes': 'single',
	    'wrap': false,
	    'es6': false,
	    'json': false,
	    'compact': true,
	    'lowercaseHex': false,
	    'numbers': 'decimal',
	    'indent': '\t',
	    'indentLevel': 0,
	    '__inline1__': false,
	    '__inline2__': false
	  };
	  var json = options && options.json;

	  if (json) {
	    defaults.quotes = 'double';
	    defaults.wrap = true;
	  }

	  options = extend(defaults, options);

	  if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
	    options.quotes = 'single';
	  }

	  var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
	  var compact = options.compact;
	  var lowercaseHex = options.lowercaseHex;
	  var indent = options.indent.repeat(options.indentLevel);
	  var oldIndent = '';
	  var inline1 = options.__inline1__;
	  var inline2 = options.__inline2__;
	  var newLine = compact ? '' : '\n';
	  var result;
	  var isEmpty = true;
	  var useBinNumbers = options.numbers == 'binary';
	  var useOctNumbers = options.numbers == 'octal';
	  var useDecNumbers = options.numbers == 'decimal';
	  var useHexNumbers = options.numbers == 'hexadecimal';

	  if (json && argument && isFunction$2(argument.toJSON)) {
	    argument = argument.toJSON();
	  }

	  if (!isString(argument)) {
	    if (isMap(argument)) {
	      if (argument.size == 0) {
	        return 'new Map()';
	      }

	      if (!compact) {
	        options.__inline1__ = true;
	        options.__inline2__ = false;
	      }

	      return 'new Map(' + jsesc(Array.from(argument), options) + ')';
	    }

	    if (isSet(argument)) {
	      if (argument.size == 0) {
	        return 'new Set()';
	      }

	      return 'new Set(' + jsesc(Array.from(argument), options) + ')';
	    }

	    if (isBuffer(argument)) {
	      if (argument.length == 0) {
	        return 'Buffer.from([])';
	      }

	      return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
	    }

	    if (isArray$1(argument)) {
	      result = [];
	      options.wrap = true;

	      if (inline1) {
	        options.__inline1__ = false;
	        options.__inline2__ = true;
	      }

	      if (!inline2) {
	        increaseIndentation();
	      }

	      forEach(argument, function (value) {
	        isEmpty = false;

	        if (inline2) {
	          options.__inline2__ = false;
	        }

	        result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
	      });

	      if (isEmpty) {
	        return '[]';
	      }

	      if (inline2) {
	        return '[' + result.join(', ') + ']';
	      }

	      return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
	    } else if (isNumber(argument)) {
	      if (json) {
	        return JSON.stringify(argument);
	      }

	      if (useDecNumbers) {
	        return String(argument);
	      }

	      if (useHexNumbers) {
	        var hexadecimal = argument.toString(16);

	        if (!lowercaseHex) {
	          hexadecimal = hexadecimal.toUpperCase();
	        }

	        return '0x' + hexadecimal;
	      }

	      if (useBinNumbers) {
	        return '0b' + argument.toString(2);
	      }

	      if (useOctNumbers) {
	        return '0o' + argument.toString(8);
	      }
	    } else if (!isObject(argument)) {
	      if (json) {
	        return JSON.stringify(argument) || 'null';
	      }

	      return String(argument);
	    } else {
	      result = [];
	      options.wrap = true;
	      increaseIndentation();
	      forOwn(argument, function (key, value) {
	        isEmpty = false;
	        result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
	      });

	      if (isEmpty) {
	        return '{}';
	      }

	      return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
	    }
	  }

	  var string = argument;
	  var index = -1;
	  var length = string.length;
	  result = '';

	  while (++index < length) {
	    var character = string.charAt(index);

	    if (options.es6) {
	      var first = string.charCodeAt(index);

	      if (first >= 0xD800 && first <= 0xDBFF && length > index + 1) {
	        var second = string.charCodeAt(index + 1);

	        if (second >= 0xDC00 && second <= 0xDFFF) {
	          var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

	          var _hexadecimal2 = codePoint.toString(16);

	          if (!lowercaseHex) {
	            _hexadecimal2 = _hexadecimal2.toUpperCase();
	          }

	          result += "\\u{" + _hexadecimal2 + '}';
	          ++index;
	          continue;
	        }
	      }
	    }

	    if (!options.escapeEverything) {
	      if (regexWhitelist.test(character)) {
	        result += character;
	        continue;
	      }

	      if (character == '"') {
	        result += quote == character ? '\\"' : character;
	        continue;
	      }

	      if (character == '`') {
	        result += quote == character ? '\\`' : character;
	        continue;
	      }

	      if (character == '\'') {
	        result += quote == character ? '\\\'' : character;
	        continue;
	      }
	    }

	    if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
	      result += '\\0';
	      continue;
	    }

	    if (regexSingleEscape.test(character)) {
	      result += singleEscapes[character];
	      continue;
	    }

	    var charCode = character.charCodeAt(0);

	    if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
	      result += character;
	      continue;
	    }

	    var _hexadecimal = charCode.toString(16);

	    if (!lowercaseHex) {
	      _hexadecimal = _hexadecimal.toUpperCase();
	    }

	    var longhand = _hexadecimal.length > 2 || json;

	    var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

	    result += escaped;
	    continue;
	  }

	  if (options.wrap) {
	    result = quote + result + quote;
	  }

	  if (quote == '`') {
	    result = result.replace(/\$\{/g, '\\\$\{');
	  }

	  if (options.isScriptContext) {
	    return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
	  }

	  return result;
	};

	jsesc$1.version = '2.5.2';
	var jsesc_1 = jsesc$1;

	var jsesc = jsesc_1;

	var isAssignmentPattern$3 = isAssignmentPattern$4,
	    isIdentifier$b = isIdentifier$g;
	function Identifier(node) {
	  var _this = this;

	  this.exactSource(node.loc, function () {
	    _this.word(node.name);
	  });
	}
	function ArgumentPlaceholder() {
	  this.token("?");
	}
	function RestElement$1(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}
	function ObjectExpression$1(node) {
	  var props = node.properties;
	  this.token("{");
	  this.printInnerComments(node);

	  if (props.length) {
	    this.space();
	    this.printList(props, node, {
	      indent: true,
	      statement: true
	    });
	    this.space();
	  }

	  this.token("}");
	}
	function ObjectMethod(node) {
	  this.printJoin(node.decorators, node);

	  this._methodHead(node);

	  this.space();
	  this.print(node.body, node);
	}
	function ObjectProperty(node) {
	  this.printJoin(node.decorators, node);

	  if (node.computed) {
	    this.token("[");
	    this.print(node.key, node);
	    this.token("]");
	  } else {
	    if (isAssignmentPattern$3(node.value) && isIdentifier$b(node.key) && node.key.name === node.value.left.name) {
	      this.print(node.value, node);
	      return;
	    }

	    this.print(node.key, node);

	    if (node.shorthand && isIdentifier$b(node.key) && isIdentifier$b(node.value) && node.key.name === node.value.name) {
	      return;
	    }
	  }

	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}
	function ArrayExpression$1(node) {
	  var elems = node.elements;
	  var len = elems.length;
	  this.token("[");
	  this.printInnerComments(node);

	  for (var i = 0; i < elems.length; i++) {
	    var elem = elems[i];

	    if (elem) {
	      if (i > 0) this.space();
	      this.print(elem, node);
	      if (i < len - 1) this.token(",");
	    } else {
	      this.token(",");
	    }
	  }

	  this.token("]");
	}
	function RecordExpression(node) {
	  var props = node.properties;
	  var startToken;
	  var endToken;

	  if (this.format.recordAndTupleSyntaxType === "bar") {
	    startToken = "{|";
	    endToken = "|}";
	  } else if (this.format.recordAndTupleSyntaxType === "hash") {
	    startToken = "#{";
	    endToken = "}";
	  } else {
	    throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
	  }

	  this.token(startToken);
	  this.printInnerComments(node);

	  if (props.length) {
	    this.space();
	    this.printList(props, node, {
	      indent: true,
	      statement: true
	    });
	    this.space();
	  }

	  this.token(endToken);
	}
	function TupleExpression(node) {
	  var elems = node.elements;
	  var len = elems.length;
	  var startToken;
	  var endToken;

	  if (this.format.recordAndTupleSyntaxType === "bar") {
	    startToken = "[|";
	    endToken = "|]";
	  } else if (this.format.recordAndTupleSyntaxType === "hash") {
	    startToken = "#[";
	    endToken = "]";
	  } else {
	    throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
	  }

	  this.token(startToken);
	  this.printInnerComments(node);

	  for (var i = 0; i < elems.length; i++) {
	    var elem = elems[i];

	    if (elem) {
	      if (i > 0) this.space();
	      this.print(elem, node);
	      if (i < len - 1) this.token(",");
	    }
	  }

	  this.token(endToken);
	}
	function RegExpLiteral$1(node) {
	  this.word("/" + node.pattern + "/" + node.flags);
	}
	function BooleanLiteral$1(node) {
	  this.word(node.value ? "true" : "false");
	}
	function NullLiteral$1() {
	  this.word("null");
	}
	function NumericLiteral$2(node) {
	  var raw = this.getPossibleRaw(node);
	  var opts = this.format.jsescOption;
	  var value = node.value + "";

	  if (opts.numbers) {
	    this.number(jsesc(node.value, opts));
	  } else if (raw == null) {
	    this.number(value);
	  } else if (this.format.minified) {
	    this.number(raw.length < value.length ? raw : value);
	  } else {
	    this.number(raw);
	  }
	}
	function StringLiteral$2(node) {
	  var raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.token(raw);
	    return;
	  }

	  var val = jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
	    json: true
	  }));
	  return this.token(val);
	}
	function BigIntLiteral(node) {
	  var raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.word(raw);
	    return;
	  }

	  this.word(node.value + "n");
	}
	function DecimalLiteral(node) {
	  var raw = this.getPossibleRaw(node);

	  if (!this.format.minified && raw != null) {
	    this.word(raw);
	    return;
	  }

	  this.word(node.value + "m");
	}
	var validTopicTokenSet = new Set(["^", "%", "#"]);
	function TopicReference() {
	  var topicToken = this.format.topicToken;

	  if (validTopicTokenSet.has(topicToken)) {
	    this.token(topicToken);
	  } else {
	    var givenTopicTokenJSON = JSON.stringify(topicToken);
	    var validTopics = Array.from(validTopicTokenSet, function (v) {
	      return JSON.stringify(v);
	    });
	    throw new Error("The \"topicToken\" generator option must be one of " + (validTopics.join(", ") + " (" + givenTopicTokenJSON + " received instead)."));
	  }
	}
	function PipelineTopicExpression(node) {
	  this.print(node.expression, node);
	}
	function PipelineBareFunction(node) {
	  this.print(node.callee, node);
	}
	function PipelinePrimaryTopicReference() {
	  this.token("#");
	}

	var isDeclareExportDeclaration = isDeclareExportDeclaration$1,
	    isStatement$3 = isStatement$7;
	function AnyTypeAnnotation() {
	  this.word("any");
	}
	function ArrayTypeAnnotation(node) {
	  this.print(node.elementType, node);
	  this.token("[");
	  this.token("]");
	}
	function BooleanTypeAnnotation() {
	  this.word("boolean");
	}
	function BooleanLiteralTypeAnnotation(node) {
	  this.word(node.value ? "true" : "false");
	}
	function NullLiteralTypeAnnotation() {
	  this.word("null");
	}
	function DeclareClass(node, parent) {
	  if (!isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("class");
	  this.space();

	  this._interfaceish(node);
	}
	function DeclareFunction(node, parent) {
	  if (!isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("function");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation.typeAnnotation, node);

	  if (node.predicate) {
	    this.space();
	    this.print(node.predicate, node);
	  }

	  this.semicolon();
	}
	function InferredPredicate() {
	  this.token("%");
	  this.word("checks");
	}
	function DeclaredPredicate(node) {
	  this.token("%");
	  this.word("checks");
	  this.token("(");
	  this.print(node.value, node);
	  this.token(")");
	}
	function DeclareInterface(node) {
	  this.word("declare");
	  this.space();
	  this.InterfaceDeclaration(node);
	}
	function DeclareModule(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.space();
	  this.print(node.id, node);
	  this.space();
	  this.print(node.body, node);
	}
	function DeclareModuleExports(node) {
	  this.word("declare");
	  this.space();
	  this.word("module");
	  this.token(".");
	  this.word("exports");
	  this.print(node.typeAnnotation, node);
	}
	function DeclareTypeAlias(node) {
	  this.word("declare");
	  this.space();
	  this.TypeAlias(node);
	}
	function DeclareOpaqueType(node, parent) {
	  if (!isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.OpaqueType(node);
	}
	function DeclareVariable(node, parent) {
	  if (!isDeclareExportDeclaration(parent)) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("var");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.id.typeAnnotation, node);
	  this.semicolon();
	}
	function DeclareExportDeclaration(node) {
	  this.word("declare");
	  this.space();
	  this.word("export");
	  this.space();

	  if (node["default"]) {
	    this.word("default");
	    this.space();
	  }

	  FlowExportDeclaration.apply(this, arguments);
	}
	function DeclareExportAllDeclaration() {
	  this.word("declare");
	  this.space();
	  ExportAllDeclaration.apply(this, arguments);
	}
	function EnumDeclaration(node) {
	  var id = node.id,
	      body = node.body;
	  this.word("enum");
	  this.space();
	  this.print(id, node);
	  this.print(body, node);
	}

	function enumExplicitType(context, name, hasExplicitType) {
	  if (hasExplicitType) {
	    context.space();
	    context.word("of");
	    context.space();
	    context.word(name);
	  }

	  context.space();
	}

	function enumBody(context, node) {
	  var members = node.members;
	  context.token("{");
	  context.indent();
	  context.newline();

	  for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
	    var member = _step.value;
	    context.print(member, node);
	    context.newline();
	  }

	  if (node.hasUnknownMembers) {
	    context.token("...");
	    context.newline();
	  }

	  context.dedent();
	  context.token("}");
	}

	function EnumBooleanBody(node) {
	  var explicitType = node.explicitType;
	  enumExplicitType(this, "boolean", explicitType);
	  enumBody(this, node);
	}
	function EnumNumberBody(node) {
	  var explicitType = node.explicitType;
	  enumExplicitType(this, "number", explicitType);
	  enumBody(this, node);
	}
	function EnumStringBody(node) {
	  var explicitType = node.explicitType;
	  enumExplicitType(this, "string", explicitType);
	  enumBody(this, node);
	}
	function EnumSymbolBody(node) {
	  enumExplicitType(this, "symbol", true);
	  enumBody(this, node);
	}
	function EnumDefaultedMember(node) {
	  var id = node.id;
	  this.print(id, node);
	  this.token(",");
	}

	function enumInitializedMember(context, node) {
	  var id = node.id,
	      init = node.init;
	  context.print(id, node);
	  context.space();
	  context.token("=");
	  context.space();
	  context.print(init, node);
	  context.token(",");
	}

	function EnumBooleanMember(node) {
	  enumInitializedMember(this, node);
	}
	function EnumNumberMember(node) {
	  enumInitializedMember(this, node);
	}
	function EnumStringMember(node) {
	  enumInitializedMember(this, node);
	}

	function FlowExportDeclaration(node) {
	  if (node.declaration) {
	    var declar = node.declaration;
	    this.print(declar, node);
	    if (!isStatement$3(declar)) this.semicolon();
	  } else {
	    this.token("{");

	    if (node.specifiers.length) {
	      this.space();
	      this.printList(node.specifiers, node);
	      this.space();
	    }

	    this.token("}");

	    if (node.source) {
	      this.space();
	      this.word("from");
	      this.space();
	      this.print(node.source, node);
	    }

	    this.semicolon();
	  }
	}

	function ExistsTypeAnnotation() {
	  this.token("*");
	}
	function FunctionTypeAnnotation(node, parent) {
	  this.print(node.typeParameters, node);
	  this.token("(");

	  if (node["this"]) {
	    this.word("this");
	    this.token(":");
	    this.space();
	    this.print(node["this"].typeAnnotation, node);

	    if (node.params.length || node.rest) {
	      this.token(",");
	      this.space();
	    }
	  }

	  this.printList(node.params, node);

	  if (node.rest) {
	    if (node.params.length) {
	      this.token(",");
	      this.space();
	    }

	    this.token("...");
	    this.print(node.rest, node);
	  }

	  this.token(")");

	  if (parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method)) {
	    this.token(":");
	  } else {
	    this.space();
	    this.token("=>");
	  }

	  this.space();
	  this.print(node.returnType, node);
	}
	function FunctionTypeParam(node) {
	  this.print(node.name, node);
	  if (node.optional) this.token("?");

	  if (node.name) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.typeAnnotation, node);
	}
	function InterfaceExtends(node) {
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	}
	function _interfaceish(node) {
	  var _node$extends;

	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if ((_node$extends = node["extends"]) != null && _node$extends.length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(node["extends"], node);
	  }

	  if (node.mixins && node.mixins.length) {
	    this.space();
	    this.word("mixins");
	    this.space();
	    this.printList(node.mixins, node);
	  }

	  if (node["implements"] && node["implements"].length) {
	    this.space();
	    this.word("implements");
	    this.space();
	    this.printList(node["implements"], node);
	  }

	  this.space();
	  this.print(node.body, node);
	}
	function _variance(node) {
	  if (node.variance) {
	    if (node.variance.kind === "plus") {
	      this.token("+");
	    } else if (node.variance.kind === "minus") {
	      this.token("-");
	    }
	  }
	}
	function InterfaceDeclaration(node) {
	  this.word("interface");
	  this.space();

	  this._interfaceish(node);
	}

	function andSeparator() {
	  this.space();
	  this.token("&");
	  this.space();
	}

	function InterfaceTypeAnnotation(node) {
	  this.word("interface");

	  if (node["extends"] && node["extends"].length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(node["extends"], node);
	  }

	  this.space();
	  this.print(node.body, node);
	}
	function IntersectionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: andSeparator
	  });
	}
	function MixedTypeAnnotation() {
	  this.word("mixed");
	}
	function EmptyTypeAnnotation() {
	  this.word("empty");
	}
	function NullableTypeAnnotation(node) {
	  this.token("?");
	  this.print(node.typeAnnotation, node);
	}
	function NumberTypeAnnotation() {
	  this.word("number");
	}
	function StringTypeAnnotation() {
	  this.word("string");
	}
	function ThisTypeAnnotation() {
	  this.word("this");
	}
	function TupleTypeAnnotation(node) {
	  this.token("[");
	  this.printList(node.types, node);
	  this.token("]");
	}
	function TypeofTypeAnnotation(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.argument, node);
	}
	function TypeAlias(node) {
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.right, node);
	  this.semicolon();
	}
	function TypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}
	function TypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}
	function TypeParameter(node) {
	  this._variance(node);

	  this.word(node.name);

	  if (node.bound) {
	    this.print(node.bound, node);
	  }

	  if (node["default"]) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node["default"], node);
	  }
	}
	function OpaqueType(node) {
	  this.word("opaque");
	  this.space();
	  this.word("type");
	  this.space();
	  this.print(node.id, node);
	  this.print(node.typeParameters, node);

	  if (node.supertype) {
	    this.token(":");
	    this.space();
	    this.print(node.supertype, node);
	  }

	  if (node.impltype) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node.impltype, node);
	  }

	  this.semicolon();
	}
	function ObjectTypeAnnotation(node) {
	  var _this = this;

	  if (node.exact) {
	    this.token("{|");
	  } else {
	    this.token("{");
	  }

	  var props = [].concat(_toConsumableArray(node.properties), _toConsumableArray(node.callProperties || []), _toConsumableArray(node.indexers || []), _toConsumableArray(node.internalSlots || []));

	  if (props.length) {
	    this.space();
	    this.printJoin(props, node, {
	      addNewlines: function addNewlines(leading) {
	        if (leading && !props[0]) return 1;
	      },
	      indent: true,
	      statement: true,
	      iterator: function iterator() {
	        if (props.length !== 1 || node.inexact) {
	          _this.token(",");

	          _this.space();
	        }
	      }
	    });
	    this.space();
	  }

	  if (node.inexact) {
	    this.indent();
	    this.token("...");

	    if (props.length) {
	      this.newline();
	    }

	    this.dedent();
	  }

	  if (node.exact) {
	    this.token("|}");
	  } else {
	    this.token("}");
	  }
	}
	function ObjectTypeInternalSlot(node) {
	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  this.token("[");
	  this.token("[");
	  this.print(node.id, node);
	  this.token("]");
	  this.token("]");
	  if (node.optional) this.token("?");

	  if (!node.method) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.value, node);
	}
	function ObjectTypeCallProperty(node) {
	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  this.print(node.value, node);
	}
	function ObjectTypeIndexer(node) {
	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  this._variance(node);

	  this.token("[");

	  if (node.id) {
	    this.print(node.id, node);
	    this.token(":");
	    this.space();
	  }

	  this.print(node.key, node);
	  this.token("]");
	  this.token(":");
	  this.space();
	  this.print(node.value, node);
	}
	function ObjectTypeProperty(node) {
	  if (node.proto) {
	    this.word("proto");
	    this.space();
	  }

	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  if (node.kind === "get" || node.kind === "set") {
	    this.word(node.kind);
	    this.space();
	  }

	  this._variance(node);

	  this.print(node.key, node);
	  if (node.optional) this.token("?");

	  if (!node.method) {
	    this.token(":");
	    this.space();
	  }

	  this.print(node.value, node);
	}
	function ObjectTypeSpreadProperty(node) {
	  this.token("...");
	  this.print(node.argument, node);
	}
	function QualifiedTypeIdentifier(node) {
	  this.print(node.qualification, node);
	  this.token(".");
	  this.print(node.id, node);
	}
	function SymbolTypeAnnotation() {
	  this.word("symbol");
	}

	function orSeparator() {
	  this.space();
	  this.token("|");
	  this.space();
	}

	function UnionTypeAnnotation(node) {
	  this.printJoin(node.types, node, {
	    separator: orSeparator
	  });
	}
	function TypeCastExpression$1(node) {
	  this.token("(");
	  this.print(node.expression, node);
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}
	function Variance(node) {
	  if (node.kind === "plus") {
	    this.token("+");
	  } else {
	    this.token("-");
	  }
	}
	function VoidTypeAnnotation() {
	  this.word("void");
	}
	function IndexedAccessType(node) {
	  this.print(node.objectType, node);
	  this.token("[");
	  this.print(node.indexType, node);
	  this.token("]");
	}
	function OptionalIndexedAccessType(node) {
	  this.print(node.objectType, node);

	  if (node.optional) {
	    this.token("?.");
	  }

	  this.token("[");
	  this.print(node.indexType, node);
	  this.token("]");
	}

	function File$1(node) {
	  if (node.program) {
	    this.print(node.program.interpreter, node);
	  }

	  this.print(node.program, node);
	}
	function Program(node) {
	  this.printInnerComments(node, false);
	  this.printSequence(node.directives, node);
	  if (node.directives && node.directives.length) this.newline();
	  this.printSequence(node.body, node);
	}
	function BlockStatement(node) {
	  var _node$directives;

	  this.token("{");
	  this.printInnerComments(node);
	  var hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;

	  if (node.body.length || hasDirectives) {
	    this.newline();
	    this.printSequence(node.directives, node, {
	      indent: true
	    });
	    if (hasDirectives) this.newline();
	    this.printSequence(node.body, node, {
	      indent: true
	    });
	    this.removeTrailingNewline();
	    this.source("end", node.loc);
	    if (!this.endsWith(10)) this.newline();
	    this.rightBrace();
	  } else {
	    this.source("end", node.loc);
	    this.token("}");
	  }
	}
	function Directive(node) {
	  this.print(node.value, node);
	  this.semicolon();
	}
	var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
	var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
	function DirectiveLiteral(node) {
	  var raw = this.getPossibleRaw(node);

	  if (raw != null) {
	    this.token(raw);
	    return;
	  }

	  var value = node.value;

	  if (!unescapedDoubleQuoteRE.test(value)) {
	    this.token("\"" + value + "\"");
	  } else if (!unescapedSingleQuoteRE.test(value)) {
	    this.token("'" + value + "'");
	  } else {
	    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
	  }
	}
	function InterpreterDirective(node) {
	  this.token("#!" + node.value + "\n");
	}
	function Placeholder(node) {
	  this.token("%%");
	  this.print(node.name);
	  this.token("%%");

	  if (node.expectedNode === "Statement") {
	    this.semicolon();
	  }
	}

	function JSXAttribute(node) {
	  this.print(node.name, node);

	  if (node.value) {
	    this.token("=");
	    this.print(node.value, node);
	  }
	}
	function JSXIdentifier$1(node) {
	  this.word(node.name);
	}
	function JSXNamespacedName(node) {
	  this.print(node.namespace, node);
	  this.token(":");
	  this.print(node.name, node);
	}
	function JSXMemberExpression(node) {
	  this.print(node.object, node);
	  this.token(".");
	  this.print(node.property, node);
	}
	function JSXSpreadAttribute(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.argument, node);
	  this.token("}");
	}
	function JSXExpressionContainer(node) {
	  this.token("{");
	  this.print(node.expression, node);
	  this.token("}");
	}
	function JSXSpreadChild(node) {
	  this.token("{");
	  this.token("...");
	  this.print(node.expression, node);
	  this.token("}");
	}
	function JSXText$1(node) {
	  var raw = this.getPossibleRaw(node);

	  if (raw != null) {
	    this.token(raw);
	  } else {
	    this.token(node.value);
	  }
	}
	function JSXElement(node) {
	  var open = node.openingElement;
	  this.print(open, node);
	  if (open.selfClosing) return;
	  this.indent();

	  for (var _iterator = _createForOfIteratorHelperLoose(node.children), _step; !(_step = _iterator()).done;) {
	    var child = _step.value;
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingElement, node);
	}

	function spaceSeparator() {
	  this.space();
	}

	function JSXOpeningElement(node) {
	  this.token("<");
	  this.print(node.name, node);
	  this.print(node.typeParameters, node);

	  if (node.attributes.length > 0) {
	    this.space();
	    this.printJoin(node.attributes, node, {
	      separator: spaceSeparator
	    });
	  }

	  if (node.selfClosing) {
	    this.space();
	    this.token("/>");
	  } else {
	    this.token(">");
	  }
	}
	function JSXClosingElement(node) {
	  this.token("</");
	  this.print(node.name, node);
	  this.token(">");
	}
	function JSXEmptyExpression(node) {
	  this.printInnerComments(node);
	}
	function JSXFragment(node) {
	  this.print(node.openingFragment, node);
	  this.indent();

	  for (var _iterator2 = _createForOfIteratorHelperLoose(node.children), _step2; !(_step2 = _iterator2()).done;) {
	    var child = _step2.value;
	    this.print(child, node);
	  }

	  this.dedent();
	  this.print(node.closingFragment, node);
	}
	function JSXOpeningFragment() {
	  this.token("<");
	  this.token(">");
	}
	function JSXClosingFragment() {
	  this.token("</");
	  this.token(">");
	}

	function TSTypeAnnotation(node) {
	  this.token(":");
	  this.space();
	  if (node.optional) this.token("?");
	  this.print(node.typeAnnotation, node);
	}
	function TSTypeParameterInstantiation(node) {
	  this.token("<");
	  this.printList(node.params, node, {});
	  this.token(">");
	}
	function TSTypeParameter(node) {
	  this.word(node.name);

	  if (node.constraint) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.print(node.constraint, node);
	  }

	  if (node["default"]) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(node["default"], node);
	  }
	}
	function TSParameterProperty(node) {
	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node.readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this._param(node.parameter);
	}
	function TSDeclareFunction(node) {
	  if (node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  this._functionHead(node);

	  this.token(";");
	}
	function TSDeclareMethod(node) {
	  this._classMethodHead(node);

	  this.token(";");
	}
	function TSQualifiedName(node) {
	  this.print(node.left, node);
	  this.token(".");
	  this.print(node.right, node);
	}
	function TSCallSignatureDeclaration(node) {
	  this.tsPrintSignatureDeclarationBase(node);
	  this.token(";");
	}
	function TSConstructSignatureDeclaration(node) {
	  this.word("new");
	  this.space();
	  this.tsPrintSignatureDeclarationBase(node);
	  this.token(";");
	}
	function TSPropertySignature(node) {
	  var readonly = node.readonly,
	      initializer = node.initializer;

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.tsPrintPropertyOrMethodName(node);
	  this.print(node.typeAnnotation, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(";");
	}
	function tsPrintPropertyOrMethodName(node) {
	  if (node.computed) {
	    this.token("[");
	  }

	  this.print(node.key, node);

	  if (node.computed) {
	    this.token("]");
	  }

	  if (node.optional) {
	    this.token("?");
	  }
	}
	function TSMethodSignature(node) {
	  var kind = node.kind;

	  if (kind === "set" || kind === "get") {
	    this.word(kind);
	    this.space();
	  }

	  this.tsPrintPropertyOrMethodName(node);
	  this.tsPrintSignatureDeclarationBase(node);
	  this.token(";");
	}
	function TSIndexSignature(node) {
	  var readonly = node.readonly,
	      isStatic = node["static"];

	  if (isStatic) {
	    this.word("static");
	    this.space();
	  }

	  if (readonly) {
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");

	  this._parameters(node.parameters, node);

	  this.token("]");
	  this.print(node.typeAnnotation, node);
	  this.token(";");
	}
	function TSAnyKeyword() {
	  this.word("any");
	}
	function TSBigIntKeyword() {
	  this.word("bigint");
	}
	function TSUnknownKeyword() {
	  this.word("unknown");
	}
	function TSNumberKeyword() {
	  this.word("number");
	}
	function TSObjectKeyword() {
	  this.word("object");
	}
	function TSBooleanKeyword() {
	  this.word("boolean");
	}
	function TSStringKeyword() {
	  this.word("string");
	}
	function TSSymbolKeyword() {
	  this.word("symbol");
	}
	function TSVoidKeyword() {
	  this.word("void");
	}
	function TSUndefinedKeyword() {
	  this.word("undefined");
	}
	function TSNullKeyword() {
	  this.word("null");
	}
	function TSNeverKeyword() {
	  this.word("never");
	}
	function TSIntrinsicKeyword() {
	  this.word("intrinsic");
	}
	function TSThisType() {
	  this.word("this");
	}
	function TSFunctionType(node) {
	  this.tsPrintFunctionOrConstructorType(node);
	}
	function TSConstructorType(node) {
	  if (node["abstract"]) {
	    this.word("abstract");
	    this.space();
	  }

	  this.word("new");
	  this.space();
	  this.tsPrintFunctionOrConstructorType(node);
	}
	function tsPrintFunctionOrConstructorType(node) {
	  var typeParameters = node.typeParameters,
	      parameters = node.parameters;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.space();
	  this.token("=>");
	  this.space();
	  this.print(node.typeAnnotation.typeAnnotation, node);
	}
	function TSTypeReference(node) {
	  this.print(node.typeName, node);
	  this.print(node.typeParameters, node);
	}
	function TSTypePredicate(node) {
	  if (node.asserts) {
	    this.word("asserts");
	    this.space();
	  }

	  this.print(node.parameterName);

	  if (node.typeAnnotation) {
	    this.space();
	    this.word("is");
	    this.space();
	    this.print(node.typeAnnotation.typeAnnotation);
	  }
	}
	function TSTypeQuery(node) {
	  this.word("typeof");
	  this.space();
	  this.print(node.exprName);
	}
	function TSTypeLiteral(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
	}
	function tsPrintTypeLiteralOrInterfaceBody(members, node) {
	  this.tsPrintBraced(members, node);
	}
	function tsPrintBraced(members, node) {
	  this.token("{");

	  if (members.length) {
	    this.indent();
	    this.newline();

	    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
	      var member = _step.value;
	      this.print(member, node);
	      this.newline();
	    }

	    this.dedent();
	    this.rightBrace();
	  } else {
	    this.token("}");
	  }
	}
	function TSArrayType(node) {
	  this.print(node.elementType, node);
	  this.token("[]");
	}
	function TSTupleType(node) {
	  this.token("[");
	  this.printList(node.elementTypes, node);
	  this.token("]");
	}
	function TSOptionalType(node) {
	  this.print(node.typeAnnotation, node);
	  this.token("?");
	}
	function TSRestType(node) {
	  this.token("...");
	  this.print(node.typeAnnotation, node);
	}
	function TSNamedTupleMember(node) {
	  this.print(node.label, node);
	  if (node.optional) this.token("?");
	  this.token(":");
	  this.space();
	  this.print(node.elementType, node);
	}
	function TSUnionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "|");
	}
	function TSIntersectionType(node) {
	  this.tsPrintUnionOrIntersectionType(node, "&");
	}
	function tsPrintUnionOrIntersectionType(node, sep) {
	  this.printJoin(node.types, node, {
	    separator: function separator() {
	      this.space();
	      this.token(sep);
	      this.space();
	    }
	  });
	}
	function TSConditionalType(node) {
	  this.print(node.checkType);
	  this.space();
	  this.word("extends");
	  this.space();
	  this.print(node.extendsType);
	  this.space();
	  this.token("?");
	  this.space();
	  this.print(node.trueType);
	  this.space();
	  this.token(":");
	  this.space();
	  this.print(node.falseType);
	}
	function TSInferType(node) {
	  this.token("infer");
	  this.space();
	  this.print(node.typeParameter);
	}
	function TSParenthesizedType(node) {
	  this.token("(");
	  this.print(node.typeAnnotation, node);
	  this.token(")");
	}
	function TSTypeOperator(node) {
	  this.word(node.operator);
	  this.space();
	  this.print(node.typeAnnotation, node);
	}
	function TSIndexedAccessType(node) {
	  this.print(node.objectType, node);
	  this.token("[");
	  this.print(node.indexType, node);
	  this.token("]");
	}
	function TSMappedType(node) {
	  var nameType = node.nameType,
	      optional = node.optional,
	      readonly = node.readonly,
	      typeParameter = node.typeParameter;
	  this.token("{");
	  this.space();

	  if (readonly) {
	    tokenIfPlusMinus(this, readonly);
	    this.word("readonly");
	    this.space();
	  }

	  this.token("[");
	  this.word(typeParameter.name);
	  this.space();
	  this.word("in");
	  this.space();
	  this.print(typeParameter.constraint, typeParameter);

	  if (nameType) {
	    this.space();
	    this.word("as");
	    this.space();
	    this.print(nameType, node);
	  }

	  this.token("]");

	  if (optional) {
	    tokenIfPlusMinus(this, optional);
	    this.token("?");
	  }

	  this.token(":");
	  this.space();
	  this.print(node.typeAnnotation, node);
	  this.space();
	  this.token("}");
	}

	function tokenIfPlusMinus(self, tok) {
	  if (tok !== true) {
	    self.token(tok);
	  }
	}

	function TSLiteralType(node) {
	  this.print(node.literal, node);
	}
	function TSExpressionWithTypeArguments(node) {
	  this.print(node.expression, node);
	  this.print(node.typeParameters, node);
	}
	function TSInterfaceDeclaration(node) {
	  var declare = node.declare,
	      id = node.id,
	      typeParameters = node.typeParameters,
	      extendz = node["extends"],
	      body = node.body;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("interface");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);

	  if (extendz != null && extendz.length) {
	    this.space();
	    this.word("extends");
	    this.space();
	    this.printList(extendz, node);
	  }

	  this.space();
	  this.print(body, node);
	}
	function TSInterfaceBody(node) {
	  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
	}
	function TSTypeAliasDeclaration(node) {
	  var declare = node.declare,
	      id = node.id,
	      typeParameters = node.typeParameters,
	      typeAnnotation = node.typeAnnotation;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  this.word("type");
	  this.space();
	  this.print(id, node);
	  this.print(typeParameters, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(typeAnnotation, node);
	  this.token(";");
	}
	function TSAsExpression(node) {
	  var expression = node.expression,
	      typeAnnotation = node.typeAnnotation;
	  this.print(expression, node);
	  this.space();
	  this.word("as");
	  this.space();
	  this.print(typeAnnotation, node);
	}
	function TSTypeAssertion(node) {
	  var typeAnnotation = node.typeAnnotation,
	      expression = node.expression;
	  this.token("<");
	  this.print(typeAnnotation, node);
	  this.token(">");
	  this.space();
	  this.print(expression, node);
	}
	function TSEnumDeclaration(node) {
	  var declare = node.declare,
	      isConst = node["const"],
	      id = node.id,
	      members = node.members;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (isConst) {
	    this.word("const");
	    this.space();
	  }

	  this.word("enum");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.tsPrintBraced(members, node);
	}
	function TSEnumMember(node) {
	  var id = node.id,
	      initializer = node.initializer;
	  this.print(id, node);

	  if (initializer) {
	    this.space();
	    this.token("=");
	    this.space();
	    this.print(initializer, node);
	  }

	  this.token(",");
	}
	function TSModuleDeclaration(node) {
	  var declare = node.declare,
	      id = node.id;

	  if (declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (!node.global) {
	    this.word(id.type === "Identifier" ? "namespace" : "module");
	    this.space();
	  }

	  this.print(id, node);

	  if (!node.body) {
	    this.token(";");
	    return;
	  }

	  var body = node.body;

	  while (body.type === "TSModuleDeclaration") {
	    this.token(".");
	    this.print(body.id, body);
	    body = body.body;
	  }

	  this.space();
	  this.print(body, node);
	}
	function TSModuleBlock(node) {
	  this.tsPrintBraced(node.body, node);
	}
	function TSImportType(node) {
	  var argument = node.argument,
	      qualifier = node.qualifier,
	      typeParameters = node.typeParameters;
	  this.word("import");
	  this.token("(");
	  this.print(argument, node);
	  this.token(")");

	  if (qualifier) {
	    this.token(".");
	    this.print(qualifier, node);
	  }

	  if (typeParameters) {
	    this.print(typeParameters, node);
	  }
	}
	function TSImportEqualsDeclaration(node) {
	  var isExport = node.isExport,
	      id = node.id,
	      moduleReference = node.moduleReference;

	  if (isExport) {
	    this.word("export");
	    this.space();
	  }

	  this.word("import");
	  this.space();
	  this.print(id, node);
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(moduleReference, node);
	  this.token(";");
	}
	function TSExternalModuleReference(node) {
	  this.token("require(");
	  this.print(node.expression, node);
	  this.token(")");
	}
	function TSNonNullExpression(node) {
	  this.print(node.expression, node);
	  this.token("!");
	}
	function TSExportAssignment(node) {
	  this.word("export");
	  this.space();
	  this.token("=");
	  this.space();
	  this.print(node.expression, node);
	  this.token(";");
	}
	function TSNamespaceExportDeclaration(node) {
	  this.word("export");
	  this.space();
	  this.word("as");
	  this.space();
	  this.word("namespace");
	  this.space();
	  this.print(node.id, node);
	}
	function tsPrintSignatureDeclarationBase(node) {
	  var typeParameters = node.typeParameters,
	      parameters = node.parameters;
	  this.print(typeParameters, node);
	  this.token("(");

	  this._parameters(parameters, node);

	  this.token(")");
	  this.print(node.typeAnnotation, node);
	}
	function tsPrintClassMemberModifiers(node, isField) {
	  if (isField && node.declare) {
	    this.word("declare");
	    this.space();
	  }

	  if (node.accessibility) {
	    this.word(node.accessibility);
	    this.space();
	  }

	  if (node["static"]) {
	    this.word("static");
	    this.space();
	  }

	  if (node.override) {
	    this.word("override");
	    this.space();
	  }

	  if (node["abstract"]) {
	    this.word("abstract");
	    this.space();
	  }

	  if (isField && node.readonly) {
	    this.word("readonly");
	    this.space();
	  }
	}

	var generatorFunctions = /*#__PURE__*/Object.freeze({
		__proto__: null,
		TaggedTemplateExpression: TaggedTemplateExpression$1,
		TemplateElement: TemplateElement,
		TemplateLiteral: TemplateLiteral$1,
		UnaryExpression: UnaryExpression$1,
		DoExpression: DoExpression,
		ParenthesizedExpression: ParenthesizedExpression$1,
		UpdateExpression: UpdateExpression$1,
		ConditionalExpression: ConditionalExpression$1,
		NewExpression: NewExpression$1,
		SequenceExpression: SequenceExpression$1,
		ThisExpression: ThisExpression,
		Super: Super,
		Decorator: Decorator,
		OptionalMemberExpression: OptionalMemberExpression,
		OptionalCallExpression: OptionalCallExpression,
		CallExpression: CallExpression$1,
		Import: Import,
		YieldExpression: YieldExpression,
		AwaitExpression: AwaitExpression,
		EmptyStatement: EmptyStatement,
		ExpressionStatement: ExpressionStatement,
		AssignmentPattern: AssignmentPattern,
		AssignmentExpression: AssignmentExpression$1,
		BindExpression: BindExpression,
		BinaryExpression: AssignmentExpression$1,
		LogicalExpression: AssignmentExpression$1,
		MemberExpression: MemberExpression,
		MetaProperty: MetaProperty,
		PrivateName: PrivateName,
		V8IntrinsicIdentifier: V8IntrinsicIdentifier,
		ModuleExpression: ModuleExpression,
		WithStatement: WithStatement,
		IfStatement: IfStatement,
		ForStatement: ForStatement,
		WhileStatement: WhileStatement,
		ForInStatement: ForInStatement,
		ForOfStatement: ForOfStatement,
		DoWhileStatement: DoWhileStatement,
		ContinueStatement: ContinueStatement,
		ReturnStatement: ReturnStatement,
		BreakStatement: BreakStatement,
		ThrowStatement: ThrowStatement,
		LabeledStatement: LabeledStatement,
		TryStatement: TryStatement,
		CatchClause: CatchClause,
		SwitchStatement: SwitchStatement,
		SwitchCase: SwitchCase,
		DebuggerStatement: DebuggerStatement,
		VariableDeclaration: VariableDeclaration,
		VariableDeclarator: VariableDeclarator$1,
		ClassDeclaration: ClassDeclaration,
		ClassExpression: ClassDeclaration,
		ClassBody: ClassBody,
		ClassProperty: ClassProperty,
		ClassPrivateProperty: ClassPrivateProperty,
		ClassMethod: ClassMethod,
		ClassPrivateMethod: ClassPrivateMethod,
		_classMethodHead: _classMethodHead,
		StaticBlock: StaticBlock,
		_params: _params,
		_parameters: _parameters,
		_param: _param,
		_methodHead: _methodHead,
		_predicate: _predicate,
		_functionHead: _functionHead,
		FunctionExpression: FunctionExpression,
		FunctionDeclaration: FunctionExpression,
		ArrowFunctionExpression: ArrowFunctionExpression,
		ImportSpecifier: ImportSpecifier,
		ImportDefaultSpecifier: ImportDefaultSpecifier,
		ExportDefaultSpecifier: ExportDefaultSpecifier,
		ExportSpecifier: ExportSpecifier,
		ExportNamespaceSpecifier: ExportNamespaceSpecifier,
		ExportAllDeclaration: ExportAllDeclaration,
		ExportNamedDeclaration: ExportNamedDeclaration,
		ExportDefaultDeclaration: ExportDefaultDeclaration,
		ImportDeclaration: ImportDeclaration,
		ImportAttribute: ImportAttribute,
		ImportNamespaceSpecifier: ImportNamespaceSpecifier,
		Identifier: Identifier,
		ArgumentPlaceholder: ArgumentPlaceholder,
		RestElement: RestElement$1,
		SpreadElement: RestElement$1,
		ObjectExpression: ObjectExpression$1,
		ObjectPattern: ObjectExpression$1,
		ObjectMethod: ObjectMethod,
		ObjectProperty: ObjectProperty,
		ArrayExpression: ArrayExpression$1,
		ArrayPattern: ArrayExpression$1,
		RecordExpression: RecordExpression,
		TupleExpression: TupleExpression,
		RegExpLiteral: RegExpLiteral$1,
		BooleanLiteral: BooleanLiteral$1,
		NullLiteral: NullLiteral$1,
		NumericLiteral: NumericLiteral$2,
		StringLiteral: StringLiteral$2,
		BigIntLiteral: BigIntLiteral,
		DecimalLiteral: DecimalLiteral,
		TopicReference: TopicReference,
		PipelineTopicExpression: PipelineTopicExpression,
		PipelineBareFunction: PipelineBareFunction,
		PipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
		NumberLiteralTypeAnnotation: NumericLiteral$2,
		StringLiteralTypeAnnotation: StringLiteral$2,
		AnyTypeAnnotation: AnyTypeAnnotation,
		ArrayTypeAnnotation: ArrayTypeAnnotation,
		BooleanTypeAnnotation: BooleanTypeAnnotation,
		BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
		NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
		DeclareClass: DeclareClass,
		DeclareFunction: DeclareFunction,
		InferredPredicate: InferredPredicate,
		DeclaredPredicate: DeclaredPredicate,
		DeclareInterface: DeclareInterface,
		DeclareModule: DeclareModule,
		DeclareModuleExports: DeclareModuleExports,
		DeclareTypeAlias: DeclareTypeAlias,
		DeclareOpaqueType: DeclareOpaqueType,
		DeclareVariable: DeclareVariable,
		DeclareExportDeclaration: DeclareExportDeclaration,
		DeclareExportAllDeclaration: DeclareExportAllDeclaration,
		EnumDeclaration: EnumDeclaration,
		EnumBooleanBody: EnumBooleanBody,
		EnumNumberBody: EnumNumberBody,
		EnumStringBody: EnumStringBody,
		EnumSymbolBody: EnumSymbolBody,
		EnumDefaultedMember: EnumDefaultedMember,
		EnumBooleanMember: EnumBooleanMember,
		EnumNumberMember: EnumNumberMember,
		EnumStringMember: EnumStringMember,
		ExistsTypeAnnotation: ExistsTypeAnnotation,
		FunctionTypeAnnotation: FunctionTypeAnnotation,
		FunctionTypeParam: FunctionTypeParam,
		InterfaceExtends: InterfaceExtends,
		ClassImplements: InterfaceExtends,
		GenericTypeAnnotation: InterfaceExtends,
		_interfaceish: _interfaceish,
		_variance: _variance,
		InterfaceDeclaration: InterfaceDeclaration,
		InterfaceTypeAnnotation: InterfaceTypeAnnotation,
		IntersectionTypeAnnotation: IntersectionTypeAnnotation,
		MixedTypeAnnotation: MixedTypeAnnotation,
		EmptyTypeAnnotation: EmptyTypeAnnotation,
		NullableTypeAnnotation: NullableTypeAnnotation,
		NumberTypeAnnotation: NumberTypeAnnotation,
		StringTypeAnnotation: StringTypeAnnotation,
		ThisTypeAnnotation: ThisTypeAnnotation,
		TupleTypeAnnotation: TupleTypeAnnotation,
		TypeofTypeAnnotation: TypeofTypeAnnotation,
		TypeAlias: TypeAlias,
		TypeAnnotation: TypeAnnotation,
		TypeParameterInstantiation: TypeParameterInstantiation,
		TypeParameterDeclaration: TypeParameterInstantiation,
		TypeParameter: TypeParameter,
		OpaqueType: OpaqueType,
		ObjectTypeAnnotation: ObjectTypeAnnotation,
		ObjectTypeInternalSlot: ObjectTypeInternalSlot,
		ObjectTypeCallProperty: ObjectTypeCallProperty,
		ObjectTypeIndexer: ObjectTypeIndexer,
		ObjectTypeProperty: ObjectTypeProperty,
		ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
		QualifiedTypeIdentifier: QualifiedTypeIdentifier,
		SymbolTypeAnnotation: SymbolTypeAnnotation,
		UnionTypeAnnotation: UnionTypeAnnotation,
		TypeCastExpression: TypeCastExpression$1,
		Variance: Variance,
		VoidTypeAnnotation: VoidTypeAnnotation,
		IndexedAccessType: IndexedAccessType,
		OptionalIndexedAccessType: OptionalIndexedAccessType,
		File: File$1,
		Program: Program,
		BlockStatement: BlockStatement,
		Directive: Directive,
		DirectiveLiteral: DirectiveLiteral,
		InterpreterDirective: InterpreterDirective,
		Placeholder: Placeholder,
		JSXAttribute: JSXAttribute,
		JSXIdentifier: JSXIdentifier$1,
		JSXNamespacedName: JSXNamespacedName,
		JSXMemberExpression: JSXMemberExpression,
		JSXSpreadAttribute: JSXSpreadAttribute,
		JSXExpressionContainer: JSXExpressionContainer,
		JSXSpreadChild: JSXSpreadChild,
		JSXText: JSXText$1,
		JSXElement: JSXElement,
		JSXOpeningElement: JSXOpeningElement,
		JSXClosingElement: JSXClosingElement,
		JSXEmptyExpression: JSXEmptyExpression,
		JSXFragment: JSXFragment,
		JSXOpeningFragment: JSXOpeningFragment,
		JSXClosingFragment: JSXClosingFragment,
		TSTypeAnnotation: TSTypeAnnotation,
		TSTypeParameterInstantiation: TSTypeParameterInstantiation,
		TSTypeParameterDeclaration: TSTypeParameterInstantiation,
		TSTypeParameter: TSTypeParameter,
		TSParameterProperty: TSParameterProperty,
		TSDeclareFunction: TSDeclareFunction,
		TSDeclareMethod: TSDeclareMethod,
		TSQualifiedName: TSQualifiedName,
		TSCallSignatureDeclaration: TSCallSignatureDeclaration,
		TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
		TSPropertySignature: TSPropertySignature,
		tsPrintPropertyOrMethodName: tsPrintPropertyOrMethodName,
		TSMethodSignature: TSMethodSignature,
		TSIndexSignature: TSIndexSignature,
		TSAnyKeyword: TSAnyKeyword,
		TSBigIntKeyword: TSBigIntKeyword,
		TSUnknownKeyword: TSUnknownKeyword,
		TSNumberKeyword: TSNumberKeyword,
		TSObjectKeyword: TSObjectKeyword,
		TSBooleanKeyword: TSBooleanKeyword,
		TSStringKeyword: TSStringKeyword,
		TSSymbolKeyword: TSSymbolKeyword,
		TSVoidKeyword: TSVoidKeyword,
		TSUndefinedKeyword: TSUndefinedKeyword,
		TSNullKeyword: TSNullKeyword,
		TSNeverKeyword: TSNeverKeyword,
		TSIntrinsicKeyword: TSIntrinsicKeyword,
		TSThisType: TSThisType,
		TSFunctionType: TSFunctionType,
		TSConstructorType: TSConstructorType,
		tsPrintFunctionOrConstructorType: tsPrintFunctionOrConstructorType,
		TSTypeReference: TSTypeReference,
		TSTypePredicate: TSTypePredicate,
		TSTypeQuery: TSTypeQuery,
		TSTypeLiteral: TSTypeLiteral,
		tsPrintTypeLiteralOrInterfaceBody: tsPrintTypeLiteralOrInterfaceBody,
		tsPrintBraced: tsPrintBraced,
		TSArrayType: TSArrayType,
		TSTupleType: TSTupleType,
		TSOptionalType: TSOptionalType,
		TSRestType: TSRestType,
		TSNamedTupleMember: TSNamedTupleMember,
		TSUnionType: TSUnionType,
		TSIntersectionType: TSIntersectionType,
		tsPrintUnionOrIntersectionType: tsPrintUnionOrIntersectionType,
		TSConditionalType: TSConditionalType,
		TSInferType: TSInferType,
		TSParenthesizedType: TSParenthesizedType,
		TSTypeOperator: TSTypeOperator,
		TSIndexedAccessType: TSIndexedAccessType,
		TSMappedType: TSMappedType,
		TSLiteralType: TSLiteralType,
		TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
		TSInterfaceDeclaration: TSInterfaceDeclaration,
		TSInterfaceBody: TSInterfaceBody,
		TSTypeAliasDeclaration: TSTypeAliasDeclaration,
		TSAsExpression: TSAsExpression,
		TSTypeAssertion: TSTypeAssertion,
		TSEnumDeclaration: TSEnumDeclaration,
		TSEnumMember: TSEnumMember,
		TSModuleDeclaration: TSModuleDeclaration,
		TSModuleBlock: TSModuleBlock,
		TSImportType: TSImportType,
		TSImportEqualsDeclaration: TSImportEqualsDeclaration,
		TSExternalModuleReference: TSExternalModuleReference,
		TSNonNullExpression: TSNonNullExpression,
		TSExportAssignment: TSExportAssignment,
		TSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
		tsPrintSignatureDeclarationBase: tsPrintSignatureDeclarationBase,
		tsPrintClassMemberModifiers: tsPrintClassMemberModifiers
	});

	var isProgram$1 = isProgram$2,
	    isFile = isFile$1,
	    isEmptyStatement = isEmptyStatement$1;
	var SCIENTIFIC_NOTATION = /e/i;
	var ZERO_DECIMAL_INTEGER = /\.0+$/;
	var NON_DECIMAL_LITERAL = /^0[box]/;
	var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
	var needsParens = needsParens$1,
	    needsWhitespaceAfter = needsWhitespaceAfter$1,
	    needsWhitespaceBefore = needsWhitespaceBefore$1;

	var Printer = function () {
	  function Printer(format, map) {
	    this.inForStatementInitCounter = 0;
	    this._printStack = [];
	    this._indent = 0;
	    this._insideAux = false;
	    this._parenPushNewlineState = null;
	    this._noLineTerminator = false;
	    this._printAuxAfterOnNextUserNode = false;
	    this._printedComments = new WeakSet();
	    this._endsWithInteger = false;
	    this._endsWithWord = false;
	    this.format = format;
	    this._buf = new Buffer(map);
	  }

	  var _proto = Printer.prototype;

	  _proto.generate = function generate(ast) {
	    this.print(ast);

	    this._maybeAddAuxComment();

	    return this._buf.get();
	  };

	  _proto.indent = function indent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent++;
	  };

	  _proto.dedent = function dedent() {
	    if (this.format.compact || this.format.concise) return;
	    this._indent--;
	  };

	  _proto.semicolon = function semicolon(force) {
	    if (force === void 0) {
	      force = false;
	    }

	    this._maybeAddAuxComment();

	    this._append(";", !force);
	  };

	  _proto.rightBrace = function rightBrace() {
	    if (this.format.minified) {
	      this._buf.removeLastSemicolon();
	    }

	    this.token("}");
	  };

	  _proto.space = function space(force) {
	    if (force === void 0) {
	      force = false;
	    }

	    if (this.format.compact) return;

	    if (force) {
	      this._space();
	    } else if (this._buf.hasContent()) {
	      var lastCp = this.getLastChar();

	      if (lastCp !== 32 && lastCp !== 10) {
	        this._space();
	      }
	    }
	  };

	  _proto.word = function word(str) {
	    if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);

	    this._endsWithWord = true;
	  };

	  _proto.number = function number(str) {
	    this.word(str);
	    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
	  };

	  _proto.token = function token(str) {
	    var lastChar = this.getLastChar();
	    var strFirst = str.charCodeAt(0);

	    if (str === "--" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
	      this._space();
	    }

	    this._maybeAddAuxComment();

	    this._append(str);
	  };

	  _proto.newline = function newline(i) {
	    if (i === void 0) {
	      i = 1;
	    }

	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    var charBeforeNewline = this.endsWithCharAndNewline();
	    if (charBeforeNewline === 10) return;

	    if (charBeforeNewline === 123 || charBeforeNewline === 58) {
	      i--;
	    }

	    if (i <= 0) return;

	    for (var j = 0; j < i; j++) {
	      this._newline();
	    }
	  };

	  _proto.endsWith = function endsWith(_char) {
	    return this.getLastChar() === _char;
	  };

	  _proto.getLastChar = function getLastChar() {
	    return this._buf.getLastChar();
	  };

	  _proto.endsWithCharAndNewline = function endsWithCharAndNewline() {
	    return this._buf.endsWithCharAndNewline();
	  };

	  _proto.removeTrailingNewline = function removeTrailingNewline() {
	    this._buf.removeTrailingNewline();
	  };

	  _proto.exactSource = function exactSource(loc, cb) {
	    this._catchUp("start", loc);

	    this._buf.exactSource(loc, cb);
	  };

	  _proto.source = function source(prop, loc) {
	    this._catchUp(prop, loc);

	    this._buf.source(prop, loc);
	  };

	  _proto.withSource = function withSource(prop, loc, cb) {
	    this._catchUp(prop, loc);

	    this._buf.withSource(prop, loc, cb);
	  };

	  _proto._space = function _space() {
	    this._append(" ", true);
	  };

	  _proto._newline = function _newline() {
	    this._append("\n", true);
	  };

	  _proto._append = function _append(str, queue) {
	    if (queue === void 0) {
	      queue = false;
	    }

	    this._maybeAddParen(str);

	    this._maybeIndent(str);

	    if (queue) this._buf.queue(str);else this._buf.append(str);
	    this._endsWithWord = false;
	    this._endsWithInteger = false;
	  };

	  _proto._maybeIndent = function _maybeIndent(str) {
	    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {
	      this._buf.queue(this._getIndent());
	    }
	  };

	  _proto._maybeAddParen = function _maybeAddParen(str) {
	    var parenPushNewlineState = this._parenPushNewlineState;
	    if (!parenPushNewlineState) return;
	    var i;

	    for (i = 0; i < str.length && str[i] === " "; i++) {
	      continue;
	    }

	    if (i === str.length) {
	      return;
	    }

	    var cha = str[i];

	    if (cha !== "\n") {
	      if (cha !== "/" || i + 1 === str.length) {
	        this._parenPushNewlineState = null;
	        return;
	      }

	      var chaPost = str[i + 1];

	      if (chaPost === "*") {
	        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
	          return;
	        }
	      } else if (chaPost !== "/") {
	        this._parenPushNewlineState = null;
	        return;
	      }
	    }

	    this.token("(");
	    this.indent();
	    parenPushNewlineState.printed = true;
	  };

	  _proto._catchUp = function _catchUp(prop, loc) {
	    if (!this.format.retainLines) return;
	    var pos = loc ? loc[prop] : null;

	    if ((pos == null ? void 0 : pos.line) != null) {
	      var count = pos.line - this._buf.getCurrentLine();

	      for (var i = 0; i < count; i++) {
	        this._newline();
	      }
	    }
	  };

	  _proto._getIndent = function _getIndent() {
	    return this.format.indent.style.repeat(this._indent);
	  };

	  _proto.startTerminatorless = function startTerminatorless(isLabel) {
	    if (isLabel === void 0) {
	      isLabel = false;
	    }

	    if (isLabel) {
	      this._noLineTerminator = true;
	      return null;
	    } else {
	      return this._parenPushNewlineState = {
	        printed: false
	      };
	    }
	  };

	  _proto.endTerminatorless = function endTerminatorless(state) {
	    this._noLineTerminator = false;

	    if (state != null && state.printed) {
	      this.dedent();
	      this.newline();
	      this.token(")");
	    }
	  };

	  _proto.print = function print(node, parent) {
	    var _this = this;

	    if (!node) return;
	    var oldConcise = this.format.concise;

	    if (node._compact) {
	      this.format.concise = true;
	    }

	    var printMethod = this[node.type];

	    if (!printMethod) {
	      throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node == null ? void 0 : node.constructor.name));
	    }

	    this._printStack.push(node);

	    var oldInAux = this._insideAux;
	    this._insideAux = !node.loc;

	    this._maybeAddAuxComment(this._insideAux && !oldInAux);

	    var shouldPrintParens = needsParens(node, parent, this._printStack);

	    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
	      shouldPrintParens = true;
	    }

	    if (shouldPrintParens) this.token("(");

	    this._printLeadingComments(node);

	    var loc = isProgram$1(node) || isFile(node) ? null : node.loc;
	    this.withSource("start", loc, function () {
	      printMethod.call(_this, node, parent);
	    });

	    this._printTrailingComments(node);

	    if (shouldPrintParens) this.token(")");

	    this._printStack.pop();

	    this.format.concise = oldConcise;
	    this._insideAux = oldInAux;
	  };

	  _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
	    if (enteredPositionlessNode) this._printAuxBeforeComment();
	    if (!this._insideAux) this._printAuxAfterComment();
	  };

	  _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
	    if (this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = true;
	    var comment = this.format.auxiliaryCommentBefore;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  };

	  _proto._printAuxAfterComment = function _printAuxAfterComment() {
	    if (!this._printAuxAfterOnNextUserNode) return;
	    this._printAuxAfterOnNextUserNode = false;
	    var comment = this.format.auxiliaryCommentAfter;

	    if (comment) {
	      this._printComment({
	        type: "CommentBlock",
	        value: comment
	      });
	    }
	  };

	  _proto.getPossibleRaw = function getPossibleRaw(node) {
	    var extra = node.extra;

	    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
	      return extra.raw;
	    }
	  };

	  _proto.printJoin = function printJoin(nodes, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    if (!(nodes != null && nodes.length)) return;
	    if (opts.indent) this.indent();
	    var newlineOpts = {
	      addNewlines: opts.addNewlines
	    };

	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      if (!node) continue;
	      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
	      this.print(node, parent);

	      if (opts.iterator) {
	        opts.iterator(node, i);
	      }

	      if (opts.separator && i < nodes.length - 1) {
	        opts.separator.call(this);
	      }

	      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
	    }

	    if (opts.indent) this.dedent();
	  };

	  _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
	    var indent = node.leadingComments && node.leadingComments.length > 0;
	    if (indent) this.indent();
	    this.print(node, parent);
	    if (indent) this.dedent();
	  };

	  _proto.printBlock = function printBlock(parent) {
	    var node = parent.body;

	    if (!isEmptyStatement(node)) {
	      this.space();
	    }

	    this.print(node, parent);
	  };

	  _proto._printTrailingComments = function _printTrailingComments(node) {
	    this._printComments(this._getComments(false, node));
	  };

	  _proto._printLeadingComments = function _printLeadingComments(node) {
	    this._printComments(this._getComments(true, node), true);
	  };

	  _proto.printInnerComments = function printInnerComments(node, indent) {
	    var _node$innerComments;

	    if (indent === void 0) {
	      indent = true;
	    }

	    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;
	    if (indent) this.indent();

	    this._printComments(node.innerComments);

	    if (indent) this.dedent();
	  };

	  _proto.printSequence = function printSequence(nodes, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    opts.statement = true;
	    return this.printJoin(nodes, parent, opts);
	  };

	  _proto.printList = function printList(items, parent, opts) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    if (opts.separator == null) {
	      opts.separator = commaSeparator;
	    }

	    return this.printJoin(items, parent, opts);
	  };

	  _proto._printNewline = function _printNewline(leading, node, parent, opts) {
	    if (this.format.retainLines || this.format.compact) return;

	    if (this.format.concise) {
	      this.space();
	      return;
	    }

	    var lines = 0;

	    if (this._buf.hasContent()) {
	      if (!leading) lines++;
	      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
	      var needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
	      if (needs(node, parent)) lines++;
	    }

	    this.newline(Math.min(2, lines));
	  };

	  _proto._getComments = function _getComments(leading, node) {
	    return node && (leading ? node.leadingComments : node.trailingComments) || [];
	  };

	  _proto._printComment = function _printComment(comment, skipNewLines) {
	    var _this2 = this;

	    if (!this.format.shouldPrintComment(comment.value)) return;
	    if (comment.ignore) return;
	    if (this._printedComments.has(comment)) return;

	    this._printedComments.add(comment);

	    var isBlockComment = comment.type === "CommentBlock";
	    var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
	    if (printNewLines && this._buf.hasContent()) this.newline(1);
	    var lastCharCode = this.getLastChar();

	    if (lastCharCode !== 91 && lastCharCode !== 123) {
	      this.space();
	    }

	    var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

	    if (isBlockComment && this.format.indent.adjustMultilineComment) {
	      var _comment$loc;

	      var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;

	      if (offset) {
	        var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
	        val = val.replace(newlineRegex, "\n");
	      }

	      var indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
	      val = val.replace(/\n(?!$)/g, "\n" + " ".repeat(indentSize));
	    }

	    if (this.endsWith(47)) this._space();
	    this.withSource("start", comment.loc, function () {
	      _this2._append(val);
	    });
	    if (printNewLines) this.newline(1);
	  };

	  _proto._printComments = function _printComments(comments, inlinePureAnnotation) {
	    if (!(comments != null && comments.length)) return;

	    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
	      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));
	    } else {
	      for (var _iterator = _createForOfIteratorHelperLoose(comments), _step; !(_step = _iterator()).done;) {
	        var _comment = _step.value;

	        this._printComment(_comment);
	      }
	    }
	  };

	  _proto.printAssertions = function printAssertions(node) {
	    var _node$assertions;

	    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
	      this.space();
	      this.word("assert");
	      this.space();
	      this.token("{");
	      this.space();
	      this.printList(node.assertions, node);
	      this.space();
	      this.token("}");
	    }
	  };

	  return Printer;
	}();

	Object.assign(Printer.prototype, generatorFunctions);
	{
	  Printer.prototype.Noop = function Noop() {};
	}

	function commaSeparator() {
	  this.token(",");
	  this.space();
	}

	var Generator = function (_Printer) {
	  _inherits(Generator, _Printer);

	  function Generator(ast, opts, code) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    var format = normalizeOptions$6(code, opts);
	    var map = opts.sourceMaps ? new SourceMap(opts, code) : null;
	    _this = _Printer.call(this, format, map) || this;
	    _this.ast = void 0;
	    _this.ast = ast;
	    return _this;
	  }

	  var _proto = Generator.prototype;

	  _proto.generate = function generate() {
	    return _Printer.prototype.generate.call(this, this.ast);
	  };

	  return Generator;
	}(Printer);

	function normalizeOptions$6(code, opts) {
	  var format = {
	    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
	    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
	    shouldPrintComment: opts.shouldPrintComment,
	    retainLines: opts.retainLines,
	    retainFunctionParens: opts.retainFunctionParens,
	    comments: opts.comments == null || opts.comments,
	    compact: opts.compact,
	    minified: opts.minified,
	    concise: opts.concise,
	    indent: {
	      adjustMultilineComment: true,
	      style: "  ",
	      base: 0
	    },
	    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
	    jsescOption: Object.assign({
	      quotes: "double",
	      wrap: true,
	      minimal: false
	    }, opts.jsescOption),
	    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
	    topicToken: opts.topicToken
	  };
	  {
	    format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
	  }

	  if (format.minified) {
	    format.compact = true;

	    format.shouldPrintComment = format.shouldPrintComment || function () {
	      return format.comments;
	    };
	  } else {
	    format.shouldPrintComment = format.shouldPrintComment || function (value) {
	      return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
	    };
	  }

	  if (format.compact === "auto") {
	    format.compact = code.length > 500000;

	    if (format.compact) {
	      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
	    }
	  }

	  if (format.compact) {
	    format.indent.adjustMultilineComment = false;
	  }

	  return format;
	}
	function generate$1(ast, opts, code) {
	  var gen = new Generator(ast, opts, code);
	  return gen.generate();
	}

	var VISITOR_KEYS$4 = VISITOR_KEYS$6;
	function findParent(callback) {
	  var path = this;

	  while (path = path.parentPath) {
	    if (callback(path)) return path;
	  }

	  return null;
	}
	function find$1(callback) {
	  var path = this;

	  do {
	    if (callback(path)) return path;
	  } while (path = path.parentPath);

	  return null;
	}
	function getFunctionParent() {
	  return this.findParent(function (p) {
	    return p.isFunction();
	  });
	}
	function getStatementParent() {
	  var path = this;

	  do {
	    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
	      break;
	    } else {
	      path = path.parentPath;
	    }
	  } while (path);

	  if (path && (path.isProgram() || path.isFile())) {
	    throw new Error("File/Program node, we can't possibly find a statement parent to this");
	  }

	  return path;
	}
	function getEarliestCommonAncestorFrom(paths) {
	  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
	    var earliest;
	    var keys = VISITOR_KEYS$4[deepest.type];

	    for (var _iterator = _createForOfIteratorHelperLoose(ancestries), _step; !(_step = _iterator()).done;) {
	      var ancestry = _step.value;
	      var path = ancestry[i + 1];

	      if (!earliest) {
	        earliest = path;
	        continue;
	      }

	      if (path.listKey && earliest.listKey === path.listKey) {
	        if (path.key < earliest.key) {
	          earliest = path;
	          continue;
	        }
	      }

	      var earliestKeyIndex = keys.indexOf(earliest.parentKey);
	      var currentKeyIndex = keys.indexOf(path.parentKey);

	      if (earliestKeyIndex > currentKeyIndex) {
	        earliest = path;
	      }
	    }

	    return earliest;
	  });
	}
	function getDeepestCommonAncestorFrom(paths, filter) {
	  var _this = this;

	  if (!paths.length) {
	    return this;
	  }

	  if (paths.length === 1) {
	    return paths[0];
	  }

	  var minDepth = Infinity;
	  var lastCommonIndex, lastCommon;
	  var ancestries = paths.map(function (path) {
	    var ancestry = [];

	    do {
	      ancestry.unshift(path);
	    } while ((path = path.parentPath) && path !== _this);

	    if (ancestry.length < minDepth) {
	      minDepth = ancestry.length;
	    }

	    return ancestry;
	  });
	  var first = ancestries[0];

	  depthLoop: for (var _i = 0; _i < minDepth; _i++) {
	    var shouldMatch = first[_i];

	    for (var _iterator2 = _createForOfIteratorHelperLoose(ancestries), _step2; !(_step2 = _iterator2()).done;) {
	      var ancestry = _step2.value;

	      if (ancestry[_i] !== shouldMatch) {
	        break depthLoop;
	      }
	    }

	    lastCommonIndex = _i;
	    lastCommon = shouldMatch;
	  }

	  if (lastCommon) {
	    if (filter) {
	      return filter(lastCommon, lastCommonIndex, ancestries);
	    } else {
	      return lastCommon;
	    }
	  } else {
	    throw new Error("Couldn't find intersection");
	  }
	}
	function getAncestry() {
	  var path = this;
	  var paths = [];

	  do {
	    paths.push(path);
	  } while (path = path.parentPath);

	  return paths;
	}
	function isAncestor(maybeDescendant) {
	  return maybeDescendant.isDescendant(this);
	}
	function isDescendant(maybeAncestor) {
	  return !!this.findParent(function (parent) {
	    return parent === maybeAncestor;
	  });
	}
	function inType() {
	  var path = this;

	  for (var _len = arguments.length, candidateTypes = new Array(_len), _key = 0; _key < _len; _key++) {
	    candidateTypes[_key] = arguments[_key];
	  }

	  while (path) {
	    for (var _iterator3 = _createForOfIteratorHelperLoose(candidateTypes), _step3; !(_step3 = _iterator3()).done;) {
	      var type = _step3.value;
	      if (path.node.type === type) return true;
	    }

	    path = path.parentPath;
	  }

	  return false;
	}

	var NodePath_ancestry = /*#__PURE__*/Object.freeze({
		__proto__: null,
		findParent: findParent,
		find: find$1,
		getFunctionParent: getFunctionParent,
		getStatementParent: getStatementParent,
		getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom,
		getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom,
		getAncestry: getAncestry,
		isAncestor: isAncestor,
		isDescendant: isDescendant,
		inType: inType
	});

	var BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS$1,
	    createFlowUnionType$1 = createFlowUnionType$2,
	    createTSUnionType$1 = createTSUnionType$2,
	    createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof$1,
	    createUnionTypeAnnotation$1 = createFlowUnionType$2,
	    isTSTypeAnnotation$1 = isTSTypeAnnotation$2,
	    numberTypeAnnotation$1 = numberTypeAnnotation$2,
	    voidTypeAnnotation$2 = voidTypeAnnotation$3;
	function infererReference (node) {
	  if (!this.isReferenced()) return;
	  var binding = this.scope.getBinding(node.name);

	  if (binding) {
	    if (binding.identifier.typeAnnotation) {
	      return binding.identifier.typeAnnotation;
	    } else {
	      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
	    }
	  }

	  if (node.name === "undefined") {
	    return voidTypeAnnotation$2();
	  } else if (node.name === "NaN" || node.name === "Infinity") {
	    return numberTypeAnnotation$1();
	  } else if (node.name === "arguments") ;
	}

	function getTypeAnnotationBindingConstantViolations(binding, path, name) {
	  var types = [];
	  var functionConstantViolations = [];
	  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
	  var testType = getConditionalAnnotation(binding, path, name);

	  if (testType) {
	    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
	    constantViolations = constantViolations.filter(function (path) {
	      return testConstantViolations.indexOf(path) < 0;
	    });
	    types.push(testType.typeAnnotation);
	  }

	  if (constantViolations.length) {
	    var _constantViolations;

	    (_constantViolations = constantViolations).push.apply(_constantViolations, functionConstantViolations);

	    for (var _iterator = _createForOfIteratorHelperLoose(constantViolations), _step; !(_step = _iterator()).done;) {
	      var violation = _step.value;
	      types.push(violation.getTypeAnnotation());
	    }
	  }

	  if (!types.length) {
	    return;
	  }

	  if (isTSTypeAnnotation$1(types[0]) && createTSUnionType$1) {
	    return createTSUnionType$1(types);
	  }

	  if (createFlowUnionType$1) {
	    return createFlowUnionType$1(types);
	  }

	  return createUnionTypeAnnotation$1(types);
	}

	function getConstantViolationsBefore(binding, path, functions) {
	  var violations = binding.constantViolations.slice();
	  violations.unshift(binding.path);
	  return violations.filter(function (violation) {
	    violation = violation.resolve();

	    var status = violation._guessExecutionStatusRelativeTo(path);

	    if (functions && status === "unknown") functions.push(violation);
	    return status === "before";
	  });
	}

	function inferAnnotationFromBinaryExpression(name, path) {
	  var operator = path.node.operator;
	  var right = path.get("right").resolve();
	  var left = path.get("left").resolve();
	  var target;

	  if (left.isIdentifier({
	    name: name
	  })) {
	    target = right;
	  } else if (right.isIdentifier({
	    name: name
	  })) {
	    target = left;
	  }

	  if (target) {
	    if (operator === "===") {
	      return target.getTypeAnnotation();
	    }

	    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
	      return numberTypeAnnotation$1();
	    }

	    return;
	  }

	  if (operator !== "===" && operator !== "==") return;
	  var typeofPath;
	  var typePath;

	  if (left.isUnaryExpression({
	    operator: "typeof"
	  })) {
	    typeofPath = left;
	    typePath = right;
	  } else if (right.isUnaryExpression({
	    operator: "typeof"
	  })) {
	    typeofPath = right;
	    typePath = left;
	  }

	  if (!typeofPath) return;
	  if (!typeofPath.get("argument").isIdentifier({
	    name: name
	  })) return;
	  typePath = typePath.resolve();
	  if (!typePath.isLiteral()) return;
	  var typeValue = typePath.node.value;
	  if (typeof typeValue !== "string") return;
	  return createTypeAnnotationBasedOnTypeof(typeValue);
	}

	function getParentConditionalPath(binding, path, name) {
	  var parentPath;

	  while (parentPath = path.parentPath) {
	    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
	      if (path.key === "test") {
	        return;
	      }

	      return parentPath;
	    }

	    if (parentPath.isFunction()) {
	      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
	    }

	    path = parentPath;
	  }
	}

	function getConditionalAnnotation(binding, path, name) {
	  var ifStatement = getParentConditionalPath(binding, path, name);
	  if (!ifStatement) return;
	  var test = ifStatement.get("test");
	  var paths = [test];
	  var types = [];

	  for (var i = 0; i < paths.length; i++) {
	    var _path = paths[i];

	    if (_path.isLogicalExpression()) {
	      if (_path.node.operator === "&&") {
	        paths.push(_path.get("left"));
	        paths.push(_path.get("right"));
	      }
	    } else if (_path.isBinaryExpression()) {
	      var type = inferAnnotationFromBinaryExpression(name, _path);
	      if (type) types.push(type);
	    }
	  }

	  if (types.length) {
	    if (isTSTypeAnnotation$1(types[0]) && createTSUnionType$1) {
	      return {
	        typeAnnotation: createTSUnionType$1(types),
	        ifStatement: ifStatement
	      };
	    }

	    if (createFlowUnionType$1) {
	      return {
	        typeAnnotation: createFlowUnionType$1(types),
	        ifStatement: ifStatement
	      };
	    }

	    return {
	      typeAnnotation: createUnionTypeAnnotation$1(types),
	      ifStatement: ifStatement
	    };
	  }

	  return getConditionalAnnotation(ifStatement, name);
	}

	var BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS$1,
	    BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS$1,
	    NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS$1,
	    NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS$1,
	    STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS$1,
	    anyTypeAnnotation$1 = anyTypeAnnotation$2,
	    arrayTypeAnnotation = arrayTypeAnnotation$1,
	    booleanTypeAnnotation = booleanTypeAnnotation$1,
	    buildMatchMemberExpression = buildMatchMemberExpression$1,
	    createFlowUnionType = createFlowUnionType$2,
	    createTSUnionType = createTSUnionType$2,
	    createUnionTypeAnnotation = createFlowUnionType$2,
	    genericTypeAnnotation = genericTypeAnnotation$1,
	    identifier$g = identifier$j,
	    isTSTypeAnnotation = isTSTypeAnnotation$2,
	    nullLiteralTypeAnnotation = nullLiteralTypeAnnotation$1,
	    numberTypeAnnotation = numberTypeAnnotation$2,
	    stringTypeAnnotation$1 = stringTypeAnnotation$2,
	    tupleTypeAnnotation = tupleTypeAnnotation$1,
	    unionTypeAnnotation = unionTypeAnnotation$1,
	    voidTypeAnnotation$1 = voidTypeAnnotation$3;
	function VariableDeclarator() {
	  var _type;

	  var id = this.get("id");
	  if (!id.isIdentifier()) return;
	  var init = this.get("init");
	  var type = init.getTypeAnnotation();

	  if (((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation") {
	    if (init.isCallExpression() && init.get("callee").isIdentifier({
	      name: "Array"
	    }) && !init.scope.hasBinding("Array", true)) {
	      type = ArrayExpression();
	    }
	  }

	  return type;
	}
	function TypeCastExpression(node) {
	  return node.typeAnnotation;
	}
	TypeCastExpression.validParent = true;
	function NewExpression(node) {
	  if (this.get("callee").isIdentifier()) {
	    return genericTypeAnnotation(node.callee);
	  }
	}
	function TemplateLiteral() {
	  return stringTypeAnnotation$1();
	}
	function UnaryExpression(node) {
	  var operator = node.operator;

	  if (operator === "void") {
	    return voidTypeAnnotation$1();
	  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
	    return numberTypeAnnotation();
	  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
	    return stringTypeAnnotation$1();
	  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
	    return booleanTypeAnnotation();
	  }
	}
	function BinaryExpression(node) {
	  var operator = node.operator;

	  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
	    return numberTypeAnnotation();
	  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
	    return booleanTypeAnnotation();
	  } else if (operator === "+") {
	    var right = this.get("right");
	    var left = this.get("left");

	    if (left.isBaseType("number") && right.isBaseType("number")) {
	      return numberTypeAnnotation();
	    } else if (left.isBaseType("string") || right.isBaseType("string")) {
	      return stringTypeAnnotation$1();
	    }

	    return unionTypeAnnotation([stringTypeAnnotation$1(), numberTypeAnnotation()]);
	  }
	}
	function LogicalExpression() {
	  var argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];

	  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
	    return createTSUnionType(argumentTypes);
	  }

	  if (createFlowUnionType) {
	    return createFlowUnionType(argumentTypes);
	  }

	  return createUnionTypeAnnotation(argumentTypes);
	}
	function ConditionalExpression() {
	  var argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];

	  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
	    return createTSUnionType(argumentTypes);
	  }

	  if (createFlowUnionType) {
	    return createFlowUnionType(argumentTypes);
	  }

	  return createUnionTypeAnnotation(argumentTypes);
	}
	function SequenceExpression() {
	  return this.get("expressions").pop().getTypeAnnotation();
	}
	function ParenthesizedExpression() {
	  return this.get("expression").getTypeAnnotation();
	}
	function AssignmentExpression() {
	  return this.get("right").getTypeAnnotation();
	}
	function UpdateExpression(node) {
	  var operator = node.operator;

	  if (operator === "++" || operator === "--") {
	    return numberTypeAnnotation();
	  }
	}
	function StringLiteral$1() {
	  return stringTypeAnnotation$1();
	}
	function NumericLiteral$1() {
	  return numberTypeAnnotation();
	}
	function BooleanLiteral() {
	  return booleanTypeAnnotation();
	}
	function NullLiteral() {
	  return nullLiteralTypeAnnotation();
	}
	function RegExpLiteral() {
	  return genericTypeAnnotation(identifier$g("RegExp"));
	}
	function ObjectExpression() {
	  return genericTypeAnnotation(identifier$g("Object"));
	}
	function ArrayExpression() {
	  return genericTypeAnnotation(identifier$g("Array"));
	}
	function RestElement() {
	  return ArrayExpression();
	}
	RestElement.validParent = true;

	function Func() {
	  return genericTypeAnnotation(identifier$g("Function"));
	}
	var isArrayFrom = buildMatchMemberExpression("Array.from");
	var isObjectKeys = buildMatchMemberExpression("Object.keys");
	var isObjectValues = buildMatchMemberExpression("Object.values");
	var isObjectEntries = buildMatchMemberExpression("Object.entries");
	function CallExpression() {
	  var callee = this.node.callee;

	  if (isObjectKeys(callee)) {
	    return arrayTypeAnnotation(stringTypeAnnotation$1());
	  } else if (isArrayFrom(callee) || isObjectValues(callee)) {
	    return arrayTypeAnnotation(anyTypeAnnotation$1());
	  } else if (isObjectEntries(callee)) {
	    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation$1(), anyTypeAnnotation$1()]));
	  }

	  return resolveCall(this.get("callee"));
	}
	function TaggedTemplateExpression() {
	  return resolveCall(this.get("tag"));
	}

	function resolveCall(callee) {
	  callee = callee.resolve();

	  if (callee.isFunction()) {
	    if (callee.is("async")) {
	      if (callee.is("generator")) {
	        return genericTypeAnnotation(identifier$g("AsyncIterator"));
	      } else {
	        return genericTypeAnnotation(identifier$g("Promise"));
	      }
	    } else {
	      if (callee.node.returnType) {
	        return callee.node.returnType;
	      }
	    }
	  }
	}

	var inferers = /*#__PURE__*/Object.freeze({
		__proto__: null,
		VariableDeclarator: VariableDeclarator,
		TypeCastExpression: TypeCastExpression,
		NewExpression: NewExpression,
		TemplateLiteral: TemplateLiteral,
		UnaryExpression: UnaryExpression,
		BinaryExpression: BinaryExpression,
		LogicalExpression: LogicalExpression,
		ConditionalExpression: ConditionalExpression,
		SequenceExpression: SequenceExpression,
		ParenthesizedExpression: ParenthesizedExpression,
		AssignmentExpression: AssignmentExpression,
		UpdateExpression: UpdateExpression,
		StringLiteral: StringLiteral$1,
		NumericLiteral: NumericLiteral$1,
		BooleanLiteral: BooleanLiteral,
		NullLiteral: NullLiteral,
		RegExpLiteral: RegExpLiteral,
		ObjectExpression: ObjectExpression,
		ArrayExpression: ArrayExpression,
		RestElement: RestElement,
		FunctionExpression: Func,
		ArrowFunctionExpression: Func,
		FunctionDeclaration: Func,
		ClassExpression: Func,
		ClassDeclaration: Func,
		CallExpression: CallExpression,
		TaggedTemplateExpression: TaggedTemplateExpression,
		Identifier: infererReference
	});

	var anyTypeAnnotation = anyTypeAnnotation$2,
	    isAnyTypeAnnotation = isAnyTypeAnnotation$1,
	    isBooleanTypeAnnotation = isBooleanTypeAnnotation$1,
	    isEmptyTypeAnnotation = isEmptyTypeAnnotation$1,
	    isFlowBaseAnnotation = isFlowBaseAnnotation$1,
	    isGenericTypeAnnotation = isGenericTypeAnnotation$1,
	    isIdentifier$a = isIdentifier$g,
	    isMixedTypeAnnotation = isMixedTypeAnnotation$1,
	    isNumberTypeAnnotation = isNumberTypeAnnotation$1,
	    isStringTypeAnnotation = isStringTypeAnnotation$1,
	    isTypeAnnotation = isTypeAnnotation$2,
	    isUnionTypeAnnotation = isUnionTypeAnnotation$2,
	    isVoidTypeAnnotation = isVoidTypeAnnotation$1,
	    stringTypeAnnotation = stringTypeAnnotation$2,
	    voidTypeAnnotation = voidTypeAnnotation$3;
	function getTypeAnnotation() {
	  if (this.typeAnnotation) return this.typeAnnotation;
	  var type = this._getTypeAnnotation() || anyTypeAnnotation();
	  if (isTypeAnnotation(type)) type = type.typeAnnotation;
	  return this.typeAnnotation = type;
	}
	var typeAnnotationInferringNodes = new WeakSet();
	function _getTypeAnnotation() {
	  var node = this.node;

	  if (!node) {
	    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
	      var declar = this.parentPath.parentPath;
	      var declarParent = declar.parentPath;

	      if (declar.key === "left" && declarParent.isForInStatement()) {
	        return stringTypeAnnotation();
	      }

	      if (declar.key === "left" && declarParent.isForOfStatement()) {
	        return anyTypeAnnotation();
	      }

	      return voidTypeAnnotation();
	    } else {
	      return;
	    }
	  }

	  if (node.typeAnnotation) {
	    return node.typeAnnotation;
	  }

	  if (typeAnnotationInferringNodes.has(node)) {
	    return;
	  }

	  typeAnnotationInferringNodes.add(node);

	  try {
	    var _inferer;

	    var inferer = inferers[node.type];

	    if (inferer) {
	      return inferer.call(this, node);
	    }

	    inferer = inferers[this.parentPath.type];

	    if ((_inferer = inferer) != null && _inferer.validParent) {
	      return this.parentPath.getTypeAnnotation();
	    }
	  } finally {
	    typeAnnotationInferringNodes["delete"](node);
	  }
	}
	function isBaseType(baseName, soft) {
	  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
	}

	function _isBaseType(baseName, type, soft) {
	  if (baseName === "string") {
	    return isStringTypeAnnotation(type);
	  } else if (baseName === "number") {
	    return isNumberTypeAnnotation(type);
	  } else if (baseName === "boolean") {
	    return isBooleanTypeAnnotation(type);
	  } else if (baseName === "any") {
	    return isAnyTypeAnnotation(type);
	  } else if (baseName === "mixed") {
	    return isMixedTypeAnnotation(type);
	  } else if (baseName === "empty") {
	    return isEmptyTypeAnnotation(type);
	  } else if (baseName === "void") {
	    return isVoidTypeAnnotation(type);
	  } else {
	    if (soft) {
	      return false;
	    } else {
	      throw new Error("Unknown base type " + baseName);
	    }
	  }
	}

	function couldBeBaseType(name) {
	  var type = this.getTypeAnnotation();
	  if (isAnyTypeAnnotation(type)) return true;

	  if (isUnionTypeAnnotation(type)) {
	    for (var _iterator = _createForOfIteratorHelperLoose(type.types), _step; !(_step = _iterator()).done;) {
	      var type2 = _step.value;

	      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
	        return true;
	      }
	    }

	    return false;
	  } else {
	    return _isBaseType(name, type, true);
	  }
	}
	function baseTypeStrictlyMatches(rightArg) {
	  var left = this.getTypeAnnotation();
	  var right = rightArg.getTypeAnnotation();

	  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
	    return right.type === left.type;
	  }

	  return false;
	}
	function isGenericType(genericName) {
	  var type = this.getTypeAnnotation();
	  return isGenericTypeAnnotation(type) && isIdentifier$a(type.id, {
	    name: genericName
	  });
	}

	var NodePath_inference = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getTypeAnnotation: getTypeAnnotation,
		_getTypeAnnotation: _getTypeAnnotation,
		isBaseType: isBaseType,
		couldBeBaseType: couldBeBaseType,
		baseTypeStrictlyMatches: baseTypeStrictlyMatches,
		isGenericType: isGenericType
	});

	var runtime_1 = createCommonjsModule(function (module) {
	  var runtime = function (exports) {

	    var Op = Object.prototype;
	    var hasOwn = Op.hasOwnProperty;
	    var undefined$1;
	    var $Symbol = typeof Symbol === "function" ? Symbol : {};
	    var iteratorSymbol = $Symbol.iterator || "@@iterator";
	    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	    function define(obj, key, value) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	      return obj[key];
	    }

	    try {
	      define({}, "");
	    } catch (err) {
	      define = function define(obj, key, value) {
	        return obj[key] = value;
	      };
	    }

	    function wrap(innerFn, outerFn, self, tryLocsList) {
	      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	      var generator = Object.create(protoGenerator.prototype);
	      var context = new Context(tryLocsList || []);
	      generator._invoke = makeInvokeMethod(innerFn, self, context);
	      return generator;
	    }

	    exports.wrap = wrap;

	    function tryCatch(fn, obj, arg) {
	      try {
	        return {
	          type: "normal",
	          arg: fn.call(obj, arg)
	        };
	      } catch (err) {
	        return {
	          type: "throw",
	          arg: err
	        };
	      }
	    }

	    var GenStateSuspendedStart = "suspendedStart";
	    var GenStateSuspendedYield = "suspendedYield";
	    var GenStateExecuting = "executing";
	    var GenStateCompleted = "completed";
	    var ContinueSentinel = {};

	    function Generator() {}

	    function GeneratorFunction() {}

	    function GeneratorFunctionPrototype() {}

	    var IteratorPrototype = {};

	    IteratorPrototype[iteratorSymbol] = function () {
	      return this;
	    };

	    var getProto = Object.getPrototypeOf;
	    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

	    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	      IteratorPrototype = NativeIteratorPrototype;
	    }

	    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	    GeneratorFunctionPrototype.constructor = GeneratorFunction;
	    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

	    function defineIteratorMethods(prototype) {
	      ["next", "throw", "return"].forEach(function (method) {
	        define(prototype, method, function (arg) {
	          return this._invoke(method, arg);
	        });
	      });
	    }

	    exports.isGeneratorFunction = function (genFun) {
	      var ctor = typeof genFun === "function" && genFun.constructor;
	      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	    };

	    exports.mark = function (genFun) {
	      if (Object.setPrototypeOf) {
	        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	      } else {
	        genFun.__proto__ = GeneratorFunctionPrototype;
	        define(genFun, toStringTagSymbol, "GeneratorFunction");
	      }

	      genFun.prototype = Object.create(Gp);
	      return genFun;
	    };

	    exports.awrap = function (arg) {
	      return {
	        __await: arg
	      };
	    };

	    function AsyncIterator(generator, PromiseImpl) {
	      function invoke(method, arg, resolve, reject) {
	        var record = tryCatch(generator[method], generator, arg);

	        if (record.type === "throw") {
	          reject(record.arg);
	        } else {
	          var result = record.arg;
	          var value = result.value;

	          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
	            return PromiseImpl.resolve(value.__await).then(function (value) {
	              invoke("next", value, resolve, reject);
	            }, function (err) {
	              invoke("throw", err, resolve, reject);
	            });
	          }

	          return PromiseImpl.resolve(value).then(function (unwrapped) {
	            result.value = unwrapped;
	            resolve(result);
	          }, function (error) {
	            return invoke("throw", error, resolve, reject);
	          });
	        }
	      }

	      var previousPromise;

	      function enqueue(method, arg) {
	        function callInvokeWithMethodAndArg() {
	          return new PromiseImpl(function (resolve, reject) {
	            invoke(method, arg, resolve, reject);
	          });
	        }

	        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }

	      this._invoke = enqueue;
	    }

	    defineIteratorMethods(AsyncIterator.prototype);

	    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	      return this;
	    };

	    exports.AsyncIterator = AsyncIterator;

	    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	      if (PromiseImpl === void 0) PromiseImpl = Promise;
	      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
	        return result.done ? result.value : iter.next();
	      });
	    };

	    function makeInvokeMethod(innerFn, self, context) {
	      var state = GenStateSuspendedStart;
	      return function invoke(method, arg) {
	        if (state === GenStateExecuting) {
	          throw new Error("Generator is already running");
	        }

	        if (state === GenStateCompleted) {
	          if (method === "throw") {
	            throw arg;
	          }

	          return doneResult();
	        }

	        context.method = method;
	        context.arg = arg;

	        while (true) {
	          var delegate = context.delegate;

	          if (delegate) {
	            var delegateResult = maybeInvokeDelegate(delegate, context);

	            if (delegateResult) {
	              if (delegateResult === ContinueSentinel) continue;
	              return delegateResult;
	            }
	          }

	          if (context.method === "next") {
	            context.sent = context._sent = context.arg;
	          } else if (context.method === "throw") {
	            if (state === GenStateSuspendedStart) {
	              state = GenStateCompleted;
	              throw context.arg;
	            }

	            context.dispatchException(context.arg);
	          } else if (context.method === "return") {
	            context.abrupt("return", context.arg);
	          }

	          state = GenStateExecuting;
	          var record = tryCatch(innerFn, self, context);

	          if (record.type === "normal") {
	            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

	            if (record.arg === ContinueSentinel) {
	              continue;
	            }

	            return {
	              value: record.arg,
	              done: context.done
	            };
	          } else if (record.type === "throw") {
	            state = GenStateCompleted;
	            context.method = "throw";
	            context.arg = record.arg;
	          }
	        }
	      };
	    }

	    function maybeInvokeDelegate(delegate, context) {
	      var method = delegate.iterator[context.method];

	      if (method === undefined$1) {
	        context.delegate = null;

	        if (context.method === "throw") {
	          if (delegate.iterator["return"]) {
	            context.method = "return";
	            context.arg = undefined$1;
	            maybeInvokeDelegate(delegate, context);

	            if (context.method === "throw") {
	              return ContinueSentinel;
	            }
	          }

	          context.method = "throw";
	          context.arg = new TypeError("The iterator does not provide a 'throw' method");
	        }

	        return ContinueSentinel;
	      }

	      var record = tryCatch(method, delegate.iterator, context.arg);

	      if (record.type === "throw") {
	        context.method = "throw";
	        context.arg = record.arg;
	        context.delegate = null;
	        return ContinueSentinel;
	      }

	      var info = record.arg;

	      if (!info) {
	        context.method = "throw";
	        context.arg = new TypeError("iterator result is not an object");
	        context.delegate = null;
	        return ContinueSentinel;
	      }

	      if (info.done) {
	        context[delegate.resultName] = info.value;
	        context.next = delegate.nextLoc;

	        if (context.method !== "return") {
	          context.method = "next";
	          context.arg = undefined$1;
	        }
	      } else {
	        return info;
	      }

	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    defineIteratorMethods(Gp);
	    define(Gp, toStringTagSymbol, "Generator");

	    Gp[iteratorSymbol] = function () {
	      return this;
	    };

	    Gp.toString = function () {
	      return "[object Generator]";
	    };

	    function pushTryEntry(locs) {
	      var entry = {
	        tryLoc: locs[0]
	      };

	      if (1 in locs) {
	        entry.catchLoc = locs[1];
	      }

	      if (2 in locs) {
	        entry.finallyLoc = locs[2];
	        entry.afterLoc = locs[3];
	      }

	      this.tryEntries.push(entry);
	    }

	    function resetTryEntry(entry) {
	      var record = entry.completion || {};
	      record.type = "normal";
	      delete record.arg;
	      entry.completion = record;
	    }

	    function Context(tryLocsList) {
	      this.tryEntries = [{
	        tryLoc: "root"
	      }];
	      tryLocsList.forEach(pushTryEntry, this);
	      this.reset(true);
	    }

	    exports.keys = function (object) {
	      var keys = [];

	      for (var key in object) {
	        keys.push(key);
	      }

	      keys.reverse();
	      return function next() {
	        while (keys.length) {
	          var key = keys.pop();

	          if (key in object) {
	            next.value = key;
	            next.done = false;
	            return next;
	          }
	        }

	        next.done = true;
	        return next;
	      };
	    };

	    function values(iterable) {
	      if (iterable) {
	        var iteratorMethod = iterable[iteratorSymbol];

	        if (iteratorMethod) {
	          return iteratorMethod.call(iterable);
	        }

	        if (typeof iterable.next === "function") {
	          return iterable;
	        }

	        if (!isNaN(iterable.length)) {
	          var i = -1,
	              next = function next() {
	            while (++i < iterable.length) {
	              if (hasOwn.call(iterable, i)) {
	                next.value = iterable[i];
	                next.done = false;
	                return next;
	              }
	            }

	            next.value = undefined$1;
	            next.done = true;
	            return next;
	          };

	          return next.next = next;
	        }
	      }

	      return {
	        next: doneResult
	      };
	    }

	    exports.values = values;

	    function doneResult() {
	      return {
	        value: undefined$1,
	        done: true
	      };
	    }

	    Context.prototype = {
	      constructor: Context,
	      reset: function reset(skipTempReset) {
	        this.prev = 0;
	        this.next = 0;
	        this.sent = this._sent = undefined$1;
	        this.done = false;
	        this.delegate = null;
	        this.method = "next";
	        this.arg = undefined$1;
	        this.tryEntries.forEach(resetTryEntry);

	        if (!skipTempReset) {
	          for (var name in this) {
	            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	              this[name] = undefined$1;
	            }
	          }
	        }
	      },
	      stop: function stop() {
	        this.done = true;
	        var rootEntry = this.tryEntries[0];
	        var rootRecord = rootEntry.completion;

	        if (rootRecord.type === "throw") {
	          throw rootRecord.arg;
	        }

	        return this.rval;
	      },
	      dispatchException: function dispatchException(exception) {
	        if (this.done) {
	          throw exception;
	        }

	        var context = this;

	        function handle(loc, caught) {
	          record.type = "throw";
	          record.arg = exception;
	          context.next = loc;

	          if (caught) {
	            context.method = "next";
	            context.arg = undefined$1;
	          }

	          return !!caught;
	        }

	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];
	          var record = entry.completion;

	          if (entry.tryLoc === "root") {
	            return handle("end");
	          }

	          if (entry.tryLoc <= this.prev) {
	            var hasCatch = hasOwn.call(entry, "catchLoc");
	            var hasFinally = hasOwn.call(entry, "finallyLoc");

	            if (hasCatch && hasFinally) {
	              if (this.prev < entry.catchLoc) {
	                return handle(entry.catchLoc, true);
	              } else if (this.prev < entry.finallyLoc) {
	                return handle(entry.finallyLoc);
	              }
	            } else if (hasCatch) {
	              if (this.prev < entry.catchLoc) {
	                return handle(entry.catchLoc, true);
	              }
	            } else if (hasFinally) {
	              if (this.prev < entry.finallyLoc) {
	                return handle(entry.finallyLoc);
	              }
	            } else {
	              throw new Error("try statement without catch or finally");
	            }
	          }
	        }
	      },
	      abrupt: function abrupt(type, arg) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	            var finallyEntry = entry;
	            break;
	          }
	        }

	        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	          finallyEntry = null;
	        }

	        var record = finallyEntry ? finallyEntry.completion : {};
	        record.type = type;
	        record.arg = arg;

	        if (finallyEntry) {
	          this.method = "next";
	          this.next = finallyEntry.finallyLoc;
	          return ContinueSentinel;
	        }

	        return this.complete(record);
	      },
	      complete: function complete(record, afterLoc) {
	        if (record.type === "throw") {
	          throw record.arg;
	        }

	        if (record.type === "break" || record.type === "continue") {
	          this.next = record.arg;
	        } else if (record.type === "return") {
	          this.rval = this.arg = record.arg;
	          this.method = "return";
	          this.next = "end";
	        } else if (record.type === "normal" && afterLoc) {
	          this.next = afterLoc;
	        }

	        return ContinueSentinel;
	      },
	      finish: function finish(finallyLoc) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.finallyLoc === finallyLoc) {
	            this.complete(entry.completion, entry.afterLoc);
	            resetTryEntry(entry);
	            return ContinueSentinel;
	          }
	        }
	      },
	      "catch": function _catch(tryLoc) {
	        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	          var entry = this.tryEntries[i];

	          if (entry.tryLoc === tryLoc) {
	            var record = entry.completion;

	            if (record.type === "throw") {
	              var thrown = record.arg;
	              resetTryEntry(entry);
	            }

	            return thrown;
	          }
	        }

	        throw new Error("illegal catch attempt");
	      },
	      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	        this.delegate = {
	          iterator: values(iterable),
	          resultName: resultName,
	          nextLoc: nextLoc
	        };

	        if (this.method === "next") {
	          this.arg = undefined$1;
	        }

	        return ContinueSentinel;
	      }
	    };
	    return exports;
	  }(module.exports );

	  try {
	    regeneratorRuntime = runtime;
	  } catch (accidentalStrictMode) {
		  console.log('regeneratorRuntime', accidentalStrictMode);
	    // Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}, "/$$rollup_base$$/node_modules/regenerator-runtime");

	var regenerator = runtime_1;

	var IdentifierName, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
	RegularExpressionLiteral = new RegExp("\\/(?![\\*\\/])(?:\\[(?:(?![\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*\\]|(?![\\/\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*(\\/(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u0898-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDD\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])*|\\\\)?", "y");
	Punctuator = new RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
	IdentifierName = new RegExp("(?=(?:[\\$A-Z\\\\_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]))(?:(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u0898-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDD\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])|\\\\u[0-9A-Fa-f]{4}|\\\\u\\{[0-9A-Fa-f]+\\})+", "y");
	StringLiteral = new RegExp("(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?", "y");
	NumericLiteral = new RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
	Template = new RegExp("[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
	WhiteSpace = new RegExp("[\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]+", "y");
	LineTerminatorSequence = new RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
	MultiLineComment = new RegExp("\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?", "y");
	SingleLineComment = new RegExp("\\/\\/.*", "y");
	JSXPunctuator = new RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
	JSXIdentifier = new RegExp("(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])(?:[\\$\\x2D0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u0898-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3C-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C5D\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDD\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1715\\u171F-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B4C\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDF70-\\uDF85\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC75\\uDC7F-\\uDCBA\\uDCC2\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDE70-\\uDEBE\\uDEC0-\\uDEC9\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDE90-\\uDEAE\\uDEC0-\\uDEF9]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])*", "y");
	JSXString = new RegExp("(['\"])(?:(?!\\1)[^])*(\\1)?", "y");
	JSXText = new RegExp("[^<>{}]+", "y");
	TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
	TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
	KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
	KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
	Newline = RegExp(LineTerminatorSequence.source);

	regenerator.mark(function jsTokens(input, _temp) {
	  var _ref, _ref$jsx, jsx, braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;

	  return regenerator.wrap(function jsTokens$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          _ref = _temp === void 0 ? {} : _temp, _ref$jsx = _ref.jsx, jsx = _ref$jsx === void 0 ? false : _ref$jsx;
	          length = input.length;
	          lastIndex = 0;
	          lastSignificantToken = "";
	          stack = [{
	            tag: "JS"
	          }];
	          braces = [];
	          parenNesting = 0;
	          postfixIncDec = false;

	        case 8:
	          if (!(lastIndex < length)) {
	            _context.next = 231;
	            break;
	          }

	          mode = stack[stack.length - 1];
	          _context.t0 = mode.tag;
	          _context.next = _context.t0 === "JS" ? 13 : _context.t0 === "JSNonExpressionParen" ? 13 : _context.t0 === "InterpolationInTemplate" ? 13 : _context.t0 === "InterpolationInJSX" ? 13 : _context.t0 === "JSXTag" ? 136 : _context.t0 === "JSXTagEnd" ? 136 : _context.t0 === "JSXChildren" ? 172 : 195;
	          break;

	        case 13:
	          if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
	            _context.next = 22;
	            break;
	          }

	          RegularExpressionLiteral.lastIndex = lastIndex;

	          if (!(match = RegularExpressionLiteral.exec(input))) {
	            _context.next = 22;
	            break;
	          }

	          lastIndex = RegularExpressionLiteral.lastIndex;
	          lastSignificantToken = match[0];
	          postfixIncDec = true;
	          _context.next = 21;
	          return {
	            type: "RegularExpressionLiteral",
	            value: match[0],
	            closed: match[1] !== void 0 && match[1] !== "\\"
	          };

	        case 21:
	          return _context.abrupt("continue", 8);

	        case 22:
	          Punctuator.lastIndex = lastIndex;

	          if (!(match = Punctuator.exec(input))) {
	            _context.next = 93;
	            break;
	          }

	          punctuator = match[0];
	          nextLastIndex = Punctuator.lastIndex;
	          nextLastSignificantToken = punctuator;
	          _context.t1 = punctuator;
	          _context.next = _context.t1 === "(" ? 30 : _context.t1 === ")" ? 34 : _context.t1 === "{" ? 38 : _context.t1 === "}" ? 43 : _context.t1 === "]" ? 74 : _context.t1 === "++" ? 76 : _context.t1 === "--" ? 76 : _context.t1 === "<" ? 78 : 87;
	          break;

	        case 30:
	          if (lastSignificantToken === "?NonExpressionParenKeyword") {
	            stack.push({
	              tag: "JSNonExpressionParen",
	              nesting: parenNesting
	            });
	          }

	          parenNesting++;
	          postfixIncDec = false;
	          return _context.abrupt("break", 88);

	        case 34:
	          parenNesting--;
	          postfixIncDec = true;

	          if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
	            stack.pop();
	            nextLastSignificantToken = "?NonExpressionParenEnd";
	            postfixIncDec = false;
	          }

	          return _context.abrupt("break", 88);

	        case 38:
	          Punctuator.lastIndex = 0;
	          isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
	          braces.push(isExpression);
	          postfixIncDec = false;
	          return _context.abrupt("break", 88);

	        case 43:
	          _context.t2 = mode.tag;
	          _context.next = _context.t2 === "InterpolationInTemplate" ? 46 : _context.t2 === "InterpolationInJSX" ? 64 : 71;
	          break;

	        case 46:
	          if (!(braces.length === mode.nesting)) {
	            _context.next = 63;
	            break;
	          }

	          Template.lastIndex = lastIndex;
	          match = Template.exec(input);
	          lastIndex = Template.lastIndex;
	          lastSignificantToken = match[0];

	          if (!(match[1] === "${")) {
	            _context.next = 58;
	            break;
	          }

	          lastSignificantToken = "?InterpolationInTemplate";
	          postfixIncDec = false;
	          _context.next = 56;
	          return {
	            type: "TemplateMiddle",
	            value: match[0]
	          };

	        case 56:
	          _context.next = 62;
	          break;

	        case 58:
	          stack.pop();
	          postfixIncDec = true;
	          _context.next = 62;
	          return {
	            type: "TemplateTail",
	            value: match[0],
	            closed: match[1] === "`"
	          };

	        case 62:
	          return _context.abrupt("continue", 8);

	        case 63:
	          return _context.abrupt("break", 71);

	        case 64:
	          if (!(braces.length === mode.nesting)) {
	            _context.next = 71;
	            break;
	          }

	          stack.pop();
	          lastIndex += 1;
	          lastSignificantToken = "}";
	          _context.next = 70;
	          return {
	            type: "JSXPunctuator",
	            value: "}"
	          };

	        case 70:
	          return _context.abrupt("continue", 8);

	        case 71:
	          postfixIncDec = braces.pop();
	          nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
	          return _context.abrupt("break", 88);

	        case 74:
	          postfixIncDec = true;
	          return _context.abrupt("break", 88);

	        case 76:
	          nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
	          return _context.abrupt("break", 88);

	        case 78:
	          if (!(jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
	            _context.next = 85;
	            break;
	          }

	          stack.push({
	            tag: "JSXTag"
	          });
	          lastIndex += 1;
	          lastSignificantToken = "<";
	          _context.next = 84;
	          return {
	            type: "JSXPunctuator",
	            value: punctuator
	          };

	        case 84:
	          return _context.abrupt("continue", 8);

	        case 85:
	          postfixIncDec = false;
	          return _context.abrupt("break", 88);

	        case 87:
	          postfixIncDec = false;

	        case 88:
	          lastIndex = nextLastIndex;
	          lastSignificantToken = nextLastSignificantToken;
	          _context.next = 92;
	          return {
	            type: "Punctuator",
	            value: punctuator
	          };

	        case 92:
	          return _context.abrupt("continue", 8);

	        case 93:
	          IdentifierName.lastIndex = lastIndex;

	          if (!(match = IdentifierName.exec(input))) {
	            _context.next = 103;
	            break;
	          }

	          lastIndex = IdentifierName.lastIndex;
	          nextLastSignificantToken = match[0];

	          switch (match[0]) {
	            case "for":
	            case "if":
	            case "while":
	            case "with":
	              if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
	                nextLastSignificantToken = "?NonExpressionParenKeyword";
	              }

	          }

	          lastSignificantToken = nextLastSignificantToken;
	          postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
	          _context.next = 102;
	          return {
	            type: "IdentifierName",
	            value: match[0]
	          };

	        case 102:
	          return _context.abrupt("continue", 8);

	        case 103:
	          StringLiteral.lastIndex = lastIndex;

	          if (!(match = StringLiteral.exec(input))) {
	            _context.next = 111;
	            break;
	          }

	          lastIndex = StringLiteral.lastIndex;
	          lastSignificantToken = match[0];
	          postfixIncDec = true;
	          _context.next = 110;
	          return {
	            type: "StringLiteral",
	            value: match[0],
	            closed: match[2] !== void 0
	          };

	        case 110:
	          return _context.abrupt("continue", 8);

	        case 111:
	          NumericLiteral.lastIndex = lastIndex;

	          if (!(match = NumericLiteral.exec(input))) {
	            _context.next = 119;
	            break;
	          }

	          lastIndex = NumericLiteral.lastIndex;
	          lastSignificantToken = match[0];
	          postfixIncDec = true;
	          _context.next = 118;
	          return {
	            type: "NumericLiteral",
	            value: match[0]
	          };

	        case 118:
	          return _context.abrupt("continue", 8);

	        case 119:
	          Template.lastIndex = lastIndex;

	          if (!(match = Template.exec(input))) {
	            _context.next = 135;
	            break;
	          }

	          lastIndex = Template.lastIndex;
	          lastSignificantToken = match[0];

	          if (!(match[1] === "${")) {
	            _context.next = 131;
	            break;
	          }

	          lastSignificantToken = "?InterpolationInTemplate";
	          stack.push({
	            tag: "InterpolationInTemplate",
	            nesting: braces.length
	          });
	          postfixIncDec = false;
	          _context.next = 129;
	          return {
	            type: "TemplateHead",
	            value: match[0]
	          };

	        case 129:
	          _context.next = 134;
	          break;

	        case 131:
	          postfixIncDec = true;
	          _context.next = 134;
	          return {
	            type: "NoSubstitutionTemplate",
	            value: match[0],
	            closed: match[1] === "`"
	          };

	        case 134:
	          return _context.abrupt("continue", 8);

	        case 135:
	          return _context.abrupt("break", 195);

	        case 136:
	          JSXPunctuator.lastIndex = lastIndex;

	          if (!(match = JSXPunctuator.exec(input))) {
	            _context.next = 157;
	            break;
	          }

	          lastIndex = JSXPunctuator.lastIndex;
	          nextLastSignificantToken = match[0];
	          _context.t3 = match[0];
	          _context.next = _context.t3 === "<" ? 143 : _context.t3 === ">" ? 145 : _context.t3 === "{" ? 148 : _context.t3 === "/" ? 152 : 153;
	          break;

	        case 143:
	          stack.push({
	            tag: "JSXTag"
	          });
	          return _context.abrupt("break", 153);

	        case 145:
	          stack.pop();

	          if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
	            nextLastSignificantToken = "?JSX";
	            postfixIncDec = true;
	          } else {
	            stack.push({
	              tag: "JSXChildren"
	            });
	          }

	          return _context.abrupt("break", 153);

	        case 148:
	          stack.push({
	            tag: "InterpolationInJSX",
	            nesting: braces.length
	          });
	          nextLastSignificantToken = "?InterpolationInJSX";
	          postfixIncDec = false;
	          return _context.abrupt("break", 153);

	        case 152:
	          if (lastSignificantToken === "<") {
	            stack.pop();

	            if (stack[stack.length - 1].tag === "JSXChildren") {
	              stack.pop();
	            }

	            stack.push({
	              tag: "JSXTagEnd"
	            });
	          }

	        case 153:
	          lastSignificantToken = nextLastSignificantToken;
	          _context.next = 156;
	          return {
	            type: "JSXPunctuator",
	            value: match[0]
	          };

	        case 156:
	          return _context.abrupt("continue", 8);

	        case 157:
	          JSXIdentifier.lastIndex = lastIndex;

	          if (!(match = JSXIdentifier.exec(input))) {
	            _context.next = 164;
	            break;
	          }

	          lastIndex = JSXIdentifier.lastIndex;
	          lastSignificantToken = match[0];
	          _context.next = 163;
	          return {
	            type: "JSXIdentifier",
	            value: match[0]
	          };

	        case 163:
	          return _context.abrupt("continue", 8);

	        case 164:
	          JSXString.lastIndex = lastIndex;

	          if (!(match = JSXString.exec(input))) {
	            _context.next = 171;
	            break;
	          }

	          lastIndex = JSXString.lastIndex;
	          lastSignificantToken = match[0];
	          _context.next = 170;
	          return {
	            type: "JSXString",
	            value: match[0],
	            closed: match[2] !== void 0
	          };

	        case 170:
	          return _context.abrupt("continue", 8);

	        case 171:
	          return _context.abrupt("break", 195);

	        case 172:
	          JSXText.lastIndex = lastIndex;

	          if (!(match = JSXText.exec(input))) {
	            _context.next = 179;
	            break;
	          }

	          lastIndex = JSXText.lastIndex;
	          lastSignificantToken = match[0];
	          _context.next = 178;
	          return {
	            type: "JSXText",
	            value: match[0]
	          };

	        case 178:
	          return _context.abrupt("continue", 8);

	        case 179:
	          _context.t4 = input[lastIndex];
	          _context.next = _context.t4 === "<" ? 182 : _context.t4 === "{" ? 188 : 195;
	          break;

	        case 182:
	          stack.push({
	            tag: "JSXTag"
	          });
	          lastIndex++;
	          lastSignificantToken = "<";
	          _context.next = 187;
	          return {
	            type: "JSXPunctuator",
	            value: "<"
	          };

	        case 187:
	          return _context.abrupt("continue", 8);

	        case 188:
	          stack.push({
	            tag: "InterpolationInJSX",
	            nesting: braces.length
	          });
	          lastIndex++;
	          lastSignificantToken = "?InterpolationInJSX";
	          postfixIncDec = false;
	          _context.next = 194;
	          return {
	            type: "JSXPunctuator",
	            value: "{"
	          };

	        case 194:
	          return _context.abrupt("continue", 8);

	        case 195:
	          WhiteSpace.lastIndex = lastIndex;

	          if (!(match = WhiteSpace.exec(input))) {
	            _context.next = 201;
	            break;
	          }

	          lastIndex = WhiteSpace.lastIndex;
	          _context.next = 200;
	          return {
	            type: "WhiteSpace",
	            value: match[0]
	          };

	        case 200:
	          return _context.abrupt("continue", 8);

	        case 201:
	          LineTerminatorSequence.lastIndex = lastIndex;

	          if (!(match = LineTerminatorSequence.exec(input))) {
	            _context.next = 209;
	            break;
	          }

	          lastIndex = LineTerminatorSequence.lastIndex;
	          postfixIncDec = false;

	          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
	            lastSignificantToken = "?NoLineTerminatorHere";
	          }

	          _context.next = 208;
	          return {
	            type: "LineTerminatorSequence",
	            value: match[0]
	          };

	        case 208:
	          return _context.abrupt("continue", 8);

	        case 209:
	          MultiLineComment.lastIndex = lastIndex;

	          if (!(match = MultiLineComment.exec(input))) {
	            _context.next = 216;
	            break;
	          }

	          lastIndex = MultiLineComment.lastIndex;

	          if (Newline.test(match[0])) {
	            postfixIncDec = false;

	            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
	              lastSignificantToken = "?NoLineTerminatorHere";
	            }
	          }

	          _context.next = 215;
	          return {
	            type: "MultiLineComment",
	            value: match[0],
	            closed: match[1] !== void 0
	          };

	        case 215:
	          return _context.abrupt("continue", 8);

	        case 216:
	          SingleLineComment.lastIndex = lastIndex;

	          if (!(match = SingleLineComment.exec(input))) {
	            _context.next = 223;
	            break;
	          }

	          lastIndex = SingleLineComment.lastIndex;
	          postfixIncDec = false;
	          _context.next = 222;
	          return {
	            type: "SingleLineComment",
	            value: match[0]
	          };

	        case 222:
	          return _context.abrupt("continue", 8);

	        case 223:
	          firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
	          lastIndex += firstCodePoint.length;
	          lastSignificantToken = firstCodePoint;
	          postfixIncDec = false;
	          _context.next = 229;
	          return {
	            type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
	            value: firstCodePoint
	          };

	        case 229:
	          _context.next = 8;
	          break;

	        case 231:
	          return _context.abrupt("return", void 0);

	        case 232:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, jsTokens);
	});

	var _default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

	var matchToToken = function matchToToken(match) {
	  var token = {
	    type: "invalid",
	    value: match[0],
	    closed: undefined
	  };
	  if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
	  return token;
	};

	var jsTokensBABEL_8_BREAKINGFalse = Object.defineProperty({
	  "default": _default,
	  matchToToken: matchToToken
	}, '__esModule', {
	  value: true
	});

	var jsTokens = jsTokensBABEL_8_BREAKINGFalse;

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	var escapeStringRegexp = function escapeStringRegexp(str) {
	  if (typeof str !== 'string') {
	    throw new TypeError('Expected a string');
	  }

	  return str.replace(matchOperatorsRe, '\\$&');
	};

	var colorName = {
	  "aliceblue": [240, 248, 255],
	  "antiquewhite": [250, 235, 215],
	  "aqua": [0, 255, 255],
	  "aquamarine": [127, 255, 212],
	  "azure": [240, 255, 255],
	  "beige": [245, 245, 220],
	  "bisque": [255, 228, 196],
	  "black": [0, 0, 0],
	  "blanchedalmond": [255, 235, 205],
	  "blue": [0, 0, 255],
	  "blueviolet": [138, 43, 226],
	  "brown": [165, 42, 42],
	  "burlywood": [222, 184, 135],
	  "cadetblue": [95, 158, 160],
	  "chartreuse": [127, 255, 0],
	  "chocolate": [210, 105, 30],
	  "coral": [255, 127, 80],
	  "cornflowerblue": [100, 149, 237],
	  "cornsilk": [255, 248, 220],
	  "crimson": [220, 20, 60],
	  "cyan": [0, 255, 255],
	  "darkblue": [0, 0, 139],
	  "darkcyan": [0, 139, 139],
	  "darkgoldenrod": [184, 134, 11],
	  "darkgray": [169, 169, 169],
	  "darkgreen": [0, 100, 0],
	  "darkgrey": [169, 169, 169],
	  "darkkhaki": [189, 183, 107],
	  "darkmagenta": [139, 0, 139],
	  "darkolivegreen": [85, 107, 47],
	  "darkorange": [255, 140, 0],
	  "darkorchid": [153, 50, 204],
	  "darkred": [139, 0, 0],
	  "darksalmon": [233, 150, 122],
	  "darkseagreen": [143, 188, 143],
	  "darkslateblue": [72, 61, 139],
	  "darkslategray": [47, 79, 79],
	  "darkslategrey": [47, 79, 79],
	  "darkturquoise": [0, 206, 209],
	  "darkviolet": [148, 0, 211],
	  "deeppink": [255, 20, 147],
	  "deepskyblue": [0, 191, 255],
	  "dimgray": [105, 105, 105],
	  "dimgrey": [105, 105, 105],
	  "dodgerblue": [30, 144, 255],
	  "firebrick": [178, 34, 34],
	  "floralwhite": [255, 250, 240],
	  "forestgreen": [34, 139, 34],
	  "fuchsia": [255, 0, 255],
	  "gainsboro": [220, 220, 220],
	  "ghostwhite": [248, 248, 255],
	  "gold": [255, 215, 0],
	  "goldenrod": [218, 165, 32],
	  "gray": [128, 128, 128],
	  "green": [0, 128, 0],
	  "greenyellow": [173, 255, 47],
	  "grey": [128, 128, 128],
	  "honeydew": [240, 255, 240],
	  "hotpink": [255, 105, 180],
	  "indianred": [205, 92, 92],
	  "indigo": [75, 0, 130],
	  "ivory": [255, 255, 240],
	  "khaki": [240, 230, 140],
	  "lavender": [230, 230, 250],
	  "lavenderblush": [255, 240, 245],
	  "lawngreen": [124, 252, 0],
	  "lemonchiffon": [255, 250, 205],
	  "lightblue": [173, 216, 230],
	  "lightcoral": [240, 128, 128],
	  "lightcyan": [224, 255, 255],
	  "lightgoldenrodyellow": [250, 250, 210],
	  "lightgray": [211, 211, 211],
	  "lightgreen": [144, 238, 144],
	  "lightgrey": [211, 211, 211],
	  "lightpink": [255, 182, 193],
	  "lightsalmon": [255, 160, 122],
	  "lightseagreen": [32, 178, 170],
	  "lightskyblue": [135, 206, 250],
	  "lightslategray": [119, 136, 153],
	  "lightslategrey": [119, 136, 153],
	  "lightsteelblue": [176, 196, 222],
	  "lightyellow": [255, 255, 224],
	  "lime": [0, 255, 0],
	  "limegreen": [50, 205, 50],
	  "linen": [250, 240, 230],
	  "magenta": [255, 0, 255],
	  "maroon": [128, 0, 0],
	  "mediumaquamarine": [102, 205, 170],
	  "mediumblue": [0, 0, 205],
	  "mediumorchid": [186, 85, 211],
	  "mediumpurple": [147, 112, 219],
	  "mediumseagreen": [60, 179, 113],
	  "mediumslateblue": [123, 104, 238],
	  "mediumspringgreen": [0, 250, 154],
	  "mediumturquoise": [72, 209, 204],
	  "mediumvioletred": [199, 21, 133],
	  "midnightblue": [25, 25, 112],
	  "mintcream": [245, 255, 250],
	  "mistyrose": [255, 228, 225],
	  "moccasin": [255, 228, 181],
	  "navajowhite": [255, 222, 173],
	  "navy": [0, 0, 128],
	  "oldlace": [253, 245, 230],
	  "olive": [128, 128, 0],
	  "olivedrab": [107, 142, 35],
	  "orange": [255, 165, 0],
	  "orangered": [255, 69, 0],
	  "orchid": [218, 112, 214],
	  "palegoldenrod": [238, 232, 170],
	  "palegreen": [152, 251, 152],
	  "paleturquoise": [175, 238, 238],
	  "palevioletred": [219, 112, 147],
	  "papayawhip": [255, 239, 213],
	  "peachpuff": [255, 218, 185],
	  "peru": [205, 133, 63],
	  "pink": [255, 192, 203],
	  "plum": [221, 160, 221],
	  "powderblue": [176, 224, 230],
	  "purple": [128, 0, 128],
	  "rebeccapurple": [102, 51, 153],
	  "red": [255, 0, 0],
	  "rosybrown": [188, 143, 143],
	  "royalblue": [65, 105, 225],
	  "saddlebrown": [139, 69, 19],
	  "salmon": [250, 128, 114],
	  "sandybrown": [244, 164, 96],
	  "seagreen": [46, 139, 87],
	  "seashell": [255, 245, 238],
	  "sienna": [160, 82, 45],
	  "silver": [192, 192, 192],
	  "skyblue": [135, 206, 235],
	  "slateblue": [106, 90, 205],
	  "slategray": [112, 128, 144],
	  "slategrey": [112, 128, 144],
	  "snow": [255, 250, 250],
	  "springgreen": [0, 255, 127],
	  "steelblue": [70, 130, 180],
	  "tan": [210, 180, 140],
	  "teal": [0, 128, 128],
	  "thistle": [216, 191, 216],
	  "tomato": [255, 99, 71],
	  "turquoise": [64, 224, 208],
	  "violet": [238, 130, 238],
	  "wheat": [245, 222, 179],
	  "white": [255, 255, 255],
	  "whitesmoke": [245, 245, 245],
	  "yellow": [255, 255, 0],
	  "yellowgreen": [154, 205, 50]
	};

	var conversions = createCommonjsModule(function (module) {
	  var reverseKeywords = {};

	  for (var key in colorName) {
	    if (colorName.hasOwnProperty(key)) {
	      reverseKeywords[colorName[key]] = key;
	    }
	  }

	  var convert = module.exports = {
	    rgb: {
	      channels: 3,
	      labels: 'rgb'
	    },
	    hsl: {
	      channels: 3,
	      labels: 'hsl'
	    },
	    hsv: {
	      channels: 3,
	      labels: 'hsv'
	    },
	    hwb: {
	      channels: 3,
	      labels: 'hwb'
	    },
	    cmyk: {
	      channels: 4,
	      labels: 'cmyk'
	    },
	    xyz: {
	      channels: 3,
	      labels: 'xyz'
	    },
	    lab: {
	      channels: 3,
	      labels: 'lab'
	    },
	    lch: {
	      channels: 3,
	      labels: 'lch'
	    },
	    hex: {
	      channels: 1,
	      labels: ['hex']
	    },
	    keyword: {
	      channels: 1,
	      labels: ['keyword']
	    },
	    ansi16: {
	      channels: 1,
	      labels: ['ansi16']
	    },
	    ansi256: {
	      channels: 1,
	      labels: ['ansi256']
	    },
	    hcg: {
	      channels: 3,
	      labels: ['h', 'c', 'g']
	    },
	    apple: {
	      channels: 3,
	      labels: ['r16', 'g16', 'b16']
	    },
	    gray: {
	      channels: 1,
	      labels: ['gray']
	    }
	  };

	  for (var model in convert) {
	    if (convert.hasOwnProperty(model)) {
	      if (!('channels' in convert[model])) {
	        throw new Error('missing channels property: ' + model);
	      }

	      if (!('labels' in convert[model])) {
	        throw new Error('missing channel labels property: ' + model);
	      }

	      if (convert[model].labels.length !== convert[model].channels) {
	        throw new Error('channel and label counts mismatch: ' + model);
	      }

	      var channels = convert[model].channels;
	      var labels = convert[model].labels;
	      delete convert[model].channels;
	      delete convert[model].labels;
	      Object.defineProperty(convert[model], 'channels', {
	        value: channels
	      });
	      Object.defineProperty(convert[model], 'labels', {
	        value: labels
	      });
	    }
	  }

	  convert.rgb.hsl = function (rgb) {
	    var r = rgb[0] / 255;
	    var g = rgb[1] / 255;
	    var b = rgb[2] / 255;
	    var min = Math.min(r, g, b);
	    var max = Math.max(r, g, b);
	    var delta = max - min;
	    var h;
	    var s;
	    var l;

	    if (max === min) {
	      h = 0;
	    } else if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else if (b === max) {
	      h = 4 + (r - g) / delta;
	    }

	    h = Math.min(h * 60, 360);

	    if (h < 0) {
	      h += 360;
	    }

	    l = (min + max) / 2;

	    if (max === min) {
	      s = 0;
	    } else if (l <= 0.5) {
	      s = delta / (max + min);
	    } else {
	      s = delta / (2 - max - min);
	    }

	    return [h, s * 100, l * 100];
	  };

	  convert.rgb.hsv = function (rgb) {
	    var rdif;
	    var gdif;
	    var bdif;
	    var h;
	    var s;
	    var r = rgb[0] / 255;
	    var g = rgb[1] / 255;
	    var b = rgb[2] / 255;
	    var v = Math.max(r, g, b);
	    var diff = v - Math.min(r, g, b);

	    var diffc = function diffc(c) {
	      return (v - c) / 6 / diff + 1 / 2;
	    };

	    if (diff === 0) {
	      h = s = 0;
	    } else {
	      s = diff / v;
	      rdif = diffc(r);
	      gdif = diffc(g);
	      bdif = diffc(b);

	      if (r === v) {
	        h = bdif - gdif;
	      } else if (g === v) {
	        h = 1 / 3 + rdif - bdif;
	      } else if (b === v) {
	        h = 2 / 3 + gdif - rdif;
	      }

	      if (h < 0) {
	        h += 1;
	      } else if (h > 1) {
	        h -= 1;
	      }
	    }

	    return [h * 360, s * 100, v * 100];
	  };

	  convert.rgb.hwb = function (rgb) {
	    var r = rgb[0];
	    var g = rgb[1];
	    var b = rgb[2];
	    var h = convert.rgb.hsl(rgb)[0];
	    var w = 1 / 255 * Math.min(r, Math.min(g, b));
	    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
	    return [h, w * 100, b * 100];
	  };

	  convert.rgb.cmyk = function (rgb) {
	    var r = rgb[0] / 255;
	    var g = rgb[1] / 255;
	    var b = rgb[2] / 255;
	    var c;
	    var m;
	    var y;
	    var k;
	    k = Math.min(1 - r, 1 - g, 1 - b);
	    c = (1 - r - k) / (1 - k) || 0;
	    m = (1 - g - k) / (1 - k) || 0;
	    y = (1 - b - k) / (1 - k) || 0;
	    return [c * 100, m * 100, y * 100, k * 100];
	  };

	  function comparativeDistance(x, y) {
	    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
	  }

	  convert.rgb.keyword = function (rgb) {
	    var reversed = reverseKeywords[rgb];

	    if (reversed) {
	      return reversed;
	    }

	    var currentClosestDistance = Infinity;
	    var currentClosestKeyword;

	    for (var keyword in colorName) {
	      if (colorName.hasOwnProperty(keyword)) {
	        var value = colorName[keyword];
	        var distance = comparativeDistance(rgb, value);

	        if (distance < currentClosestDistance) {
	          currentClosestDistance = distance;
	          currentClosestKeyword = keyword;
	        }
	      }
	    }

	    return currentClosestKeyword;
	  };

	  convert.keyword.rgb = function (keyword) {
	    return colorName[keyword];
	  };

	  convert.rgb.xyz = function (rgb) {
	    var r = rgb[0] / 255;
	    var g = rgb[1] / 255;
	    var b = rgb[2] / 255;
	    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
	    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
	    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
	    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
	    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
	    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
	    return [x * 100, y * 100, z * 100];
	  };

	  convert.rgb.lab = function (rgb) {
	    var xyz = convert.rgb.xyz(rgb);
	    var x = xyz[0];
	    var y = xyz[1];
	    var z = xyz[2];
	    var l;
	    var a;
	    var b;
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
	    l = 116 * y - 16;
	    a = 500 * (x - y);
	    b = 200 * (y - z);
	    return [l, a, b];
	  };

	  convert.hsl.rgb = function (hsl) {
	    var h = hsl[0] / 360;
	    var s = hsl[1] / 100;
	    var l = hsl[2] / 100;
	    var t1;
	    var t2;
	    var t3;
	    var rgb;
	    var val;

	    if (s === 0) {
	      val = l * 255;
	      return [val, val, val];
	    }

	    if (l < 0.5) {
	      t2 = l * (1 + s);
	    } else {
	      t2 = l + s - l * s;
	    }

	    t1 = 2 * l - t2;
	    rgb = [0, 0, 0];

	    for (var i = 0; i < 3; i++) {
	      t3 = h + 1 / 3 * -(i - 1);

	      if (t3 < 0) {
	        t3++;
	      }

	      if (t3 > 1) {
	        t3--;
	      }

	      if (6 * t3 < 1) {
	        val = t1 + (t2 - t1) * 6 * t3;
	      } else if (2 * t3 < 1) {
	        val = t2;
	      } else if (3 * t3 < 2) {
	        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	      } else {
	        val = t1;
	      }

	      rgb[i] = val * 255;
	    }

	    return rgb;
	  };

	  convert.hsl.hsv = function (hsl) {
	    var h = hsl[0];
	    var s = hsl[1] / 100;
	    var l = hsl[2] / 100;
	    var smin = s;
	    var lmin = Math.max(l, 0.01);
	    var sv;
	    var v;
	    l *= 2;
	    s *= l <= 1 ? l : 2 - l;
	    smin *= lmin <= 1 ? lmin : 2 - lmin;
	    v = (l + s) / 2;
	    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
	    return [h, sv * 100, v * 100];
	  };

	  convert.hsv.rgb = function (hsv) {
	    var h = hsv[0] / 60;
	    var s = hsv[1] / 100;
	    var v = hsv[2] / 100;
	    var hi = Math.floor(h) % 6;
	    var f = h - Math.floor(h);
	    var p = 255 * v * (1 - s);
	    var q = 255 * v * (1 - s * f);
	    var t = 255 * v * (1 - s * (1 - f));
	    v *= 255;

	    switch (hi) {
	      case 0:
	        return [v, t, p];

	      case 1:
	        return [q, v, p];

	      case 2:
	        return [p, v, t];

	      case 3:
	        return [p, q, v];

	      case 4:
	        return [t, p, v];

	      case 5:
	        return [v, p, q];
	    }
	  };

	  convert.hsv.hsl = function (hsv) {
	    var h = hsv[0];
	    var s = hsv[1] / 100;
	    var v = hsv[2] / 100;
	    var vmin = Math.max(v, 0.01);
	    var lmin;
	    var sl;
	    var l;
	    l = (2 - s) * v;
	    lmin = (2 - s) * vmin;
	    sl = s * vmin;
	    sl /= lmin <= 1 ? lmin : 2 - lmin;
	    sl = sl || 0;
	    l /= 2;
	    return [h, sl * 100, l * 100];
	  };

	  convert.hwb.rgb = function (hwb) {
	    var h = hwb[0] / 360;
	    var wh = hwb[1] / 100;
	    var bl = hwb[2] / 100;
	    var ratio = wh + bl;
	    var i;
	    var v;
	    var f;
	    var n;

	    if (ratio > 1) {
	      wh /= ratio;
	      bl /= ratio;
	    }

	    i = Math.floor(6 * h);
	    v = 1 - bl;
	    f = 6 * h - i;

	    if ((i & 0x01) !== 0) {
	      f = 1 - f;
	    }

	    n = wh + f * (v - wh);
	    var r;
	    var g;
	    var b;

	    switch (i) {
	      default:
	      case 6:
	      case 0:
	        r = v;
	        g = n;
	        b = wh;
	        break;

	      case 1:
	        r = n;
	        g = v;
	        b = wh;
	        break;

	      case 2:
	        r = wh;
	        g = v;
	        b = n;
	        break;

	      case 3:
	        r = wh;
	        g = n;
	        b = v;
	        break;

	      case 4:
	        r = n;
	        g = wh;
	        b = v;
	        break;

	      case 5:
	        r = v;
	        g = wh;
	        b = n;
	        break;
	    }

	    return [r * 255, g * 255, b * 255];
	  };

	  convert.cmyk.rgb = function (cmyk) {
	    var c = cmyk[0] / 100;
	    var m = cmyk[1] / 100;
	    var y = cmyk[2] / 100;
	    var k = cmyk[3] / 100;
	    var r;
	    var g;
	    var b;
	    r = 1 - Math.min(1, c * (1 - k) + k);
	    g = 1 - Math.min(1, m * (1 - k) + k);
	    b = 1 - Math.min(1, y * (1 - k) + k);
	    return [r * 255, g * 255, b * 255];
	  };

	  convert.xyz.rgb = function (xyz) {
	    var x = xyz[0] / 100;
	    var y = xyz[1] / 100;
	    var z = xyz[2] / 100;
	    var r;
	    var g;
	    var b;
	    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
	    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
	    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
	    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
	    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
	    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
	    r = Math.min(Math.max(0, r), 1);
	    g = Math.min(Math.max(0, g), 1);
	    b = Math.min(Math.max(0, b), 1);
	    return [r * 255, g * 255, b * 255];
	  };

	  convert.xyz.lab = function (xyz) {
	    var x = xyz[0];
	    var y = xyz[1];
	    var z = xyz[2];
	    var l;
	    var a;
	    var b;
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
	    l = 116 * y - 16;
	    a = 500 * (x - y);
	    b = 200 * (y - z);
	    return [l, a, b];
	  };

	  convert.lab.xyz = function (lab) {
	    var l = lab[0];
	    var a = lab[1];
	    var b = lab[2];
	    var x;
	    var y;
	    var z;
	    y = (l + 16) / 116;
	    x = a / 500 + y;
	    z = y - b / 200;
	    var y2 = Math.pow(y, 3);
	    var x2 = Math.pow(x, 3);
	    var z2 = Math.pow(z, 3);
	    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
	    x *= 95.047;
	    y *= 100;
	    z *= 108.883;
	    return [x, y, z];
	  };

	  convert.lab.lch = function (lab) {
	    var l = lab[0];
	    var a = lab[1];
	    var b = lab[2];
	    var hr;
	    var h;
	    var c;
	    hr = Math.atan2(b, a);
	    h = hr * 360 / 2 / Math.PI;

	    if (h < 0) {
	      h += 360;
	    }

	    c = Math.sqrt(a * a + b * b);
	    return [l, c, h];
	  };

	  convert.lch.lab = function (lch) {
	    var l = lch[0];
	    var c = lch[1];
	    var h = lch[2];
	    var a;
	    var b;
	    var hr;
	    hr = h / 360 * 2 * Math.PI;
	    a = c * Math.cos(hr);
	    b = c * Math.sin(hr);
	    return [l, a, b];
	  };

	  convert.rgb.ansi16 = function (args) {
	    var r = args[0];
	    var g = args[1];
	    var b = args[2];
	    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
	    value = Math.round(value / 50);

	    if (value === 0) {
	      return 30;
	    }

	    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

	    if (value === 2) {
	      ansi += 60;
	    }

	    return ansi;
	  };

	  convert.hsv.ansi16 = function (args) {
	    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	  };

	  convert.rgb.ansi256 = function (args) {
	    var r = args[0];
	    var g = args[1];
	    var b = args[2];

	    if (r === g && g === b) {
	      if (r < 8) {
	        return 16;
	      }

	      if (r > 248) {
	        return 231;
	      }

	      return Math.round((r - 8) / 247 * 24) + 232;
	    }

	    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	    return ansi;
	  };

	  convert.ansi16.rgb = function (args) {
	    var color = args % 10;

	    if (color === 0 || color === 7) {
	      if (args > 50) {
	        color += 3.5;
	      }

	      color = color / 10.5 * 255;
	      return [color, color, color];
	    }

	    var mult = (~~(args > 50) + 1) * 0.5;
	    var r = (color & 1) * mult * 255;
	    var g = (color >> 1 & 1) * mult * 255;
	    var b = (color >> 2 & 1) * mult * 255;
	    return [r, g, b];
	  };

	  convert.ansi256.rgb = function (args) {
	    if (args >= 232) {
	      var c = (args - 232) * 10 + 8;
	      return [c, c, c];
	    }

	    args -= 16;
	    var rem;
	    var r = Math.floor(args / 36) / 5 * 255;
	    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	    var b = rem % 6 / 5 * 255;
	    return [r, g, b];
	  };

	  convert.rgb.hex = function (args) {
	    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
	    var string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };

	  convert.hex.rgb = function (args) {
	    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

	    if (!match) {
	      return [0, 0, 0];
	    }

	    var colorString = match[0];

	    if (match[0].length === 3) {
	      colorString = colorString.split('').map(function (_char) {
	        return _char + _char;
	      }).join('');
	    }

	    var integer = parseInt(colorString, 16);
	    var r = integer >> 16 & 0xFF;
	    var g = integer >> 8 & 0xFF;
	    var b = integer & 0xFF;
	    return [r, g, b];
	  };

	  convert.rgb.hcg = function (rgb) {
	    var r = rgb[0] / 255;
	    var g = rgb[1] / 255;
	    var b = rgb[2] / 255;
	    var max = Math.max(Math.max(r, g), b);
	    var min = Math.min(Math.min(r, g), b);
	    var chroma = max - min;
	    var grayscale;
	    var hue;

	    if (chroma < 1) {
	      grayscale = min / (1 - chroma);
	    } else {
	      grayscale = 0;
	    }

	    if (chroma <= 0) {
	      hue = 0;
	    } else if (max === r) {
	      hue = (g - b) / chroma % 6;
	    } else if (max === g) {
	      hue = 2 + (b - r) / chroma;
	    } else {
	      hue = 4 + (r - g) / chroma + 4;
	    }

	    hue /= 6;
	    hue %= 1;
	    return [hue * 360, chroma * 100, grayscale * 100];
	  };

	  convert.hsl.hcg = function (hsl) {
	    var s = hsl[1] / 100;
	    var l = hsl[2] / 100;
	    var c = 1;
	    var f = 0;

	    if (l < 0.5) {
	      c = 2.0 * s * l;
	    } else {
	      c = 2.0 * s * (1.0 - l);
	    }

	    if (c < 1.0) {
	      f = (l - 0.5 * c) / (1.0 - c);
	    }

	    return [hsl[0], c * 100, f * 100];
	  };

	  convert.hsv.hcg = function (hsv) {
	    var s = hsv[1] / 100;
	    var v = hsv[2] / 100;
	    var c = s * v;
	    var f = 0;

	    if (c < 1.0) {
	      f = (v - c) / (1 - c);
	    }

	    return [hsv[0], c * 100, f * 100];
	  };

	  convert.hcg.rgb = function (hcg) {
	    var h = hcg[0] / 360;
	    var c = hcg[1] / 100;
	    var g = hcg[2] / 100;

	    if (c === 0.0) {
	      return [g * 255, g * 255, g * 255];
	    }

	    var pure = [0, 0, 0];
	    var hi = h % 1 * 6;
	    var v = hi % 1;
	    var w = 1 - v;
	    var mg = 0;

	    switch (Math.floor(hi)) {
	      case 0:
	        pure[0] = 1;
	        pure[1] = v;
	        pure[2] = 0;
	        break;

	      case 1:
	        pure[0] = w;
	        pure[1] = 1;
	        pure[2] = 0;
	        break;

	      case 2:
	        pure[0] = 0;
	        pure[1] = 1;
	        pure[2] = v;
	        break;

	      case 3:
	        pure[0] = 0;
	        pure[1] = w;
	        pure[2] = 1;
	        break;

	      case 4:
	        pure[0] = v;
	        pure[1] = 0;
	        pure[2] = 1;
	        break;

	      default:
	        pure[0] = 1;
	        pure[1] = 0;
	        pure[2] = w;
	    }

	    mg = (1.0 - c) * g;
	    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
	  };

	  convert.hcg.hsv = function (hcg) {
	    var c = hcg[1] / 100;
	    var g = hcg[2] / 100;
	    var v = c + g * (1.0 - c);
	    var f = 0;

	    if (v > 0.0) {
	      f = c / v;
	    }

	    return [hcg[0], f * 100, v * 100];
	  };

	  convert.hcg.hsl = function (hcg) {
	    var c = hcg[1] / 100;
	    var g = hcg[2] / 100;
	    var l = g * (1.0 - c) + 0.5 * c;
	    var s = 0;

	    if (l > 0.0 && l < 0.5) {
	      s = c / (2 * l);
	    } else if (l >= 0.5 && l < 1.0) {
	      s = c / (2 * (1 - l));
	    }

	    return [hcg[0], s * 100, l * 100];
	  };

	  convert.hcg.hwb = function (hcg) {
	    var c = hcg[1] / 100;
	    var g = hcg[2] / 100;
	    var v = c + g * (1.0 - c);
	    return [hcg[0], (v - c) * 100, (1 - v) * 100];
	  };

	  convert.hwb.hcg = function (hwb) {
	    var w = hwb[1] / 100;
	    var b = hwb[2] / 100;
	    var v = 1 - b;
	    var c = v - w;
	    var g = 0;

	    if (c < 1) {
	      g = (v - c) / (1 - c);
	    }

	    return [hwb[0], c * 100, g * 100];
	  };

	  convert.apple.rgb = function (apple) {
	    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
	  };

	  convert.rgb.apple = function (rgb) {
	    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
	  };

	  convert.gray.rgb = function (args) {
	    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	  };

	  convert.gray.hsl = convert.gray.hsv = function (args) {
	    return [0, 0, args[0]];
	  };

	  convert.gray.hwb = function (gray) {
	    return [0, 100, gray[0]];
	  };

	  convert.gray.cmyk = function (gray) {
	    return [0, 0, 0, gray[0]];
	  };

	  convert.gray.lab = function (gray) {
	    return [gray[0], 0, 0];
	  };

	  convert.gray.hex = function (gray) {
	    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	    var integer = (val << 16) + (val << 8) + val;
	    var string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };

	  convert.rgb.gray = function (rgb) {
	    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	    return [val / 255 * 100];
	  };
	}, "/$$rollup_base$$/node_modules/color-convert");

	function buildGraph() {
	  var graph = {};
	  var models = Object.keys(conversions);

	  for (var len = models.length, i = 0; i < len; i++) {
	    graph[models[i]] = {
	      distance: -1,
	      parent: null
	    };
	  }

	  return graph;
	}

	function deriveBFS(fromModel) {
	  var graph = buildGraph();
	  var queue = [fromModel];
	  graph[fromModel].distance = 0;

	  while (queue.length) {
	    var current = queue.pop();
	    var adjacents = Object.keys(conversions[current]);

	    for (var len = adjacents.length, i = 0; i < len; i++) {
	      var adjacent = adjacents[i];
	      var node = graph[adjacent];

	      if (node.distance === -1) {
	        node.distance = graph[current].distance + 1;
	        node.parent = current;
	        queue.unshift(adjacent);
	      }
	    }
	  }

	  return graph;
	}

	function link(from, to) {
	  return function (args) {
	    return to(from(args));
	  };
	}

	function wrapConversion(toModel, graph) {
	  var path = [graph[toModel].parent, toModel];
	  var fn = conversions[graph[toModel].parent][toModel];
	  var cur = graph[toModel].parent;

	  while (graph[cur].parent) {
	    path.unshift(graph[cur].parent);
	    fn = link(conversions[graph[cur].parent][cur], fn);
	    cur = graph[cur].parent;
	  }

	  fn.conversion = path;
	  return fn;
	}

	var route = function route(fromModel) {
	  var graph = deriveBFS(fromModel);
	  var conversion = {};
	  var models = Object.keys(graph);

	  for (var len = models.length, i = 0; i < len; i++) {
	    var toModel = models[i];
	    var node = graph[toModel];

	    if (node.parent === null) {
	      continue;
	    }

	    conversion[toModel] = wrapConversion(toModel, graph);
	  }

	  return conversion;
	};

	var convert = {};
	var models = Object.keys(conversions);

	function wrapRaw(fn) {
	  var wrappedFn = function wrappedFn(args) {
	    if (args === undefined || args === null) {
	      return args;
	    }

	    if (arguments.length > 1) {
	      args = Array.prototype.slice.call(arguments);
	    }

	    return fn(args);
	  };

	  if ('conversion' in fn) {
	    wrappedFn.conversion = fn.conversion;
	  }

	  return wrappedFn;
	}

	function wrapRounded(fn) {
	  var wrappedFn = function wrappedFn(args) {
	    if (args === undefined || args === null) {
	      return args;
	    }

	    if (arguments.length > 1) {
	      args = Array.prototype.slice.call(arguments);
	    }

	    var result = fn(args);

	    if (typeof result === 'object') {
	      for (var len = result.length, i = 0; i < len; i++) {
	        result[i] = Math.round(result[i]);
	      }
	    }

	    return result;
	  };

	  if ('conversion' in fn) {
	    wrappedFn.conversion = fn.conversion;
	  }

	  return wrappedFn;
	}

	models.forEach(function (fromModel) {
	  convert[fromModel] = {};
	  Object.defineProperty(convert[fromModel], 'channels', {
	    value: conversions[fromModel].channels
	  });
	  Object.defineProperty(convert[fromModel], 'labels', {
	    value: conversions[fromModel].labels
	  });
	  var routes = route(fromModel);
	  var routeModels = Object.keys(routes);
	  routeModels.forEach(function (toModel) {
	    var fn = routes[toModel];
	    convert[fromModel][toModel] = wrapRounded(fn);
	    convert[fromModel][toModel].raw = wrapRaw(fn);
	  });
	});
	var colorConvert = convert;

	var ansiStyles = createCommonjsModule(function (module) {

	  var wrapAnsi16 = function wrapAnsi16(fn, offset) {
	    return function () {
	      var code = fn.apply(colorConvert, arguments);
	      return "\x1B[" + (code + offset) + "m";
	    };
	  };

	  var wrapAnsi256 = function wrapAnsi256(fn, offset) {
	    return function () {
	      var code = fn.apply(colorConvert, arguments);
	      return "\x1B[" + (38 + offset) + ";5;" + code + "m";
	    };
	  };

	  var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
	    return function () {
	      var rgb = fn.apply(colorConvert, arguments);
	      return "\x1B[" + (38 + offset) + ";2;" + rgb[0] + ";" + rgb[1] + ";" + rgb[2] + "m";
	    };
	  };

	  function assembleStyles() {
	    var codes = new Map();
	    var styles = {
	      modifier: {
	        reset: [0, 0],
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        gray: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    };
	    styles.color.grey = styles.color.gray;

	    for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
	      var groupName = _Object$keys[_i];
	      var group = styles[groupName];

	      for (var _i2 = 0, _Object$keys2 = Object.keys(group); _i2 < _Object$keys2.length; _i2++) {
	        var styleName = _Object$keys2[_i2];
	        var style = group[styleName];
	        styles[styleName] = {
	          open: "\x1B[" + style[0] + "m",
	          close: "\x1B[" + style[1] + "m"
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }

	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	      Object.defineProperty(styles, 'codes', {
	        value: codes,
	        enumerable: false
	      });
	    }

	    var ansi2ansi = function ansi2ansi(n) {
	      return n;
	    };

	    var rgb2rgb = function rgb2rgb(r, g, b) {
	      return [r, g, b];
	    };

	    styles.color.close = "\x1B[39m";
	    styles.bgColor.close = "\x1B[49m";
	    styles.color.ansi = {
	      ansi: wrapAnsi16(ansi2ansi, 0)
	    };
	    styles.color.ansi256 = {
	      ansi256: wrapAnsi256(ansi2ansi, 0)
	    };
	    styles.color.ansi16m = {
	      rgb: wrapAnsi16m(rgb2rgb, 0)
	    };
	    styles.bgColor.ansi = {
	      ansi: wrapAnsi16(ansi2ansi, 10)
	    };
	    styles.bgColor.ansi256 = {
	      ansi256: wrapAnsi256(ansi2ansi, 10)
	    };
	    styles.bgColor.ansi16m = {
	      rgb: wrapAnsi16m(rgb2rgb, 10)
	    };

	    for (var _i3 = 0, _Object$keys3 = Object.keys(colorConvert); _i3 < _Object$keys3.length; _i3++) {
	      var key = _Object$keys3[_i3];

	      if (typeof colorConvert[key] !== 'object') {
	        continue;
	      }

	      var suite = colorConvert[key];

	      if (key === 'ansi16') {
	        key = 'ansi';
	      }

	      if ('ansi16' in suite) {
	        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
	        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
	      }

	      if ('ansi256' in suite) {
	        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
	        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
	      }

	      if ('rgb' in suite) {
	        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
	        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
	      }
	    }

	    return styles;
	  }

	  Object.defineProperty(module, 'exports', {
	    enumerable: true,
	    get: assembleStyles
	  });
	}, "/$$rollup_base$$/node_modules/chalk/node_modules/ansi-styles");

	var browser$1 = {
	  stdout: false,
	  stderr: false
	};

	var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
	var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
	var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
	var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
	var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

	function unescape(c) {
	  if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
	    return String.fromCharCode(parseInt(c.slice(1), 16));
	  }

	  return ESCAPES.get(c) || c;
	}

	function parseArguments(name, args) {
	  var results = [];
	  var chunks = args.trim().split(/\s*,\s*/g);
	  var matches;

	  for (var _iterator = _createForOfIteratorHelperLoose(chunks), _step; !(_step = _iterator()).done;) {
	    var chunk = _step.value;

	    if (!isNaN(chunk)) {
	      results.push(Number(chunk));
	    } else if (matches = chunk.match(STRING_REGEX)) {
	      results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
	        return escape ? unescape(escape) : chr;
	      }));
	    } else {
	      throw new Error("Invalid Chalk template style argument: " + chunk + " (in style '" + name + "')");
	    }
	  }

	  return results;
	}

	function parseStyle(style) {
	  STYLE_REGEX.lastIndex = 0;
	  var results = [];
	  var matches;

	  while ((matches = STYLE_REGEX.exec(style)) !== null) {
	    var name = matches[1];

	    if (matches[2]) {
	      var args = parseArguments(name, matches[2]);
	      results.push([name].concat(args));
	    } else {
	      results.push([name]);
	    }
	  }

	  return results;
	}

	function buildStyle(chalk, styles) {
	  var enabled = {};

	  for (var _iterator2 = _createForOfIteratorHelperLoose(styles), _step2; !(_step2 = _iterator2()).done;) {
	    var layer = _step2.value;

	    for (var _iterator3 = _createForOfIteratorHelperLoose(layer.styles), _step3; !(_step3 = _iterator3()).done;) {
	      var style = _step3.value;
	      enabled[style[0]] = layer.inverse ? null : style.slice(1);
	    }
	  }

	  var current = chalk;

	  for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
	    var styleName = _Object$keys[_i];

	    if (Array.isArray(enabled[styleName])) {
	      if (!(styleName in current)) {
	        throw new Error("Unknown Chalk style: " + styleName);
	      }

	      if (enabled[styleName].length > 0) {
	        current = current[styleName].apply(current, enabled[styleName]);
	      } else {
	        current = current[styleName];
	      }
	    }
	  }

	  return current;
	}

	var templates = function templates(chalk, tmp) {
	  var styles = [];
	  var chunks = [];
	  var chunk = [];
	  tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
	    if (escapeChar) {
	      chunk.push(unescape(escapeChar));
	    } else if (style) {
	      var str = chunk.join('');
	      chunk = [];
	      chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
	      styles.push({
	        inverse: inverse,
	        styles: parseStyle(style)
	      });
	    } else if (close) {
	      if (styles.length === 0) {
	        throw new Error('Found extraneous } in Chalk template literal');
	      }

	      chunks.push(buildStyle(chalk, styles)(chunk.join('')));
	      chunk = [];
	      styles.pop();
	    } else {
	      chunk.push(chr);
	    }
	  });
	  chunks.push(chunk.join(''));

	  if (styles.length > 0) {
	    var errMsg = "Chalk template literal is missing " + styles.length + " closing bracket" + (styles.length === 1 ? '' : 's') + " (`}`)";
	    throw new Error(errMsg);
	  }

	  return chunks.join('');
	};

	var chalk = createCommonjsModule(function (module) {

	  var stdoutColor = browser$1.stdout;
	  var isSimpleWindowsTerm = browser$4.platform === 'win32' && !(browser$4.env.TERM || '').toLowerCase().startsWith('xterm');
	  var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
	  var skipModels = new Set(['gray']);
	  var styles = Object.create(null);

	  function applyOptions(obj, options) {
	    options = options || {};
	    var scLevel = 0;
	    obj.level = options.level === undefined ? scLevel : options.level;
	    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
	  }

	  function Chalk(options) {
	    if (!this || !(this instanceof Chalk) || this.template) {
	      var _chalk = {};
	      applyOptions(_chalk, options);

	      _chalk.template = function () {
	        var args = [].slice.call(arguments);
	        return chalkTag.apply(null, [_chalk.template].concat(args));
	      };

	      Object.setPrototypeOf(_chalk, Chalk.prototype);
	      Object.setPrototypeOf(_chalk.template, _chalk);
	      _chalk.template.constructor = Chalk;
	      return _chalk.template;
	    }

	    applyOptions(this, options);
	  }

	  if (isSimpleWindowsTerm) {
	    ansiStyles.blue.open = "\x1B[94m";
	  }

	  var _loop = function _loop() {
	    var key = _Object$keys[_i];
	    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
	    styles[key] = {
	      get: function get() {
	        var codes = ansiStyles[key];
	        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
	      }
	    };
	  };

	  for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
	    _loop();
	  }

	  styles.visible = {
	    get: function get() {
	      return build.call(this, this._styles || [], true, 'visible');
	    }
	  };
	  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

	  var _loop2 = function _loop2() {
	    var model = _Object$keys2[_i2];

	    if (skipModels.has(model)) {
	      return "continue";
	    }

	    styles[model] = {
	      get: function get() {
	        var level = this.level;
	        return function () {
	          var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
	          var codes = {
	            open: open,
	            close: ansiStyles.color.close,
	            closeRe: ansiStyles.color.closeRe
	          };
	          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
	        };
	      }
	    };
	  };

	  for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
	    var _ret = _loop2();

	    if (_ret === "continue") continue;
	  }

	  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

	  var _loop3 = function _loop3() {
	    var model = _Object$keys3[_i3];

	    if (skipModels.has(model)) {
	      return "continue";
	    }

	    var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	    styles[bgModel] = {
	      get: function get() {
	        var level = this.level;
	        return function () {
	          var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
	          var codes = {
	            open: open,
	            close: ansiStyles.bgColor.close,
	            closeRe: ansiStyles.bgColor.closeRe
	          };
	          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
	        };
	      }
	    };
	  };

	  for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
	    var _ret2 = _loop3();

	    if (_ret2 === "continue") continue;
	  }

	  var proto = Object.defineProperties(function () {}, styles);

	  function build(_styles, _empty, key) {
	    var builder = function builder() {
	      return applyStyle.apply(builder, arguments);
	    };

	    builder._styles = _styles;
	    builder._empty = _empty;
	    var self = this;
	    Object.defineProperty(builder, 'level', {
	      enumerable: true,
	      get: function get() {
	        return self.level;
	      },
	      set: function set(level) {
	        self.level = level;
	      }
	    });
	    Object.defineProperty(builder, 'enabled', {
	      enumerable: true,
	      get: function get() {
	        return self.enabled;
	      },
	      set: function set(enabled) {
	        self.enabled = enabled;
	      }
	    });
	    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
	    builder.__proto__ = proto;
	    return builder;
	  }

	  function applyStyle() {
	    var args = arguments;
	    var argsLen = args.length;
	    var str = String(arguments[0]);

	    if (argsLen === 0) {
	      return '';
	    }

	    if (argsLen > 1) {
	      for (var a = 1; a < argsLen; a++) {
	        str += ' ' + args[a];
	      }
	    }

	    if (!this.enabled || this.level <= 0 || !str) {
	      return this._empty ? '' : str;
	    }

	    var originalDim = ansiStyles.dim.open;

	    if (isSimpleWindowsTerm && this.hasGrey) {
	      ansiStyles.dim.open = '';
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose(this._styles.slice().reverse()), _step; !(_step = _iterator()).done;) {
	      var code = _step.value;
	      str = code.open + str.replace(code.closeRe, code.open) + code.close;
	      str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
	    }

	    ansiStyles.dim.open = originalDim;
	    return str;
	  }

	  function chalkTag(chalk, strings) {
	    if (!Array.isArray(strings)) {
	      return [].slice.call(arguments, 1).join(' ');
	    }

	    var args = [].slice.call(arguments, 2);
	    var parts = [strings.raw[0]];

	    for (var i = 1; i < strings.length; i++) {
	      parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
	      parts.push(String(strings.raw[i]));
	    }

	    return templates(chalk, parts.join(''));
	  }

	  Object.defineProperties(Chalk.prototype, styles);
	  module.exports = Chalk();
	  module.exports.supportsColor = stdoutColor;
	  module.exports["default"] = module.exports;
	}, "/$$rollup_base$$/node_modules/chalk");

	var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

	function getDefs$1(chalk) {
	  return {
	    keyword: chalk.cyan,
	    capitalized: chalk.yellow,
	    jsxIdentifier: chalk.yellow,
	    punctuator: chalk.yellow,
	    number: chalk.magenta,
	    string: chalk.green,
	    regex: chalk.magenta,
	    comment: chalk.grey,
	    invalid: chalk.white.bgRed.bold
	  };
	}

	var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
	var BRACKET = /^[()[\]{}]$/;
	var tokenize;
	{
	  var JSX_TAG = /^[a-z][\w-]*$/i;

	  var getTokenType = function getTokenType(token, offset, text) {
	    if (token.type === "name") {
	      if (isKeyword(token.value) || isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
	        return "keyword";
	      }

	      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
	        return "jsxIdentifier";
	      }

	      if (token.value[0] !== token.value[0].toLowerCase()) {
	        return "capitalized";
	      }
	    }

	    if (token.type === "punctuator" && BRACKET.test(token.value)) {
	      return "bracket";
	    }

	    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
	      return "punctuator";
	    }

	    return token.type;
	  };

	  tokenize = regenerator.mark(function tokenize(text) {
	    var match, token;
	    return regenerator.wrap(function tokenize$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if (!(match = jsTokens["default"].exec(text))) {
	              _context.next = 6;
	              break;
	            }

	            token = jsTokens.matchToToken(match);
	            _context.next = 4;
	            return {
	              type: getTokenType(token, match.index, text),
	              value: token.value
	            };

	          case 4:
	            _context.next = 0;
	            break;

	          case 6:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, tokenize);
	  });
	}

	function highlightTokens(defs, text) {
	  var highlighted = "";

	  var _loop = function _loop() {
	    var _step$value = _step.value,
	        type = _step$value.type,
	        value = _step$value.value;
	    var colorize = defs[type];

	    if (colorize) {
	      highlighted += value.split(NEWLINE$1).map(function (str) {
	        return colorize(str);
	      }).join("\n");
	    } else {
	      highlighted += value;
	    }
	  };

	  for (var _iterator = _createForOfIteratorHelperLoose(tokenize(text)), _step; !(_step = _iterator()).done;) {
	    _loop();
	  }

	  return highlighted;
	}

	function shouldHighlight(options) {
	  return !!chalk.supportsColor || options.forceColor;
	}
	function getChalk(options) {
	  return options.forceColor ? new chalk.constructor({
	    enabled: true,
	    level: 1
	  }) : chalk;
	}
	function highlight(code, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  if (shouldHighlight(options)) {
	    var chalk = getChalk(options);
	    var defs = getDefs$1(chalk);
	    return highlightTokens(defs, code);
	  } else {
	    return code;
	  }
	}

	function getDefs(chalk) {
	  return {
	    gutter: chalk.grey,
	    marker: chalk.red.bold,
	    message: chalk.red.bold
	  };
	}

	var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

	function getMarkerLines(loc, source, opts) {
	  var startLoc = Object.assign({
	    column: 0,
	    line: -1
	  }, loc.start);
	  var endLoc = Object.assign({}, startLoc, loc.end);

	  var _ref = opts || {},
	      _ref$linesAbove = _ref.linesAbove,
	      linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
	      _ref$linesBelow = _ref.linesBelow,
	      linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

	  var startLine = startLoc.line;
	  var startColumn = startLoc.column;
	  var endLine = endLoc.line;
	  var endColumn = endLoc.column;
	  var start = Math.max(startLine - (linesAbove + 1), 0);
	  var end = Math.min(source.length, endLine + linesBelow);

	  if (startLine === -1) {
	    start = 0;
	  }

	  if (endLine === -1) {
	    end = source.length;
	  }

	  var lineDiff = endLine - startLine;
	  var markerLines = {};

	  if (lineDiff) {
	    for (var i = 0; i <= lineDiff; i++) {
	      var lineNumber = i + startLine;

	      if (!startColumn) {
	        markerLines[lineNumber] = true;
	      } else if (i === 0) {
	        var sourceLength = source[lineNumber - 1].length;
	        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
	      } else if (i === lineDiff) {
	        markerLines[lineNumber] = [0, endColumn];
	      } else {
	        var _sourceLength = source[lineNumber - i].length;
	        markerLines[lineNumber] = [0, _sourceLength];
	      }
	    }
	  } else {
	    if (startColumn === endColumn) {
	      if (startColumn) {
	        markerLines[startLine] = [startColumn, 0];
	      } else {
	        markerLines[startLine] = true;
	      }
	    } else {
	      markerLines[startLine] = [startColumn, endColumn - startColumn];
	    }
	  }

	  return {
	    start: start,
	    end: end,
	    markerLines: markerLines
	  };
	}

	function codeFrameColumns(rawLines, loc, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
	  var chalk = getChalk(opts);
	  var defs = getDefs(chalk);

	  var maybeHighlight = function maybeHighlight(chalkFn, string) {
	    return highlighted ? chalkFn(string) : string;
	  };

	  var lines = rawLines.split(NEWLINE);

	  var _getMarkerLines = getMarkerLines(loc, lines, opts),
	      start = _getMarkerLines.start,
	      end = _getMarkerLines.end,
	      markerLines = _getMarkerLines.markerLines;

	  var hasColumns = loc.start && typeof loc.start.column === "number";
	  var numberMaxWidth = String(end).length;
	  var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
	  var frame = highlightedLines.split(NEWLINE, end).slice(start, end).map(function (line, index) {
	    var number = start + 1 + index;
	    var paddedNumber = (" " + number).slice(-numberMaxWidth);
	    var gutter = " " + paddedNumber + " |";
	    var hasMarker = markerLines[number];
	    var lastMarkerLine = !markerLines[number + 1];

	    if (hasMarker) {
	      var markerLine = "";

	      if (Array.isArray(hasMarker)) {
	        var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
	        var numberOfMarkers = hasMarker[1] || 1;
	        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

	        if (lastMarkerLine && opts.message) {
	          markerLine += " " + maybeHighlight(defs.message, opts.message);
	        }
	      }

	      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? " " + line : "", markerLine].join("");
	    } else {
	      return " " + maybeHighlight(defs.gutter, gutter) + (line.length > 0 ? " " + line : "");
	    }
	  }).join("\n");

	  if (opts.message && !hasColumns) {
	    frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
	  }

	  if (highlighted) {
	    return chalk.reset(frame);
	  } else {
	    return frame;
	  }
	}

	var lineBreak = /\r\n?|[\n\u2028\u2029]/;
	var lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code) {
	  switch (code) {
	    case 10:
	    case 13:
	    case 8232:
	    case 8233:
	      return true;

	    default:
	      return false;
	  }
	}
	var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	var skipWhiteSpaceInLine = new RegExp("(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*", "y");
	var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
	function isWhitespace(code) {
	  switch (code) {
	    case 0x0009:
	    case 0x000b:
	    case 0x000c:
	    case 32:
	    case 160:
	    case 5760:
	    case 0x2000:
	    case 0x2001:
	    case 0x2002:
	    case 0x2003:
	    case 0x2004:
	    case 0x2005:
	    case 0x2006:
	    case 0x2007:
	    case 0x2008:
	    case 0x2009:
	    case 0x200a:
	    case 0x202f:
	    case 0x205f:
	    case 0x3000:
	    case 0xfeff:
	      return true;

	    default:
	      return false;
	  }
	}

	var Position = function Position(line, col) {
	  this.line = void 0;
	  this.column = void 0;
	  this.line = line;
	  this.column = col;
	};
	var SourceLocation = function SourceLocation(start, end) {
	  this.start = void 0;
	  this.end = void 0;
	  this.filename = void 0;
	  this.identifierName = void 0;
	  this.start = start;
	  this.end = end;
	};
	function getLineInfo(input, offset) {
	  var line = 1;
	  var lineStart = 0;
	  var match;
	  lineBreakG.lastIndex = 0;

	  while ((match = lineBreakG.exec(input)) && match.index < offset) {
	    line++;
	    lineStart = lineBreakG.lastIndex;
	  }

	  return new Position(line, offset - lineStart);
	}
	function createPositionWithColumnOffset(position, columnOffset) {
	  var line = position.line,
	      column = position.column;
	  return new Position(line, column + columnOffset);
	}

	var BaseParser = function () {
	  function BaseParser() {
	    this.sawUnambiguousESM = false;
	    this.ambiguousScriptDifferentAst = false;
	  }

	  var _proto = BaseParser.prototype;

	  _proto.hasPlugin = function hasPlugin(pluginConfig) {
	    if (typeof pluginConfig === "string") {
	      return this.plugins.has(pluginConfig);
	    } else {
	      var pluginName = pluginConfig[0],
	          pluginOptions = pluginConfig[1];

	      if (!this.hasPlugin(pluginName)) {
	        return false;
	      }

	      var actualOptions = this.plugins.get(pluginName);

	      for (var _i2 = 0, _Object$keys2 = Object.keys(pluginOptions); _i2 < _Object$keys2.length; _i2++) {
	        var key = _Object$keys2[_i2];

	        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
	          return false;
	        }
	      }

	      return true;
	    }
	  };

	  _proto.getPluginOption = function getPluginOption(plugin, name) {
	    var _this$plugins$get;

	    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
	  };

	  return BaseParser;
	}();

	function setTrailingComments(node, comments) {
	  if (node.trailingComments === undefined) {
	    node.trailingComments = comments;
	  } else {
	    var _node$trailingComment;

	    (_node$trailingComment = node.trailingComments).unshift.apply(_node$trailingComment, comments);
	  }
	}

	function setLeadingComments(node, comments) {
	  if (node.leadingComments === undefined) {
	    node.leadingComments = comments;
	  } else {
	    var _node$leadingComments;

	    (_node$leadingComments = node.leadingComments).unshift.apply(_node$leadingComments, comments);
	  }
	}

	function setInnerComments(node, comments) {
	  if (node.innerComments === undefined) {
	    node.innerComments = comments;
	  } else {
	    var _node$innerComments;

	    (_node$innerComments = node.innerComments).unshift.apply(_node$innerComments, comments);
	  }
	}

	function adjustInnerComments(node, elements, commentWS) {
	  var lastElement = null;
	  var i = elements.length;

	  while (lastElement === null && i > 0) {
	    lastElement = elements[--i];
	  }

	  if (lastElement === null || lastElement.start > commentWS.start) {
	    setInnerComments(node, commentWS.comments);
	  } else {
	    setTrailingComments(lastElement, commentWS.comments);
	  }
	}

	var CommentsParser = function (_BaseParser) {
	  _inherits(CommentsParser, _BaseParser);

	  function CommentsParser() {
	    return _BaseParser.apply(this, arguments) || this;
	  }

	  var _proto = CommentsParser.prototype;

	  _proto.addComment = function addComment(comment) {
	    if (this.filename) comment.loc.filename = this.filename;
	    this.state.comments.push(comment);
	  };

	  _proto.processComment = function processComment(node) {
	    var commentStack = this.state.commentStack;
	    var commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    var i = commentStackLength - 1;
	    var lastCommentWS = commentStack[i];

	    if (lastCommentWS.start === node.end) {
	      lastCommentWS.leadingNode = node;
	      i--;
	    }

	    var nodeStart = node.start;

	    for (; i >= 0; i--) {
	      var commentWS = commentStack[i];
	      var commentEnd = commentWS.end;

	      if (commentEnd > nodeStart) {
	        commentWS.containingNode = node;
	        this.finalizeComment(commentWS);
	        commentStack.splice(i, 1);
	      } else {
	        if (commentEnd === nodeStart) {
	          commentWS.trailingNode = node;
	        }

	        break;
	      }
	    }
	  };

	  _proto.finalizeComment = function finalizeComment(commentWS) {
	    var comments = commentWS.comments;

	    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
	      if (commentWS.leadingNode !== null) {
	        setTrailingComments(commentWS.leadingNode, comments);
	      }

	      if (commentWS.trailingNode !== null) {
	        setLeadingComments(commentWS.trailingNode, comments);
	      }
	    } else {
	      var node = commentWS.containingNode,
	          commentStart = commentWS.start;

	      if (this.input.charCodeAt(commentStart - 1) === 44) {
	        switch (node.type) {
	          case "ObjectExpression":
	          case "ObjectPattern":
	          case "RecordExpression":
	            adjustInnerComments(node, node.properties, commentWS);
	            break;

	          case "CallExpression":
	          case "OptionalCallExpression":
	            adjustInnerComments(node, node.arguments, commentWS);
	            break;

	          case "FunctionDeclaration":
	          case "FunctionExpression":
	          case "ArrowFunctionExpression":
	          case "ObjectMethod":
	          case "ClassMethod":
	          case "ClassPrivateMethod":
	            adjustInnerComments(node, node.params, commentWS);
	            break;

	          case "ArrayExpression":
	          case "ArrayPattern":
	          case "TupleExpression":
	            adjustInnerComments(node, node.elements, commentWS);
	            break;

	          case "ExportNamedDeclaration":
	          case "ImportDeclaration":
	            adjustInnerComments(node, node.specifiers, commentWS);
	            break;

	          default:
	            {
	              setInnerComments(node, comments);
	            }
	        }
	      } else {
	        setInnerComments(node, comments);
	      }
	    }
	  };

	  _proto.finalizeRemainingComments = function finalizeRemainingComments() {
	    var commentStack = this.state.commentStack;

	    for (var i = commentStack.length - 1; i >= 0; i--) {
	      this.finalizeComment(commentStack[i]);
	    }

	    this.state.commentStack = [];
	  };

	  _proto.resetPreviousNodeTrailingComments = function resetPreviousNodeTrailingComments(node) {
	    var commentStack = this.state.commentStack;
	    var length = commentStack.length;
	    if (length === 0) return;
	    var commentWS = commentStack[length - 1];

	    if (commentWS.leadingNode === node) {
	      commentWS.leadingNode = null;
	    }
	  };

	  _proto.takeSurroundingComments = function takeSurroundingComments(node, start, end) {
	    var commentStack = this.state.commentStack;
	    var commentStackLength = commentStack.length;
	    if (commentStackLength === 0) return;
	    var i = commentStackLength - 1;

	    for (; i >= 0; i--) {
	      var commentWS = commentStack[i];
	      var commentEnd = commentWS.end;
	      var commentStart = commentWS.start;

	      if (commentStart === end) {
	        commentWS.leadingNode = node;
	      } else if (commentEnd === start) {
	        commentWS.trailingNode = node;
	      } else if (commentEnd < start) {
	        break;
	      }
	    }
	  };

	  return CommentsParser;
	}(BaseParser);

	var ErrorCodes = Object.freeze({
	  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
	  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
	});

	var ErrorMessages = makeErrorTemplates({
	  AccessorIsGenerator: "A %0ter cannot be a generator.",
	  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
	  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
	  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
	  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
	  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
	  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
	  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
	  BadGetterArity: "A 'get' accesor must not have any formal parameters.",
	  BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
	  BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
	  ConstructorClassField: "Classes may not have a field named 'constructor'.",
	  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
	  ConstructorIsAccessor: "Class constructor may not be an accessor.",
	  ConstructorIsAsync: "Constructor can't be an async function.",
	  ConstructorIsGenerator: "Constructor can't be a generator.",
	  DeclarationMissingInitializer: "'%0' require an initialization value.",
	  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
	  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
	  DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
	  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
	  DecoratorStaticBlock: "Decorators can't be used with a static block.",
	  DeletePrivateField: "Deleting a private field is not allowed.",
	  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
	  DuplicateConstructor: "Duplicate constructor in the same class.",
	  DuplicateDefaultExport: "Only one default export allowed per module.",
	  DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
	  DuplicateProto: "Redefinition of __proto__ property.",
	  DuplicateRegExpFlags: "Duplicate regular expression flag.",
	  ElementAfterRest: "Rest element must be last element.",
	  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
	  ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
	  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
	  ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
	  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
	  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
	  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
	  IllegalBreakContinue: "Unsyntactic %0.",
	  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
	  IllegalReturn: "'return' outside of function.",
	  ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
	  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
	  ImportCallArity: "`import()` requires exactly %0.",
	  ImportCallNotNewExpression: "Cannot use new with import(...).",
	  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
	  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
	  InvalidCodePoint: "Code point out of bounds.",
	  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
	  InvalidDecimal: "Invalid decimal.",
	  InvalidDigit: "Expected number in radix %0.",
	  InvalidEscapeSequence: "Bad character escape sequence.",
	  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
	  InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
	  InvalidIdentifier: "Invalid identifier %0.",
	  InvalidLhs: "Invalid left-hand side in %0.",
	  InvalidLhsBinding: "Binding invalid left-hand side in %0.",
	  InvalidNumber: "Invalid number.",
	  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
	  InvalidOrUnexpectedToken: "Unexpected character '%0'.",
	  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
	  InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
	  InvalidPropertyBindingPattern: "Binding member expression.",
	  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
	  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
	  LabelRedeclaration: "Label '%0' is already declared.",
	  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
	  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
	  MalformedRegExpFlags: "Invalid regular expression flag.",
	  MissingClassName: "A class name is required.",
	  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
	  MissingSemicolon: "Missing semicolon.",
	  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
	  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
	  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
	  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
	  ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
	  ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
	  ModuleExportUndefined: "Export '%0' is not defined.",
	  MultipleDefaultsInSwitch: "Multiple default clauses.",
	  NewlineAfterThrow: "Illegal newline after throw.",
	  NoCatchOrFinally: "Missing catch or finally clause.",
	  NumberIdentifier: "Identifier directly after number.",
	  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
	  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
	  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
	  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
	  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
	  ParamDupe: "Argument name clash.",
	  PatternHasAccessor: "Object pattern can't contain getter or setter.",
	  PatternHasMethod: "Object pattern can't contain methods.",
	  PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
	  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
	  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
	  PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
	  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
	  PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",
	  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
	  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
	  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
	  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
	  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
	  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
	  PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
	  PrivateNameRedeclaration: "Duplicate private name #%0.",
	  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
	  RestTrailingComma: "Unexpected trailing comma after rest element.",
	  SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
	  StaticPrototype: "Classes may not have static property named prototype.",
	  StrictDelete: "Deleting local variable in strict mode.",
	  StrictEvalArguments: "Assigning to '%0' in strict mode.",
	  StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
	  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
	  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
	  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
	  StrictWith: "'with' in strict mode.",
	  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
	  SuperPrivateField: "Private fields can't be accessed on super.",
	  TrailingDecorator: "Decorators must be attached to a class element.",
	  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
	  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
	  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
	  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
	  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
	  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
	  UnexpectedKeyword: "Unexpected keyword '%0'.",
	  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
	  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
	  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
	  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
	  UnexpectedPrivateField: "Unexpected private name.",
	  UnexpectedReservedWord: "Unexpected reserved word '%0'.",
	  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
	  UnexpectedToken: "Unexpected token '%0'.",
	  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
	  UnsupportedBind: "Binding should be performed on object property.",
	  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
	  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
	  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
	  UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
	  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
	  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
	  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
	  UnterminatedComment: "Unterminated comment.",
	  UnterminatedRegExp: "Unterminated regular expression.",
	  UnterminatedString: "Unterminated string constant.",
	  UnterminatedTemplate: "Unterminated template.",
	  VarRedeclaration: "Identifier '%0' has already been declared.",
	  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
	  YieldInParameter: "Yield expression is not allowed in formal parameters.",
	  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
	}, ErrorCodes.SyntaxError);
	var SourceTypeModuleErrorMessages = makeErrorTemplates({
	  ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
	  ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'"
	}, ErrorCodes.SourceTypeModuleError);

	function keepReasonCodeCompat(reasonCode, syntaxPlugin) {
	  {
	    if (syntaxPlugin === "flow" && reasonCode === "PatternIsOptional") {
	      return "OptionalBindingPattern";
	    }
	  }
	  return reasonCode;
	}

	function makeErrorTemplates(messages, code, syntaxPlugin) {
	  var templates = {};
	  Object.keys(messages).forEach(function (reasonCode) {
	    templates[reasonCode] = Object.freeze({
	      code: code,
	      reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),
	      template: messages[reasonCode]
	    });
	  });
	  return Object.freeze(templates);
	}

	var ParserError = function (_CommentsParser) {
	  _inherits(ParserError, _CommentsParser);

	  function ParserError() {
	    return _CommentsParser.apply(this, arguments) || this;
	  }

	  var _proto = ParserError.prototype;

	  _proto.getLocationForPosition = function getLocationForPosition(pos) {
	    var loc;
	    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
	    return loc;
	  };

	  _proto.raise = function raise(pos, _ref) {
	    var code = _ref.code,
	        reasonCode = _ref.reasonCode,
	        template = _ref.template;

	    for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      params[_key - 2] = arguments[_key];
	    }

	    return this.raiseWithData.apply(this, [pos, {
	      code: code,
	      reasonCode: reasonCode
	    }, template].concat(params));
	  };

	  _proto.raiseOverwrite = function raiseOverwrite(pos, _ref2) {
	    var code = _ref2.code,
	        template = _ref2.template;

	    for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	      params[_key2 - 2] = arguments[_key2];
	    }

	    var loc = this.getLocationForPosition(pos);
	    var message = template.replace(/%(\d+)/g, function (_, i) {
	      return params[i];
	    }) + (" (" + loc.line + ":" + loc.column + ")");

	    if (this.options.errorRecovery) {
	      var errors = this.state.errors;

	      for (var i = errors.length - 1; i >= 0; i--) {
	        var error = errors[i];

	        if (error.pos === pos) {
	          return Object.assign(error, {
	            message: message
	          });
	        } else if (error.pos < pos) {
	          break;
	        }
	      }
	    }

	    return this._raise({
	      code: code,
	      loc: loc,
	      pos: pos
	    }, message);
	  };

	  _proto.raiseWithData = function raiseWithData(pos, data, errorTemplate) {
	    for (var _len3 = arguments.length, params = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	      params[_key3 - 3] = arguments[_key3];
	    }

	    var loc = this.getLocationForPosition(pos);
	    var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
	      return params[i];
	    }) + (" (" + loc.line + ":" + loc.column + ")");
	    return this._raise(Object.assign({
	      loc: loc,
	      pos: pos
	    }, data), message);
	  };

	  _proto._raise = function _raise(errorContext, message) {
	    var err = new SyntaxError(message);
	    Object.assign(err, errorContext);

	    if (this.options.errorRecovery) {
	      if (!this.isLookahead) this.state.errors.push(err);
	      return err;
	    } else {
	      throw err;
	    }
	  };

	  return ParserError;
	}(CommentsParser);

	var estree = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.parseRegExpLiteral = function parseRegExpLiteral(_ref) {
	      var pattern = _ref.pattern,
	          flags = _ref.flags;
	      var regex = null;

	      try {
	        regex = new RegExp(pattern, flags);
	      } catch (e) {}

	      var node = this.estreeParseLiteral(regex);
	      node.regex = {
	        pattern: pattern,
	        flags: flags
	      };
	      return node;
	    };

	    _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
	      var bigInt;

	      try {
	        bigInt = BigInt(value);
	      } catch (_unused) {
	        bigInt = null;
	      }

	      var node = this.estreeParseLiteral(bigInt);
	      node.bigint = String(node.value || value);
	      return node;
	    };

	    _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
	      var decimal = null;
	      var node = this.estreeParseLiteral(decimal);
	      node.decimal = String(node.value || value);
	      return node;
	    };

	    _proto.estreeParseLiteral = function estreeParseLiteral(value) {
	      return this.parseLiteral(value, "Literal");
	    };

	    _proto.parseStringLiteral = function parseStringLiteral(value) {
	      return this.estreeParseLiteral(value);
	    };

	    _proto.parseNumericLiteral = function parseNumericLiteral(value) {
	      return this.estreeParseLiteral(value);
	    };

	    _proto.parseNullLiteral = function parseNullLiteral() {
	      return this.estreeParseLiteral(null);
	    };

	    _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
	      return this.estreeParseLiteral(value);
	    };

	    _proto.directiveToStmt = function directiveToStmt(directive) {
	      var directiveLiteral = directive.value;
	      var stmt = this.startNodeAt(directive.start, directive.loc.start);
	      var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
	      expression.value = directiveLiteral.extra.expressionValue;
	      expression.raw = directiveLiteral.extra.raw;
	      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
	      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
	      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
	    };

	    _proto.initFunction = function initFunction(node, isAsync) {
	      _superClass.prototype.initFunction.call(this, node, isAsync);

	      node.expression = false;
	    };

	    _proto.checkDeclaration = function checkDeclaration(node) {
	      if (node != null && this.isObjectProperty(node)) {
	        this.checkDeclaration(node.value);
	      } else {
	        _superClass.prototype.checkDeclaration.call(this, node);
	      }
	    };

	    _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
	      return method.value.params;
	    };

	    _proto.isValidDirective = function isValidDirective(stmt) {
	      var _stmt$expression$extr;

	      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
	    };

	    _proto.parseBlockBody = function parseBlockBody(node) {
	      var _superClass$prototype,
	          _this = this;

	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      (_superClass$prototype = _superClass.prototype.parseBlockBody).call.apply(_superClass$prototype, [this, node].concat(args));

	      var directiveStatements = node.directives.map(function (d) {
	        return _this.directiveToStmt(d);
	      });
	      node.body = directiveStatements.concat(node.body);
	      delete node.directives;
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

	      if (method.typeParameters) {
	        method.value.typeParameters = method.typeParameters;
	        delete method.typeParameters;
	      }

	      classBody.body.push(method);
	    };

	    _proto.parsePrivateName = function parsePrivateName() {
	      var node = _superClass.prototype.parsePrivateName.call(this);

	      {
	        if (!this.getPluginOption("estree", "classFeatures")) {
	          return node;
	        }
	      }
	      return this.convertPrivateNameToPrivateIdentifier(node);
	    };

	    _proto.convertPrivateNameToPrivateIdentifier = function convertPrivateNameToPrivateIdentifier(node) {
	      var name = _superClass.prototype.getPrivateNameSV.call(this, node);

	      node = node;
	      delete node.id;
	      node.name = name;
	      node.type = "PrivateIdentifier";
	      return node;
	    };

	    _proto.isPrivateName = function isPrivateName(node) {
	      {
	        if (!this.getPluginOption("estree", "classFeatures")) {
	          return _superClass.prototype.isPrivateName.call(this, node);
	        }
	      }
	      return node.type === "PrivateIdentifier";
	    };

	    _proto.getPrivateNameSV = function getPrivateNameSV(node) {
	      {
	        if (!this.getPluginOption("estree", "classFeatures")) {
	          return _superClass.prototype.getPrivateNameSV.call(this, node);
	        }
	      }
	      return node.name;
	    };

	    _proto.parseLiteral = function parseLiteral(value, type) {
	      var node = _superClass.prototype.parseLiteral.call(this, value, type);

	      node.raw = node.extra.raw;
	      delete node.extra;
	      return node;
	    };

	    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
	      if (isMethod === void 0) {
	        isMethod = false;
	      }

	      _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);

	      node.expression = node.body.type !== "BlockStatement";
	    };

	    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
	      if (inClassScope === void 0) {
	        inClassScope = false;
	      }

	      var funcNode = this.startNode();
	      funcNode.kind = node.kind;
	      funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
	      funcNode.type = "FunctionExpression";
	      delete funcNode.kind;
	      node.value = funcNode;

	      if (type === "ClassPrivateMethod") {
	        node.computed = false;
	      }

	      type = "MethodDefinition";
	      return this.finishNode(node, type);
	    };

	    _proto.parseClassProperty = function parseClassProperty() {
	      var _superClass$prototype2;

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      var propertyNode = (_superClass$prototype2 = _superClass.prototype.parseClassProperty).call.apply(_superClass$prototype2, [this].concat(args));

	      {
	        if (!this.getPluginOption("estree", "classFeatures")) {
	          return propertyNode;
	        }
	      }
	      propertyNode.type = "PropertyDefinition";
	      return propertyNode;
	    };

	    _proto.parseClassPrivateProperty = function parseClassPrivateProperty() {
	      var _superClass$prototype3;

	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      var propertyNode = (_superClass$prototype3 = _superClass.prototype.parseClassPrivateProperty).call.apply(_superClass$prototype3, [this].concat(args));

	      {
	        if (!this.getPluginOption("estree", "classFeatures")) {
	          return propertyNode;
	        }
	      }
	      propertyNode.type = "PropertyDefinition";
	      propertyNode.computed = false;
	      return propertyNode;
	    };

	    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
	      var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, isAccessor);

	      if (node) {
	        node.type = "Property";
	        if (node.kind === "method") node.kind = "init";
	        node.shorthand = false;
	      }

	      return node;
	    };

	    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
	      var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

	      if (node) {
	        node.kind = "init";
	        node.type = "Property";
	      }

	      return node;
	    };

	    _proto.isAssignable = function isAssignable(node, isBinding) {
	      if (node != null && this.isObjectProperty(node)) {
	        return this.isAssignable(node.value, isBinding);
	      }

	      return _superClass.prototype.isAssignable.call(this, node, isBinding);
	    };

	    _proto.toAssignable = function toAssignable(node, isLHS) {
	      if (isLHS === void 0) {
	        isLHS = false;
	      }

	      if (node != null && this.isObjectProperty(node)) {
	        this.toAssignable(node.value, isLHS);
	        return node;
	      }

	      return _superClass.prototype.toAssignable.call(this, node, isLHS);
	    };

	    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop) {
	      if (prop.kind === "get" || prop.kind === "set") {
	        this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
	      } else if (prop.method) {
	        this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
	      } else {
	        var _superClass$prototype4;

	        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	          args[_key4 - 1] = arguments[_key4];
	        }

	        (_superClass$prototype4 = _superClass.prototype.toAssignableObjectExpressionProp).call.apply(_superClass$prototype4, [this, prop].concat(args));
	      }
	    };

	    _proto.finishCallExpression = function finishCallExpression(node, optional) {
	      _superClass.prototype.finishCallExpression.call(this, node, optional);

	      if (node.callee.type === "Import") {
	        node.type = "ImportExpression";
	        node.source = node.arguments[0];

	        if (this.hasPlugin("importAssertions")) {
	          var _node$arguments$;

	          node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
	        }

	        delete node.arguments;
	        delete node.callee;
	      }

	      return node;
	    };

	    _proto.toReferencedArguments = function toReferencedArguments(node) {
	      if (node.type === "ImportExpression") {
	        return;
	      }

	      _superClass.prototype.toReferencedArguments.call(this, node);
	    };

	    _proto.parseExport = function parseExport(node) {
	      _superClass.prototype.parseExport.call(this, node);

	      switch (node.type) {
	        case "ExportAllDeclaration":
	          node.exported = null;
	          break;

	        case "ExportNamedDeclaration":
	          if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
	            node.type = "ExportAllDeclaration";
	            node.exported = node.specifiers[0].exported;
	            delete node.specifiers;
	          }

	          break;
	      }

	      return node;
	    };

	    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
	      var node = _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);

	      if (state.optionalChainMember) {
	        if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
	          node.type = node.type.substring(8);
	        }

	        if (state.stop) {
	          var chain = this.startNodeAtNode(node);
	          chain.expression = node;
	          return this.finishNode(chain, "ChainExpression");
	        }
	      } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
	        node.optional = false;
	      }

	      return node;
	    };

	    _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
	      if (node.type === "ChainExpression") {
	        node = node.expression;
	      }

	      return _superClass.prototype.hasPropertyAsPrivateName.call(this, node);
	    };

	    _proto.isOptionalChain = function isOptionalChain(node) {
	      return node.type === "ChainExpression";
	    };

	    _proto.isObjectProperty = function isObjectProperty(node) {
	      return node.type === "Property" && node.kind === "init" && !node.method;
	    };

	    _proto.isObjectMethod = function isObjectMethod(node) {
	      return node.method || node.kind === "get" || node.kind === "set";
	    };

	    return _class;
	  }(superClass);
	});

	var TokContext = function TokContext(token, preserveSpace) {
	  this.token = void 0;
	  this.preserveSpace = void 0;
	  this.token = token;
	  this.preserveSpace = !!preserveSpace;
	};
	var types = {
	  brace: new TokContext("{"),
	  j_oTag: new TokContext("<tag"),
	  j_cTag: new TokContext("</tag"),
	  j_expr: new TokContext("<tag>...</tag>", true)
	};
	{
	  types.template = new TokContext("`", true);
	}

	var beforeExpr = true;
	var startsExpr = true;
	var isLoop = true;
	var isAssign = true;
	var prefix = true;
	var postfix = true;
	var ExportedTokenType = function ExportedTokenType(label, conf) {
	  if (conf === void 0) {
	    conf = {};
	  }

	  this.label = void 0;
	  this.keyword = void 0;
	  this.beforeExpr = void 0;
	  this.startsExpr = void 0;
	  this.rightAssociative = void 0;
	  this.isLoop = void 0;
	  this.isAssign = void 0;
	  this.prefix = void 0;
	  this.postfix = void 0;
	  this.binop = void 0;
	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.rightAssociative = !!conf.rightAssociative;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop != null ? conf.binop : null;
	  {
	    this.updateContext = null;
	  }
	};
	var keywords = new Map();

	function createKeyword(name, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  options.keyword = name;
	  var token = createToken(name, options);
	  keywords.set(name, token);
	  return token;
	}

	function createBinop(name, binop) {
	  return createToken(name, {
	    beforeExpr: beforeExpr,
	    binop: binop
	  });
	}

	var tokenTypeCounter = -1;
	var tokenTypes = [];
	var tokenLabels = [];
	var tokenBinops = [];
	var tokenBeforeExprs = [];
	var tokenStartsExprs = [];
	var tokenPrefixes = [];

	function createToken(name, options) {
	  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;

	  if (options === void 0) {
	    options = {};
	  }

	  ++tokenTypeCounter;
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
	  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
	  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
	  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
	  tokenTypes.push(new ExportedTokenType(name, options));
	  return tokenTypeCounter;
	}

	function createKeywordLike(name, options) {
	  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;

	  if (options === void 0) {
	    options = {};
	  }

	  ++tokenTypeCounter;
	  keywords.set(name, tokenTypeCounter);
	  tokenLabels.push(name);
	  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
	  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
	  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
	  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
	  tokenTypes.push(new ExportedTokenType("name", options));
	  return tokenTypeCounter;
	}

	var tt = {
	  bracketL: createToken("[", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  bracketHashL: createToken("#[", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  bracketBarL: createToken("[|", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  bracketR: createToken("]"),
	  bracketBarR: createToken("|]"),
	  braceL: createToken("{", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  braceBarL: createToken("{|", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  braceHashL: createToken("#{", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  braceR: createToken("}", {
	    beforeExpr: beforeExpr
	  }),
	  braceBarR: createToken("|}"),
	  parenL: createToken("(", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  parenR: createToken(")"),
	  comma: createToken(",", {
	    beforeExpr: beforeExpr
	  }),
	  semi: createToken(";", {
	    beforeExpr: beforeExpr
	  }),
	  colon: createToken(":", {
	    beforeExpr: beforeExpr
	  }),
	  doubleColon: createToken("::", {
	    beforeExpr: beforeExpr
	  }),
	  dot: createToken("."),
	  question: createToken("?", {
	    beforeExpr: beforeExpr
	  }),
	  questionDot: createToken("?."),
	  arrow: createToken("=>", {
	    beforeExpr: beforeExpr
	  }),
	  template: createToken("template"),
	  ellipsis: createToken("...", {
	    beforeExpr: beforeExpr
	  }),
	  backQuote: createToken("`", {
	    startsExpr: startsExpr
	  }),
	  dollarBraceL: createToken("${", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  templateTail: createToken("...`", {
	    startsExpr: startsExpr
	  }),
	  templateNonTail: createToken("...${", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  at: createToken("@"),
	  hash: createToken("#", {
	    startsExpr: startsExpr
	  }),
	  interpreterDirective: createToken("#!..."),
	  eq: createToken("=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  assign: createToken("_=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  slashAssign: createToken("_=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  xorAssign: createToken("_=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  moduloAssign: createToken("_=", {
	    beforeExpr: beforeExpr,
	    isAssign: isAssign
	  }),
	  incDec: createToken("++/--", {
	    prefix: prefix,
	    postfix: postfix,
	    startsExpr: startsExpr
	  }),
	  bang: createToken("!", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  tilde: createToken("~", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  pipeline: createBinop("|>", 0),
	  nullishCoalescing: createBinop("??", 1),
	  logicalOR: createBinop("||", 1),
	  logicalAND: createBinop("&&", 2),
	  bitwiseOR: createBinop("|", 3),
	  bitwiseXOR: createBinop("^", 4),
	  bitwiseAND: createBinop("&", 5),
	  equality: createBinop("==/!=/===/!==", 6),
	  lt: createBinop("</>/<=/>=", 7),
	  gt: createBinop("</>/<=/>=", 7),
	  relational: createBinop("</>/<=/>=", 7),
	  bitShift: createBinop("<</>>/>>>", 8),
	  plusMin: createToken("+/-", {
	    beforeExpr: beforeExpr,
	    binop: 9,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  modulo: createToken("%", {
	    binop: 10,
	    startsExpr: startsExpr
	  }),
	  star: createToken("*", {
	    binop: 10
	  }),
	  slash: createBinop("/", 10),
	  exponent: createToken("**", {
	    beforeExpr: beforeExpr,
	    binop: 11,
	    rightAssociative: true
	  }),
	  _in: createKeyword("in", {
	    beforeExpr: beforeExpr,
	    binop: 7
	  }),
	  _instanceof: createKeyword("instanceof", {
	    beforeExpr: beforeExpr,
	    binop: 7
	  }),
	  _break: createKeyword("break"),
	  _case: createKeyword("case", {
	    beforeExpr: beforeExpr
	  }),
	  _catch: createKeyword("catch"),
	  _continue: createKeyword("continue"),
	  _debugger: createKeyword("debugger"),
	  _default: createKeyword("default", {
	    beforeExpr: beforeExpr
	  }),
	  _else: createKeyword("else", {
	    beforeExpr: beforeExpr
	  }),
	  _finally: createKeyword("finally"),
	  _function: createKeyword("function", {
	    startsExpr: startsExpr
	  }),
	  _if: createKeyword("if"),
	  _return: createKeyword("return", {
	    beforeExpr: beforeExpr
	  }),
	  _switch: createKeyword("switch"),
	  _throw: createKeyword("throw", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  _try: createKeyword("try"),
	  _var: createKeyword("var"),
	  _const: createKeyword("const"),
	  _with: createKeyword("with"),
	  _new: createKeyword("new", {
	    beforeExpr: beforeExpr,
	    startsExpr: startsExpr
	  }),
	  _this: createKeyword("this", {
	    startsExpr: startsExpr
	  }),
	  _super: createKeyword("super", {
	    startsExpr: startsExpr
	  }),
	  _class: createKeyword("class", {
	    startsExpr: startsExpr
	  }),
	  _extends: createKeyword("extends", {
	    beforeExpr: beforeExpr
	  }),
	  _export: createKeyword("export"),
	  _import: createKeyword("import", {
	    startsExpr: startsExpr
	  }),
	  _null: createKeyword("null", {
	    startsExpr: startsExpr
	  }),
	  _true: createKeyword("true", {
	    startsExpr: startsExpr
	  }),
	  _false: createKeyword("false", {
	    startsExpr: startsExpr
	  }),
	  _typeof: createKeyword("typeof", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  _void: createKeyword("void", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  _delete: createKeyword("delete", {
	    beforeExpr: beforeExpr,
	    prefix: prefix,
	    startsExpr: startsExpr
	  }),
	  _do: createKeyword("do", {
	    isLoop: isLoop,
	    beforeExpr: beforeExpr
	  }),
	  _for: createKeyword("for", {
	    isLoop: isLoop
	  }),
	  _while: createKeyword("while", {
	    isLoop: isLoop
	  }),
	  _as: createKeywordLike("as", {
	    startsExpr: startsExpr
	  }),
	  _assert: createKeywordLike("assert", {
	    startsExpr: startsExpr
	  }),
	  _async: createKeywordLike("async", {
	    startsExpr: startsExpr
	  }),
	  _await: createKeywordLike("await", {
	    startsExpr: startsExpr
	  }),
	  _from: createKeywordLike("from", {
	    startsExpr: startsExpr
	  }),
	  _get: createKeywordLike("get", {
	    startsExpr: startsExpr
	  }),
	  _let: createKeywordLike("let", {
	    startsExpr: startsExpr
	  }),
	  _meta: createKeywordLike("meta", {
	    startsExpr: startsExpr
	  }),
	  _of: createKeywordLike("of", {
	    startsExpr: startsExpr
	  }),
	  _sent: createKeywordLike("sent", {
	    startsExpr: startsExpr
	  }),
	  _set: createKeywordLike("set", {
	    startsExpr: startsExpr
	  }),
	  _static: createKeywordLike("static", {
	    startsExpr: startsExpr
	  }),
	  _yield: createKeywordLike("yield", {
	    startsExpr: startsExpr
	  }),
	  _asserts: createKeywordLike("asserts", {
	    startsExpr: startsExpr
	  }),
	  _checks: createKeywordLike("checks", {
	    startsExpr: startsExpr
	  }),
	  _exports: createKeywordLike("exports", {
	    startsExpr: startsExpr
	  }),
	  _global: createKeywordLike("global", {
	    startsExpr: startsExpr
	  }),
	  _implements: createKeywordLike("implements", {
	    startsExpr: startsExpr
	  }),
	  _intrinsic: createKeywordLike("intrinsic", {
	    startsExpr: startsExpr
	  }),
	  _infer: createKeywordLike("infer", {
	    startsExpr: startsExpr
	  }),
	  _is: createKeywordLike("is", {
	    startsExpr: startsExpr
	  }),
	  _mixins: createKeywordLike("mixins", {
	    startsExpr: startsExpr
	  }),
	  _proto: createKeywordLike("proto", {
	    startsExpr: startsExpr
	  }),
	  _require: createKeywordLike("require", {
	    startsExpr: startsExpr
	  }),
	  _keyof: createKeywordLike("keyof", {
	    startsExpr: startsExpr
	  }),
	  _readonly: createKeywordLike("readonly", {
	    startsExpr: startsExpr
	  }),
	  _unique: createKeywordLike("unique", {
	    startsExpr: startsExpr
	  }),
	  _abstract: createKeywordLike("abstract", {
	    startsExpr: startsExpr
	  }),
	  _declare: createKeywordLike("declare", {
	    startsExpr: startsExpr
	  }),
	  _enum: createKeywordLike("enum", {
	    startsExpr: startsExpr
	  }),
	  _module: createKeywordLike("module", {
	    startsExpr: startsExpr
	  }),
	  _namespace: createKeywordLike("namespace", {
	    startsExpr: startsExpr
	  }),
	  _interface: createKeywordLike("interface", {
	    startsExpr: startsExpr
	  }),
	  _type: createKeywordLike("type", {
	    startsExpr: startsExpr
	  }),
	  _opaque: createKeywordLike("opaque", {
	    startsExpr: startsExpr
	  }),
	  name: createToken("name", {
	    startsExpr: startsExpr
	  }),
	  string: createToken("string", {
	    startsExpr: startsExpr
	  }),
	  num: createToken("num", {
	    startsExpr: startsExpr
	  }),
	  bigint: createToken("bigint", {
	    startsExpr: startsExpr
	  }),
	  decimal: createToken("decimal", {
	    startsExpr: startsExpr
	  }),
	  regexp: createToken("regexp", {
	    startsExpr: startsExpr
	  }),
	  privateName: createToken("#name", {
	    startsExpr: startsExpr
	  }),
	  eof: createToken("eof"),
	  jsxName: createToken("jsxName"),
	  jsxText: createToken("jsxText", {
	    beforeExpr: true
	  }),
	  jsxTagStart: createToken("jsxTagStart", {
	    startsExpr: true
	  }),
	  jsxTagEnd: createToken("jsxTagEnd"),
	  placeholder: createToken("%%", {
	    startsExpr: true
	  })
	};
	function tokenIsIdentifier(token) {
	  return token >= 89 && token <= 124;
	}
	function tokenKeywordOrIdentifierIsKeyword(token) {
	  return token <= 88;
	}
	function tokenIsKeywordOrIdentifier(token) {
	  return token >= 54 && token <= 124;
	}
	function tokenIsLiteralPropertyName(token) {
	  return token >= 54 && token <= 128;
	}
	function tokenComesBeforeExpression(token) {
	  return tokenBeforeExprs[token];
	}
	function tokenCanStartExpression(token) {
	  return tokenStartsExprs[token];
	}
	function tokenIsAssignment(token) {
	  return token >= 29 && token <= 33;
	}
	function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
	  return token >= 121 && token <= 123;
	}
	function tokenIsLoop(token) {
	  return token >= 86 && token <= 88;
	}
	function tokenIsKeyword(token) {
	  return token >= 54 && token <= 88;
	}
	function tokenIsOperator(token) {
	  return token >= 37 && token <= 55;
	}
	function tokenIsPostfix(token) {
	  return token === 34;
	}
	function tokenIsPrefix(token) {
	  return tokenPrefixes[token];
	}
	function tokenIsTSTypeOperator(token) {
	  return token >= 113 && token <= 115;
	}
	function tokenIsTSDeclarationStart(token) {
	  return token >= 116 && token <= 122;
	}
	function tokenLabelName(token) {
	  return tokenLabels[token];
	}
	function tokenOperatorPrecedence(token) {
	  return tokenBinops[token];
	}
	function tokenIsRightAssociative(token) {
	  return token === 53;
	}
	function tokenIsTemplate(token) {
	  return token >= 24 && token <= 25;
	}
	function getExportedToken(token) {
	  return tokenTypes[token];
	}
	function isTokenType(obj) {
	  return typeof obj === "number";
	}
	{
	  tokenTypes[8].updateContext = function (context) {
	    context.pop();
	  };

	  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = function (context) {
	    context.push(types.brace);
	  };

	  tokenTypes[22].updateContext = function (context) {
	    if (context[context.length - 1] === types.template) {
	      context.pop();
	    } else {
	      context.push(types.template);
	    }
	  };

	  tokenTypes[134].updateContext = function (context) {
	    context.push(types.j_expr, types.j_oTag);
	  };
	}

	function isIteratorStart(current, next) {
	  return current === 64 && next === 64;
	}
	var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
	function canBeReservedWord(word) {
	  return reservedWordLikeSet.has(word);
	}

	var SCOPE_OTHER = 0,
	    SCOPE_PROGRAM = 1,
	    SCOPE_FUNCTION = 2,
	    SCOPE_ARROW = 4,
	    SCOPE_SIMPLE_CATCH = 8,
	    SCOPE_SUPER = 16,
	    SCOPE_DIRECT_SUPER = 32,
	    SCOPE_CLASS = 64,
	    SCOPE_STATIC_BLOCK = 128,
	    SCOPE_TS_MODULE = 256,
	    SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
	var BIND_KIND_VALUE = 1,
	    BIND_KIND_TYPE = 2,
	    BIND_SCOPE_VAR = 4,
	    BIND_SCOPE_LEXICAL = 8,
	    BIND_SCOPE_FUNCTION = 16,
	    BIND_FLAGS_NONE = 64,
	    BIND_FLAGS_CLASS = 128,
	    BIND_FLAGS_TS_ENUM = 256,
	    BIND_FLAGS_TS_CONST_ENUM = 512,
	    BIND_FLAGS_TS_EXPORT_ONLY = 1024,
	    BIND_FLAGS_FLOW_DECLARE_FN = 2048;
	var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
	    BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
	    BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
	    BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
	    BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
	    BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
	    BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
	    BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
	    BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
	    BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
	    BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
	    BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
	    BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
	var CLASS_ELEMENT_FLAG_STATIC = 4,
	    CLASS_ELEMENT_KIND_GETTER = 2,
	    CLASS_ELEMENT_KIND_SETTER = 1,
	    CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
	var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
	    CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
	    CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
	    CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
	    CLASS_ELEMENT_OTHER = 0;

	var Scope = function Scope(flags) {
	  this["var"] = new Set();
	  this.lexical = new Set();
	  this.functions = new Set();
	  this.flags = flags;
	};

	var ScopeHandler = function () {
	  function ScopeHandler(raise, inModule) {
	    this.scopeStack = [];
	    this.undefinedExports = new Map();
	    this.undefinedPrivateNames = new Map();
	    this.raise = raise;
	    this.inModule = inModule;
	  }

	  var _proto = ScopeHandler.prototype;

	  _proto.createScope = function createScope(flags) {
	    return new Scope(flags);
	  };

	  _proto.enter = function enter(flags) {
	    this.scopeStack.push(this.createScope(flags));
	  };

	  _proto.exit = function exit() {
	    this.scopeStack.pop();
	  };

	  _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
	    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
	  };

	  _proto.declareName = function declareName(name, bindingType, pos) {
	    var scope = this.currentScope();

	    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
	      this.checkRedeclarationInScope(scope, name, bindingType, pos);

	      if (bindingType & BIND_SCOPE_FUNCTION) {
	        scope.functions.add(name);
	      } else {
	        scope.lexical.add(name);
	      }

	      if (bindingType & BIND_SCOPE_LEXICAL) {
	        this.maybeExportDefined(scope, name);
	      }
	    } else if (bindingType & BIND_SCOPE_VAR) {
	      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
	        scope = this.scopeStack[i];
	        this.checkRedeclarationInScope(scope, name, bindingType, pos);
	        scope["var"].add(name);
	        this.maybeExportDefined(scope, name);
	        if (scope.flags & SCOPE_VAR) break;
	      }
	    }

	    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
	      this.undefinedExports["delete"](name);
	    }
	  };

	  _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
	    if (this.inModule && scope.flags & SCOPE_PROGRAM) {
	      this.undefinedExports["delete"](name);
	    }
	  };

	  _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, pos) {
	    if (this.isRedeclaredInScope(scope, name, bindingType)) {
	      this.raise(pos, ErrorMessages.VarRedeclaration, name);
	    }
	  };

	  _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
	    if (!(bindingType & BIND_KIND_VALUE)) return false;

	    if (bindingType & BIND_SCOPE_LEXICAL) {
	      return scope.lexical.has(name) || scope.functions.has(name) || scope["var"].has(name);
	    }

	    if (bindingType & BIND_SCOPE_FUNCTION) {
	      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope["var"].has(name);
	    }

	    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
	  };

	  _proto.checkLocalExport = function checkLocalExport(id) {
	    var name = id.name;
	    var topLevelScope = this.scopeStack[0];

	    if (!topLevelScope.lexical.has(name) && !topLevelScope["var"].has(name) && !topLevelScope.functions.has(name)) {
	      this.undefinedExports.set(name, id.start);
	    }
	  };

	  _proto.currentScope = function currentScope() {
	    return this.scopeStack[this.scopeStack.length - 1];
	  };

	  _proto.currentVarScopeFlags = function currentVarScopeFlags() {
	    for (var i = this.scopeStack.length - 1;; i--) {
	      var flags = this.scopeStack[i].flags;

	      if (flags & SCOPE_VAR) {
	        return flags;
	      }
	    }
	  };

	  _proto.currentThisScopeFlags = function currentThisScopeFlags() {
	    for (var i = this.scopeStack.length - 1;; i--) {
	      var flags = this.scopeStack[i].flags;

	      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
	        return flags;
	      }
	    }
	  };

	  _createClass(ScopeHandler, [{
	    key: "inFunction",
	    get: function get() {
	      return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
	    }
	  }, {
	    key: "allowSuper",
	    get: function get() {
	      return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
	    }
	  }, {
	    key: "allowDirectSuper",
	    get: function get() {
	      return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
	    }
	  }, {
	    key: "inClass",
	    get: function get() {
	      return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
	    }
	  }, {
	    key: "inClassAndNotInNonArrowFunction",
	    get: function get() {
	      var flags = this.currentThisScopeFlags();
	      return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
	    }
	  }, {
	    key: "inStaticBlock",
	    get: function get() {
	      for (var i = this.scopeStack.length - 1;; i--) {
	        var flags = this.scopeStack[i].flags;

	        if (flags & SCOPE_STATIC_BLOCK) {
	          return true;
	        }

	        if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
	          return false;
	        }
	      }
	    }
	  }, {
	    key: "inNonArrowFunction",
	    get: function get() {
	      return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
	    }
	  }, {
	    key: "treatFunctionsAsVar",
	    get: function get() {
	      return this.treatFunctionsAsVarInScope(this.currentScope());
	    }
	  }]);

	  return ScopeHandler;
	}();

	var FlowScope = function (_Scope) {
	  _inherits(FlowScope, _Scope);

	  function FlowScope() {
	    var _this;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
	    _this.declareFunctions = new Set();
	    return _this;
	  }

	  return FlowScope;
	}(Scope);

	var FlowScopeHandler = function (_ScopeHandler) {
	  _inherits(FlowScopeHandler, _ScopeHandler);

	  function FlowScopeHandler() {
	    return _ScopeHandler.apply(this, arguments) || this;
	  }

	  var _proto = FlowScopeHandler.prototype;

	  _proto.createScope = function createScope(flags) {
	    return new FlowScope(flags);
	  };

	  _proto.declareName = function declareName(name, bindingType, pos) {
	    var scope = this.currentScope();

	    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
	      this.checkRedeclarationInScope(scope, name, bindingType, pos);
	      this.maybeExportDefined(scope, name);
	      scope.declareFunctions.add(name);
	      return;
	    }

	    _ScopeHandler.prototype.declareName.apply(this, arguments);
	  };

	  _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
	    if (_ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments)) return true;

	    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
	      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
	    }

	    return false;
	  };

	  _proto.checkLocalExport = function checkLocalExport(id) {
	    if (!this.scopeStack[0].declareFunctions.has(id.name)) {
	      _ScopeHandler.prototype.checkLocalExport.call(this, id);
	    }
	  };

	  return FlowScopeHandler;
	}(ScopeHandler);

	var State = function () {
	  function State() {
	    this.strict = void 0;
	    this.curLine = void 0;
	    this.lineStart = void 0;
	    this.startLoc = void 0;
	    this.endLoc = void 0;
	    this.errors = [];
	    this.potentialArrowAt = -1;
	    this.noArrowAt = [];
	    this.noArrowParamsConversionAt = [];
	    this.maybeInArrowParameters = false;
	    this.inType = false;
	    this.noAnonFunctionType = false;
	    this.hasFlowComment = false;
	    this.isAmbientContext = false;
	    this.inAbstractClass = false;
	    this.topicContext = {
	      maxNumOfResolvableTopics: 0,
	      maxTopicIndex: null
	    };
	    this.soloAwait = false;
	    this.inFSharpPipelineDirectBody = false;
	    this.labels = [];
	    this.decoratorStack = [[]];
	    this.comments = [];
	    this.commentStack = [];
	    this.pos = 0;
	    this.type = 131;
	    this.value = null;
	    this.start = 0;
	    this.end = 0;
	    this.lastTokEndLoc = null;
	    this.lastTokStartLoc = null;
	    this.lastTokStart = 0;
	    this.lastTokEnd = 0;
	    this.context = [types.brace];
	    this.canStartJSXElement = true;
	    this.containsEsc = false;
	    this.strictErrors = new Map();
	    this.tokensLength = 0;
	  }

	  var _proto = State.prototype;

	  _proto.init = function init(_ref) {
	    var strictMode = _ref.strictMode,
	        sourceType = _ref.sourceType,
	        startLine = _ref.startLine,
	        startColumn = _ref.startColumn;
	    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
	    this.curLine = startLine;
	    this.lineStart = -startColumn;
	    this.startLoc = this.endLoc = new Position(startLine, startColumn);
	  };

	  _proto.curPosition = function curPosition() {
	    return new Position(this.curLine, this.pos - this.lineStart);
	  };

	  _proto.clone = function clone(skipArrays) {
	    var state = new State();
	    var keys = Object.keys(this);

	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var val = this[key];

	      if (!skipArrays && Array.isArray(val)) {
	        val = val.slice();
	      }

	      state[key] = val;
	    }

	    return state;
	  };

	  return State;
	}();

	var _isDigit = function isDigit(code) {
	  return code >= 48 && code <= 57;
	};
	var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
	var forbiddenNumericSeparatorSiblings = {
	  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
	  hex: [46, 88, 95, 120]
	};
	var allowedNumericSeparatorSiblings = {};
	allowedNumericSeparatorSiblings.bin = [48, 49];
	allowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);
	allowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);
	allowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
	var Token = function Token(state) {
	  this.type = state.type;
	  this.value = state.value;
	  this.start = state.start;
	  this.end = state.end;
	  this.loc = new SourceLocation(state.startLoc, state.endLoc);
	};

	var Tokenizer = function (_ParserErrors) {
	  _inherits(Tokenizer, _ParserErrors);

	  function Tokenizer(options, input) {
	    var _this;

	    _this = _ParserErrors.call(this) || this;
	    _this.isLookahead = void 0;
	    _this.tokens = [];
	    _this.state = new State();

	    _this.state.init(options);

	    _this.input = input;
	    _this.length = input.length;
	    _this.isLookahead = false;
	    return _this;
	  }

	  var _proto = Tokenizer.prototype;

	  _proto.pushToken = function pushToken(token) {
	    this.tokens.length = this.state.tokensLength;
	    this.tokens.push(token);
	    ++this.state.tokensLength;
	  };

	  _proto.next = function next() {
	    this.checkKeywordEscapes();

	    if (this.options.tokens) {
	      this.pushToken(new Token(this.state));
	    }

	    this.state.lastTokEnd = this.state.end;
	    this.state.lastTokStart = this.state.start;
	    this.state.lastTokEndLoc = this.state.endLoc;
	    this.state.lastTokStartLoc = this.state.startLoc;
	    this.nextToken();
	  };

	  _proto.eat = function eat(type) {
	    if (this.match(type)) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  };

	  _proto.match = function match(type) {
	    return this.state.type === type;
	  };

	  _proto.createLookaheadState = function createLookaheadState(state) {
	    return {
	      pos: state.pos,
	      value: null,
	      type: state.type,
	      start: state.start,
	      end: state.end,
	      lastTokEnd: state.end,
	      context: [this.curContext()],
	      inType: state.inType
	    };
	  };

	  _proto.lookahead = function lookahead() {
	    var old = this.state;
	    this.state = this.createLookaheadState(old);
	    this.isLookahead = true;
	    this.nextToken();
	    this.isLookahead = false;
	    var curr = this.state;
	    this.state = old;
	    return curr;
	  };

	  _proto.nextTokenStart = function nextTokenStart() {
	    return this.nextTokenStartSince(this.state.pos);
	  };

	  _proto.nextTokenStartSince = function nextTokenStartSince(pos) {
	    skipWhiteSpace.lastIndex = pos;
	    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
	  };

	  _proto.lookaheadCharCode = function lookaheadCharCode() {
	    return this.input.charCodeAt(this.nextTokenStart());
	  };

	  _proto.codePointAtPos = function codePointAtPos(pos) {
	    var cp = this.input.charCodeAt(pos);

	    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
	      var trail = this.input.charCodeAt(pos);

	      if ((trail & 0xfc00) === 0xdc00) {
	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
	      }
	    }

	    return cp;
	  };

	  _proto.setStrict = function setStrict(strict) {
	    var _this2 = this;

	    this.state.strict = strict;

	    if (strict) {
	      this.state.strictErrors.forEach(function (message, pos) {
	        return _this2.raise(pos, message);
	      });
	      this.state.strictErrors.clear();
	    }
	  };

	  _proto.curContext = function curContext() {
	    return this.state.context[this.state.context.length - 1];
	  };

	  _proto.nextToken = function nextToken() {
	    this.skipSpace();
	    this.state.start = this.state.pos;
	    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();

	    if (this.state.pos >= this.length) {
	      this.finishToken(131);
	      return;
	    }

	    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
	  };

	  _proto.skipBlockComment = function skipBlockComment() {
	    var startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    var start = this.state.pos;
	    var end = this.input.indexOf("*/", start + 2);
	    if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
	    this.state.pos = end + 2;
	    lineBreakG.lastIndex = start + 2;

	    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
	      ++this.state.curLine;
	      this.state.lineStart = lineBreakG.lastIndex;
	    }

	    if (this.isLookahead) return;
	    var comment = {
	      type: "CommentBlock",
	      value: this.input.slice(start + 2, end),
	      start: start,
	      end: end + 2,
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.options.tokens) this.pushToken(comment);
	    return comment;
	  };

	  _proto.skipLineComment = function skipLineComment(startSkip) {
	    var start = this.state.pos;
	    var startLoc;
	    if (!this.isLookahead) startLoc = this.state.curPosition();
	    var ch = this.input.charCodeAt(this.state.pos += startSkip);

	    if (this.state.pos < this.length) {
	      while (!isNewLine(ch) && ++this.state.pos < this.length) {
	        ch = this.input.charCodeAt(this.state.pos);
	      }
	    }

	    if (this.isLookahead) return;
	    var end = this.state.pos;
	    var value = this.input.slice(start + startSkip, end);
	    var comment = {
	      type: "CommentLine",
	      value: value,
	      start: start,
	      end: end,
	      loc: new SourceLocation(startLoc, this.state.curPosition())
	    };
	    if (this.options.tokens) this.pushToken(comment);
	    return comment;
	  };

	  _proto.skipSpace = function skipSpace() {
	    var spaceStart = this.state.pos;
	    var comments = [];

	    loop: while (this.state.pos < this.length) {
	      var ch = this.input.charCodeAt(this.state.pos);

	      switch (ch) {
	        case 32:
	        case 160:
	        case 9:
	          ++this.state.pos;
	          break;

	        case 13:
	          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
	            ++this.state.pos;
	          }

	        case 10:
	        case 8232:
	        case 8233:
	          ++this.state.pos;
	          ++this.state.curLine;
	          this.state.lineStart = this.state.pos;
	          break;

	        case 47:
	          switch (this.input.charCodeAt(this.state.pos + 1)) {
	            case 42:
	              {
	                var comment = this.skipBlockComment();

	                if (comment !== undefined) {
	                  this.addComment(comment);
	                  if (this.options.attachComment) comments.push(comment);
	                }

	                break;
	              }

	            case 47:
	              {
	                var _comment = this.skipLineComment(2);

	                if (_comment !== undefined) {
	                  this.addComment(_comment);
	                  if (this.options.attachComment) comments.push(_comment);
	                }

	                break;
	              }

	            default:
	              break loop;
	          }

	          break;

	        default:
	          if (isWhitespace(ch)) {
	            ++this.state.pos;
	          } else if (ch === 45 && !this.inModule) {
	            var pos = this.state.pos;

	            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
	              var _comment2 = this.skipLineComment(3);

	              if (_comment2 !== undefined) {
	                this.addComment(_comment2);
	                if (this.options.attachComment) comments.push(_comment2);
	              }
	            } else {
	              break loop;
	            }
	          } else if (ch === 60 && !this.inModule) {
	            var _pos = this.state.pos;

	            if (this.input.charCodeAt(_pos + 1) === 33 && this.input.charCodeAt(_pos + 2) === 45 && this.input.charCodeAt(_pos + 3) === 45) {
	              var _comment3 = this.skipLineComment(4);

	              if (_comment3 !== undefined) {
	                this.addComment(_comment3);
	                if (this.options.attachComment) comments.push(_comment3);
	              }
	            } else {
	              break loop;
	            }
	          } else {
	            break loop;
	          }

	      }
	    }

	    if (comments.length > 0) {
	      var end = this.state.pos;
	      var CommentWhitespace = {
	        start: spaceStart,
	        end: end,
	        comments: comments,
	        leadingNode: null,
	        trailingNode: null,
	        containingNode: null
	      };
	      this.state.commentStack.push(CommentWhitespace);
	    }
	  };

	  _proto.finishToken = function finishToken(type, val) {
	    this.state.end = this.state.pos;
	    var prevType = this.state.type;
	    this.state.type = type;
	    this.state.value = val;

	    if (!this.isLookahead) {
	      this.state.endLoc = this.state.curPosition();
	      this.updateContext(prevType);
	    }
	  };

	  _proto.replaceToken = function replaceToken(type) {
	    this.state.type = type;
	    this.updateContext();
	  };

	  _proto.readToken_numberSign = function readToken_numberSign() {
	    if (this.state.pos === 0 && this.readToken_interpreter()) {
	      return;
	    }

	    var nextPos = this.state.pos + 1;
	    var next = this.codePointAtPos(nextPos);

	    if (next >= 48 && next <= 57) {
	      throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
	    }

	    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
	      this.expectPlugin("recordAndTuple");

	      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
	        throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
	      }

	      this.state.pos += 2;

	      if (next === 123) {
	        this.finishToken(7);
	      } else {
	        this.finishToken(1);
	      }
	    } else if (isIdentifierStart(next)) {
	      ++this.state.pos;
	      this.finishToken(130, this.readWord1(next));
	    } else if (next === 92) {
	      ++this.state.pos;
	      this.finishToken(130, this.readWord1());
	    } else {
	      this.finishOp(27, 1);
	    }
	  };

	  _proto.readToken_dot = function readToken_dot() {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next >= 48 && next <= 57) {
	      this.readNumber(true);
	      return;
	    }

	    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
	      this.state.pos += 3;
	      this.finishToken(21);
	    } else {
	      ++this.state.pos;
	      this.finishToken(16);
	    }
	  };

	  _proto.readToken_slash = function readToken_slash() {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61) {
	      this.finishOp(31, 2);
	    } else {
	      this.finishOp(52, 1);
	    }
	  };

	  _proto.readToken_interpreter = function readToken_interpreter() {
	    if (this.state.pos !== 0 || this.length < 2) return false;
	    var ch = this.input.charCodeAt(this.state.pos + 1);
	    if (ch !== 33) return false;
	    var start = this.state.pos;
	    this.state.pos += 1;

	    while (!isNewLine(ch) && ++this.state.pos < this.length) {
	      ch = this.input.charCodeAt(this.state.pos);
	    }

	    var value = this.input.slice(start + 2, this.state.pos);
	    this.finishToken(28, value);
	    return true;
	  };

	  _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
	    var type = code === 42 ? 51 : 50;
	    var width = 1;
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (code === 42 && next === 42) {
	      width++;
	      next = this.input.charCodeAt(this.state.pos + 2);
	      type = 53;
	    }

	    if (next === 61 && !this.state.inType) {
	      width++;
	      type = code === 37 ? 33 : 30;
	    }

	    this.finishOp(type, width);
	  };

	  _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === code) {
	      if (this.input.charCodeAt(this.state.pos + 2) === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(code === 124 ? 39 : 40, 2);
	      }

	      return;
	    }

	    if (code === 124) {
	      if (next === 62) {
	        this.finishOp(37, 2);
	        return;
	      }

	      if (this.hasPlugin("recordAndTuple") && next === 125) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
	        }

	        this.state.pos += 2;
	        this.finishToken(9);
	        return;
	      }

	      if (this.hasPlugin("recordAndTuple") && next === 93) {
	        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	          throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
	        }

	        this.state.pos += 2;
	        this.finishToken(4);
	        return;
	      }
	    }

	    if (next === 61) {
	      this.finishOp(30, 2);
	      return;
	    }

	    this.finishOp(code === 124 ? 41 : 43, 1);
	  };

	  _proto.readToken_caret = function readToken_caret() {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61 && !this.state.inType) {
	      this.finishOp(32, 2);
	    } else {
	      this.finishOp(42, 1);
	    }
	  };

	  _proto.readToken_plus_min = function readToken_plus_min(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === code) {
	      this.finishOp(34, 2);
	      return;
	    }

	    if (next === 61) {
	      this.finishOp(30, 2);
	    } else {
	      this.finishOp(49, 1);
	    }
	  };

	  _proto.readToken_lt = function readToken_lt() {
	    var pos = this.state.pos;
	    var next = this.input.charCodeAt(pos + 1);

	    if (next === 60) {
	      if (this.input.charCodeAt(pos + 2) === 61) {
	        this.finishOp(30, 3);
	        return;
	      }

	      this.finishOp(48, 2);
	      return;
	    }

	    if (next === 61) {
	      this.finishOp(47, 2);
	      return;
	    }

	    this.finishOp(45, 1);
	  };

	  _proto.readToken_gt = function readToken_gt() {
	    var pos = this.state.pos;
	    var next = this.input.charCodeAt(pos + 1);

	    if (next === 62) {
	      var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;

	      if (this.input.charCodeAt(pos + size) === 61) {
	        this.finishOp(30, size + 1);
	        return;
	      }

	      this.finishOp(48, size);
	      return;
	    }

	    if (next === 61) {
	      this.finishOp(47, 2);
	      return;
	    }

	    this.finishOp(46, 1);
	  };

	  _proto.readToken_eq_excl = function readToken_eq_excl(code) {
	    var next = this.input.charCodeAt(this.state.pos + 1);

	    if (next === 61) {
	      this.finishOp(44, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
	      return;
	    }

	    if (code === 61 && next === 62) {
	      this.state.pos += 2;
	      this.finishToken(19);
	      return;
	    }

	    this.finishOp(code === 61 ? 29 : 35, 1);
	  };

	  _proto.readToken_question = function readToken_question() {
	    var next = this.input.charCodeAt(this.state.pos + 1);
	    var next2 = this.input.charCodeAt(this.state.pos + 2);

	    if (next === 63) {
	      if (next2 === 61) {
	        this.finishOp(30, 3);
	      } else {
	        this.finishOp(38, 2);
	      }
	    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
	      this.state.pos += 2;
	      this.finishToken(18);
	    } else {
	      ++this.state.pos;
	      this.finishToken(17);
	    }
	  };

	  _proto.getTokenFromCode = function getTokenFromCode(code) {
	    switch (code) {
	      case 46:
	        this.readToken_dot();
	        return;

	      case 40:
	        ++this.state.pos;
	        this.finishToken(10);
	        return;

	      case 41:
	        ++this.state.pos;
	        this.finishToken(11);
	        return;

	      case 59:
	        ++this.state.pos;
	        this.finishToken(13);
	        return;

	      case 44:
	        ++this.state.pos;
	        this.finishToken(12);
	        return;

	      case 91:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
	          }

	          this.state.pos += 2;
	          this.finishToken(2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(0);
	        }

	        return;

	      case 93:
	        ++this.state.pos;
	        this.finishToken(3);
	        return;

	      case 123:
	        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
	          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
	            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
	          }

	          this.state.pos += 2;
	          this.finishToken(6);
	        } else {
	          ++this.state.pos;
	          this.finishToken(5);
	        }

	        return;

	      case 125:
	        ++this.state.pos;
	        this.finishToken(8);
	        return;

	      case 58:
	        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
	          this.finishOp(15, 2);
	        } else {
	          ++this.state.pos;
	          this.finishToken(14);
	        }

	        return;

	      case 63:
	        this.readToken_question();
	        return;

	      case 96:
	        this.readTemplateToken();
	        return;

	      case 48:
	        {
	          var next = this.input.charCodeAt(this.state.pos + 1);

	          if (next === 120 || next === 88) {
	            this.readRadixNumber(16);
	            return;
	          }

	          if (next === 111 || next === 79) {
	            this.readRadixNumber(8);
	            return;
	          }

	          if (next === 98 || next === 66) {
	            this.readRadixNumber(2);
	            return;
	          }
	        }

	      case 49:
	      case 50:
	      case 51:
	      case 52:
	      case 53:
	      case 54:
	      case 55:
	      case 56:
	      case 57:
	        this.readNumber(false);
	        return;

	      case 34:
	      case 39:
	        this.readString(code);
	        return;

	      case 47:
	        this.readToken_slash();
	        return;

	      case 37:
	      case 42:
	        this.readToken_mult_modulo(code);
	        return;

	      case 124:
	      case 38:
	        this.readToken_pipe_amp(code);
	        return;

	      case 94:
	        this.readToken_caret();
	        return;

	      case 43:
	      case 45:
	        this.readToken_plus_min(code);
	        return;

	      case 60:
	        this.readToken_lt();
	        return;

	      case 62:
	        this.readToken_gt();
	        return;

	      case 61:
	      case 33:
	        this.readToken_eq_excl(code);
	        return;

	      case 126:
	        this.finishOp(36, 1);
	        return;

	      case 64:
	        ++this.state.pos;
	        this.finishToken(26);
	        return;

	      case 35:
	        this.readToken_numberSign();
	        return;

	      case 92:
	        this.readWord();
	        return;

	      default:
	        if (isIdentifierStart(code)) {
	          this.readWord(code);
	          return;
	        }

	    }

	    throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
	  };

	  _proto.finishOp = function finishOp(type, size) {
	    var str = this.input.slice(this.state.pos, this.state.pos + size);
	    this.state.pos += size;
	    this.finishToken(type, str);
	  };

	  _proto.readRegexp = function readRegexp() {
	    var start = this.state.start + 1;
	    var escaped, inClass;
	    var pos = this.state.pos;

	    for (;; ++pos) {
	      if (pos >= this.length) {
	        throw this.raise(start, ErrorMessages.UnterminatedRegExp);
	      }

	      var ch = this.input.charCodeAt(pos);

	      if (isNewLine(ch)) {
	        throw this.raise(start, ErrorMessages.UnterminatedRegExp);
	      }

	      if (escaped) {
	        escaped = false;
	      } else {
	        if (ch === 91) {
	          inClass = true;
	        } else if (ch === 93 && inClass) {
	          inClass = false;
	        } else if (ch === 47 && !inClass) {
	          break;
	        }

	        escaped = ch === 92;
	      }
	    }

	    var content = this.input.slice(start, pos);
	    ++pos;
	    var mods = "";

	    while (pos < this.length) {
	      var cp = this.codePointAtPos(pos);

	      var _char = String.fromCharCode(cp);

	      if (VALID_REGEX_FLAGS.has(cp)) {
	        if (mods.includes(_char)) {
	          this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
	        }
	      } else if (isIdentifierChar(cp) || cp === 92) {
	        this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
	      } else {
	        break;
	      }

	      ++pos;
	      mods += _char;
	    }

	    this.state.pos = pos;
	    this.finishToken(129, {
	      pattern: content,
	      flags: mods
	    });
	  };

	  _proto.readInt = function readInt(radix, len, forceLen, allowNumSeparator) {
	    if (allowNumSeparator === void 0) {
	      allowNumSeparator = true;
	    }

	    var start = this.state.pos;
	    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
	    var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
	    var invalid = false;
	    var total = 0;

	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = this.input.charCodeAt(this.state.pos);
	      var val = void 0;

	      if (code === 95) {
	        var prev = this.input.charCodeAt(this.state.pos - 1);
	        var next = this.input.charCodeAt(this.state.pos + 1);

	        if (allowedSiblings.indexOf(next) === -1) {
	          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
	        } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
	          this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
	        }

	        if (!allowNumSeparator) {
	          this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
	        }

	        ++this.state.pos;
	        continue;
	      }

	      if (code >= 97) {
	        val = code - 97 + 10;
	      } else if (code >= 65) {
	        val = code - 65 + 10;
	      } else if (_isDigit(code)) {
	        val = code - 48;
	      } else {
	        val = Infinity;
	      }

	      if (val >= radix) {
	        if (this.options.errorRecovery && val <= 9) {
	          val = 0;
	          this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
	        } else if (forceLen) {
	          val = 0;
	          invalid = true;
	        } else {
	          break;
	        }
	      }

	      ++this.state.pos;
	      total = total * radix + val;
	    }

	    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
	      return null;
	    }

	    return total;
	  };

	  _proto.readRadixNumber = function readRadixNumber(radix) {
	    var start = this.state.pos;
	    var isBigInt = false;
	    this.state.pos += 2;
	    var val = this.readInt(radix);

	    if (val == null) {
	      this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
	    }

	    var next = this.input.charCodeAt(this.state.pos);

	    if (next === 110) {
	      ++this.state.pos;
	      isBigInt = true;
	    } else if (next === 109) {
	      throw this.raise(start, ErrorMessages.InvalidDecimal);
	    }

	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
	    }

	    if (isBigInt) {
	      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
	      this.finishToken(127, str);
	      return;
	    }

	    this.finishToken(126, val);
	  };

	  _proto.readNumber = function readNumber(startsWithDot) {
	    var start = this.state.pos;
	    var isFloat = false;
	    var isBigInt = false;
	    var isDecimal = false;
	    var hasExponent = false;
	    var isOctal = false;

	    if (!startsWithDot && this.readInt(10) === null) {
	      this.raise(start, ErrorMessages.InvalidNumber);
	    }

	    var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

	    if (hasLeadingZero) {
	      var integer = this.input.slice(start, this.state.pos);
	      this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

	      if (!this.state.strict) {
	        var underscorePos = integer.indexOf("_");

	        if (underscorePos > 0) {
	          this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
	        }
	      }

	      isOctal = hasLeadingZero && !/[89]/.test(integer);
	    }

	    var next = this.input.charCodeAt(this.state.pos);

	    if (next === 46 && !isOctal) {
	      ++this.state.pos;
	      this.readInt(10);
	      isFloat = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }

	    if ((next === 69 || next === 101) && !isOctal) {
	      next = this.input.charCodeAt(++this.state.pos);

	      if (next === 43 || next === 45) {
	        ++this.state.pos;
	      }

	      if (this.readInt(10) === null) {
	        this.raise(start, ErrorMessages.InvalidOrMissingExponent);
	      }

	      isFloat = true;
	      hasExponent = true;
	      next = this.input.charCodeAt(this.state.pos);
	    }

	    if (next === 110) {
	      if (isFloat || hasLeadingZero) {
	        this.raise(start, ErrorMessages.InvalidBigIntLiteral);
	      }

	      ++this.state.pos;
	      isBigInt = true;
	    }

	    if (next === 109) {
	      this.expectPlugin("decimal", this.state.pos);

	      if (hasExponent || hasLeadingZero) {
	        this.raise(start, ErrorMessages.InvalidDecimal);
	      }

	      ++this.state.pos;
	      isDecimal = true;
	    }

	    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
	      throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
	    }

	    var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

	    if (isBigInt) {
	      this.finishToken(127, str);
	      return;
	    }

	    if (isDecimal) {
	      this.finishToken(128, str);
	      return;
	    }

	    var val = isOctal ? parseInt(str, 8) : parseFloat(str);
	    this.finishToken(126, val);
	  };

	  _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
	    var ch = this.input.charCodeAt(this.state.pos);
	    var code;

	    if (ch === 123) {
	      var codePos = ++this.state.pos;
	      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
	      ++this.state.pos;

	      if (code !== null && code > 0x10ffff) {
	        if (throwOnInvalid) {
	          this.raise(codePos, ErrorMessages.InvalidCodePoint);
	        } else {
	          return null;
	        }
	      }
	    } else {
	      code = this.readHexChar(4, false, throwOnInvalid);
	    }

	    return code;
	  };

	  _proto.readString = function readString(quote) {
	    var out = "",
	        chunkStart = ++this.state.pos;

	    for (;;) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
	      }

	      var ch = this.input.charCodeAt(this.state.pos);
	      if (ch === quote) break;

	      if (ch === 92) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        out += this.readEscapedChar(false);
	        chunkStart = this.state.pos;
	      } else if (ch === 8232 || ch === 8233) {
	        ++this.state.pos;
	        ++this.state.curLine;
	        this.state.lineStart = this.state.pos;
	      } else if (isNewLine(ch)) {
	        throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
	      } else {
	        ++this.state.pos;
	      }
	    }

	    out += this.input.slice(chunkStart, this.state.pos++);
	    this.finishToken(125, out);
	  };

	  _proto.readTemplateContinuation = function readTemplateContinuation() {
	    if (!this.match(8)) {
	      this.unexpected(this.state.start, 8);
	    }

	    this.state.pos--;
	    this.readTemplateToken();
	  };

	  _proto.readTemplateToken = function readTemplateToken() {
	    var out = "",
	        chunkStart = this.state.pos,
	        containsInvalid = false;
	    ++this.state.pos;

	    for (;;) {
	      if (this.state.pos >= this.length) {
	        throw this.raise(this.state.start + 1, ErrorMessages.UnterminatedTemplate);
	      }

	      var ch = this.input.charCodeAt(this.state.pos);

	      if (ch === 96) {
	        ++this.state.pos;
	        out += this.input.slice(chunkStart, this.state.pos);
	        this.finishToken(24, containsInvalid ? null : out);
	        return;
	      }

	      if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
	        this.state.pos += 2;
	        out += this.input.slice(chunkStart, this.state.pos);
	        this.finishToken(25, containsInvalid ? null : out);
	        return;
	      }

	      if (ch === 92) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        var escaped = this.readEscapedChar(true);

	        if (escaped === null) {
	          containsInvalid = true;
	        } else {
	          out += escaped;
	        }

	        chunkStart = this.state.pos;
	      } else if (isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.state.pos);
	        ++this.state.pos;

	        switch (ch) {
	          case 13:
	            if (this.input.charCodeAt(this.state.pos) === 10) {
	              ++this.state.pos;
	            }

	          case 10:
	            out += "\n";
	            break;

	          default:
	            out += String.fromCharCode(ch);
	            break;
	        }

	        ++this.state.curLine;
	        this.state.lineStart = this.state.pos;
	        chunkStart = this.state.pos;
	      } else {
	        ++this.state.pos;
	      }
	    }
	  };

	  _proto.recordStrictModeErrors = function recordStrictModeErrors(pos, message) {
	    if (this.state.strict && !this.state.strictErrors.has(pos)) {
	      this.raise(pos, message);
	    } else {
	      this.state.strictErrors.set(pos, message);
	    }
	  };

	  _proto.readEscapedChar = function readEscapedChar(inTemplate) {
	    var throwOnInvalid = !inTemplate;
	    var ch = this.input.charCodeAt(++this.state.pos);
	    ++this.state.pos;

	    switch (ch) {
	      case 110:
	        return "\n";

	      case 114:
	        return "\r";

	      case 120:
	        {
	          var code = this.readHexChar(2, false, throwOnInvalid);
	          return code === null ? null : String.fromCharCode(code);
	        }

	      case 117:
	        {
	          var _code = this.readCodePoint(throwOnInvalid);

	          return _code === null ? null : String.fromCodePoint(_code);
	        }

	      case 116:
	        return "\t";

	      case 98:
	        return "\b";

	      case 118:
	        return "\x0B";

	      case 102:
	        return "\f";

	      case 13:
	        if (this.input.charCodeAt(this.state.pos) === 10) {
	          ++this.state.pos;
	        }

	      case 10:
	        this.state.lineStart = this.state.pos;
	        ++this.state.curLine;

	      case 8232:
	      case 8233:
	        return "";

	      case 56:
	      case 57:
	        if (inTemplate) {
	          return null;
	        } else {
	          this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
	        }

	      default:
	        if (ch >= 48 && ch <= 55) {
	          var codePos = this.state.pos - 1;
	          var match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
	          var octalStr = match[0];
	          var octal = parseInt(octalStr, 8);

	          if (octal > 255) {
	            octalStr = octalStr.slice(0, -1);
	            octal = parseInt(octalStr, 8);
	          }

	          this.state.pos += octalStr.length - 1;
	          var next = this.input.charCodeAt(this.state.pos);

	          if (octalStr !== "0" || next === 56 || next === 57) {
	            if (inTemplate) {
	              return null;
	            } else {
	              this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
	            }
	          }

	          return String.fromCharCode(octal);
	        }

	        return String.fromCharCode(ch);
	    }
	  };

	  _proto.readHexChar = function readHexChar(len, forceLen, throwOnInvalid) {
	    var codePos = this.state.pos;
	    var n = this.readInt(16, len, forceLen, false);

	    if (n === null) {
	      if (throwOnInvalid) {
	        this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
	      } else {
	        this.state.pos = codePos - 1;
	      }
	    }

	    return n;
	  };

	  _proto.readWord1 = function readWord1(firstCode) {
	    this.state.containsEsc = false;
	    var word = "";
	    var start = this.state.pos;
	    var chunkStart = this.state.pos;

	    if (firstCode !== undefined) {
	      this.state.pos += firstCode <= 0xffff ? 1 : 2;
	    }

	    while (this.state.pos < this.length) {
	      var ch = this.codePointAtPos(this.state.pos);

	      if (isIdentifierChar(ch)) {
	        this.state.pos += ch <= 0xffff ? 1 : 2;
	      } else if (ch === 92) {
	        this.state.containsEsc = true;
	        word += this.input.slice(chunkStart, this.state.pos);
	        var escStart = this.state.pos;
	        var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

	        if (this.input.charCodeAt(++this.state.pos) !== 117) {
	          this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
	          chunkStart = this.state.pos - 1;
	          continue;
	        }

	        ++this.state.pos;
	        var esc = this.readCodePoint(true);

	        if (esc !== null) {
	          if (!identifierCheck(esc)) {
	            this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
	          }

	          word += String.fromCodePoint(esc);
	        }

	        chunkStart = this.state.pos;
	      } else {
	        break;
	      }
	    }

	    return word + this.input.slice(chunkStart, this.state.pos);
	  };

	  _proto.readWord = function readWord(firstCode) {
	    var word = this.readWord1(firstCode);
	    var type = keywords.get(word);

	    if (type !== undefined) {
	      this.finishToken(type, tokenLabelName(type));
	    } else {
	      this.finishToken(124, word);
	    }
	  };

	  _proto.checkKeywordEscapes = function checkKeywordEscapes() {
	    var type = this.state.type;

	    if (tokenIsKeyword(type) && this.state.containsEsc) {
	      this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, tokenLabelName(type));
	    }
	  };

	  _proto.updateContext = function updateContext(prevType) {};

	  return Tokenizer;
	}(ParserError);

	var ClassScope = function ClassScope() {
	  this.privateNames = new Set();
	  this.loneAccessors = new Map();
	  this.undefinedPrivateNames = new Map();
	};

	var ClassScopeHandler = function () {
	  function ClassScopeHandler(raise) {
	    this.stack = [];
	    this.undefinedPrivateNames = new Map();
	    this.raise = raise;
	  }

	  var _proto = ClassScopeHandler.prototype;

	  _proto.current = function current() {
	    return this.stack[this.stack.length - 1];
	  };

	  _proto.enter = function enter() {
	    this.stack.push(new ClassScope());
	  };

	  _proto.exit = function exit() {
	    var oldClassScope = this.stack.pop();
	    var current = this.current();

	    for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
	      var _Array$from2$_i = _Array$from2[_i2],
	          name = _Array$from2$_i[0],
	          pos = _Array$from2$_i[1];

	      if (current) {
	        if (!current.undefinedPrivateNames.has(name)) {
	          current.undefinedPrivateNames.set(name, pos);
	        }
	      } else {
	        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
	      }
	    }
	  };

	  _proto.declarePrivateName = function declarePrivateName(name, elementType, pos) {
	    var _this$current = this.current(),
	        privateNames = _this$current.privateNames,
	        loneAccessors = _this$current.loneAccessors,
	        undefinedPrivateNames = _this$current.undefinedPrivateNames;

	    var redefined = privateNames.has(name);

	    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
	      var accessor = redefined && loneAccessors.get(name);

	      if (accessor) {
	        var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
	        var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
	        var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
	        var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
	        redefined = oldKind === newKind || oldStatic !== newStatic;
	        if (!redefined) loneAccessors["delete"](name);
	      } else if (!redefined) {
	        loneAccessors.set(name, elementType);
	      }
	    }

	    if (redefined) {
	      this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
	    }

	    privateNames.add(name);
	    undefinedPrivateNames["delete"](name);
	  };

	  _proto.usePrivateName = function usePrivateName(name, pos) {
	    var classScope;

	    for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
	      classScope = _this$stack2[_i4];
	      if (classScope.privateNames.has(name)) return;
	    }

	    if (classScope) {
	      classScope.undefinedPrivateNames.set(name, pos);
	    } else {
	      this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
	    }
	  };

	  return ClassScopeHandler;
	}();

	var kExpression = 0,
	    kMaybeArrowParameterDeclaration = 1,
	    kMaybeAsyncArrowParameterDeclaration = 2,
	    kParameterDeclaration = 3;

	var ExpressionScope = function () {
	  function ExpressionScope(type) {
	    if (type === void 0) {
	      type = kExpression;
	    }

	    this.type = void 0;
	    this.type = type;
	  }

	  var _proto = ExpressionScope.prototype;

	  _proto.canBeArrowParameterDeclaration = function canBeArrowParameterDeclaration() {
	    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
	  };

	  _proto.isCertainlyParameterDeclaration = function isCertainlyParameterDeclaration() {
	    return this.type === kParameterDeclaration;
	  };

	  return ExpressionScope;
	}();

	var ArrowHeadParsingScope = function (_ExpressionScope) {
	  _inherits(ArrowHeadParsingScope, _ExpressionScope);

	  function ArrowHeadParsingScope(type) {
	    var _this;

	    _this = _ExpressionScope.call(this, type) || this;
	    _this.errors = new Map();
	    return _this;
	  }

	  var _proto2 = ArrowHeadParsingScope.prototype;

	  _proto2.recordDeclarationError = function recordDeclarationError(pos, template) {
	    this.errors.set(pos, template);
	  };

	  _proto2.clearDeclarationError = function clearDeclarationError(pos) {
	    this.errors["delete"](pos);
	  };

	  _proto2.iterateErrors = function iterateErrors(iterator) {
	    this.errors.forEach(iterator);
	  };

	  return ArrowHeadParsingScope;
	}(ExpressionScope);

	var ExpressionScopeHandler = function () {
	  function ExpressionScopeHandler(raise) {
	    this.stack = [new ExpressionScope()];
	    this.raise = raise;
	  }

	  var _proto3 = ExpressionScopeHandler.prototype;

	  _proto3.enter = function enter(scope) {
	    this.stack.push(scope);
	  };

	  _proto3.exit = function exit() {
	    this.stack.pop();
	  };

	  _proto3.recordParameterInitializerError = function recordParameterInitializerError(pos, template) {
	    var stack = this.stack;
	    var i = stack.length - 1;
	    var scope = stack[i];

	    while (!scope.isCertainlyParameterDeclaration()) {
	      if (scope.canBeArrowParameterDeclaration()) {
	        scope.recordDeclarationError(pos, template);
	      } else {
	        return;
	      }

	      scope = stack[--i];
	    }

	    this.raise(pos, template);
	  };

	  _proto3.recordParenthesizedIdentifierError = function recordParenthesizedIdentifierError(pos, template) {
	    var stack = this.stack;
	    var scope = stack[stack.length - 1];

	    if (scope.isCertainlyParameterDeclaration()) {
	      this.raise(pos, template);
	    } else if (scope.canBeArrowParameterDeclaration()) {
	      scope.recordDeclarationError(pos, template);
	    } else {
	      return;
	    }
	  };

	  _proto3.recordAsyncArrowParametersError = function recordAsyncArrowParametersError(pos, template) {
	    var stack = this.stack;
	    var i = stack.length - 1;
	    var scope = stack[i];

	    while (scope.canBeArrowParameterDeclaration()) {
	      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
	        scope.recordDeclarationError(pos, template);
	      }

	      scope = stack[--i];
	    }
	  };

	  _proto3.validateAsPattern = function validateAsPattern() {
	    var _this2 = this;

	    var stack = this.stack;
	    var currentScope = stack[stack.length - 1];
	    if (!currentScope.canBeArrowParameterDeclaration()) return;
	    currentScope.iterateErrors(function (template, pos) {
	      _this2.raise(pos, template);

	      var i = stack.length - 2;
	      var scope = stack[i];

	      while (scope.canBeArrowParameterDeclaration()) {
	        scope.clearDeclarationError(pos);
	        scope = stack[--i];
	      }
	    });
	  };

	  return ExpressionScopeHandler;
	}();
	function newParameterDeclarationScope() {
	  return new ExpressionScope(kParameterDeclaration);
	}
	function newArrowHeadScope() {
	  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
	}
	function newAsyncArrowScope() {
	  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
	}
	function newExpressionScope() {
	  return new ExpressionScope();
	}

	var PARAM = 0,
	    PARAM_YIELD = 1,
	    PARAM_AWAIT = 2,
	    PARAM_RETURN = 4,
	    PARAM_IN = 8;

	var ProductionParameterHandler = function () {
	  function ProductionParameterHandler() {
	    this.stacks = [];
	  }

	  var _proto = ProductionParameterHandler.prototype;

	  _proto.enter = function enter(flags) {
	    this.stacks.push(flags);
	  };

	  _proto.exit = function exit() {
	    this.stacks.pop();
	  };

	  _proto.currentFlags = function currentFlags() {
	    return this.stacks[this.stacks.length - 1];
	  };

	  _createClass(ProductionParameterHandler, [{
	    key: "hasAwait",
	    get: function get() {
	      return (this.currentFlags() & PARAM_AWAIT) > 0;
	    }
	  }, {
	    key: "hasYield",
	    get: function get() {
	      return (this.currentFlags() & PARAM_YIELD) > 0;
	    }
	  }, {
	    key: "hasReturn",
	    get: function get() {
	      return (this.currentFlags() & PARAM_RETURN) > 0;
	    }
	  }, {
	    key: "hasIn",
	    get: function get() {
	      return (this.currentFlags() & PARAM_IN) > 0;
	    }
	  }]);

	  return ProductionParameterHandler;
	}();
	function functionFlags(isAsync, isGenerator) {
	  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
	}

	var UtilParser = function (_Tokenizer) {
	  _inherits(UtilParser, _Tokenizer);

	  function UtilParser() {
	    return _Tokenizer.apply(this, arguments) || this;
	  }

	  var _proto = UtilParser.prototype;

	  _proto.addExtra = function addExtra(node, key, val) {
	    if (!node) return;
	    var extra = node.extra = node.extra || {};
	    extra[key] = val;
	  };

	  _proto.isContextual = function isContextual(token) {
	    return this.state.type === token && !this.state.containsEsc;
	  };

	  _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
	    var nameEnd = nameStart + name.length;

	    if (this.input.slice(nameStart, nameEnd) === name) {
	      var nextCh = this.input.charCodeAt(nameEnd);
	      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
	    }

	    return false;
	  };

	  _proto.isLookaheadContextual = function isLookaheadContextual(name) {
	    var next = this.nextTokenStart();
	    return this.isUnparsedContextual(next, name);
	  };

	  _proto.eatContextual = function eatContextual(token) {
	    if (this.isContextual(token)) {
	      this.next();
	      return true;
	    }

	    return false;
	  };

	  _proto.expectContextual = function expectContextual(token, template) {
	    if (!this.eatContextual(token)) this.unexpected(null, template);
	  };

	  _proto.canInsertSemicolon = function canInsertSemicolon() {
	    return this.match(131) || this.match(8) || this.hasPrecedingLineBreak();
	  };

	  _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
	    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
	  };

	  _proto.hasFollowingLineBreak = function hasFollowingLineBreak() {
	    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
	    return skipWhiteSpaceToLineBreak.test(this.input);
	  };

	  _proto.isLineTerminator = function isLineTerminator() {
	    return this.eat(13) || this.canInsertSemicolon();
	  };

	  _proto.semicolon = function semicolon(allowAsi) {
	    if (allowAsi === void 0) {
	      allowAsi = true;
	    }

	    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
	    this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
	  };

	  _proto.expect = function expect(type, pos) {
	    this.eat(type) || this.unexpected(pos, type);
	  };

	  _proto.assertNoSpace = function assertNoSpace(message) {
	    if (message === void 0) {
	      message = "Unexpected space.";
	    }

	    if (this.state.start > this.state.lastTokEnd) {
	      this.raise(this.state.lastTokEnd, {
	        code: ErrorCodes.SyntaxError,
	        reasonCode: "UnexpectedSpace",
	        template: message
	      });
	    }
	  };

	  _proto.unexpected = function unexpected(pos, messageOrType) {
	    if (messageOrType === void 0) {
	      messageOrType = {
	        code: ErrorCodes.SyntaxError,
	        reasonCode: "UnexpectedToken",
	        template: "Unexpected token"
	      };
	    }

	    if (isTokenType(messageOrType)) {
	      messageOrType = {
	        code: ErrorCodes.SyntaxError,
	        reasonCode: "UnexpectedToken",
	        template: "Unexpected token, expected \"" + tokenLabelName(messageOrType) + "\""
	      };
	    }

	    throw this.raise(pos != null ? pos : this.state.start, messageOrType);
	  };

	  _proto.getPluginNamesFromConfigs = function getPluginNamesFromConfigs(pluginConfigs) {
	    return pluginConfigs.map(function (c) {
	      if (typeof c === "string") {
	        return c;
	      } else {
	        return c[0];
	      }
	    });
	  };

	  _proto.expectPlugin = function expectPlugin(pluginConfig, pos) {
	    if (!this.hasPlugin(pluginConfig)) {
	      throw this.raiseWithData(pos != null ? pos : this.state.start, {
	        missingPlugin: this.getPluginNamesFromConfigs([pluginConfig])
	      }, "This experimental syntax requires enabling the parser plugin: " + JSON.stringify(pluginConfig) + ".");
	    }

	    return true;
	  };

	  _proto.expectOnePlugin = function expectOnePlugin(pluginConfigs, pos) {
	    var _this = this;

	    if (!pluginConfigs.some(function (c) {
	      return _this.hasPlugin(c);
	    })) {
	      throw this.raiseWithData(pos != null ? pos : this.state.start, {
	        missingPlugin: this.getPluginNamesFromConfigs(pluginConfigs)
	      }, "This experimental syntax requires enabling one of the following parser plugin(s): " + pluginConfigs.map(function (c) {
	        return JSON.stringify(c);
	      }).join(", ") + ".");
	    }
	  };

	  _proto.tryParse = function tryParse(fn, oldState) {
	    if (oldState === void 0) {
	      oldState = this.state.clone();
	    }

	    var abortSignal = {
	      node: null
	    };

	    try {
	      var _node = fn(function (node) {
	        if (node === void 0) {
	          node = null;
	        }

	        abortSignal.node = node;
	        throw abortSignal;
	      });

	      if (this.state.errors.length > oldState.errors.length) {
	        var failState = this.state;
	        this.state = oldState;
	        this.state.tokensLength = failState.tokensLength;
	        return {
	          node: _node,
	          error: failState.errors[oldState.errors.length],
	          thrown: false,
	          aborted: false,
	          failState: failState
	        };
	      }

	      return {
	        node: _node,
	        error: null,
	        thrown: false,
	        aborted: false,
	        failState: null
	      };
	    } catch (error) {
	      var _failState = this.state;
	      this.state = oldState;

	      if (error instanceof SyntaxError) {
	        return {
	          node: null,
	          error: error,
	          thrown: true,
	          aborted: false,
	          failState: _failState
	        };
	      }

	      if (error === abortSignal) {
	        return {
	          node: abortSignal.node,
	          error: null,
	          thrown: false,
	          aborted: true,
	          failState: _failState
	        };
	      }

	      throw error;
	    }
	  };

	  _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
	    if (!refExpressionErrors) return false;
	    var shorthandAssign = refExpressionErrors.shorthandAssign,
	        doubleProto = refExpressionErrors.doubleProto,
	        optionalParameters = refExpressionErrors.optionalParameters;
	    var hasErrors = shorthandAssign + doubleProto + optionalParameters > -3;

	    if (!andThrow) {
	      return hasErrors;
	    } else if (hasErrors) {
	      if (shorthandAssign >= 0) {
	        this.raise(shorthandAssign, ErrorMessages.InvalidCoverInitializedName);
	      }

	      if (doubleProto >= 0) {
	        this.raise(doubleProto, ErrorMessages.DuplicateProto);
	      }

	      if (optionalParameters >= 0) {
	        this.unexpected(optionalParameters);
	      }
	    }
	  };

	  _proto.isLiteralPropertyName = function isLiteralPropertyName() {
	    return tokenIsLiteralPropertyName(this.state.type);
	  };

	  _proto.isPrivateName = function isPrivateName(node) {
	    return node.type === "PrivateName";
	  };

	  _proto.getPrivateNameSV = function getPrivateNameSV(node) {
	    return node.id.name;
	  };

	  _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
	    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
	  };

	  _proto.isOptionalChain = function isOptionalChain(node) {
	    return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
	  };

	  _proto.isObjectProperty = function isObjectProperty(node) {
	    return node.type === "ObjectProperty";
	  };

	  _proto.isObjectMethod = function isObjectMethod(node) {
	    return node.type === "ObjectMethod";
	  };

	  _proto.initializeScopes = function initializeScopes(inModule) {
	    var _this2 = this;

	    if (inModule === void 0) {
	      inModule = this.options.sourceType === "module";
	    }

	    var oldLabels = this.state.labels;
	    this.state.labels = [];
	    var oldExportedIdentifiers = this.exportedIdentifiers;
	    this.exportedIdentifiers = new Set();
	    var oldInModule = this.inModule;
	    this.inModule = inModule;
	    var oldScope = this.scope;
	    var ScopeHandler = this.getScopeHandler();
	    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
	    var oldProdParam = this.prodParam;
	    this.prodParam = new ProductionParameterHandler();
	    var oldClassScope = this.classScope;
	    this.classScope = new ClassScopeHandler(this.raise.bind(this));
	    var oldExpressionScope = this.expressionScope;
	    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
	    return function () {
	      _this2.state.labels = oldLabels;
	      _this2.exportedIdentifiers = oldExportedIdentifiers;
	      _this2.inModule = oldInModule;
	      _this2.scope = oldScope;
	      _this2.prodParam = oldProdParam;
	      _this2.classScope = oldClassScope;
	      _this2.expressionScope = oldExpressionScope;
	    };
	  };

	  _proto.enterInitialScopes = function enterInitialScopes() {
	    var paramFlags = PARAM;

	    if (this.inModule) {
	      paramFlags |= PARAM_AWAIT;
	    }

	    this.scope.enter(SCOPE_PROGRAM);
	    this.prodParam.enter(paramFlags);
	  };

	  return UtilParser;
	}(Tokenizer);
	var ExpressionErrors = function ExpressionErrors() {
	  this.shorthandAssign = -1;
	  this.doubleProto = -1;
	  this.optionalParameters = -1;
	};

	var Node$1 = function Node(parser, pos, loc) {
	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  this.loc = new SourceLocation(loc);
	  if (parser != null && parser.options.ranges) this.range = [pos, 0];
	  if (parser != null && parser.filename) this.loc.filename = parser.filename;
	};

	var NodePrototype = Node$1.prototype;
	{
	  NodePrototype.__clone = function () {
	    var newNode = new Node$1();
	    var keys = Object.keys(this);

	    for (var i = 0, length = keys.length; i < length; i++) {
	      var _key = keys[i];

	      if (_key !== "leadingComments" && _key !== "trailingComments" && _key !== "innerComments") {
	        newNode[_key] = this[_key];
	      }
	    }

	    return newNode;
	  };
	}

	function clonePlaceholder(node) {
	  return cloneIdentifier(node);
	}

	function cloneIdentifier(node) {
	  var type = node.type,
	      start = node.start,
	      end = node.end,
	      loc = node.loc,
	      range = node.range,
	      extra = node.extra,
	      name = node.name;
	  var cloned = Object.create(NodePrototype);
	  cloned.type = type;
	  cloned.start = start;
	  cloned.end = end;
	  cloned.loc = loc;
	  cloned.range = range;
	  cloned.extra = extra;
	  cloned.name = name;

	  if (type === "Placeholder") {
	    cloned.expectedNode = node.expectedNode;
	  }

	  return cloned;
	}
	function cloneStringLiteral(node) {
	  var type = node.type,
	      start = node.start,
	      end = node.end,
	      loc = node.loc,
	      range = node.range,
	      extra = node.extra;

	  if (type === "Placeholder") {
	    return clonePlaceholder(node);
	  }

	  var cloned = Object.create(NodePrototype);
	  cloned.type = type;
	  cloned.start = start;
	  cloned.end = end;
	  cloned.loc = loc;
	  cloned.range = range;

	  if (node.raw !== undefined) {
	    cloned.raw = node.raw;
	  } else {
	    cloned.extra = extra;
	  }

	  cloned.value = node.value;
	  return cloned;
	}
	var NodeUtils = function (_UtilParser) {
	  _inherits(NodeUtils, _UtilParser);

	  function NodeUtils() {
	    return _UtilParser.apply(this, arguments) || this;
	  }

	  var _proto = NodeUtils.prototype;

	  _proto.startNode = function startNode() {
	    return new Node$1(this, this.state.start, this.state.startLoc);
	  };

	  _proto.startNodeAt = function startNodeAt(pos, loc) {
	    return new Node$1(this, pos, loc);
	  };

	  _proto.startNodeAtNode = function startNodeAtNode(type) {
	    return this.startNodeAt(type.start, type.loc.start);
	  };

	  _proto.finishNode = function finishNode(node, type) {
	    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
	  };

	  _proto.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
	    if (node.end > 0) {
	      throw new Error("Do not call finishNode*() twice on the same node." + " Instead use resetEndLocation() or change type directly.");
	    }

	    node.type = type;
	    node.end = pos;
	    node.loc.end = loc;
	    if (this.options.ranges) node.range[1] = pos;
	    if (this.options.attachComment) this.processComment(node);
	    return node;
	  };

	  _proto.resetStartLocation = function resetStartLocation(node, start, startLoc) {
	    node.start = start;
	    node.loc.start = startLoc;
	    if (this.options.ranges) node.range[0] = start;
	  };

	  _proto.resetEndLocation = function resetEndLocation(node, end, endLoc) {
	    if (end === void 0) {
	      end = this.state.lastTokEnd;
	    }

	    if (endLoc === void 0) {
	      endLoc = this.state.lastTokEndLoc;
	    }

	    node.end = end;
	    node.loc.end = endLoc;
	    if (this.options.ranges) node.range[1] = end;
	  };

	  _proto.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
	    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
	  };

	  return NodeUtils;
	}(UtilParser);

	var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
	var FlowErrors = makeErrorTemplates({
	  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
	  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
	  AssignReservedType: "Cannot overwrite reserved type %0.",
	  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
	  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
	  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
	  EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
	  EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
	  EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
	  EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
	  EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
	  EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
	  EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
	  EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
	  EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
	  EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
	  EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
	  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
	  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
	  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
	  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
	  InexactVariance: "Explicit inexact syntax cannot have variance.",
	  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
	  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
	  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
	  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
	  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
	  SpreadVariance: "Spread properties cannot have variance.",
	  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
	  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
	  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
	  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
	  ThisParamNoDefault: "The `this` parameter may not have a default value.",
	  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
	  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
	  UnexpectedReservedType: "Unexpected reserved type %0.",
	  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
	  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
	  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
	  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
	  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
	  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
	  UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
	  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
	  UnterminatedFlowComment: "Unterminated flow-comment."
	}, ErrorCodes.SyntaxError, "flow");

	function isEsModuleType(bodyElement) {
	  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
	}

	function hasTypeImportKind(node) {
	  return node.importKind === "type" || node.importKind === "typeof";
	}

	function isMaybeDefaultImport(type) {
	  return tokenIsKeywordOrIdentifier(type) && type !== 93;
	}

	var exportSuggestions = {
	  "const": "declare export var",
	  "let": "declare export var",
	  type: "export type",
	  "interface": "export interface"
	};

	function partition(list, test) {
	  var list1 = [];
	  var list2 = [];

	  for (var i = 0; i < list.length; i++) {
	    (test(list[i], i, list) ? list1 : list2).push(list[i]);
	  }

	  return [list1, list2];
	}

	var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
	var flow = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class2, _superClass);

	    function _class2() {
	      var _this2;

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      _this2 = _superClass.call.apply(_superClass, [this].concat(args)) || this;
	      _this2.flowPragma = undefined;
	      return _this2;
	    }

	    var _proto = _class2.prototype;

	    _proto.getScopeHandler = function getScopeHandler() {
	      return FlowScopeHandler;
	    };

	    _proto.shouldParseTypes = function shouldParseTypes() {
	      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
	    };

	    _proto.shouldParseEnums = function shouldParseEnums() {
	      return !!this.getPluginOption("flow", "enums");
	    };

	    _proto.finishToken = function finishToken(type, val) {
	      if (type !== 125 && type !== 13 && type !== 28) {
	        if (this.flowPragma === undefined) {
	          this.flowPragma = null;
	        }
	      }

	      return _superClass.prototype.finishToken.call(this, type, val);
	    };

	    _proto.addComment = function addComment(comment) {
	      if (this.flowPragma === undefined) {
	        var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

	        if (!matches) ; else if (matches[1] === "flow") {
	          this.flowPragma = "flow";
	        } else if (matches[1] === "noflow") {
	          this.flowPragma = "noflow";
	        } else {
	          throw new Error("Unexpected flow pragma");
	        }
	      }

	      return _superClass.prototype.addComment.call(this, comment);
	    };

	    _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      this.expect(tok || 14);
	      var type = this.flowParseType();
	      this.state.inType = oldInType;
	      return type;
	    };

	    _proto.flowParsePredicate = function flowParsePredicate() {
	      var node = this.startNode();
	      var moduloPos = this.state.start;
	      this.next();
	      this.expectContextual(103);

	      if (this.state.lastTokStart > moduloPos + 1) {
	        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
	      }

	      if (this.eat(10)) {
	        node.value = this.parseExpression();
	        this.expect(11);
	        return this.finishNode(node, "DeclaredPredicate");
	      } else {
	        return this.finishNode(node, "InferredPredicate");
	      }
	    };

	    _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      this.expect(14);
	      var type = null;
	      var predicate = null;

	      if (this.match(50)) {
	        this.state.inType = oldInType;
	        predicate = this.flowParsePredicate();
	      } else {
	        type = this.flowParseType();
	        this.state.inType = oldInType;

	        if (this.match(50)) {
	          predicate = this.flowParsePredicate();
	        }
	      }

	      return [type, predicate];
	    };

	    _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
	      this.next();
	      this.flowParseInterfaceish(node, true);
	      return this.finishNode(node, "DeclareClass");
	    };

	    _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
	      this.next();
	      var id = node.id = this.parseIdentifier();
	      var typeNode = this.startNode();
	      var typeContainer = this.startNode();

	      if (this.match(45)) {
	        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        typeNode.typeParameters = null;
	      }

	      this.expect(10);
	      var tmp = this.flowParseFunctionTypeParams();
	      typeNode.params = tmp.params;
	      typeNode.rest = tmp.rest;
	      typeNode["this"] = tmp._this;
	      this.expect(11);

	      var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

	      typeNode.returnType = _this$flowParseTypeAn[0];
	      node.predicate = _this$flowParseTypeAn[1];
	      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
	      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
	      this.resetEndLocation(id);
	      this.semicolon();
	      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
	      return this.finishNode(node, "DeclareFunction");
	    };

	    _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
	      if (this.match(76)) {
	        return this.flowParseDeclareClass(node);
	      } else if (this.match(64)) {
	        return this.flowParseDeclareFunction(node);
	      } else if (this.match(70)) {
	        return this.flowParseDeclareVariable(node);
	      } else if (this.eatContextual(119)) {
	        if (this.match(16)) {
	          return this.flowParseDeclareModuleExports(node);
	        } else {
	          if (insideModule) {
	            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
	          }

	          return this.flowParseDeclareModule(node);
	        }
	      } else if (this.isContextual(122)) {
	        return this.flowParseDeclareTypeAlias(node);
	      } else if (this.isContextual(123)) {
	        return this.flowParseDeclareOpaqueType(node);
	      } else if (this.isContextual(121)) {
	        return this.flowParseDeclareInterface(node);
	      } else if (this.match(78)) {
	        return this.flowParseDeclareExportDeclaration(node, insideModule);
	      } else {
	        throw this.unexpected();
	      }
	    };

	    _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
	      this.next();
	      node.id = this.flowParseTypeAnnotatableIdentifier(true);
	      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
	      this.semicolon();
	      return this.finishNode(node, "DeclareVariable");
	    };

	    _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
	      var _this3 = this;

	      this.scope.enter(SCOPE_OTHER);

	      if (this.match(125)) {
	        node.id = this.parseExprAtom();
	      } else {
	        node.id = this.parseIdentifier();
	      }

	      var bodyNode = node.body = this.startNode();
	      var body = bodyNode.body = [];
	      this.expect(5);

	      while (!this.match(8)) {
	        var _bodyNode = this.startNode();

	        if (this.match(79)) {
	          this.next();

	          if (!this.isContextual(122) && !this.match(83)) {
	            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
	          }

	          this.parseImport(_bodyNode);
	        } else {
	          this.expectContextual(117, FlowErrors.UnsupportedStatementInDeclareModule);
	          _bodyNode = this.flowParseDeclare(_bodyNode, true);
	        }

	        body.push(_bodyNode);
	      }

	      this.scope.exit();
	      this.expect(8);
	      this.finishNode(bodyNode, "BlockStatement");
	      var kind = null;
	      var hasModuleExport = false;
	      body.forEach(function (bodyElement) {
	        if (isEsModuleType(bodyElement)) {
	          if (kind === "CommonJS") {
	            _this3.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
	          }

	          kind = "ES";
	        } else if (bodyElement.type === "DeclareModuleExports") {
	          if (hasModuleExport) {
	            _this3.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
	          }

	          if (kind === "ES") {
	            _this3.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
	          }

	          kind = "CommonJS";
	          hasModuleExport = true;
	        }
	      });
	      node.kind = kind || "CommonJS";
	      return this.finishNode(node, "DeclareModule");
	    };

	    _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
	      this.expect(78);

	      if (this.eat(61)) {
	        if (this.match(64) || this.match(76)) {
	          node.declaration = this.flowParseDeclare(this.startNode());
	        } else {
	          node.declaration = this.flowParseType();
	          this.semicolon();
	        }

	        node["default"] = true;
	        return this.finishNode(node, "DeclareExportDeclaration");
	      } else {
	        if (this.match(71) || this.isLet() || (this.isContextual(122) || this.isContextual(121)) && !insideModule) {
	          var label = this.state.value;
	          var suggestion = exportSuggestions[label];
	          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
	        }

	        if (this.match(70) || this.match(64) || this.match(76) || this.isContextual(123)) {
	          node.declaration = this.flowParseDeclare(this.startNode());
	          node["default"] = false;
	          return this.finishNode(node, "DeclareExportDeclaration");
	        } else if (this.match(51) || this.match(5) || this.isContextual(121) || this.isContextual(122) || this.isContextual(123)) {
	          node = this.parseExport(node);

	          if (node.type === "ExportNamedDeclaration") {
	            node.type = "ExportDeclaration";
	            node["default"] = false;
	            delete node.exportKind;
	          }

	          node.type = "Declare" + node.type;
	          return node;
	        }
	      }

	      throw this.unexpected();
	    };

	    _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
	      this.next();
	      this.expectContextual(104);
	      node.typeAnnotation = this.flowParseTypeAnnotation();
	      this.semicolon();
	      return this.finishNode(node, "DeclareModuleExports");
	    };

	    _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
	      this.next();
	      this.flowParseTypeAlias(node);
	      node.type = "DeclareTypeAlias";
	      return node;
	    };

	    _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
	      this.next();
	      this.flowParseOpaqueType(node, true);
	      node.type = "DeclareOpaqueType";
	      return node;
	    };

	    _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
	      this.next();
	      this.flowParseInterfaceish(node);
	      return this.finishNode(node, "DeclareInterface");
	    };

	    _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
	      if (isClass === void 0) {
	        isClass = false;
	      }

	      node.id = this.flowParseRestrictedIdentifier(!isClass, true);
	      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node["extends"] = [];
	      node["implements"] = [];
	      node.mixins = [];

	      if (this.eat(77)) {
	        do {
	          node["extends"].push(this.flowParseInterfaceExtends());
	        } while (!isClass && this.eat(12));
	      }

	      if (this.isContextual(110)) {
	        this.next();

	        do {
	          node.mixins.push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }

	      if (this.isContextual(106)) {
	        this.next();

	        do {
	          node["implements"].push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }

	      node.body = this.flowParseObjectType({
	        allowStatic: isClass,
	        allowExact: false,
	        allowSpread: false,
	        allowProto: isClass,
	        allowInexact: false
	      });
	    };

	    _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
	      var node = this.startNode();
	      node.id = this.flowParseQualifiedTypeIdentifier();

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterInstantiation();
	      } else {
	        node.typeParameters = null;
	      }

	      return this.finishNode(node, "InterfaceExtends");
	    };

	    _proto.flowParseInterface = function flowParseInterface(node) {
	      this.flowParseInterfaceish(node);
	      return this.finishNode(node, "InterfaceDeclaration");
	    };

	    _proto.checkNotUnderscore = function checkNotUnderscore(word) {
	      if (word === "_") {
	        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
	      }
	    };

	    _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
	      if (!reservedTypes.has(word)) return;
	      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
	    };

	    _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
	      this.checkReservedType(this.state.value, this.state.start, declaration);
	      return this.parseIdentifier(liberal);
	    };

	    _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
	      node.id = this.flowParseRestrictedIdentifier(false, true);
	      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node.right = this.flowParseTypeInitialiser(29);
	      this.semicolon();
	      return this.finishNode(node, "TypeAlias");
	    };

	    _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
	      this.expectContextual(122);
	      node.id = this.flowParseRestrictedIdentifier(true, true);
	      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      } else {
	        node.typeParameters = null;
	      }

	      node.supertype = null;

	      if (this.match(14)) {
	        node.supertype = this.flowParseTypeInitialiser(14);
	      }

	      node.impltype = null;

	      if (!declare) {
	        node.impltype = this.flowParseTypeInitialiser(29);
	      }

	      this.semicolon();
	      return this.finishNode(node, "OpaqueType");
	    };

	    _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
	      if (requireDefault === void 0) {
	        requireDefault = false;
	      }

	      var nodeStart = this.state.start;
	      var node = this.startNode();
	      var variance = this.flowParseVariance();
	      var ident = this.flowParseTypeAnnotatableIdentifier();
	      node.name = ident.name;
	      node.variance = variance;
	      node.bound = ident.typeAnnotation;

	      if (this.match(29)) {
	        this.eat(29);
	        node["default"] = this.flowParseType();
	      } else {
	        if (requireDefault) {
	          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
	        }
	      }

	      return this.finishNode(node, "TypeParameter");
	    };

	    _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
	      var oldInType = this.state.inType;
	      var node = this.startNode();
	      node.params = [];
	      this.state.inType = true;

	      if (this.match(45) || this.match(134)) {
	        this.next();
	      } else {
	        this.unexpected();
	      }

	      var defaultRequired = false;

	      do {
	        var typeParameter = this.flowParseTypeParameter(defaultRequired);
	        node.params.push(typeParameter);

	        if (typeParameter["default"]) {
	          defaultRequired = true;
	        }

	        if (!this.match(46)) {
	          this.expect(12);
	        }
	      } while (!this.match(46));

	      this.expect(46);
	      this.state.inType = oldInType;
	      return this.finishNode(node, "TypeParameterDeclaration");
	    };

	    _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
	      var node = this.startNode();
	      var oldInType = this.state.inType;
	      node.params = [];
	      this.state.inType = true;
	      this.expect(45);
	      var oldNoAnonFunctionType = this.state.noAnonFunctionType;
	      this.state.noAnonFunctionType = false;

	      while (!this.match(46)) {
	        node.params.push(this.flowParseType());

	        if (!this.match(46)) {
	          this.expect(12);
	        }
	      }

	      this.state.noAnonFunctionType = oldNoAnonFunctionType;
	      this.expect(46);
	      this.state.inType = oldInType;
	      return this.finishNode(node, "TypeParameterInstantiation");
	    };

	    _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
	      var node = this.startNode();
	      var oldInType = this.state.inType;
	      node.params = [];
	      this.state.inType = true;
	      this.expect(45);

	      while (!this.match(46)) {
	        node.params.push(this.flowParseTypeOrImplicitInstantiation());

	        if (!this.match(46)) {
	          this.expect(12);
	        }
	      }

	      this.expect(46);
	      this.state.inType = oldInType;
	      return this.finishNode(node, "TypeParameterInstantiation");
	    };

	    _proto.flowParseInterfaceType = function flowParseInterfaceType() {
	      var node = this.startNode();
	      this.expectContextual(121);
	      node["extends"] = [];

	      if (this.eat(77)) {
	        do {
	          node["extends"].push(this.flowParseInterfaceExtends());
	        } while (this.eat(12));
	      }

	      node.body = this.flowParseObjectType({
	        allowStatic: false,
	        allowExact: false,
	        allowSpread: false,
	        allowProto: false,
	        allowInexact: false
	      });
	      return this.finishNode(node, "InterfaceTypeAnnotation");
	    };

	    _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
	      return this.match(126) || this.match(125) ? this.parseExprAtom() : this.parseIdentifier(true);
	    };

	    _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
	      node["static"] = isStatic;

	      if (this.lookahead().type === 14) {
	        node.id = this.flowParseObjectPropertyKey();
	        node.key = this.flowParseTypeInitialiser();
	      } else {
	        node.id = null;
	        node.key = this.flowParseType();
	      }

	      this.expect(3);
	      node.value = this.flowParseTypeInitialiser();
	      node.variance = variance;
	      return this.finishNode(node, "ObjectTypeIndexer");
	    };

	    _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
	      node["static"] = isStatic;
	      node.id = this.flowParseObjectPropertyKey();
	      this.expect(3);
	      this.expect(3);

	      if (this.match(45) || this.match(10)) {
	        node.method = true;
	        node.optional = false;
	        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
	      } else {
	        node.method = false;

	        if (this.eat(17)) {
	          node.optional = true;
	        }

	        node.value = this.flowParseTypeInitialiser();
	      }

	      return this.finishNode(node, "ObjectTypeInternalSlot");
	    };

	    _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
	      node.params = [];
	      node.rest = null;
	      node.typeParameters = null;
	      node["this"] = null;

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      }

	      this.expect(10);

	      if (this.match(74)) {
	        node["this"] = this.flowParseFunctionTypeParam(true);
	        node["this"].name = null;

	        if (!this.match(11)) {
	          this.expect(12);
	        }
	      }

	      while (!this.match(11) && !this.match(21)) {
	        node.params.push(this.flowParseFunctionTypeParam(false));

	        if (!this.match(11)) {
	          this.expect(12);
	        }
	      }

	      if (this.eat(21)) {
	        node.rest = this.flowParseFunctionTypeParam(false);
	      }

	      this.expect(11);
	      node.returnType = this.flowParseTypeInitialiser();
	      return this.finishNode(node, "FunctionTypeAnnotation");
	    };

	    _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
	      var valueNode = this.startNode();
	      node["static"] = isStatic;
	      node.value = this.flowParseObjectTypeMethodish(valueNode);
	      return this.finishNode(node, "ObjectTypeCallProperty");
	    };

	    _proto.flowParseObjectType = function flowParseObjectType(_ref) {
	      var allowStatic = _ref.allowStatic,
	          allowExact = _ref.allowExact,
	          allowSpread = _ref.allowSpread,
	          allowProto = _ref.allowProto,
	          allowInexact = _ref.allowInexact;
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      var nodeStart = this.startNode();
	      nodeStart.callProperties = [];
	      nodeStart.properties = [];
	      nodeStart.indexers = [];
	      nodeStart.internalSlots = [];
	      var endDelim;
	      var exact;
	      var inexact = false;

	      if (allowExact && this.match(6)) {
	        this.expect(6);
	        endDelim = 9;
	        exact = true;
	      } else {
	        this.expect(5);
	        endDelim = 8;
	        exact = false;
	      }

	      nodeStart.exact = exact;

	      while (!this.match(endDelim)) {
	        var isStatic = false;
	        var protoStart = null;
	        var inexactStart = null;
	        var node = this.startNode();

	        if (allowProto && this.isContextual(111)) {
	          var lookahead = this.lookahead();

	          if (lookahead.type !== 14 && lookahead.type !== 17) {
	            this.next();
	            protoStart = this.state.start;
	            allowStatic = false;
	          }
	        }

	        if (allowStatic && this.isContextual(100)) {
	          var _lookahead = this.lookahead();

	          if (_lookahead.type !== 14 && _lookahead.type !== 17) {
	            this.next();
	            isStatic = true;
	          }
	        }

	        var variance = this.flowParseVariance();

	        if (this.eat(0)) {
	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (this.eat(0)) {
	            if (variance) {
	              this.unexpected(variance.start);
	            }

	            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
	          } else {
	            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
	          }
	        } else if (this.match(10) || this.match(45)) {
	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (variance) {
	            this.unexpected(variance.start);
	          }

	          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
	        } else {
	          var kind = "init";

	          if (this.isContextual(94) || this.isContextual(99)) {
	            var _lookahead2 = this.lookahead();

	            if (tokenIsLiteralPropertyName(_lookahead2.type)) {
	              kind = this.state.value;
	              this.next();
	            }
	          }

	          var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

	          if (propOrInexact === null) {
	            inexact = true;
	            inexactStart = this.state.lastTokStart;
	          } else {
	            nodeStart.properties.push(propOrInexact);
	          }
	        }

	        this.flowObjectTypeSemicolon();

	        if (inexactStart && !this.match(8) && !this.match(9)) {
	          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
	        }
	      }

	      this.expect(endDelim);

	      if (allowSpread) {
	        nodeStart.inexact = inexact;
	      }

	      var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
	      this.state.inType = oldInType;
	      return out;
	    };

	    _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
	      if (this.eat(21)) {
	        var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);

	        if (isInexactToken) {
	          if (!allowSpread) {
	            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
	          } else if (!allowInexact) {
	            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
	          }

	          if (variance) {
	            this.raise(variance.start, FlowErrors.InexactVariance);
	          }

	          return null;
	        }

	        if (!allowSpread) {
	          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
	        }

	        if (protoStart != null) {
	          this.unexpected(protoStart);
	        }

	        if (variance) {
	          this.raise(variance.start, FlowErrors.SpreadVariance);
	        }

	        node.argument = this.flowParseType();
	        return this.finishNode(node, "ObjectTypeSpreadProperty");
	      } else {
	        node.key = this.flowParseObjectPropertyKey();
	        node["static"] = isStatic;
	        node.proto = protoStart != null;
	        node.kind = kind;
	        var optional = false;

	        if (this.match(45) || this.match(10)) {
	          node.method = true;

	          if (protoStart != null) {
	            this.unexpected(protoStart);
	          }

	          if (variance) {
	            this.unexpected(variance.start);
	          }

	          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

	          if (kind === "get" || kind === "set") {
	            this.flowCheckGetterSetterParams(node);
	          }

	          if (!allowSpread && node.key.name === "constructor" && node.value["this"]) {
	            this.raise(node.value["this"].start, FlowErrors.ThisParamBannedInConstructor);
	          }
	        } else {
	          if (kind !== "init") this.unexpected();
	          node.method = false;

	          if (this.eat(17)) {
	            optional = true;
	          }

	          node.value = this.flowParseTypeInitialiser();
	          node.variance = variance;
	        }

	        node.optional = optional;
	        return this.finishNode(node, "ObjectTypeProperty");
	      }
	    };

	    _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
	      var paramCount = property.kind === "get" ? 0 : 1;
	      var start = property.start;
	      var length = property.value.params.length + (property.value.rest ? 1 : 0);

	      if (property.value["this"]) {
	        this.raise(property.value["this"].start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
	      }

	      if (length !== paramCount) {
	        if (property.kind === "get") {
	          this.raise(start, ErrorMessages.BadGetterArity);
	        } else {
	          this.raise(start, ErrorMessages.BadSetterArity);
	        }
	      }

	      if (property.kind === "set" && property.value.rest) {
	        this.raise(start, ErrorMessages.BadSetterRestParameter);
	      }
	    };

	    _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
	      if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
	        this.unexpected();
	      }
	    };

	    _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
	      startPos = startPos || this.state.start;
	      startLoc = startLoc || this.state.startLoc;
	      var node = id || this.flowParseRestrictedIdentifier(true);

	      while (this.eat(16)) {
	        var node2 = this.startNodeAt(startPos, startLoc);
	        node2.qualification = node;
	        node2.id = this.flowParseRestrictedIdentifier(true);
	        node = this.finishNode(node2, "QualifiedTypeIdentifier");
	      }

	      return node;
	    };

	    _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.typeParameters = null;
	      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterInstantiation();
	      }

	      return this.finishNode(node, "GenericTypeAnnotation");
	    };

	    _proto.flowParseTypeofType = function flowParseTypeofType() {
	      var node = this.startNode();
	      this.expect(83);
	      node.argument = this.flowParsePrimaryType();
	      return this.finishNode(node, "TypeofTypeAnnotation");
	    };

	    _proto.flowParseTupleType = function flowParseTupleType() {
	      var node = this.startNode();
	      node.types = [];
	      this.expect(0);

	      while (this.state.pos < this.length && !this.match(3)) {
	        node.types.push(this.flowParseType());
	        if (this.match(3)) break;
	        this.expect(12);
	      }

	      this.expect(3);
	      return this.finishNode(node, "TupleTypeAnnotation");
	    };

	    _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam(first) {
	      var name = null;
	      var optional = false;
	      var typeAnnotation = null;
	      var node = this.startNode();
	      var lh = this.lookahead();
	      var isThis = this.state.type === 74;

	      if (lh.type === 14 || lh.type === 17) {
	        if (isThis && !first) {
	          this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
	        }

	        name = this.parseIdentifier(isThis);

	        if (this.eat(17)) {
	          optional = true;

	          if (isThis) {
	            this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
	          }
	        }

	        typeAnnotation = this.flowParseTypeInitialiser();
	      } else {
	        typeAnnotation = this.flowParseType();
	      }

	      node.name = name;
	      node.optional = optional;
	      node.typeAnnotation = typeAnnotation;
	      return this.finishNode(node, "FunctionTypeParam");
	    };

	    _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
	      var node = this.startNodeAt(type.start, type.loc.start);
	      node.name = null;
	      node.optional = false;
	      node.typeAnnotation = type;
	      return this.finishNode(node, "FunctionTypeParam");
	    };

	    _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
	      if (params === void 0) {
	        params = [];
	      }

	      var rest = null;
	      var _this = null;

	      if (this.match(74)) {
	        _this = this.flowParseFunctionTypeParam(true);
	        _this.name = null;

	        if (!this.match(11)) {
	          this.expect(12);
	        }
	      }

	      while (!this.match(11) && !this.match(21)) {
	        params.push(this.flowParseFunctionTypeParam(false));

	        if (!this.match(11)) {
	          this.expect(12);
	        }
	      }

	      if (this.eat(21)) {
	        rest = this.flowParseFunctionTypeParam(false);
	      }

	      return {
	        params: params,
	        rest: rest,
	        _this: _this
	      };
	    };

	    _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
	      switch (id.name) {
	        case "any":
	          return this.finishNode(node, "AnyTypeAnnotation");

	        case "bool":
	        case "boolean":
	          return this.finishNode(node, "BooleanTypeAnnotation");

	        case "mixed":
	          return this.finishNode(node, "MixedTypeAnnotation");

	        case "empty":
	          return this.finishNode(node, "EmptyTypeAnnotation");

	        case "number":
	          return this.finishNode(node, "NumberTypeAnnotation");

	        case "string":
	          return this.finishNode(node, "StringTypeAnnotation");

	        case "symbol":
	          return this.finishNode(node, "SymbolTypeAnnotation");

	        default:
	          this.checkNotUnderscore(id.name);
	          return this.flowParseGenericType(startPos, startLoc, id);
	      }
	    };

	    _proto.flowParsePrimaryType = function flowParsePrimaryType() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var node = this.startNode();
	      var tmp;
	      var type;
	      var isGroupedType = false;
	      var oldNoAnonFunctionType = this.state.noAnonFunctionType;

	      switch (this.state.type) {
	        case 5:
	          return this.flowParseObjectType({
	            allowStatic: false,
	            allowExact: false,
	            allowSpread: true,
	            allowProto: false,
	            allowInexact: true
	          });

	        case 6:
	          return this.flowParseObjectType({
	            allowStatic: false,
	            allowExact: true,
	            allowSpread: true,
	            allowProto: false,
	            allowInexact: false
	          });

	        case 0:
	          this.state.noAnonFunctionType = false;
	          type = this.flowParseTupleType();
	          this.state.noAnonFunctionType = oldNoAnonFunctionType;
	          return type;

	        case 45:
	          node.typeParameters = this.flowParseTypeParameterDeclaration();
	          this.expect(10);
	          tmp = this.flowParseFunctionTypeParams();
	          node.params = tmp.params;
	          node.rest = tmp.rest;
	          node["this"] = tmp._this;
	          this.expect(11);
	          this.expect(19);
	          node.returnType = this.flowParseType();
	          return this.finishNode(node, "FunctionTypeAnnotation");

	        case 10:
	          this.next();

	          if (!this.match(11) && !this.match(21)) {
	            if (tokenIsIdentifier(this.state.type) || this.match(74)) {
	              var token = this.lookahead().type;
	              isGroupedType = token !== 17 && token !== 14;
	            } else {
	              isGroupedType = true;
	            }
	          }

	          if (isGroupedType) {
	            this.state.noAnonFunctionType = false;
	            type = this.flowParseType();
	            this.state.noAnonFunctionType = oldNoAnonFunctionType;

	            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
	              this.expect(11);
	              return type;
	            } else {
	              this.eat(12);
	            }
	          }

	          if (type) {
	            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
	          } else {
	            tmp = this.flowParseFunctionTypeParams();
	          }

	          node.params = tmp.params;
	          node.rest = tmp.rest;
	          node["this"] = tmp._this;
	          this.expect(11);
	          this.expect(19);
	          node.returnType = this.flowParseType();
	          node.typeParameters = null;
	          return this.finishNode(node, "FunctionTypeAnnotation");

	        case 125:
	          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

	        case 81:
	        case 82:
	          node.value = this.match(81);
	          this.next();
	          return this.finishNode(node, "BooleanLiteralTypeAnnotation");

	        case 49:
	          if (this.state.value === "-") {
	            this.next();

	            if (this.match(126)) {
	              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
	            }

	            if (this.match(127)) {
	              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
	            }

	            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
	          }

	          throw this.unexpected();

	        case 126:
	          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

	        case 127:
	          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

	        case 84:
	          this.next();
	          return this.finishNode(node, "VoidTypeAnnotation");

	        case 80:
	          this.next();
	          return this.finishNode(node, "NullLiteralTypeAnnotation");

	        case 74:
	          this.next();
	          return this.finishNode(node, "ThisTypeAnnotation");

	        case 51:
	          this.next();
	          return this.finishNode(node, "ExistsTypeAnnotation");

	        case 83:
	          return this.flowParseTypeofType();

	        default:
	          if (tokenIsKeyword(this.state.type)) {
	            var label = tokenLabelName(this.state.type);
	            this.next();
	            return _superClass.prototype.createIdentifier.call(this, node, label);
	          } else if (tokenIsIdentifier(this.state.type)) {
	            if (this.isContextual(121)) {
	              return this.flowParseInterfaceType();
	            }

	            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
	          }

	      }

	      throw this.unexpected();
	    };

	    _proto.flowParsePostfixType = function flowParsePostfixType() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var type = this.flowParsePrimaryType();
	      var seenOptionalIndexedAccess = false;

	      while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
	        var node = this.startNodeAt(startPos, startLoc);
	        var optional = this.eat(18);
	        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
	        this.expect(0);

	        if (!optional && this.match(3)) {
	          node.elementType = type;
	          this.next();
	          type = this.finishNode(node, "ArrayTypeAnnotation");
	        } else {
	          node.objectType = type;
	          node.indexType = this.flowParseType();
	          this.expect(3);

	          if (seenOptionalIndexedAccess) {
	            node.optional = optional;
	            type = this.finishNode(node, "OptionalIndexedAccessType");
	          } else {
	            type = this.finishNode(node, "IndexedAccessType");
	          }
	        }
	      }

	      return type;
	    };

	    _proto.flowParsePrefixType = function flowParsePrefixType() {
	      var node = this.startNode();

	      if (this.eat(17)) {
	        node.typeAnnotation = this.flowParsePrefixType();
	        return this.finishNode(node, "NullableTypeAnnotation");
	      } else {
	        return this.flowParsePostfixType();
	      }
	    };

	    _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
	      var param = this.flowParsePrefixType();

	      if (!this.state.noAnonFunctionType && this.eat(19)) {
	        var node = this.startNodeAt(param.start, param.loc.start);
	        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
	        node.rest = null;
	        node["this"] = null;
	        node.returnType = this.flowParseType();
	        node.typeParameters = null;
	        return this.finishNode(node, "FunctionTypeAnnotation");
	      }

	      return param;
	    };

	    _proto.flowParseIntersectionType = function flowParseIntersectionType() {
	      var node = this.startNode();
	      this.eat(43);
	      var type = this.flowParseAnonFunctionWithoutParens();
	      node.types = [type];

	      while (this.eat(43)) {
	        node.types.push(this.flowParseAnonFunctionWithoutParens());
	      }

	      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
	    };

	    _proto.flowParseUnionType = function flowParseUnionType() {
	      var node = this.startNode();
	      this.eat(41);
	      var type = this.flowParseIntersectionType();
	      node.types = [type];

	      while (this.eat(41)) {
	        node.types.push(this.flowParseIntersectionType());
	      }

	      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
	    };

	    _proto.flowParseType = function flowParseType() {
	      var oldInType = this.state.inType;
	      this.state.inType = true;
	      var type = this.flowParseUnionType();
	      this.state.inType = oldInType;
	      return type;
	    };

	    _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
	      if (this.state.type === 124 && this.state.value === "_") {
	        var startPos = this.state.start;
	        var startLoc = this.state.startLoc;
	        var node = this.parseIdentifier();
	        return this.flowParseGenericType(startPos, startLoc, node);
	      } else {
	        return this.flowParseType();
	      }
	    };

	    _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
	      var node = this.startNode();
	      node.typeAnnotation = this.flowParseTypeInitialiser();
	      return this.finishNode(node, "TypeAnnotation");
	    };

	    _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
	      var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

	      if (this.match(14)) {
	        ident.typeAnnotation = this.flowParseTypeAnnotation();
	        this.resetEndLocation(ident);
	      }

	      return ident;
	    };

	    _proto.typeCastToParameter = function typeCastToParameter(node) {
	      node.expression.typeAnnotation = node.typeAnnotation;
	      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
	      return node.expression;
	    };

	    _proto.flowParseVariance = function flowParseVariance() {
	      var variance = null;

	      if (this.match(49)) {
	        variance = this.startNode();

	        if (this.state.value === "+") {
	          variance.kind = "plus";
	        } else {
	          variance.kind = "minus";
	        }

	        this.next();
	        this.finishNode(variance, "Variance");
	      }

	      return variance;
	    };

	    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
	      var _this4 = this;

	      if (isMethod === void 0) {
	        isMethod = false;
	      }

	      if (allowExpressionBody) {
	        return this.forwardNoArrowParamsConversionAt(node, function () {
	          return _superClass.prototype.parseFunctionBody.call(_this4, node, true, isMethod);
	        });
	      }

	      return _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
	    };

	    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
	      if (isMethod === void 0) {
	        isMethod = false;
	      }

	      if (this.match(14)) {
	        var typeNode = this.startNode();

	        var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

	        typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
	        node.predicate = _this$flowParseTypeAn2[1];
	        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
	      }

	      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
	    };

	    _proto.parseStatement = function parseStatement(context, topLevel) {
	      if (this.state.strict && this.isContextual(121)) {
	        var lookahead = this.lookahead();

	        if (tokenIsKeywordOrIdentifier(lookahead.type)) {
	          var node = this.startNode();
	          this.next();
	          return this.flowParseInterface(node);
	        }
	      } else if (this.shouldParseEnums() && this.isContextual(118)) {
	        var _node = this.startNode();

	        this.next();
	        return this.flowParseEnumDeclaration(_node);
	      }

	      var stmt = _superClass.prototype.parseStatement.call(this, context, topLevel);

	      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
	        this.flowPragma = null;
	      }

	      return stmt;
	    };

	    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	      if (expr.type === "Identifier") {
	        if (expr.name === "declare") {
	          if (this.match(76) || tokenIsIdentifier(this.state.type) || this.match(64) || this.match(70) || this.match(78)) {
	            return this.flowParseDeclare(node);
	          }
	        } else if (tokenIsIdentifier(this.state.type)) {
	          if (expr.name === "interface") {
	            return this.flowParseInterface(node);
	          } else if (expr.name === "type") {
	            return this.flowParseTypeAlias(node);
	          } else if (expr.name === "opaque") {
	            return this.flowParseOpaqueType(node, false);
	          }
	        }
	      }

	      return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
	    };

	    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	      var type = this.state.type;

	      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 118) {
	        return !this.state.containsEsc;
	      }

	      return _superClass.prototype.shouldParseExportDeclaration.call(this);
	    };

	    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	      var type = this.state.type;

	      if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 118) {
	        return this.state.containsEsc;
	      }

	      return _superClass.prototype.isExportDefaultSpecifier.call(this);
	    };

	    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
	      if (this.shouldParseEnums() && this.isContextual(118)) {
	        var node = this.startNode();
	        this.next();
	        return this.flowParseEnumDeclaration(node);
	      }

	      return _superClass.prototype.parseExportDefaultExpression.call(this);
	    };

	    _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
	      var _this5 = this;

	      if (!this.match(17)) return expr;

	      if (this.state.maybeInArrowParameters) {
	        var nextCh = this.lookaheadCharCode();

	        if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
	          this.setOptionalParametersError(refExpressionErrors);
	          return expr;
	        }
	      }

	      this.expect(17);
	      var state = this.state.clone();
	      var originalNoArrowAt = this.state.noArrowAt;
	      var node = this.startNodeAt(startPos, startLoc);

	      var _this$tryParseConditi = this.tryParseConditionalConsequent(),
	          consequent = _this$tryParseConditi.consequent,
	          failed = _this$tryParseConditi.failed;

	      var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
	          valid = _this$getArrowLikeExp[0],
	          invalid = _this$getArrowLikeExp[1];

	      if (failed || invalid.length > 0) {
	        var noArrowAt = [].concat(originalNoArrowAt);

	        if (invalid.length > 0) {
	          this.state = state;
	          this.state.noArrowAt = noArrowAt;

	          for (var i = 0; i < invalid.length; i++) {
	            noArrowAt.push(invalid[i].start);
	          }

	          var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

	          consequent = _this$tryParseConditi2.consequent;
	          failed = _this$tryParseConditi2.failed;

	          var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

	          valid = _this$getArrowLikeExp2[0];
	          invalid = _this$getArrowLikeExp2[1];
	        }

	        if (failed && valid.length > 1) {
	          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
	        }

	        if (failed && valid.length === 1) {
	          this.state = state;
	          noArrowAt.push(valid[0].start);
	          this.state.noArrowAt = noArrowAt;

	          var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

	          consequent = _this$tryParseConditi3.consequent;
	          failed = _this$tryParseConditi3.failed;
	        }
	      }

	      this.getArrowLikeExpressions(consequent, true);
	      this.state.noArrowAt = originalNoArrowAt;
	      this.expect(14);
	      node.test = expr;
	      node.consequent = consequent;
	      node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
	        return _this5.parseMaybeAssign(undefined, undefined);
	      });
	      return this.finishNode(node, "ConditionalExpression");
	    };

	    _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
	      this.state.noArrowParamsConversionAt.push(this.state.start);
	      var consequent = this.parseMaybeAssignAllowIn();
	      var failed = !this.match(14);
	      this.state.noArrowParamsConversionAt.pop();
	      return {
	        consequent: consequent,
	        failed: failed
	      };
	    };

	    _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
	      var _this6 = this;

	      var stack = [node];
	      var arrows = [];

	      while (stack.length !== 0) {
	        var _node2 = stack.pop();

	        if (_node2.type === "ArrowFunctionExpression") {
	          if (_node2.typeParameters || !_node2.returnType) {
	            this.finishArrowValidation(_node2);
	          } else {
	            arrows.push(_node2);
	          }

	          stack.push(_node2.body);
	        } else if (_node2.type === "ConditionalExpression") {
	          stack.push(_node2.consequent);
	          stack.push(_node2.alternate);
	        }
	      }

	      if (disallowInvalid) {
	        arrows.forEach(function (node) {
	          return _this6.finishArrowValidation(node);
	        });
	        return [arrows, []];
	      }

	      return partition(arrows, function (node) {
	        return node.params.every(function (param) {
	          return _this6.isAssignable(param, true);
	        });
	      });
	    };

	    _proto.finishArrowValidation = function finishArrowValidation(node) {
	      var _node$extra;

	      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
	      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

	      _superClass.prototype.checkParams.call(this, node, false, true);

	      this.scope.exit();
	    };

	    _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
	      var result;

	      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        this.state.noArrowParamsConversionAt.push(this.state.start);
	        result = parse();
	        this.state.noArrowParamsConversionAt.pop();
	      } else {
	        result = parse();
	      }

	      return result;
	    };

	    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

	      if (this.eat(17)) {
	        node.optional = true;
	        this.resetEndLocation(node);
	      }

	      if (this.match(14)) {
	        var typeCastNode = this.startNodeAt(startPos, startLoc);
	        typeCastNode.expression = node;
	        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
	        return this.finishNode(typeCastNode, "TypeCastExpression");
	      }

	      return node;
	    };

	    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
	      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
	        return;
	      }

	      _superClass.prototype.assertModuleNodeAllowed.call(this, node);
	    };

	    _proto.parseExport = function parseExport(node) {
	      var decl = _superClass.prototype.parseExport.call(this, node);

	      if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
	        decl.exportKind = decl.exportKind || "value";
	      }

	      return decl;
	    };

	    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	      if (this.isContextual(122)) {
	        node.exportKind = "type";
	        var declarationNode = this.startNode();
	        this.next();

	        if (this.match(5)) {
	          node.specifiers = this.parseExportSpecifiers(true);
	          this.parseExportFrom(node);
	          return null;
	        } else {
	          return this.flowParseTypeAlias(declarationNode);
	        }
	      } else if (this.isContextual(123)) {
	        node.exportKind = "type";

	        var _declarationNode = this.startNode();

	        this.next();
	        return this.flowParseOpaqueType(_declarationNode, false);
	      } else if (this.isContextual(121)) {
	        node.exportKind = "type";

	        var _declarationNode2 = this.startNode();

	        this.next();
	        return this.flowParseInterface(_declarationNode2);
	      } else if (this.shouldParseEnums() && this.isContextual(118)) {
	        node.exportKind = "value";

	        var _declarationNode3 = this.startNode();

	        this.next();
	        return this.flowParseEnumDeclaration(_declarationNode3);
	      } else {
	        return _superClass.prototype.parseExportDeclaration.call(this, node);
	      }
	    };

	    _proto.eatExportStar = function eatExportStar(node) {
	      if (_superClass.prototype.eatExportStar.apply(this, arguments)) return true;

	      if (this.isContextual(122) && this.lookahead().type === 51) {
	        node.exportKind = "type";
	        this.next();
	        this.next();
	        return true;
	      }

	      return false;
	    };

	    _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
	      var pos = this.state.start;

	      var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);

	      if (hasNamespace && node.exportKind === "type") {
	        this.unexpected(pos);
	      }

	      return hasNamespace;
	    };

	    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
	      _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

	      if (this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      }
	    };

	    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
	      var pos = this.state.start;

	      if (this.isContextual(117)) {
	        if (this.parseClassMemberFromModifier(classBody, member)) {
	          return;
	        }

	        member.declare = true;
	      }

	      _superClass.prototype.parseClassMember.call(this, classBody, member, state);

	      if (member.declare) {
	        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
	          this.raise(pos, FlowErrors.DeclareClassElement);
	        } else if (member.value) {
	          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
	        }
	      }
	    };

	    _proto.isIterator = function isIterator(word) {
	      return word === "iterator" || word === "asyncIterator";
	    };

	    _proto.readIterator = function readIterator() {
	      var word = _superClass.prototype.readWord1.call(this);

	      var fullWord = "@@" + word;

	      if (!this.isIterator(word) || !this.state.inType) {
	        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
	      }

	      this.finishToken(124, fullWord);
	    };

	    _proto.getTokenFromCode = function getTokenFromCode(code) {
	      var next = this.input.charCodeAt(this.state.pos + 1);

	      if (code === 123 && next === 124) {
	        return this.finishOp(6, 2);
	      } else if (this.state.inType && (code === 62 || code === 60)) {
	        return this.finishOp(code === 62 ? 46 : 45, 1);
	      } else if (this.state.inType && code === 63) {
	        if (next === 46) {
	          return this.finishOp(18, 2);
	        }

	        return this.finishOp(17, 1);
	      } else if (isIteratorStart(code, next)) {
	        this.state.pos += 2;
	        return this.readIterator();
	      } else {
	        return _superClass.prototype.getTokenFromCode.call(this, code);
	      }
	    };

	    _proto.isAssignable = function isAssignable(node, isBinding) {
	      if (node.type === "TypeCastExpression") {
	        return this.isAssignable(node.expression, isBinding);
	      } else {
	        return _superClass.prototype.isAssignable.call(this, node, isBinding);
	      }
	    };

	    _proto.toAssignable = function toAssignable(node, isLHS) {
	      if (isLHS === void 0) {
	        isLHS = false;
	      }

	      if (node.type === "TypeCastExpression") {
	        return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);
	      } else {
	        return _superClass.prototype.toAssignable.call(this, node, isLHS);
	      }
	    };

	    _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];

	        if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
	          exprList[i] = this.typeCastToParameter(expr);
	        }
	      }

	      return _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaPos, isLHS);
	    };

	    _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
	      for (var i = 0; i < exprList.length; i++) {
	        var _expr$extra;

	        var expr = exprList[i];

	        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
	          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
	        }
	      }

	      return exprList;
	    };

	    _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	      var node = _superClass.prototype.parseArrayLike.call(this, close, canBePattern, isTuple, refExpressionErrors);

	      if (canBePattern && !this.state.maybeInArrowParameters) {
	        this.toReferencedList(node.elements);
	      }

	      return node;
	    };

	    _proto.checkLVal = function checkLVal(expr) {
	      if (expr.type !== "TypeCastExpression") {
	        var _superClass$prototype;

	        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          args[_key2 - 1] = arguments[_key2];
	        }

	        return (_superClass$prototype = _superClass.prototype.checkLVal).call.apply(_superClass$prototype, [this, expr].concat(args));
	      }
	    };

	    _proto.parseClassProperty = function parseClassProperty(node) {
	      if (this.match(14)) {
	        node.typeAnnotation = this.flowParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseClassProperty.call(this, node);
	    };

	    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
	      if (this.match(14)) {
	        node.typeAnnotation = this.flowParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseClassPrivateProperty.call(this, node);
	    };

	    _proto.isClassMethod = function isClassMethod() {
	      return this.match(45) || _superClass.prototype.isClassMethod.call(this);
	    };

	    _proto.isClassProperty = function isClassProperty() {
	      return this.match(14) || _superClass.prototype.isClassProperty.call(this);
	    };

	    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
	      return !this.match(14) && _superClass.prototype.isNonstaticConstructor.call(this, method);
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	      if (method.variance) {
	        this.unexpected(method.variance.start);
	      }

	      delete method.variance;

	      if (this.match(45)) {
	        method.typeParameters = this.flowParseTypeParameterDeclaration();
	      }

	      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

	      if (method.params && isConstructor) {
	        var params = method.params;

	        if (params.length > 0 && this.isThisParam(params[0])) {
	          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
	        }
	      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
	        var _params = method.value.params;

	        if (_params.length > 0 && this.isThisParam(_params[0])) {
	          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
	        }
	      }
	    };

	    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	      if (method.variance) {
	        this.unexpected(method.variance.start);
	      }

	      delete method.variance;

	      if (this.match(45)) {
	        method.typeParameters = this.flowParseTypeParameterDeclaration();
	      }

	      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
	    };

	    _proto.parseClassSuper = function parseClassSuper(node) {
	      _superClass.prototype.parseClassSuper.call(this, node);

	      if (node.superClass && this.match(45)) {
	        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
	      }

	      if (this.isContextual(106)) {
	        this.next();
	        var implemented = node["implements"] = [];

	        do {
	          var _node3 = this.startNode();

	          _node3.id = this.flowParseRestrictedIdentifier(true);

	          if (this.match(45)) {
	            _node3.typeParameters = this.flowParseTypeParameterInstantiation();
	          } else {
	            _node3.typeParameters = null;
	          }

	          implemented.push(this.finishNode(_node3, "ClassImplements"));
	        } while (this.eat(12));
	      }
	    };

	    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
	      _superClass.prototype.checkGetterSetterParams.call(this, method);

	      var params = this.getObjectOrClassMethodParams(method);

	      if (params.length > 0) {
	        var param = params[0];

	        if (this.isThisParam(param) && method.kind === "get") {
	          this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
	        } else if (this.isThisParam(param)) {
	          this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
	        }
	      }
	    };

	    _proto.parsePropertyNamePrefixOperator = function parsePropertyNamePrefixOperator(node) {
	      node.variance = this.flowParseVariance();
	    };

	    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	      if (prop.variance) {
	        this.unexpected(prop.variance.start);
	      }

	      delete prop.variance;
	      var typeParameters;

	      if (this.match(45) && !isAccessor) {
	        typeParameters = this.flowParseTypeParameterDeclaration();
	        if (!this.match(10)) this.unexpected();
	      }

	      _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

	      if (typeParameters) {
	        (prop.value || prop).typeParameters = typeParameters;
	      }
	    };

	    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	      if (this.eat(17)) {
	        if (param.type !== "Identifier") {
	          this.raise(param.start, FlowErrors.PatternIsOptional);
	        }

	        if (this.isThisParam(param)) {
	          this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
	        }

	        param.optional = true;
	      }

	      if (this.match(14)) {
	        param.typeAnnotation = this.flowParseTypeAnnotation();
	      } else if (this.isThisParam(param)) {
	        this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
	      }

	      if (this.match(29) && this.isThisParam(param)) {
	        this.raise(param.start, FlowErrors.ThisParamNoDefault);
	      }

	      this.resetEndLocation(param);
	      return param;
	    };

	    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
	      var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

	      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
	      }

	      return node;
	    };

	    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
	      if (!hasTypeImportKind(node)) {
	        return _superClass.prototype.shouldParseDefaultImport.call(this, node);
	      }

	      return isMaybeDefaultImport(this.state.type);
	    };

	    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
	      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
	      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
	      node.specifiers.push(this.finishNode(specifier, type));
	    };

	    _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
	      node.importKind = "value";
	      var kind = null;

	      if (this.match(83)) {
	        kind = "typeof";
	      } else if (this.isContextual(122)) {
	        kind = "type";
	      }

	      if (kind) {
	        var lh = this.lookahead();
	        var type = lh.type;

	        if (kind === "type" && type === 51) {
	          this.unexpected(lh.start);
	        }

	        if (isMaybeDefaultImport(type) || type === 5 || type === 51) {
	          this.next();
	          node.importKind = kind;
	        }
	      }

	      return _superClass.prototype.maybeParseDefaultImportSpecifier.call(this, node);
	    };

	    _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
	      var firstIdent = specifier.imported;
	      var specifierTypeKind = null;

	      if (firstIdent.type === "Identifier") {
	        if (firstIdent.name === "type") {
	          specifierTypeKind = "type";
	        } else if (firstIdent.name === "typeof") {
	          specifierTypeKind = "typeof";
	        }
	      }

	      var isBinding = false;

	      if (this.isContextual(89) && !this.isLookaheadContextual("as")) {
	        var as_ident = this.parseIdentifier(true);

	        if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
	          specifier.imported = as_ident;
	          specifier.importKind = specifierTypeKind;
	          specifier.local = cloneIdentifier(as_ident);
	        } else {
	          specifier.imported = firstIdent;
	          specifier.importKind = null;
	          specifier.local = this.parseIdentifier();
	        }
	      } else {
	        if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
	          specifier.imported = this.parseIdentifier(true);
	          specifier.importKind = specifierTypeKind;
	        } else {
	          if (importedIsString) {
	            throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
	          }

	          specifier.imported = firstIdent;
	          specifier.importKind = null;
	        }

	        if (this.eatContextual(89)) {
	          specifier.local = this.parseIdentifier();
	        } else {
	          isBinding = true;
	          specifier.local = cloneIdentifier(specifier.imported);
	        }
	      }

	      var specifierIsTypeImport = hasTypeImportKind(specifier);

	      if (isInTypeOnlyImport && specifierIsTypeImport) {
	        this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
	      }

	      if (isInTypeOnlyImport || specifierIsTypeImport) {
	        this.checkReservedType(specifier.local.name, specifier.local.start, true);
	      }

	      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
	        this.checkReservedWord(specifier.local.name, specifier.start, true, true);
	      }

	      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
	      return this.finishNode(specifier, "ImportSpecifier");
	    };

	    _proto.parseBindingAtom = function parseBindingAtom() {
	      switch (this.state.type) {
	        case 74:
	          return this.parseIdentifier(true);

	        default:
	          return _superClass.prototype.parseBindingAtom.call(this);
	      }
	    };

	    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
	      var kind = node.kind;

	      if (kind !== "get" && kind !== "set" && this.match(45)) {
	        node.typeParameters = this.flowParseTypeParameterDeclaration();
	      }

	      _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
	    };

	    _proto.parseVarId = function parseVarId(decl, kind) {
	      _superClass.prototype.parseVarId.call(this, decl, kind);

	      if (this.match(14)) {
	        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
	        this.resetEndLocation(decl.id);
	      }
	    };

	    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	      if (this.match(14)) {
	        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
	        this.state.noAnonFunctionType = true;
	        node.returnType = this.flowParseTypeAnnotation();
	        this.state.noAnonFunctionType = oldNoAnonFunctionType;
	      }

	      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
	    };

	    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	      return this.match(14) || _superClass.prototype.shouldParseAsyncArrow.call(this);
	    };

	    _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	      var _this7 = this,
	          _jsx;

	      var state = null;
	      var jsx;

	      if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
	        state = this.state.clone();
	        jsx = this.tryParse(function () {
	          return _superClass.prototype.parseMaybeAssign.call(_this7, refExpressionErrors, afterLeftParse);
	        }, state);
	        if (!jsx.error) return jsx.node;
	        var context = this.state.context;
	        var currentContext = context[context.length - 1];

	        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	          context.pop();
	        }
	      }

	      if ((_jsx = jsx) != null && _jsx.error || this.match(45)) {
	        var _jsx2, _jsx3;

	        state = state || this.state.clone();
	        var typeParameters;
	        var arrow = this.tryParse(function (abort) {
	          var _arrowExpression$extr;

	          typeParameters = _this7.flowParseTypeParameterDeclaration();

	          var arrowExpression = _this7.forwardNoArrowParamsConversionAt(typeParameters, function () {
	            var result = _superClass.prototype.parseMaybeAssign.call(_this7, refExpressionErrors, afterLeftParse);

	            _this7.resetStartLocationFromNode(result, typeParameters);

	            return result;
	          });

	          if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();

	          var expr = _this7.maybeUnwrapTypeCastExpression(arrowExpression);

	          if (expr.type !== "ArrowFunctionExpression") abort();
	          expr.typeParameters = typeParameters;

	          _this7.resetStartLocationFromNode(expr, typeParameters);

	          return arrowExpression;
	        }, state);
	        var arrowExpression = null;

	        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
	          if (!arrow.error && !arrow.aborted) {
	            if (arrow.node.async) {
	              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
	            }

	            return arrow.node;
	          }

	          arrowExpression = arrow.node;
	        }

	        if ((_jsx2 = jsx) != null && _jsx2.node) {
	          this.state = jsx.failState;
	          return jsx.node;
	        }

	        if (arrowExpression) {
	          this.state = arrow.failState;
	          return arrowExpression;
	        }

	        if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
	        if (arrow.thrown) throw arrow.error;
	        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
	      }

	      return _superClass.prototype.parseMaybeAssign.call(this, refExpressionErrors, afterLeftParse);
	    };

	    _proto.parseArrow = function parseArrow(node) {
	      var _this8 = this;

	      if (this.match(14)) {
	        var result = this.tryParse(function () {
	          var oldNoAnonFunctionType = _this8.state.noAnonFunctionType;
	          _this8.state.noAnonFunctionType = true;

	          var typeNode = _this8.startNode();

	          var _this8$flowParseTypeA = _this8.flowParseTypeAndPredicateInitialiser();

	          typeNode.typeAnnotation = _this8$flowParseTypeA[0];
	          node.predicate = _this8$flowParseTypeA[1];
	          _this8.state.noAnonFunctionType = oldNoAnonFunctionType;
	          if (_this8.canInsertSemicolon()) _this8.unexpected();
	          if (!_this8.match(19)) _this8.unexpected();
	          return typeNode;
	        });
	        if (result.thrown) return null;
	        if (result.error) this.state = result.failState;
	        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
	      }

	      return _superClass.prototype.parseArrow.call(this, node);
	    };

	    _proto.shouldParseArrow = function shouldParseArrow(params) {
	      return this.match(14) || _superClass.prototype.shouldParseArrow.call(this, params);
	    };

	    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
	      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        node.params = params;
	      } else {
	        _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
	      }
	    };

	    _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction) {
	      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
	        return;
	      }

	      for (var i = 0; i < node.params.length; i++) {
	        if (this.isThisParam(node.params[i]) && i > 0) {
	          this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
	        }
	      }

	      return _superClass.prototype.checkParams.apply(this, arguments);
	    };

	    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
	      return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
	    };

	    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
	      var _this9 = this;

	      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
	        this.next();
	        var node = this.startNodeAt(startPos, startLoc);
	        node.callee = base;
	        node.arguments = this.parseCallExpressionArguments(11, false);
	        base = this.finishNode(node, "CallExpression");
	      } else if (base.type === "Identifier" && base.name === "async" && this.match(45)) {
	        var state = this.state.clone();
	        var arrow = this.tryParse(function (abort) {
	          return _this9.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
	        }, state);
	        if (!arrow.error && !arrow.aborted) return arrow.node;
	        var result = this.tryParse(function () {
	          return _superClass.prototype.parseSubscripts.call(_this9, base, startPos, startLoc, noCalls);
	        }, state);
	        if (result.node && !result.error) return result.node;

	        if (arrow.node) {
	          this.state = arrow.failState;
	          return arrow.node;
	        }

	        if (result.node) {
	          this.state = result.failState;
	          return result.node;
	        }

	        throw arrow.error || result.error;
	      }

	      return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
	    };

	    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
	      var _this10 = this;

	      if (this.match(18) && this.isLookaheadToken_lt()) {
	        subscriptState.optionalChainMember = true;

	        if (noCalls) {
	          subscriptState.stop = true;
	          return base;
	        }

	        this.next();
	        var node = this.startNodeAt(startPos, startLoc);
	        node.callee = base;
	        node.typeArguments = this.flowParseTypeParameterInstantiation();
	        this.expect(10);
	        node.arguments = this.parseCallExpressionArguments(11, false);
	        node.optional = true;
	        return this.finishCallExpression(node, true);
	      } else if (!noCalls && this.shouldParseTypes() && this.match(45)) {
	        var _node4 = this.startNodeAt(startPos, startLoc);

	        _node4.callee = base;
	        var result = this.tryParse(function () {
	          _node4.typeArguments = _this10.flowParseTypeParameterInstantiationCallOrNew();

	          _this10.expect(10);

	          _node4.arguments = _this10.parseCallExpressionArguments(11, false);
	          if (subscriptState.optionalChainMember) _node4.optional = false;
	          return _this10.finishCallExpression(_node4, subscriptState.optionalChainMember);
	        });

	        if (result.node) {
	          if (result.error) this.state = result.failState;
	          return result.node;
	        }
	      }

	      return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
	    };

	    _proto.parseNewArguments = function parseNewArguments(node) {
	      var _this11 = this;

	      var targs = null;

	      if (this.shouldParseTypes() && this.match(45)) {
	        targs = this.tryParse(function () {
	          return _this11.flowParseTypeParameterInstantiationCallOrNew();
	        }).node;
	      }

	      node.typeArguments = targs;

	      _superClass.prototype.parseNewArguments.call(this, node);
	    };

	    _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);
	      this.parseFunctionParams(node);
	      if (!this.parseArrow(node)) return;
	      return this.parseArrowExpression(node, undefined, true);
	    };

	    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
	      var next = this.input.charCodeAt(this.state.pos + 1);

	      if (code === 42 && next === 47 && this.state.hasFlowComment) {
	        this.state.hasFlowComment = false;
	        this.state.pos += 2;
	        this.nextToken();
	        return;
	      }

	      _superClass.prototype.readToken_mult_modulo.call(this, code);
	    };

	    _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
	      var next = this.input.charCodeAt(this.state.pos + 1);

	      if (code === 124 && next === 125) {
	        this.finishOp(9, 2);
	        return;
	      }

	      _superClass.prototype.readToken_pipe_amp.call(this, code);
	    };

	    _proto.parseTopLevel = function parseTopLevel(file, program) {
	      var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);

	      if (this.state.hasFlowComment) {
	        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
	      }

	      return fileNode;
	    };

	    _proto.skipBlockComment = function skipBlockComment() {
	      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
	        if (this.state.hasFlowComment) {
	          this.unexpected(null, FlowErrors.NestedFlowComment);
	        }

	        this.hasFlowCommentCompletion();
	        this.state.pos += this.skipFlowComment();
	        this.state.hasFlowComment = true;
	        return;
	      }

	      if (this.state.hasFlowComment) {
	        var end = this.input.indexOf("*-/", this.state.pos += 2);

	        if (end === -1) {
	          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
	        }

	        this.state.pos = end + 3;
	        return;
	      }

	      return _superClass.prototype.skipBlockComment.call(this);
	    };

	    _proto.skipFlowComment = function skipFlowComment() {
	      var pos = this.state.pos;
	      var shiftToFirstNonWhiteSpace = 2;

	      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
	        shiftToFirstNonWhiteSpace++;
	      }

	      var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
	      var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

	      if (ch2 === 58 && ch3 === 58) {
	        return shiftToFirstNonWhiteSpace + 2;
	      }

	      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
	        return shiftToFirstNonWhiteSpace + 12;
	      }

	      if (ch2 === 58 && ch3 !== 58) {
	        return shiftToFirstNonWhiteSpace;
	      }

	      return false;
	    };

	    _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
	      var end = this.input.indexOf("*/", this.state.pos);

	      if (end === -1) {
	        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
	      }
	    };

	    _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(pos, _ref2) {
	      var enumName = _ref2.enumName,
	          memberName = _ref2.memberName;
	      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
	    };

	    _proto.flowEnumErrorInvalidMemberName = function flowEnumErrorInvalidMemberName(pos, _ref3) {
	      var enumName = _ref3.enumName,
	          memberName = _ref3.memberName;
	      var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
	      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
	    };

	    _proto.flowEnumErrorDuplicateMemberName = function flowEnumErrorDuplicateMemberName(pos, _ref4) {
	      var enumName = _ref4.enumName,
	          memberName = _ref4.memberName;
	      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
	    };

	    _proto.flowEnumErrorInconsistentMemberValues = function flowEnumErrorInconsistentMemberValues(pos, _ref5) {
	      var enumName = _ref5.enumName;
	      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
	    };

	    _proto.flowEnumErrorInvalidExplicitType = function flowEnumErrorInvalidExplicitType(pos, _ref6) {
	      var enumName = _ref6.enumName,
	          suppliedType = _ref6.suppliedType;
	      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
	    };

	    _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(pos, _ref7) {
	      var enumName = _ref7.enumName,
	          explicitType = _ref7.explicitType,
	          memberName = _ref7.memberName;
	      var message = null;

	      switch (explicitType) {
	        case "boolean":
	        case "number":
	        case "string":
	          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
	          break;

	        case "symbol":
	          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
	          break;

	        default:
	          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
	      }

	      return this.raise(pos, message, enumName, memberName, explicitType);
	    };

	    _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(pos, _ref8) {
	      var enumName = _ref8.enumName,
	          memberName = _ref8.memberName;
	      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
	    };

	    _proto.flowEnumErrorStringMemberInconsistentlyInitailized = function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref9) {
	      var enumName = _ref9.enumName;
	      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
	    };

	    _proto.flowEnumMemberInit = function flowEnumMemberInit() {
	      var _this12 = this;

	      var startPos = this.state.start;

	      var endOfInit = function endOfInit() {
	        return _this12.match(12) || _this12.match(8);
	      };

	      switch (this.state.type) {
	        case 126:
	          {
	            var literal = this.parseNumericLiteral(this.state.value);

	            if (endOfInit()) {
	              return {
	                type: "number",
	                pos: literal.start,
	                value: literal
	              };
	            }

	            return {
	              type: "invalid",
	              pos: startPos
	            };
	          }

	        case 125:
	          {
	            var _literal = this.parseStringLiteral(this.state.value);

	            if (endOfInit()) {
	              return {
	                type: "string",
	                pos: _literal.start,
	                value: _literal
	              };
	            }

	            return {
	              type: "invalid",
	              pos: startPos
	            };
	          }

	        case 81:
	        case 82:
	          {
	            var _literal2 = this.parseBooleanLiteral(this.match(81));

	            if (endOfInit()) {
	              return {
	                type: "boolean",
	                pos: _literal2.start,
	                value: _literal2
	              };
	            }

	            return {
	              type: "invalid",
	              pos: startPos
	            };
	          }

	        default:
	          return {
	            type: "invalid",
	            pos: startPos
	          };
	      }
	    };

	    _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
	      var pos = this.state.start;
	      var id = this.parseIdentifier(true);
	      var init = this.eat(29) ? this.flowEnumMemberInit() : {
	        type: "none",
	        pos: pos
	      };
	      return {
	        id: id,
	        init: init
	      };
	    };

	    _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
	      var explicitType = context.explicitType;

	      if (explicitType === null) {
	        return;
	      }

	      if (explicitType !== expectedType) {
	        this.flowEnumErrorInvalidMemberInitializer(pos, context);
	      }
	    };

	    _proto.flowEnumMembers = function flowEnumMembers(_ref10) {
	      var enumName = _ref10.enumName,
	          explicitType = _ref10.explicitType;
	      var seenNames = new Set();
	      var members = {
	        booleanMembers: [],
	        numberMembers: [],
	        stringMembers: [],
	        defaultedMembers: []
	      };
	      var hasUnknownMembers = false;

	      while (!this.match(8)) {
	        if (this.eat(21)) {
	          hasUnknownMembers = true;
	          break;
	        }

	        var memberNode = this.startNode();

	        var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
	            id = _this$flowEnumMemberR.id,
	            init = _this$flowEnumMemberR.init;

	        var memberName = id.name;

	        if (memberName === "") {
	          continue;
	        }

	        if (/^[a-z]/.test(memberName)) {
	          this.flowEnumErrorInvalidMemberName(id.start, {
	            enumName: enumName,
	            memberName: memberName
	          });
	        }

	        if (seenNames.has(memberName)) {
	          this.flowEnumErrorDuplicateMemberName(id.start, {
	            enumName: enumName,
	            memberName: memberName
	          });
	        }

	        seenNames.add(memberName);
	        var context = {
	          enumName: enumName,
	          explicitType: explicitType,
	          memberName: memberName
	        };
	        memberNode.id = id;

	        switch (init.type) {
	          case "boolean":
	            {
	              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
	              memberNode.init = init.value;
	              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
	              break;
	            }

	          case "number":
	            {
	              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
	              memberNode.init = init.value;
	              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
	              break;
	            }

	          case "string":
	            {
	              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
	              memberNode.init = init.value;
	              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
	              break;
	            }

	          case "invalid":
	            {
	              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
	            }

	          case "none":
	            {
	              switch (explicitType) {
	                case "boolean":
	                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
	                  break;

	                case "number":
	                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
	                  break;

	                default:
	                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
	              }
	            }
	        }

	        if (!this.match(8)) {
	          this.expect(12);
	        }
	      }

	      return {
	        members: members,
	        hasUnknownMembers: hasUnknownMembers
	      };
	    };

	    _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref11) {
	      var enumName = _ref11.enumName;

	      if (initializedMembers.length === 0) {
	        return defaultedMembers;
	      } else if (defaultedMembers.length === 0) {
	        return initializedMembers;
	      } else if (defaultedMembers.length > initializedMembers.length) {
	        for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
	          var member = initializedMembers[_i2];
	          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
	            enumName: enumName
	          });
	        }

	        return defaultedMembers;
	      } else {
	        for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
	          var _member = defaultedMembers[_i4];
	          this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
	            enumName: enumName
	          });
	        }

	        return initializedMembers;
	      }
	    };

	    _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref12) {
	      var enumName = _ref12.enumName;

	      if (this.eatContextual(97)) {
	        if (!tokenIsIdentifier(this.state.type)) {
	          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
	            enumName: enumName,
	            suppliedType: null
	          });
	        }

	        var value = this.state.value;
	        this.next();

	        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
	          this.flowEnumErrorInvalidExplicitType(this.state.start, {
	            enumName: enumName,
	            suppliedType: value
	          });
	        }

	        return value;
	      }

	      return null;
	    };

	    _proto.flowEnumBody = function flowEnumBody(node, _ref13) {
	      var _this13 = this;

	      var enumName = _ref13.enumName,
	          nameLoc = _ref13.nameLoc;
	      var explicitType = this.flowEnumParseExplicitType({
	        enumName: enumName
	      });
	      this.expect(5);

	      var _this$flowEnumMembers = this.flowEnumMembers({
	        enumName: enumName,
	        explicitType: explicitType
	      }),
	          members = _this$flowEnumMembers.members,
	          hasUnknownMembers = _this$flowEnumMembers.hasUnknownMembers;

	      node.hasUnknownMembers = hasUnknownMembers;

	      switch (explicitType) {
	        case "boolean":
	          node.explicitType = true;
	          node.members = members.booleanMembers;
	          this.expect(8);
	          return this.finishNode(node, "EnumBooleanBody");

	        case "number":
	          node.explicitType = true;
	          node.members = members.numberMembers;
	          this.expect(8);
	          return this.finishNode(node, "EnumNumberBody");

	        case "string":
	          node.explicitType = true;
	          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	            enumName: enumName
	          });
	          this.expect(8);
	          return this.finishNode(node, "EnumStringBody");

	        case "symbol":
	          node.members = members.defaultedMembers;
	          this.expect(8);
	          return this.finishNode(node, "EnumSymbolBody");

	        default:
	          {
	            var empty = function empty() {
	              node.members = [];

	              _this13.expect(8);

	              return _this13.finishNode(node, "EnumStringBody");
	            };

	            node.explicitType = false;
	            var boolsLen = members.booleanMembers.length;
	            var numsLen = members.numberMembers.length;
	            var strsLen = members.stringMembers.length;
	            var defaultedLen = members.defaultedMembers.length;

	            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
	              return empty();
	            } else if (!boolsLen && !numsLen) {
	              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
	                enumName: enumName
	              });
	              this.expect(8);
	              return this.finishNode(node, "EnumStringBody");
	            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
	              for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
	                var member = _members$defaultedMem2[_i6];
	                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
	                  enumName: enumName,
	                  memberName: member.id.name
	                });
	              }

	              node.members = members.booleanMembers;
	              this.expect(8);
	              return this.finishNode(node, "EnumBooleanBody");
	            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
	              for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
	                var _member2 = _members$defaultedMem4[_i8];
	                this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
	                  enumName: enumName,
	                  memberName: _member2.id.name
	                });
	              }

	              node.members = members.numberMembers;
	              this.expect(8);
	              return this.finishNode(node, "EnumNumberBody");
	            } else {
	              this.flowEnumErrorInconsistentMemberValues(nameLoc, {
	                enumName: enumName
	              });
	              return empty();
	            }
	          }
	      }
	    };

	    _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
	      var id = this.parseIdentifier();
	      node.id = id;
	      node.body = this.flowEnumBody(this.startNode(), {
	        enumName: id.name,
	        nameLoc: id.start
	      });
	      return this.finishNode(node, "EnumDeclaration");
	    };

	    _proto.isLookaheadToken_lt = function isLookaheadToken_lt() {
	      var next = this.nextTokenStart();

	      if (this.input.charCodeAt(next) === 60) {
	        var afterNext = this.input.charCodeAt(next + 1);
	        return afterNext !== 60 && afterNext !== 61;
	      }

	      return false;
	    };

	    _proto.maybeUnwrapTypeCastExpression = function maybeUnwrapTypeCastExpression(node) {
	      return node.type === "TypeCastExpression" ? node.expression : node;
	    };

	    return _class2;
	  }(superClass);
	});

	var entities = {
	  quot: "\"",
	  amp: "&",
	  apos: "'",
	  lt: "<",
	  gt: ">",
	  nbsp: "\xA0",
	  iexcl: "\xA1",
	  cent: "\xA2",
	  pound: "\xA3",
	  curren: "\xA4",
	  yen: "\xA5",
	  brvbar: "\xA6",
	  sect: "\xA7",
	  uml: "\xA8",
	  copy: "\xA9",
	  ordf: "\xAA",
	  laquo: "\xAB",
	  not: "\xAC",
	  shy: "\xAD",
	  reg: "\xAE",
	  macr: "\xAF",
	  deg: "\xB0",
	  plusmn: "\xB1",
	  sup2: "\xB2",
	  sup3: "\xB3",
	  acute: "\xB4",
	  micro: "\xB5",
	  para: "\xB6",
	  middot: "\xB7",
	  cedil: "\xB8",
	  sup1: "\xB9",
	  ordm: "\xBA",
	  raquo: "\xBB",
	  frac14: "\xBC",
	  frac12: "\xBD",
	  frac34: "\xBE",
	  iquest: "\xBF",
	  Agrave: "\xC0",
	  Aacute: "\xC1",
	  Acirc: "\xC2",
	  Atilde: "\xC3",
	  Auml: "\xC4",
	  Aring: "\xC5",
	  AElig: "\xC6",
	  Ccedil: "\xC7",
	  Egrave: "\xC8",
	  Eacute: "\xC9",
	  Ecirc: "\xCA",
	  Euml: "\xCB",
	  Igrave: "\xCC",
	  Iacute: "\xCD",
	  Icirc: "\xCE",
	  Iuml: "\xCF",
	  ETH: "\xD0",
	  Ntilde: "\xD1",
	  Ograve: "\xD2",
	  Oacute: "\xD3",
	  Ocirc: "\xD4",
	  Otilde: "\xD5",
	  Ouml: "\xD6",
	  times: "\xD7",
	  Oslash: "\xD8",
	  Ugrave: "\xD9",
	  Uacute: "\xDA",
	  Ucirc: "\xDB",
	  Uuml: "\xDC",
	  Yacute: "\xDD",
	  THORN: "\xDE",
	  szlig: "\xDF",
	  agrave: "\xE0",
	  aacute: "\xE1",
	  acirc: "\xE2",
	  atilde: "\xE3",
	  auml: "\xE4",
	  aring: "\xE5",
	  aelig: "\xE6",
	  ccedil: "\xE7",
	  egrave: "\xE8",
	  eacute: "\xE9",
	  ecirc: "\xEA",
	  euml: "\xEB",
	  igrave: "\xEC",
	  iacute: "\xED",
	  icirc: "\xEE",
	  iuml: "\xEF",
	  eth: "\xF0",
	  ntilde: "\xF1",
	  ograve: "\xF2",
	  oacute: "\xF3",
	  ocirc: "\xF4",
	  otilde: "\xF5",
	  ouml: "\xF6",
	  divide: "\xF7",
	  oslash: "\xF8",
	  ugrave: "\xF9",
	  uacute: "\xFA",
	  ucirc: "\xFB",
	  uuml: "\xFC",
	  yacute: "\xFD",
	  thorn: "\xFE",
	  yuml: "\xFF",
	  OElig: "\u0152",
	  oelig: "\u0153",
	  Scaron: "\u0160",
	  scaron: "\u0161",
	  Yuml: "\u0178",
	  fnof: "\u0192",
	  circ: "\u02C6",
	  tilde: "\u02DC",
	  Alpha: "\u0391",
	  Beta: "\u0392",
	  Gamma: "\u0393",
	  Delta: "\u0394",
	  Epsilon: "\u0395",
	  Zeta: "\u0396",
	  Eta: "\u0397",
	  Theta: "\u0398",
	  Iota: "\u0399",
	  Kappa: "\u039A",
	  Lambda: "\u039B",
	  Mu: "\u039C",
	  Nu: "\u039D",
	  Xi: "\u039E",
	  Omicron: "\u039F",
	  Pi: "\u03A0",
	  Rho: "\u03A1",
	  Sigma: "\u03A3",
	  Tau: "\u03A4",
	  Upsilon: "\u03A5",
	  Phi: "\u03A6",
	  Chi: "\u03A7",
	  Psi: "\u03A8",
	  Omega: "\u03A9",
	  alpha: "\u03B1",
	  beta: "\u03B2",
	  gamma: "\u03B3",
	  delta: "\u03B4",
	  epsilon: "\u03B5",
	  zeta: "\u03B6",
	  eta: "\u03B7",
	  theta: "\u03B8",
	  iota: "\u03B9",
	  kappa: "\u03BA",
	  lambda: "\u03BB",
	  mu: "\u03BC",
	  nu: "\u03BD",
	  xi: "\u03BE",
	  omicron: "\u03BF",
	  pi: "\u03C0",
	  rho: "\u03C1",
	  sigmaf: "\u03C2",
	  sigma: "\u03C3",
	  tau: "\u03C4",
	  upsilon: "\u03C5",
	  phi: "\u03C6",
	  chi: "\u03C7",
	  psi: "\u03C8",
	  omega: "\u03C9",
	  thetasym: "\u03D1",
	  upsih: "\u03D2",
	  piv: "\u03D6",
	  ensp: "\u2002",
	  emsp: "\u2003",
	  thinsp: "\u2009",
	  zwnj: "\u200C",
	  zwj: "\u200D",
	  lrm: "\u200E",
	  rlm: "\u200F",
	  ndash: "\u2013",
	  mdash: "\u2014",
	  lsquo: "\u2018",
	  rsquo: "\u2019",
	  sbquo: "\u201A",
	  ldquo: "\u201C",
	  rdquo: "\u201D",
	  bdquo: "\u201E",
	  dagger: "\u2020",
	  Dagger: "\u2021",
	  bull: "\u2022",
	  hellip: "\u2026",
	  permil: "\u2030",
	  prime: "\u2032",
	  Prime: "\u2033",
	  lsaquo: "\u2039",
	  rsaquo: "\u203A",
	  oline: "\u203E",
	  frasl: "\u2044",
	  euro: "\u20AC",
	  image: "\u2111",
	  weierp: "\u2118",
	  real: "\u211C",
	  trade: "\u2122",
	  alefsym: "\u2135",
	  larr: "\u2190",
	  uarr: "\u2191",
	  rarr: "\u2192",
	  darr: "\u2193",
	  harr: "\u2194",
	  crarr: "\u21B5",
	  lArr: "\u21D0",
	  uArr: "\u21D1",
	  rArr: "\u21D2",
	  dArr: "\u21D3",
	  hArr: "\u21D4",
	  forall: "\u2200",
	  part: "\u2202",
	  exist: "\u2203",
	  empty: "\u2205",
	  nabla: "\u2207",
	  isin: "\u2208",
	  notin: "\u2209",
	  ni: "\u220B",
	  prod: "\u220F",
	  sum: "\u2211",
	  minus: "\u2212",
	  lowast: "\u2217",
	  radic: "\u221A",
	  prop: "\u221D",
	  infin: "\u221E",
	  ang: "\u2220",
	  and: "\u2227",
	  or: "\u2228",
	  cap: "\u2229",
	  cup: "\u222A",
	  "int": "\u222B",
	  there4: "\u2234",
	  sim: "\u223C",
	  cong: "\u2245",
	  asymp: "\u2248",
	  ne: "\u2260",
	  equiv: "\u2261",
	  le: "\u2264",
	  ge: "\u2265",
	  sub: "\u2282",
	  sup: "\u2283",
	  nsub: "\u2284",
	  sube: "\u2286",
	  supe: "\u2287",
	  oplus: "\u2295",
	  otimes: "\u2297",
	  perp: "\u22A5",
	  sdot: "\u22C5",
	  lceil: "\u2308",
	  rceil: "\u2309",
	  lfloor: "\u230A",
	  rfloor: "\u230B",
	  lang: "\u2329",
	  rang: "\u232A",
	  loz: "\u25CA",
	  spades: "\u2660",
	  clubs: "\u2663",
	  hearts: "\u2665",
	  diams: "\u2666"
	};

	var HEX_NUMBER = /^[\da-fA-F]+$/;
	var DECIMAL_NUMBER = /^\d+$/;
	var JsxErrors = makeErrorTemplates({
	  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
	  MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
	  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
	  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
	  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
	  UnterminatedJsxContent: "Unterminated JSX contents.",
	  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
	}, ErrorCodes.SyntaxError, "jsx");

	function isFragment(object) {
	  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
	}

	function getQualifiedJSXName(object) {
	  if (object.type === "JSXIdentifier") {
	    return object.name;
	  }

	  if (object.type === "JSXNamespacedName") {
	    return object.namespace.name + ":" + object.name.name;
	  }

	  if (object.type === "JSXMemberExpression") {
	    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
	  }

	  throw new Error("Node had unexpected type: " + object.type);
	}

	var jsx = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.jsxReadToken = function jsxReadToken() {
	      var out = "";
	      var chunkStart = this.state.pos;

	      for (;;) {
	        if (this.state.pos >= this.length) {
	          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
	        }

	        var ch = this.input.charCodeAt(this.state.pos);

	        switch (ch) {
	          case 60:
	          case 123:
	            if (this.state.pos === this.state.start) {
	              if (ch === 60 && this.state.canStartJSXElement) {
	                ++this.state.pos;
	                return this.finishToken(134);
	              }

	              return _superClass.prototype.getTokenFromCode.call(this, ch);
	            }

	            out += this.input.slice(chunkStart, this.state.pos);
	            return this.finishToken(133, out);

	          case 38:
	            out += this.input.slice(chunkStart, this.state.pos);
	            out += this.jsxReadEntity();
	            chunkStart = this.state.pos;
	            break;

	          case 62:
	          case 125:

	          default:
	            if (isNewLine(ch)) {
	              out += this.input.slice(chunkStart, this.state.pos);
	              out += this.jsxReadNewLine(true);
	              chunkStart = this.state.pos;
	            } else {
	              ++this.state.pos;
	            }

	        }
	      }
	    };

	    _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
	      var ch = this.input.charCodeAt(this.state.pos);
	      var out;
	      ++this.state.pos;

	      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
	        ++this.state.pos;
	        out = normalizeCRLF ? "\n" : "\r\n";
	      } else {
	        out = String.fromCharCode(ch);
	      }

	      ++this.state.curLine;
	      this.state.lineStart = this.state.pos;
	      return out;
	    };

	    _proto.jsxReadString = function jsxReadString(quote) {
	      var out = "";
	      var chunkStart = ++this.state.pos;

	      for (;;) {
	        if (this.state.pos >= this.length) {
	          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
	        }

	        var ch = this.input.charCodeAt(this.state.pos);
	        if (ch === quote) break;

	        if (ch === 38) {
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadEntity();
	          chunkStart = this.state.pos;
	        } else if (isNewLine(ch)) {
	          out += this.input.slice(chunkStart, this.state.pos);
	          out += this.jsxReadNewLine(false);
	          chunkStart = this.state.pos;
	        } else {
	          ++this.state.pos;
	        }
	      }

	      out += this.input.slice(chunkStart, this.state.pos++);
	      return this.finishToken(125, out);
	    };

	    _proto.jsxReadEntity = function jsxReadEntity() {
	      var str = "";
	      var count = 0;
	      var entity;
	      var ch = this.input[this.state.pos];
	      var startPos = ++this.state.pos;

	      while (this.state.pos < this.length && count++ < 10) {
	        ch = this.input[this.state.pos++];

	        if (ch === ";") {
	          if (str[0] === "#") {
	            if (str[1] === "x") {
	              str = str.substr(2);

	              if (HEX_NUMBER.test(str)) {
	                entity = String.fromCodePoint(parseInt(str, 16));
	              }
	            } else {
	              str = str.substr(1);

	              if (DECIMAL_NUMBER.test(str)) {
	                entity = String.fromCodePoint(parseInt(str, 10));
	              }
	            }
	          } else {
	            entity = entities[str];
	          }

	          break;
	        }

	        str += ch;
	      }

	      if (!entity) {
	        this.state.pos = startPos;
	        return "&";
	      }

	      return entity;
	    };

	    _proto.jsxReadWord = function jsxReadWord() {
	      var ch;
	      var start = this.state.pos;

	      do {
	        ch = this.input.charCodeAt(++this.state.pos);
	      } while (isIdentifierChar(ch) || ch === 45);

	      return this.finishToken(132, this.input.slice(start, this.state.pos));
	    };

	    _proto.jsxParseIdentifier = function jsxParseIdentifier() {
	      var node = this.startNode();

	      if (this.match(132)) {
	        node.name = this.state.value;
	      } else if (tokenIsKeyword(this.state.type)) {
	        node.name = tokenLabelName(this.state.type);
	      } else {
	        this.unexpected();
	      }

	      this.next();
	      return this.finishNode(node, "JSXIdentifier");
	    };

	    _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var name = this.jsxParseIdentifier();
	      if (!this.eat(14)) return name;
	      var node = this.startNodeAt(startPos, startLoc);
	      node.namespace = name;
	      node.name = this.jsxParseIdentifier();
	      return this.finishNode(node, "JSXNamespacedName");
	    };

	    _proto.jsxParseElementName = function jsxParseElementName() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var node = this.jsxParseNamespacedName();

	      if (node.type === "JSXNamespacedName") {
	        return node;
	      }

	      while (this.eat(16)) {
	        var newNode = this.startNodeAt(startPos, startLoc);
	        newNode.object = node;
	        newNode.property = this.jsxParseIdentifier();
	        node = this.finishNode(newNode, "JSXMemberExpression");
	      }

	      return node;
	    };

	    _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
	      var node;

	      switch (this.state.type) {
	        case 5:
	          node = this.startNode();
	          this.setContext(types.brace);
	          this.next();
	          node = this.jsxParseExpressionContainer(node, types.j_oTag);

	          if (node.expression.type === "JSXEmptyExpression") {
	            this.raise(node.start, JsxErrors.AttributeIsEmpty);
	          }

	          return node;

	        case 134:
	        case 125:
	          return this.parseExprAtom();

	        default:
	          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
	      }
	    };

	    _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
	      var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
	      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
	    };

	    _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
	      this.next();
	      node.expression = this.parseExpression();
	      this.setContext(types.j_oTag);
	      this.expect(8);
	      return this.finishNode(node, "JSXSpreadChild");
	    };

	    _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node, previousContext) {
	      if (this.match(8)) {
	        node.expression = this.jsxParseEmptyExpression();
	      } else {
	        var expression = this.parseExpression();
	        node.expression = expression;
	      }

	      this.setContext(previousContext);
	      this.expect(8);
	      return this.finishNode(node, "JSXExpressionContainer");
	    };

	    _proto.jsxParseAttribute = function jsxParseAttribute() {
	      var node = this.startNode();

	      if (this.match(5)) {
	        this.setContext(types.brace);
	        this.next();
	        this.expect(21);
	        node.argument = this.parseMaybeAssignAllowIn();
	        this.setContext(types.j_oTag);
	        this.expect(8);
	        return this.finishNode(node, "JSXSpreadAttribute");
	      }

	      node.name = this.jsxParseNamespacedName();
	      node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
	      return this.finishNode(node, "JSXAttribute");
	    };

	    _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);

	      if (this.match(135)) {
	        this.expect(135);
	        return this.finishNode(node, "JSXOpeningFragment");
	      }

	      node.name = this.jsxParseElementName();
	      return this.jsxParseOpeningElementAfterName(node);
	    };

	    _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
	      var attributes = [];

	      while (!this.match(52) && !this.match(135)) {
	        attributes.push(this.jsxParseAttribute());
	      }

	      node.attributes = attributes;
	      node.selfClosing = this.eat(52);
	      this.expect(135);
	      return this.finishNode(node, "JSXOpeningElement");
	    };

	    _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);

	      if (this.match(135)) {
	        this.expect(135);
	        return this.finishNode(node, "JSXClosingFragment");
	      }

	      node.name = this.jsxParseElementName();
	      this.expect(135);
	      return this.finishNode(node, "JSXClosingElement");
	    };

	    _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
	      var node = this.startNodeAt(startPos, startLoc);
	      var children = [];
	      var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
	      var closingElement = null;

	      if (!openingElement.selfClosing) {
	        contents: for (;;) {
	          switch (this.state.type) {
	            case 134:
	              startPos = this.state.start;
	              startLoc = this.state.startLoc;
	              this.next();

	              if (this.eat(52)) {
	                closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
	                break contents;
	              }

	              children.push(this.jsxParseElementAt(startPos, startLoc));
	              break;

	            case 133:
	              children.push(this.parseExprAtom());
	              break;

	            case 5:
	              {
	                var _node = this.startNode();

	                this.setContext(types.brace);
	                this.next();

	                if (this.match(21)) {
	                  children.push(this.jsxParseSpreadChild(_node));
	                } else {
	                  children.push(this.jsxParseExpressionContainer(_node, types.j_expr));
	                }

	                break;
	              }

	            default:
	              throw this.unexpected();
	          }
	        }

	        if (isFragment(openingElement) && !isFragment(closingElement)) {
	          this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
	        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
	          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
	        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
	          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
	          }
	        }
	      }

	      if (isFragment(openingElement)) {
	        node.openingFragment = openingElement;
	        node.closingFragment = closingElement;
	      } else {
	        node.openingElement = openingElement;
	        node.closingElement = closingElement;
	      }

	      node.children = children;

	      if (this.match(45)) {
	        throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
	      }

	      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
	    };

	    _proto.jsxParseElement = function jsxParseElement() {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      this.next();
	      return this.jsxParseElementAt(startPos, startLoc);
	    };

	    _proto.setContext = function setContext(newContext) {
	      var context = this.state.context;
	      context[context.length - 1] = newContext;
	    };

	    _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
	      if (this.match(133)) {
	        return this.parseLiteral(this.state.value, "JSXText");
	      } else if (this.match(134)) {
	        return this.jsxParseElement();
	      } else if (this.match(45) && this.input.charCodeAt(this.state.pos) !== 33) {
	        this.replaceToken(134);
	        return this.jsxParseElement();
	      } else {
	        return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
	      }
	    };

	    _proto.skipSpace = function skipSpace() {
	      var curContext = this.curContext();
	      if (!curContext.preserveSpace) _superClass.prototype.skipSpace.call(this);
	    };

	    _proto.getTokenFromCode = function getTokenFromCode(code) {
	      var context = this.curContext();

	      if (context === types.j_expr) {
	        return this.jsxReadToken();
	      }

	      if (context === types.j_oTag || context === types.j_cTag) {
	        if (isIdentifierStart(code)) {
	          return this.jsxReadWord();
	        }

	        if (code === 62) {
	          ++this.state.pos;
	          return this.finishToken(135);
	        }

	        if ((code === 34 || code === 39) && context === types.j_oTag) {
	          return this.jsxReadString(code);
	        }
	      }

	      if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
	        ++this.state.pos;
	        return this.finishToken(134);
	      }

	      return _superClass.prototype.getTokenFromCode.call(this, code);
	    };

	    _proto.updateContext = function updateContext(prevType) {
	      var _this$state = this.state,
	          context = _this$state.context,
	          type = _this$state.type;

	      if (type === 52 && prevType === 134) {
	        context.splice(-2, 2, types.j_cTag);
	        this.state.canStartJSXElement = false;
	      } else if (type === 134) {
	        context.push(types.j_oTag);
	      } else if (type === 135) {
	        var out = context[context.length - 1];

	        if (out === types.j_oTag && prevType === 52 || out === types.j_cTag) {
	          context.pop();
	          this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
	        } else {
	          this.setContext(types.j_expr);
	          this.state.canStartJSXElement = true;
	        }
	      } else {
	        this.state.canStartJSXElement = tokenComesBeforeExpression(type);
	      }
	    };

	    return _class;
	  }(superClass);
	});

	var TypeScriptScope = function (_Scope) {
	  _inherits(TypeScriptScope, _Scope);

	  function TypeScriptScope() {
	    var _this;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
	    _this.types = new Set();
	    _this.enums = new Set();
	    _this.constEnums = new Set();
	    _this.classes = new Set();
	    _this.exportOnlyBindings = new Set();
	    return _this;
	  }

	  return TypeScriptScope;
	}(Scope);

	var TypeScriptScopeHandler = function (_ScopeHandler) {
	  _inherits(TypeScriptScopeHandler, _ScopeHandler);

	  function TypeScriptScopeHandler() {
	    return _ScopeHandler.apply(this, arguments) || this;
	  }

	  var _proto = TypeScriptScopeHandler.prototype;

	  _proto.createScope = function createScope(flags) {
	    return new TypeScriptScope(flags);
	  };

	  _proto.declareName = function declareName(name, bindingType, pos) {
	    var scope = this.currentScope();

	    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
	      this.maybeExportDefined(scope, name);
	      scope.exportOnlyBindings.add(name);
	      return;
	    }

	    _ScopeHandler.prototype.declareName.apply(this, arguments);

	    if (bindingType & BIND_KIND_TYPE) {
	      if (!(bindingType & BIND_KIND_VALUE)) {
	        this.checkRedeclarationInScope(scope, name, bindingType, pos);
	        this.maybeExportDefined(scope, name);
	      }

	      scope.types.add(name);
	    }

	    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
	    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
	    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
	  };

	  _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
	    if (scope.enums.has(name)) {
	      if (bindingType & BIND_FLAGS_TS_ENUM) {
	        var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
	        var wasConst = scope.constEnums.has(name);
	        return isConst !== wasConst;
	      }

	      return true;
	    }

	    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
	      if (scope.lexical.has(name)) {
	        return !!(bindingType & BIND_KIND_VALUE);
	      } else {
	        return false;
	      }
	    }

	    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
	      return true;
	    }

	    return _ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments);
	  };

	  _proto.checkLocalExport = function checkLocalExport(id) {
	    var topLevelScope = this.scopeStack[0];
	    var name = id.name;

	    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
	      _ScopeHandler.prototype.checkLocalExport.call(this, id);
	    }
	  };

	  return TypeScriptScopeHandler;
	}(ScopeHandler);

	function nonNull(x) {
	  if (x == null) {
	    throw new Error("Unexpected " + x + " value.");
	  }

	  return x;
	}

	function assert(x) {
	  if (!x) {
	    throw new Error("Assert fail");
	  }
	}

	var TSErrors = makeErrorTemplates({
	  AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
	  AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
	  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
	  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
	  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
	  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
	  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
	  DeclareAccessor: "'declare' is not allowed in %0ters.",
	  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
	  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
	  DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
	  DuplicateModifier: "Duplicate modifier: '%0'.",
	  EmptyHeritageClauseType: "'%0' list cannot be empty.",
	  EmptyTypeArguments: "Type argument list cannot be empty.",
	  EmptyTypeParameters: "Type parameter list cannot be empty.",
	  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
	  ImportAliasHasImportType: "An import alias can not use 'import type'.",
	  IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
	  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
	  IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
	  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
	  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
	  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
	  InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
	  InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
	  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
	  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
	  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
	  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
	  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
	  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
	  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
	  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
	  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
	  PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
	  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
	  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
	  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
	  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
	  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
	  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
	  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
	  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
	  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
	  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
	  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
	  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
	  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
	  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
	  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
	  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
	  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
	  UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
	}, ErrorCodes.SyntaxError, "typescript");

	function keywordTypeFromName(value) {
	  switch (value) {
	    case "any":
	      return "TSAnyKeyword";

	    case "boolean":
	      return "TSBooleanKeyword";

	    case "bigint":
	      return "TSBigIntKeyword";

	    case "never":
	      return "TSNeverKeyword";

	    case "number":
	      return "TSNumberKeyword";

	    case "object":
	      return "TSObjectKeyword";

	    case "string":
	      return "TSStringKeyword";

	    case "symbol":
	      return "TSSymbolKeyword";

	    case "undefined":
	      return "TSUndefinedKeyword";

	    case "unknown":
	      return "TSUnknownKeyword";

	    default:
	      return undefined;
	  }
	}

	function tsIsAccessModifier(modifier) {
	  return modifier === "private" || modifier === "public" || modifier === "protected";
	}

	var typescript = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.getScopeHandler = function getScopeHandler() {
	      return TypeScriptScopeHandler;
	    };

	    _proto.tsIsIdentifier = function tsIsIdentifier() {
	      return tokenIsIdentifier(this.state.type);
	    };

	    _proto.tsTokenCanFollowModifier = function tsTokenCanFollowModifier() {
	      return (this.match(0) || this.match(5) || this.match(51) || this.match(21) || this.match(130) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
	    };

	    _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
	      this.next();
	      return this.tsTokenCanFollowModifier();
	    };

	    _proto.tsParseModifier = function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
	      if (!tokenIsIdentifier(this.state.type)) {
	        return undefined;
	      }

	      var modifier = this.state.value;

	      if (allowedModifiers.indexOf(modifier) !== -1) {
	        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
	          return undefined;
	        }

	        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
	          return modifier;
	        }
	      }

	      return undefined;
	    };

	    _proto.tsParseModifiers = function tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
	      var _this = this;

	      var enforceOrder = function enforceOrder(pos, modifier, before, after) {
	        if (modifier === before && modified[after]) {
	          _this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
	        }
	      };

	      var incompatible = function incompatible(pos, modifier, mod1, mod2) {
	        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
	          _this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
	        }
	      };

	      for (;;) {
	        var startPos = this.state.start;
	        var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
	        if (!modifier) break;

	        if (tsIsAccessModifier(modifier)) {
	          if (modified.accessibility) {
	            this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
	          } else {
	            enforceOrder(startPos, modifier, modifier, "override");
	            enforceOrder(startPos, modifier, modifier, "static");
	            enforceOrder(startPos, modifier, modifier, "readonly");
	            modified.accessibility = modifier;
	          }
	        } else {
	          if (Object.hasOwnProperty.call(modified, modifier)) {
	            this.raise(startPos, TSErrors.DuplicateModifier, modifier);
	          } else {
	            enforceOrder(startPos, modifier, "static", "readonly");
	            enforceOrder(startPos, modifier, "static", "override");
	            enforceOrder(startPos, modifier, "override", "readonly");
	            enforceOrder(startPos, modifier, "abstract", "override");
	            incompatible(startPos, modifier, "declare", "override");
	            incompatible(startPos, modifier, "static", "abstract");
	          }

	          modified[modifier] = true;
	        }

	        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
	          this.raise(startPos, errorTemplate, modifier);
	        }
	      }
	    };

	    _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
	      switch (kind) {
	        case "EnumMembers":
	        case "TypeMembers":
	          return this.match(8);

	        case "HeritageClauseElement":
	          return this.match(5);

	        case "TupleElementTypes":
	          return this.match(3);

	        case "TypeParametersOrArguments":
	          return this.match(46);
	      }

	      throw new Error("Unreachable");
	    };

	    _proto.tsParseList = function tsParseList(kind, parseElement) {
	      var result = [];

	      while (!this.tsIsListTerminator(kind)) {
	        result.push(parseElement());
	      }

	      return result;
	    };

	    _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
	      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
	    };

	    _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
	      var result = [];
	      var trailingCommaPos = -1;

	      for (;;) {
	        if (this.tsIsListTerminator(kind)) {
	          break;
	        }

	        trailingCommaPos = -1;
	        var element = parseElement();

	        if (element == null) {
	          return undefined;
	        }

	        result.push(element);

	        if (this.eat(12)) {
	          trailingCommaPos = this.state.lastTokStart;
	          continue;
	        }

	        if (this.tsIsListTerminator(kind)) {
	          break;
	        }

	        if (expectSuccess) {
	          this.expect(12);
	        }

	        return undefined;
	      }

	      if (refTrailingCommaPos) {
	        refTrailingCommaPos.value = trailingCommaPos;
	      }

	      return result;
	    };

	    _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
	      if (!skipFirstToken) {
	        if (bracket) {
	          this.expect(0);
	        } else {
	          this.expect(45);
	        }
	      }

	      var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);

	      if (bracket) {
	        this.expect(3);
	      } else {
	        this.expect(46);
	      }

	      return result;
	    };

	    _proto.tsParseImportType = function tsParseImportType() {
	      var node = this.startNode();
	      this.expect(79);
	      this.expect(10);

	      if (!this.match(125)) {
	        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
	      }

	      node.argument = this.parseExprAtom();
	      this.expect(11);

	      if (this.eat(16)) {
	        node.qualifier = this.tsParseEntityName(true);
	      }

	      if (this.match(45)) {
	        node.typeParameters = this.tsParseTypeArguments();
	      }

	      return this.finishNode(node, "TSImportType");
	    };

	    _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
	      var entity = this.parseIdentifier();

	      while (this.eat(16)) {
	        var node = this.startNodeAtNode(entity);
	        node.left = entity;
	        node.right = this.parseIdentifier(allowReservedWords);
	        entity = this.finishNode(node, "TSQualifiedName");
	      }

	      return entity;
	    };

	    _proto.tsParseTypeReference = function tsParseTypeReference() {
	      var node = this.startNode();
	      node.typeName = this.tsParseEntityName(false);

	      if (!this.hasPrecedingLineBreak() && this.match(45)) {
	        node.typeParameters = this.tsParseTypeArguments();
	      }

	      return this.finishNode(node, "TSTypeReference");
	    };

	    _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
	      this.next();
	      var node = this.startNodeAtNode(lhs);
	      node.parameterName = lhs;
	      node.typeAnnotation = this.tsParseTypeAnnotation(false);
	      node.asserts = false;
	      return this.finishNode(node, "TSTypePredicate");
	    };

	    _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
	      var node = this.startNode();
	      this.next();
	      return this.finishNode(node, "TSThisType");
	    };

	    _proto.tsParseTypeQuery = function tsParseTypeQuery() {
	      var node = this.startNode();
	      this.expect(83);

	      if (this.match(79)) {
	        node.exprName = this.tsParseImportType();
	      } else {
	        node.exprName = this.tsParseEntityName(true);
	      }

	      return this.finishNode(node, "TSTypeQuery");
	    };

	    _proto.tsParseTypeParameter = function tsParseTypeParameter() {
	      var node = this.startNode();
	      node.name = this.tsParseTypeParameterName();
	      node.constraint = this.tsEatThenParseType(77);
	      node["default"] = this.tsEatThenParseType(29);
	      return this.finishNode(node, "TSTypeParameter");
	    };

	    _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
	      if (this.match(45)) {
	        return this.tsParseTypeParameters();
	      }
	    };

	    _proto.tsParseTypeParameters = function tsParseTypeParameters() {
	      var node = this.startNode();

	      if (this.match(45) || this.match(134)) {
	        this.next();
	      } else {
	        this.unexpected();
	      }

	      var refTrailingCommaPos = {
	        value: -1
	      };
	      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos);

	      if (node.params.length === 0) {
	        this.raise(node.start, TSErrors.EmptyTypeParameters);
	      }

	      if (refTrailingCommaPos.value !== -1) {
	        this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
	      }

	      return this.finishNode(node, "TSTypeParameterDeclaration");
	    };

	    _proto.tsTryNextParseConstantContext = function tsTryNextParseConstantContext() {
	      if (this.lookahead().type === 71) {
	        this.next();
	        return this.tsParseTypeReference();
	      }

	      return null;
	    };

	    _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
	      var returnTokenRequired = returnToken === 19;
	      signature.typeParameters = this.tsTryParseTypeParameters();
	      this.expect(10);
	      signature.parameters = this.tsParseBindingListForSignature();

	      if (returnTokenRequired) {
	        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	      } else if (this.match(returnToken)) {
	        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
	      }
	    };

	    _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
	      var _this2 = this;

	      return this.parseBindingList(11, 41).map(function (pattern) {
	        if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
	          _this2.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
	        }

	        return pattern;
	      });
	    };

	    _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
	      if (!this.eat(12) && !this.isLineTerminator()) {
	        this.expect(13);
	      }
	    };

	    _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
	      this.tsFillSignature(14, node);
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(node, kind);
	    };

	    _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
	      this.next();

	      if (tokenIsIdentifier(this.state.type)) {
	        this.next();
	        return this.match(14);
	      }

	      return false;
	    };

	    _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
	      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
	        return undefined;
	      }

	      this.expect(0);
	      var id = this.parseIdentifier();
	      id.typeAnnotation = this.tsParseTypeAnnotation();
	      this.resetEndLocation(id);
	      this.expect(3);
	      node.parameters = [id];
	      var type = this.tsTryParseTypeAnnotation();
	      if (type) node.typeAnnotation = type;
	      this.tsParseTypeMemberSemicolon();
	      return this.finishNode(node, "TSIndexSignature");
	    };

	    _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
	      if (this.eat(17)) node.optional = true;
	      var nodeAny = node;

	      if (this.match(10) || this.match(45)) {
	        if (readonly) {
	          this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
	        }

	        var method = nodeAny;

	        if (method.kind && this.match(45)) {
	          this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
	        }

	        this.tsFillSignature(14, method);
	        this.tsParseTypeMemberSemicolon();

	        if (method.kind === "get") {
	          if (method.parameters.length > 0) {
	            this.raise(this.state.pos, ErrorMessages.BadGetterArity);

	            if (this.isThisParam(method.parameters[0])) {
	              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
	            }
	          }
	        } else if (method.kind === "set") {
	          if (method.parameters.length !== 1) {
	            this.raise(this.state.pos, ErrorMessages.BadSetterArity);
	          } else {
	            var firstParameter = method.parameters[0];

	            if (this.isThisParam(firstParameter)) {
	              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
	            }

	            if (firstParameter.type === "Identifier" && firstParameter.optional) {
	              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
	            }

	            if (firstParameter.type === "RestElement") {
	              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
	            }
	          }

	          if (method.typeAnnotation) {
	            this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
	          }
	        } else {
	          method.kind = "method";
	        }

	        return this.finishNode(method, "TSMethodSignature");
	      } else {
	        var property = nodeAny;
	        if (readonly) property.readonly = true;
	        var type = this.tsTryParseTypeAnnotation();
	        if (type) property.typeAnnotation = type;
	        this.tsParseTypeMemberSemicolon();
	        return this.finishNode(property, "TSPropertySignature");
	      }
	    };

	    _proto.tsParseTypeMember = function tsParseTypeMember() {
	      var node = this.startNode();

	      if (this.match(10) || this.match(45)) {
	        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
	      }

	      if (this.match(73)) {
	        var id = this.startNode();
	        this.next();

	        if (this.match(10) || this.match(45)) {
	          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
	        } else {
	          node.key = this.createIdentifier(id, "new");
	          return this.tsParsePropertyOrMethodSignature(node, false);
	        }
	      }

	      this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
	      var idx = this.tsTryParseIndexSignature(node);

	      if (idx) {
	        return idx;
	      }

	      this.parsePropertyName(node);

	      if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
	        node.kind = node.key.name;
	        this.parsePropertyName(node);
	      }

	      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
	    };

	    _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
	      var node = this.startNode();
	      node.members = this.tsParseObjectTypeMembers();
	      return this.finishNode(node, "TSTypeLiteral");
	    };

	    _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
	      this.expect(5);
	      var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
	      this.expect(8);
	      return members;
	    };

	    _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
	      this.next();

	      if (this.eat(49)) {
	        return this.isContextual(114);
	      }

	      if (this.isContextual(114)) {
	        this.next();
	      }

	      if (!this.match(0)) {
	        return false;
	      }

	      this.next();

	      if (!this.tsIsIdentifier()) {
	        return false;
	      }

	      this.next();
	      return this.match(54);
	    };

	    _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
	      var node = this.startNode();
	      node.name = this.tsParseTypeParameterName();
	      node.constraint = this.tsExpectThenParseType(54);
	      return this.finishNode(node, "TSTypeParameter");
	    };

	    _proto.tsParseMappedType = function tsParseMappedType() {
	      var node = this.startNode();
	      this.expect(5);

	      if (this.match(49)) {
	        node.readonly = this.state.value;
	        this.next();
	        this.expectContextual(114);
	      } else if (this.eatContextual(114)) {
	        node.readonly = true;
	      }

	      this.expect(0);
	      node.typeParameter = this.tsParseMappedTypeParameter();
	      node.nameType = this.eatContextual(89) ? this.tsParseType() : null;
	      this.expect(3);

	      if (this.match(49)) {
	        node.optional = this.state.value;
	        this.next();
	        this.expect(17);
	      } else if (this.eat(17)) {
	        node.optional = true;
	      }

	      node.typeAnnotation = this.tsTryParseType();
	      this.semicolon();
	      this.expect(8);
	      return this.finishNode(node, "TSMappedType");
	    };

	    _proto.tsParseTupleType = function tsParseTupleType() {
	      var _this3 = this;

	      var node = this.startNode();
	      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
	      var seenOptionalElement = false;
	      var labeledElements = null;
	      node.elementTypes.forEach(function (elementNode) {
	        var _labeledElements;

	        var _elementNode = elementNode,
	            type = _elementNode.type;

	        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
	          _this3.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
	        }

	        seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

	        if (type === "TSRestType") {
	          elementNode = elementNode.typeAnnotation;
	          type = elementNode.type;
	        }

	        var isLabeled = type === "TSNamedTupleMember";
	        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

	        if (labeledElements !== isLabeled) {
	          _this3.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
	        }
	      });
	      return this.finishNode(node, "TSTupleType");
	    };

	    _proto.tsParseTupleElementType = function tsParseTupleElementType() {
	      var _this$state = this.state,
	          startPos = _this$state.start,
	          startLoc = _this$state.startLoc;
	      var rest = this.eat(21);
	      var type = this.tsParseType();
	      var optional = this.eat(17);
	      var labeled = this.eat(14);

	      if (labeled) {
	        var labeledNode = this.startNodeAtNode(type);
	        labeledNode.optional = optional;

	        if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
	          labeledNode.label = type.typeName;
	        } else {
	          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
	          labeledNode.label = type;
	        }

	        labeledNode.elementType = this.tsParseType();
	        type = this.finishNode(labeledNode, "TSNamedTupleMember");
	      } else if (optional) {
	        var optionalTypeNode = this.startNodeAtNode(type);
	        optionalTypeNode.typeAnnotation = type;
	        type = this.finishNode(optionalTypeNode, "TSOptionalType");
	      }

	      if (rest) {
	        var restNode = this.startNodeAt(startPos, startLoc);
	        restNode.typeAnnotation = type;
	        type = this.finishNode(restNode, "TSRestType");
	      }

	      return type;
	    };

	    _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
	      var node = this.startNode();
	      this.expect(10);
	      node.typeAnnotation = this.tsParseType();
	      this.expect(11);
	      return this.finishNode(node, "TSParenthesizedType");
	    };

	    _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type, _abstract) {
	      var node = this.startNode();

	      if (type === "TSConstructorType") {
	        node["abstract"] = !!_abstract;
	        if (_abstract) this.next();
	        this.next();
	      }

	      this.tsFillSignature(19, node);
	      return this.finishNode(node, type);
	    };

	    _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
	      var _this4 = this;

	      var node = this.startNode();

	      node.literal = function () {
	        switch (_this4.state.type) {
	          case 126:
	          case 127:
	          case 125:
	          case 81:
	          case 82:
	            return _this4.parseExprAtom();

	          default:
	            throw _this4.unexpected();
	        }
	      }();

	      return this.finishNode(node, "TSLiteralType");
	    };

	    _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
	      var node = this.startNode();
	      node.literal = this.parseTemplate(false);
	      return this.finishNode(node, "TSLiteralType");
	    };

	    _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
	      if (this.state.inType) return this.tsParseType();
	      return _superClass.prototype.parseTemplateSubstitution.call(this);
	    };

	    _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
	      var thisKeyword = this.tsParseThisTypeNode();

	      if (this.isContextual(109) && !this.hasPrecedingLineBreak()) {
	        return this.tsParseThisTypePredicate(thisKeyword);
	      } else {
	        return thisKeyword;
	      }
	    };

	    _proto.tsParseNonArrayType = function tsParseNonArrayType() {
	      switch (this.state.type) {
	        case 125:
	        case 126:
	        case 127:
	        case 81:
	        case 82:
	          return this.tsParseLiteralTypeNode();

	        case 49:
	          if (this.state.value === "-") {
	            var node = this.startNode();
	            var nextToken = this.lookahead();

	            if (nextToken.type !== 126 && nextToken.type !== 127) {
	              throw this.unexpected();
	            }

	            node.literal = this.parseMaybeUnary();
	            return this.finishNode(node, "TSLiteralType");
	          }

	          break;

	        case 74:
	          return this.tsParseThisTypeOrThisTypePredicate();

	        case 83:
	          return this.tsParseTypeQuery();

	        case 79:
	          return this.tsParseImportType();

	        case 5:
	          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

	        case 0:
	          return this.tsParseTupleType();

	        case 10:
	          return this.tsParseParenthesizedType();

	        case 25:
	        case 24:
	          return this.tsParseTemplateLiteralType();

	        default:
	          {
	            var type = this.state.type;

	            if (tokenIsIdentifier(type) || type === 84 || type === 80) {
	              var nodeType = type === 84 ? "TSVoidKeyword" : type === 80 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

	              if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
	                var _node = this.startNode();

	                this.next();
	                return this.finishNode(_node, nodeType);
	              }

	              return this.tsParseTypeReference();
	            }
	          }
	      }

	      throw this.unexpected();
	    };

	    _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
	      var type = this.tsParseNonArrayType();

	      while (!this.hasPrecedingLineBreak() && this.eat(0)) {
	        if (this.match(3)) {
	          var node = this.startNodeAtNode(type);
	          node.elementType = type;
	          this.expect(3);
	          type = this.finishNode(node, "TSArrayType");
	        } else {
	          var _node2 = this.startNodeAtNode(type);

	          _node2.objectType = type;
	          _node2.indexType = this.tsParseType();
	          this.expect(3);
	          type = this.finishNode(_node2, "TSIndexedAccessType");
	        }
	      }

	      return type;
	    };

	    _proto.tsParseTypeOperator = function tsParseTypeOperator() {
	      var node = this.startNode();
	      var operator = this.state.value;
	      this.next();
	      node.operator = operator;
	      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

	      if (operator === "readonly") {
	        this.tsCheckTypeAnnotationForReadOnly(node);
	      }

	      return this.finishNode(node, "TSTypeOperator");
	    };

	    _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
	      switch (node.typeAnnotation.type) {
	        case "TSTupleType":
	        case "TSArrayType":
	          return;

	        default:
	          this.raise(node.start, TSErrors.UnexpectedReadonly);
	      }
	    };

	    _proto.tsParseInferType = function tsParseInferType() {
	      var node = this.startNode();
	      this.expectContextual(108);
	      var typeParameter = this.startNode();
	      typeParameter.name = this.tsParseTypeParameterName();
	      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
	      return this.finishNode(node, "TSInferType");
	    };

	    _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
	      var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
	      return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(108) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
	    };

	    _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
	      var node = this.startNode();
	      var hasLeadingOperator = this.eat(operator);
	      var types = [];

	      do {
	        types.push(parseConstituentType());
	      } while (this.eat(operator));

	      if (types.length === 1 && !hasLeadingOperator) {
	        return types[0];
	      }

	      node.types = types;
	      return this.finishNode(node, kind);
	    };

	    _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
	      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 43);
	    };

	    _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
	      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 41);
	    };

	    _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
	      if (this.match(45)) {
	        return true;
	      }

	      return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
	    };

	    _proto.tsSkipParameterStart = function tsSkipParameterStart() {
	      if (tokenIsIdentifier(this.state.type) || this.match(74)) {
	        this.next();
	        return true;
	      }

	      if (this.match(5)) {
	        var braceStackCounter = 1;
	        this.next();

	        while (braceStackCounter > 0) {
	          if (this.match(5)) {
	            ++braceStackCounter;
	          } else if (this.match(8)) {
	            --braceStackCounter;
	          }

	          this.next();
	        }

	        return true;
	      }

	      if (this.match(0)) {
	        var _braceStackCounter = 1;
	        this.next();

	        while (_braceStackCounter > 0) {
	          if (this.match(0)) {
	            ++_braceStackCounter;
	          } else if (this.match(3)) {
	            --_braceStackCounter;
	          }

	          this.next();
	        }

	        return true;
	      }

	      return false;
	    };

	    _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
	      this.next();

	      if (this.match(11) || this.match(21)) {
	        return true;
	      }

	      if (this.tsSkipParameterStart()) {
	        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
	          return true;
	        }

	        if (this.match(11)) {
	          this.next();

	          if (this.match(19)) {
	            return true;
	          }
	        }
	      }

	      return false;
	    };

	    _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
	      var _this5 = this;

	      return this.tsInType(function () {
	        var t = _this5.startNode();

	        _this5.expect(returnToken);

	        var node = _this5.startNode();

	        var asserts = !!_this5.tsTryParse(_this5.tsParseTypePredicateAsserts.bind(_this5));

	        if (asserts && _this5.match(74)) {
	          var thisTypePredicate = _this5.tsParseThisTypeOrThisTypePredicate();

	          if (thisTypePredicate.type === "TSThisType") {
	            node.parameterName = thisTypePredicate;
	            node.asserts = true;
	            node.typeAnnotation = null;
	            thisTypePredicate = _this5.finishNode(node, "TSTypePredicate");
	          } else {
	            _this5.resetStartLocationFromNode(thisTypePredicate, node);

	            thisTypePredicate.asserts = true;
	          }

	          t.typeAnnotation = thisTypePredicate;
	          return _this5.finishNode(t, "TSTypeAnnotation");
	        }

	        var typePredicateVariable = _this5.tsIsIdentifier() && _this5.tsTryParse(_this5.tsParseTypePredicatePrefix.bind(_this5));

	        if (!typePredicateVariable) {
	          if (!asserts) {
	            return _this5.tsParseTypeAnnotation(false, t);
	          }

	          node.parameterName = _this5.parseIdentifier();
	          node.asserts = asserts;
	          node.typeAnnotation = null;
	          t.typeAnnotation = _this5.finishNode(node, "TSTypePredicate");
	          return _this5.finishNode(t, "TSTypeAnnotation");
	        }

	        var type = _this5.tsParseTypeAnnotation(false);

	        node.parameterName = typePredicateVariable;
	        node.typeAnnotation = type;
	        node.asserts = asserts;
	        t.typeAnnotation = _this5.finishNode(node, "TSTypePredicate");
	        return _this5.finishNode(t, "TSTypeAnnotation");
	      });
	    };

	    _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
	      return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;
	    };

	    _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
	      return this.match(14) ? this.tsParseTypeAnnotation() : undefined;
	    };

	    _proto.tsTryParseType = function tsTryParseType() {
	      return this.tsEatThenParseType(14);
	    };

	    _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
	      var id = this.parseIdentifier();

	      if (this.isContextual(109) && !this.hasPrecedingLineBreak()) {
	        this.next();
	        return id;
	      }
	    };

	    _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
	      if (this.state.type !== 102) {
	        return false;
	      }

	      var containsEsc = this.state.containsEsc;
	      this.next();

	      if (!tokenIsIdentifier(this.state.type) && !this.match(74)) {
	        return false;
	      }

	      if (containsEsc) {
	        this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
	      }

	      return true;
	    };

	    _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
	      var _this6 = this;

	      if (eatColon === void 0) {
	        eatColon = true;
	      }

	      if (t === void 0) {
	        t = this.startNode();
	      }

	      this.tsInType(function () {
	        if (eatColon) _this6.expect(14);
	        t.typeAnnotation = _this6.tsParseType();
	      });
	      return this.finishNode(t, "TSTypeAnnotation");
	    };

	    _proto.tsParseType = function tsParseType() {
	      assert(this.state.inType);
	      var type = this.tsParseNonConditionalType();

	      if (this.hasPrecedingLineBreak() || !this.eat(77)) {
	        return type;
	      }

	      var node = this.startNodeAtNode(type);
	      node.checkType = type;
	      node.extendsType = this.tsParseNonConditionalType();
	      this.expect(17);
	      node.trueType = this.tsParseType();
	      this.expect(14);
	      node.falseType = this.tsParseType();
	      return this.finishNode(node, "TSConditionalType");
	    };

	    _proto.isAbstractConstructorSignature = function isAbstractConstructorSignature() {
	      return this.isContextual(116) && this.lookahead().type === 73;
	    };

	    _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
	      if (this.tsIsStartOfFunctionType()) {
	        return this.tsParseFunctionOrConstructorType("TSFunctionType");
	      }

	      if (this.match(73)) {
	        return this.tsParseFunctionOrConstructorType("TSConstructorType");
	      } else if (this.isAbstractConstructorSignature()) {
	        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
	      }

	      return this.tsParseUnionTypeOrHigher();
	    };

	    _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
	      if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	        this.raise(this.state.start, TSErrors.ReservedTypeAssertion);
	      }

	      var node = this.startNode();

	      var _const = this.tsTryNextParseConstantContext();

	      node.typeAnnotation = _const || this.tsNextThenParseType();
	      this.expect(46);
	      node.expression = this.parseMaybeUnary();
	      return this.finishNode(node, "TSTypeAssertion");
	    };

	    _proto.tsParseHeritageClause = function tsParseHeritageClause(descriptor) {
	      var originalStart = this.state.start;
	      var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

	      if (!delimitedList.length) {
	        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
	      }

	      return delimitedList;
	    };

	    _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
	      var node = this.startNode();
	      node.expression = this.tsParseEntityName(false);

	      if (this.match(45)) {
	        node.typeParameters = this.tsParseTypeArguments();
	      }

	      return this.finishNode(node, "TSExpressionWithTypeArguments");
	    };

	    _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
	      if (tokenIsIdentifier(this.state.type)) {
	        node.id = this.parseIdentifier();
	        this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
	      } else {
	        node.id = null;
	        this.raise(this.state.start, TSErrors.MissingInterfaceName);
	      }

	      node.typeParameters = this.tsTryParseTypeParameters();

	      if (this.eat(77)) {
	        node["extends"] = this.tsParseHeritageClause("extends");
	      }

	      var body = this.startNode();
	      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
	      node.body = this.finishNode(body, "TSInterfaceBody");
	      return this.finishNode(node, "TSInterfaceDeclaration");
	    };

	    _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
	      var _this7 = this;

	      node.id = this.parseIdentifier();
	      this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
	      node.typeParameters = this.tsTryParseTypeParameters();
	      node.typeAnnotation = this.tsInType(function () {
	        _this7.expect(29);

	        if (_this7.isContextual(107) && _this7.lookahead().type !== 16) {
	          var _node3 = _this7.startNode();

	          _this7.next();

	          return _this7.finishNode(_node3, "TSIntrinsicKeyword");
	        }

	        return _this7.tsParseType();
	      });
	      this.semicolon();
	      return this.finishNode(node, "TSTypeAliasDeclaration");
	    };

	    _proto.tsInNoContext = function tsInNoContext(cb) {
	      var oldContext = this.state.context;
	      this.state.context = [oldContext[0]];

	      try {
	        return cb();
	      } finally {
	        this.state.context = oldContext;
	      }
	    };

	    _proto.tsInType = function tsInType(cb) {
	      var oldInType = this.state.inType;
	      this.state.inType = true;

	      try {
	        return cb();
	      } finally {
	        this.state.inType = oldInType;
	      }
	    };

	    _proto.tsEatThenParseType = function tsEatThenParseType(token) {
	      return !this.match(token) ? undefined : this.tsNextThenParseType();
	    };

	    _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
	      var _this8 = this;

	      return this.tsDoThenParseType(function () {
	        return _this8.expect(token);
	      });
	    };

	    _proto.tsNextThenParseType = function tsNextThenParseType() {
	      var _this9 = this;

	      return this.tsDoThenParseType(function () {
	        return _this9.next();
	      });
	    };

	    _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
	      var _this10 = this;

	      return this.tsInType(function () {
	        cb();
	        return _this10.tsParseType();
	      });
	    };

	    _proto.tsParseEnumMember = function tsParseEnumMember() {
	      var node = this.startNode();
	      node.id = this.match(125) ? this.parseExprAtom() : this.parseIdentifier(true);

	      if (this.eat(29)) {
	        node.initializer = this.parseMaybeAssignAllowIn();
	      }

	      return this.finishNode(node, "TSEnumMember");
	    };

	    _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
	      if (isConst) node["const"] = true;
	      node.id = this.parseIdentifier();
	      this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
	      this.expect(5);
	      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
	      this.expect(8);
	      return this.finishNode(node, "TSEnumDeclaration");
	    };

	    _proto.tsParseModuleBlock = function tsParseModuleBlock() {
	      var node = this.startNode();
	      this.scope.enter(SCOPE_OTHER);
	      this.expect(5);
	      this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);
	      this.scope.exit();
	      return this.finishNode(node, "TSModuleBlock");
	    };

	    _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
	      if (nested === void 0) {
	        nested = false;
	      }

	      node.id = this.parseIdentifier();

	      if (!nested) {
	        this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
	      }

	      if (this.eat(16)) {
	        var inner = this.startNode();
	        this.tsParseModuleOrNamespaceDeclaration(inner, true);
	        node.body = inner;
	      } else {
	        this.scope.enter(SCOPE_TS_MODULE);
	        this.prodParam.enter(PARAM);
	        node.body = this.tsParseModuleBlock();
	        this.prodParam.exit();
	        this.scope.exit();
	      }

	      return this.finishNode(node, "TSModuleDeclaration");
	    };

	    _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
	      if (this.isContextual(105)) {
	        node.global = true;
	        node.id = this.parseIdentifier();
	      } else if (this.match(125)) {
	        node.id = this.parseExprAtom();
	      } else {
	        this.unexpected();
	      }

	      if (this.match(5)) {
	        this.scope.enter(SCOPE_TS_MODULE);
	        this.prodParam.enter(PARAM);
	        node.body = this.tsParseModuleBlock();
	        this.prodParam.exit();
	        this.scope.exit();
	      } else {
	        this.semicolon();
	      }

	      return this.finishNode(node, "TSModuleDeclaration");
	    };

	    _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
	      node.isExport = isExport || false;
	      node.id = this.parseIdentifier();
	      this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
	      this.expect(29);
	      var moduleReference = this.tsParseModuleReference();

	      if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
	        this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
	      }

	      node.moduleReference = moduleReference;
	      this.semicolon();
	      return this.finishNode(node, "TSImportEqualsDeclaration");
	    };

	    _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
	      return this.isContextual(112) && this.lookaheadCharCode() === 40;
	    };

	    _proto.tsParseModuleReference = function tsParseModuleReference() {
	      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
	    };

	    _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
	      var node = this.startNode();
	      this.expectContextual(112);
	      this.expect(10);

	      if (!this.match(125)) {
	        throw this.unexpected();
	      }

	      node.expression = this.parseExprAtom();
	      this.expect(11);
	      return this.finishNode(node, "TSExternalModuleReference");
	    };

	    _proto.tsLookAhead = function tsLookAhead(f) {
	      var state = this.state.clone();
	      var res = f();
	      this.state = state;
	      return res;
	    };

	    _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
	      var result = this.tryParse(function (abort) {
	        return f() || abort();
	      });
	      if (result.aborted || !result.node) return undefined;
	      if (result.error) this.state = result.failState;
	      return result.node;
	    };

	    _proto.tsTryParse = function tsTryParse(f) {
	      var state = this.state.clone();
	      var result = f();

	      if (result !== undefined && result !== false) {
	        return result;
	      } else {
	        this.state = state;
	        return undefined;
	      }
	    };

	    _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
	      var _this11 = this;

	      if (this.isLineTerminator()) {
	        return;
	      }

	      var starttype = this.state.type;
	      var kind;

	      if (this.isContextual(95)) {
	        starttype = 70;
	        kind = "let";
	      }

	      return this.tsInAmbientContext(function () {
	        switch (starttype) {
	          case 64:
	            nany.declare = true;
	            return _this11.parseFunctionStatement(nany, false, true);

	          case 76:
	            nany.declare = true;
	            return _this11.parseClass(nany, true, false);

	          case 71:
	            if (_this11.match(71) && _this11.isLookaheadContextual("enum")) {
	              _this11.expect(71);

	              _this11.expectContextual(118);

	              return _this11.tsParseEnumDeclaration(nany, true);
	            }

	          case 70:
	            kind = kind || _this11.state.value;
	            return _this11.parseVarStatement(nany, kind);

	          case 105:
	            return _this11.tsParseAmbientExternalModuleDeclaration(nany);

	          default:
	            {
	              if (tokenIsIdentifier(starttype)) {
	                return _this11.tsParseDeclaration(nany, _this11.state.value, true);
	              }
	            }
	        }
	      });
	    };

	    _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
	      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
	    };

	    _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
	      switch (expr.name) {
	        case "declare":
	          {
	            var declaration = this.tsTryParseDeclare(node);

	            if (declaration) {
	              declaration.declare = true;
	              return declaration;
	            }

	            break;
	          }

	        case "global":
	          if (this.match(5)) {
	            this.scope.enter(SCOPE_TS_MODULE);
	            this.prodParam.enter(PARAM);
	            var mod = node;
	            mod.global = true;
	            mod.id = expr;
	            mod.body = this.tsParseModuleBlock();
	            this.scope.exit();
	            this.prodParam.exit();
	            return this.finishNode(mod, "TSModuleDeclaration");
	          }

	          break;

	        default:
	          return this.tsParseDeclaration(node, expr.name, false);
	      }
	    };

	    _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
	      switch (value) {
	        case "abstract":
	          if (this.tsCheckLineTerminator(next) && (this.match(76) || tokenIsIdentifier(this.state.type))) {
	            return this.tsParseAbstractDeclaration(node);
	          }

	          break;

	        case "enum":
	          if (next || tokenIsIdentifier(this.state.type)) {
	            if (next) this.next();
	            return this.tsParseEnumDeclaration(node, false);
	          }

	          break;

	        case "interface":
	          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	            return this.tsParseInterfaceDeclaration(node);
	          }

	          break;

	        case "module":
	          if (this.tsCheckLineTerminator(next)) {
	            if (this.match(125)) {
	              return this.tsParseAmbientExternalModuleDeclaration(node);
	            } else if (tokenIsIdentifier(this.state.type)) {
	              return this.tsParseModuleOrNamespaceDeclaration(node);
	            }
	          }

	          break;

	        case "namespace":
	          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	            return this.tsParseModuleOrNamespaceDeclaration(node);
	          }

	          break;

	        case "type":
	          if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
	            return this.tsParseTypeAliasDeclaration(node);
	          }

	          break;
	      }
	    };

	    _proto.tsCheckLineTerminator = function tsCheckLineTerminator(next) {
	      if (next) {
	        if (this.hasFollowingLineBreak()) return false;
	        this.next();
	        return true;
	      }

	      return !this.isLineTerminator();
	    };

	    _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
	      var _this12 = this;

	      if (!this.match(45)) {
	        return undefined;
	      }

	      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	      this.state.maybeInArrowParameters = true;
	      var res = this.tsTryParseAndCatch(function () {
	        var node = _this12.startNodeAt(startPos, startLoc);

	        node.typeParameters = _this12.tsParseTypeParameters();

	        _superClass.prototype.parseFunctionParams.call(_this12, node);

	        node.returnType = _this12.tsTryParseTypeOrTypePredicateAnnotation();

	        _this12.expect(19);

	        return node;
	      });
	      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

	      if (!res) {
	        return undefined;
	      }

	      return this.parseArrowExpression(res, null, true);
	    };

	    _proto.tsParseTypeArguments = function tsParseTypeArguments() {
	      var _this13 = this;

	      var node = this.startNode();
	      node.params = this.tsInType(function () {
	        return _this13.tsInNoContext(function () {
	          _this13.expect(45);

	          return _this13.tsParseDelimitedList("TypeParametersOrArguments", _this13.tsParseType.bind(_this13));
	        });
	      });

	      if (node.params.length === 0) {
	        this.raise(node.start, TSErrors.EmptyTypeArguments);
	      }

	      this.expect(46);
	      return this.finishNode(node, "TSTypeParameterInstantiation");
	    };

	    _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
	      return tokenIsTSDeclarationStart(this.state.type);
	    };

	    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	      if (this.tsIsDeclarationStart()) return false;
	      return _superClass.prototype.isExportDefaultSpecifier.call(this);
	    };

	    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var accessibility;
	      var readonly = false;
	      var override = false;

	      if (allowModifiers !== undefined) {
	        var modified = {};
	        this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
	        accessibility = modified.accessibility;
	        override = modified.override;
	        readonly = modified.readonly;

	        if (allowModifiers === false && (accessibility || readonly || override)) {
	          this.raise(startPos, TSErrors.UnexpectedParameterModifier);
	        }
	      }

	      var left = this.parseMaybeDefault();
	      this.parseAssignableListItemTypes(left);
	      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

	      if (accessibility || readonly || override) {
	        var pp = this.startNodeAt(startPos, startLoc);

	        if (decorators.length) {
	          pp.decorators = decorators;
	        }

	        if (accessibility) pp.accessibility = accessibility;
	        if (readonly) pp.readonly = readonly;
	        if (override) pp.override = override;

	        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
	          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
	        }

	        pp.parameter = elt;
	        return this.finishNode(pp, "TSParameterProperty");
	      }

	      if (decorators.length) {
	        left.decorators = decorators;
	      }

	      return elt;
	    };

	    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
	      if (isMethod === void 0) {
	        isMethod = false;
	      }

	      if (this.match(14)) {
	        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
	      }

	      var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;

	      if (bodilessType && !this.match(5) && this.isLineTerminator()) {
	        this.finishNode(node, bodilessType);
	        return;
	      }

	      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
	        this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

	        if (node.declare) {
	          _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, bodilessType, isMethod);

	          return;
	        }
	      }

	      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
	    };

	    _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
	      if (!node.body && node.id) {
	        this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
	      } else {
	        _superClass.prototype.registerFunctionStatementId.apply(this, arguments);
	      }
	    };

	    _proto.tsCheckForInvalidTypeCasts = function tsCheckForInvalidTypeCasts(items) {
	      var _this14 = this;

	      items.forEach(function (node) {
	        if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
	          _this14.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
	        }
	      });
	    };

	    _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
	      this.tsCheckForInvalidTypeCasts(exprList);
	      return exprList;
	    };

	    _proto.parseArrayLike = function parseArrayLike() {
	      var _superClass$prototype;

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      var node = (_superClass$prototype = _superClass.prototype.parseArrayLike).call.apply(_superClass$prototype, [this].concat(args));

	      if (node.type === "ArrayExpression") {
	        this.tsCheckForInvalidTypeCasts(node.elements);
	      }

	      return node;
	    };

	    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
	      var _this15 = this;

	      if (!this.hasPrecedingLineBreak() && this.match(35)) {
	        this.state.canStartJSXElement = false;
	        this.next();
	        var nonNullExpression = this.startNodeAt(startPos, startLoc);
	        nonNullExpression.expression = base;
	        return this.finishNode(nonNullExpression, "TSNonNullExpression");
	      }

	      var isOptionalCall = false;

	      if (this.match(18) && this.lookaheadCharCode() === 60) {
	        if (noCalls) {
	          state.stop = true;
	          return base;
	        }

	        state.optionalChainMember = isOptionalCall = true;
	        this.next();
	      }

	      if (this.match(45)) {
	        var missingParenErrorPos;
	        var result = this.tsTryParseAndCatch(function () {
	          if (!noCalls && _this15.atPossibleAsyncArrow(base)) {
	            var asyncArrowFn = _this15.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

	            if (asyncArrowFn) {
	              return asyncArrowFn;
	            }
	          }

	          var node = _this15.startNodeAt(startPos, startLoc);

	          node.callee = base;

	          var typeArguments = _this15.tsParseTypeArguments();

	          if (typeArguments) {
	            if (isOptionalCall && !_this15.match(10)) {
	              missingParenErrorPos = _this15.state.pos;

	              _this15.unexpected();
	            }

	            if (!noCalls && _this15.eat(10)) {
	              node.arguments = _this15.parseCallExpressionArguments(11, false);

	              _this15.tsCheckForInvalidTypeCasts(node.arguments);

	              node.typeParameters = typeArguments;

	              if (state.optionalChainMember) {
	                node.optional = isOptionalCall;
	              }

	              return _this15.finishCallExpression(node, state.optionalChainMember);
	            } else if (tokenIsTemplate(_this15.state.type)) {
	              var _result = _this15.parseTaggedTemplateExpression(base, startPos, startLoc, state);

	              _result.typeParameters = typeArguments;
	              return _result;
	            }
	          }

	          _this15.unexpected();
	        });

	        if (missingParenErrorPos) {
	          this.unexpected(missingParenErrorPos, 10);
	        }

	        if (result) return result;
	      }

	      return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
	    };

	    _proto.parseNewArguments = function parseNewArguments(node) {
	      var _this16 = this;

	      if (this.match(45)) {
	        var typeParameters = this.tsTryParseAndCatch(function () {
	          var args = _this16.tsParseTypeArguments();

	          if (!_this16.match(10)) _this16.unexpected();
	          return args;
	        });

	        if (typeParameters) {
	          node.typeParameters = typeParameters;
	        }
	      }

	      _superClass.prototype.parseNewArguments.call(this, node);
	    };

	    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
	      if (tokenOperatorPrecedence(54) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(89)) {
	        var node = this.startNodeAt(leftStartPos, leftStartLoc);
	        node.expression = left;

	        var _const = this.tsTryNextParseConstantContext();

	        if (_const) {
	          node.typeAnnotation = _const;
	        } else {
	          node.typeAnnotation = this.tsNextThenParseType();
	        }

	        this.finishNode(node, "TSAsExpression");
	        this.reScan_lt_gt();
	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
	      }

	      return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec);
	    };

	    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

	    _proto.checkDuplicateExports = function checkDuplicateExports() {};

	    _proto.parseImport = function parseImport(node) {
	      node.importKind = "value";

	      if (tokenIsIdentifier(this.state.type) || this.match(51) || this.match(5)) {
	        var ahead = this.lookahead();

	        if (this.isContextual(122) && ahead.type !== 12 && ahead.type !== 93 && ahead.type !== 29) {
	          node.importKind = "type";
	          this.next();
	          ahead = this.lookahead();
	        }

	        if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
	          return this.tsParseImportEqualsDeclaration(node);
	        }
	      }

	      var importNode = _superClass.prototype.parseImport.call(this, node);

	      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
	        this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
	      }

	      return importNode;
	    };

	    _proto.parseExport = function parseExport(node) {
	      if (this.match(79)) {
	        this.next();

	        if (this.isContextual(122) && this.lookaheadCharCode() !== 61) {
	          node.importKind = "type";
	          this.next();
	        } else {
	          node.importKind = "value";
	        }

	        return this.tsParseImportEqualsDeclaration(node, true);
	      } else if (this.eat(29)) {
	        var assign = node;
	        assign.expression = this.parseExpression();
	        this.semicolon();
	        return this.finishNode(assign, "TSExportAssignment");
	      } else if (this.eatContextual(89)) {
	        var decl = node;
	        this.expectContextual(120);
	        decl.id = this.parseIdentifier();
	        this.semicolon();
	        return this.finishNode(decl, "TSNamespaceExportDeclaration");
	      } else {
	        if (this.isContextual(122) && this.lookahead().type === 5) {
	          this.next();
	          node.exportKind = "type";
	        } else {
	          node.exportKind = "value";
	        }

	        return _superClass.prototype.parseExport.call(this, node);
	      }
	    };

	    _proto.isAbstractClass = function isAbstractClass() {
	      return this.isContextual(116) && this.lookahead().type === 76;
	    };

	    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
	      if (this.isAbstractClass()) {
	        var cls = this.startNode();
	        this.next();
	        cls["abstract"] = true;
	        this.parseClass(cls, true, true);
	        return cls;
	      }

	      if (this.match(121)) {
	        var interfaceNode = this.startNode();
	        this.next();
	        var result = this.tsParseInterfaceDeclaration(interfaceNode);
	        if (result) return result;
	      }

	      return _superClass.prototype.parseExportDefaultExpression.call(this);
	    };

	    _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
	      if (this.state.type === 71) {
	        var ahead = this.lookahead();

	        if (ahead.type === 118) {
	          var node = this.startNode();
	          this.next();
	          this.expectContextual(118);
	          return this.tsParseEnumDeclaration(node, true);
	        }
	      }

	      return _superClass.prototype.parseStatementContent.call(this, context, topLevel);
	    };

	    _proto.parseAccessModifier = function parseAccessModifier() {
	      return this.tsParseModifier(["public", "protected", "private"]);
	    };

	    _proto.tsHasSomeModifiers = function tsHasSomeModifiers(member, modifiers) {
	      return modifiers.some(function (modifier) {
	        if (tsIsAccessModifier(modifier)) {
	          return member.accessibility === modifier;
	        }

	        return !!member[modifier];
	      });
	    };

	    _proto.tsIsStartOfStaticBlocks = function tsIsStartOfStaticBlocks() {
	      return this.isContextual(100) && this.lookaheadCharCode() === 123;
	    };

	    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
	      var _this17 = this;

	      var modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
	      this.tsParseModifiers(member, modifiers, undefined, undefined, true);

	      var callParseClassMemberWithIsStatic = function callParseClassMemberWithIsStatic() {
	        if (_this17.tsIsStartOfStaticBlocks()) {
	          _this17.next();

	          _this17.next();

	          if (_this17.tsHasSomeModifiers(member, modifiers)) {
	            _this17.raise(_this17.state.pos, TSErrors.StaticBlockCannotHaveModifier);
	          }

	          _this17.parseClassStaticBlock(classBody, member);
	        } else {
	          _this17.parseClassMemberWithIsStatic(classBody, member, state, !!member["static"]);
	        }
	      };

	      if (member.declare) {
	        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
	      } else {
	        callParseClassMemberWithIsStatic();
	      }
	    };

	    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	      var idx = this.tsTryParseIndexSignature(member);

	      if (idx) {
	        classBody.body.push(idx);

	        if (member["abstract"]) {
	          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
	        }

	        if (member.accessibility) {
	          this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
	        }

	        if (member.declare) {
	          this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
	        }

	        if (member.override) {
	          this.raise(member.start, TSErrors.IndexSignatureHasOverride);
	        }

	        return;
	      }

	      if (!this.state.inAbstractClass && member["abstract"]) {
	        this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
	      }

	      if (member.override) {
	        if (!state.hadSuperClass) {
	          this.raise(member.start, TSErrors.OverrideNotInSubClass);
	        }
	      }

	      _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);
	    };

	    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
	      var optional = this.eat(17);
	      if (optional) methodOrProp.optional = true;

	      if (methodOrProp.readonly && this.match(10)) {
	        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
	      }

	      if (methodOrProp.declare && this.match(10)) {
	        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
	      }
	    };

	    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	      var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
	      return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
	    };

	    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	      if (this.tsIsDeclarationStart()) return true;
	      return _superClass.prototype.shouldParseExportDeclaration.call(this);
	    };

	    _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
	      var _this18 = this;

	      if (!this.state.maybeInArrowParameters || !this.match(17)) {
	        return _superClass.prototype.parseConditional.call(this, expr, startPos, startLoc, refExpressionErrors);
	      }

	      var result = this.tryParse(function () {
	        return _superClass.prototype.parseConditional.call(_this18, expr, startPos, startLoc);
	      });

	      if (!result.node) {
	        if (result.error) {
	          _superClass.prototype.setOptionalParametersError.call(this, refExpressionErrors, result.error);
	        }

	        return expr;
	      }

	      if (result.error) this.state = result.failState;
	      return result.node;
	    };

	    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

	      if (this.eat(17)) {
	        node.optional = true;
	        this.resetEndLocation(node);
	      }

	      if (this.match(14)) {
	        var typeCastNode = this.startNodeAt(startPos, startLoc);
	        typeCastNode.expression = node;
	        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
	        return this.finishNode(typeCastNode, "TSTypeCastExpression");
	      }

	      return node;
	    };

	    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var isDeclare = this.eatContextual(117);

	      if (isDeclare && (this.isContextual(117) || !this.shouldParseExportDeclaration())) {
	        throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
	      }

	      var declaration;

	      if (tokenIsIdentifier(this.state.type)) {
	        declaration = this.tsTryParseExportDeclaration();
	      }

	      if (!declaration) {
	        declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
	      }

	      if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
	        node.exportKind = "type";
	      }

	      if (declaration && isDeclare) {
	        this.resetStartLocation(declaration, startPos, startLoc);
	        declaration.declare = true;
	      }

	      return declaration;
	    };

	    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
	      if ((!isStatement || optionalId) && this.isContextual(106)) {
	        return;
	      }

	      _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) node.typeParameters = typeParameters;
	    };

	    _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
	      if (!node.optional && this.eat(35)) {
	        node.definite = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();
	      if (type) node.typeAnnotation = type;
	    };

	    _proto.parseClassProperty = function parseClassProperty(node) {
	      this.parseClassPropertyAnnotation(node);

	      if (this.state.isAmbientContext && this.match(29)) {
	        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
	      }

	      if (node["abstract"] && this.match(29)) {
	        var _key2 = node.key;
	        this.raise(this.state.start, TSErrors.AbstractPropertyHasInitializer, _key2.type === "Identifier" && !node.computed ? _key2.name : "[" + this.input.slice(_key2.start, _key2.end) + "]");
	      }

	      return _superClass.prototype.parseClassProperty.call(this, node);
	    };

	    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
	      if (node["abstract"]) {
	        this.raise(node.start, TSErrors.PrivateElementHasAbstract);
	      }

	      if (node.accessibility) {
	        this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
	      }

	      this.parseClassPropertyAnnotation(node);
	      return _superClass.prototype.parseClassPrivateProperty.call(this, node);
	    };

	    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	      var typeParameters = this.tsTryParseTypeParameters();

	      if (typeParameters && isConstructor) {
	        this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
	      }

	      if (method.declare && (method.kind === "get" || method.kind === "set")) {
	        this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
	      }

	      if (typeParameters) method.typeParameters = typeParameters;

	      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
	    };

	    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) method.typeParameters = typeParameters;

	      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
	    };

	    _proto.declareClassPrivateMethodInScope = function declareClassPrivateMethodInScope(node, kind) {
	      if (node.type === "TSDeclareMethod") return;
	      if (node.type === "MethodDefinition" && !node.value.body) return;

	      _superClass.prototype.declareClassPrivateMethodInScope.call(this, node, kind);
	    };

	    _proto.parseClassSuper = function parseClassSuper(node) {
	      _superClass.prototype.parseClassSuper.call(this, node);

	      if (node.superClass && this.match(45)) {
	        node.superTypeParameters = this.tsParseTypeArguments();
	      }

	      if (this.eatContextual(106)) {
	        node["implements"] = this.tsParseHeritageClause("implements");
	      }
	    };

	    _proto.parseObjPropValue = function parseObjPropValue(prop) {
	      var _superClass$prototype2;

	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) prop.typeParameters = typeParameters;

	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	        args[_key3 - 1] = arguments[_key3];
	      }

	      (_superClass$prototype2 = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype2, [this, prop].concat(args));
	    };

	    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
	      var typeParameters = this.tsTryParseTypeParameters();
	      if (typeParameters) node.typeParameters = typeParameters;

	      _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
	    };

	    _proto.parseVarId = function parseVarId(decl, kind) {
	      _superClass.prototype.parseVarId.call(this, decl, kind);

	      if (decl.id.type === "Identifier" && this.eat(35)) {
	        decl.definite = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();

	      if (type) {
	        decl.id.typeAnnotation = type;
	        this.resetEndLocation(decl.id);
	      }
	    };

	    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	      if (this.match(14)) {
	        node.returnType = this.tsParseTypeAnnotation();
	      }

	      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
	    };

	    _proto.parseMaybeAssign = function parseMaybeAssign() {
	      var _this19 = this,
	          _jsx,
	          _jsx2,
	          _typeCast,
	          _jsx3,
	          _typeCast2,
	          _jsx4,
	          _typeCast3;

	      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
	        args[_key4] = arguments[_key4];
	      }

	      var state;
	      var jsx;
	      var typeCast;

	      if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
	        state = this.state.clone();
	        jsx = this.tryParse(function () {
	          var _superClass$prototype3;

	          return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [_this19].concat(args));
	        }, state);
	        if (!jsx.error) return jsx.node;
	        var context = this.state.context;
	        var currentContext = context[context.length - 1];

	        if (currentContext === types.j_oTag || currentContext === types.j_expr) {
	          context.pop();
	        }
	      }

	      if (!((_jsx = jsx) != null && _jsx.error) && !this.match(45)) {
	        var _superClass$prototype4;

	        return (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));
	      }

	      var typeParameters;
	      state = state || this.state.clone();
	      var arrow = this.tryParse(function (abort) {
	        var _superClass$prototype5, _expr$extra, _typeParameters;

	        typeParameters = _this19.tsParseTypeParameters();

	        var expr = (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [_this19].concat(args));

	        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
	          abort();
	        }

	        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
	          _this19.resetStartLocationFromNode(expr, typeParameters);
	        }

	        expr.typeParameters = typeParameters;
	        return expr;
	      }, state);

	      if (!arrow.error && !arrow.aborted) {
	        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	        return arrow.node;
	      }

	      if (!jsx) {
	        assert(!this.hasPlugin("jsx"));
	        typeCast = this.tryParse(function () {
	          var _superClass$prototype6;

	          return (_superClass$prototype6 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype6, [_this19].concat(args));
	        }, state);
	        if (!typeCast.error) return typeCast.node;
	      }

	      if ((_jsx2 = jsx) != null && _jsx2.node) {
	        this.state = jsx.failState;
	        return jsx.node;
	      }

	      if (arrow.node) {
	        this.state = arrow.failState;
	        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
	        return arrow.node;
	      }

	      if ((_typeCast = typeCast) != null && _typeCast.node) {
	        this.state = typeCast.failState;
	        return typeCast.node;
	      }

	      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
	      if (arrow.thrown) throw arrow.error;
	      if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
	      throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
	    };

	    _proto.reportReservedArrowTypeParam = function reportReservedArrowTypeParam(node) {
	      var _node$extra;

	      if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
	        this.raise(node.start, TSErrors.ReservedArrowTypeParam);
	      }
	    };

	    _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
	      if (!this.hasPlugin("jsx") && this.match(45)) {
	        return this.tsParseTypeAssertion();
	      } else {
	        return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors);
	      }
	    };

	    _proto.parseArrow = function parseArrow(node) {
	      var _this20 = this;

	      if (this.match(14)) {
	        var result = this.tryParse(function (abort) {
	          var returnType = _this20.tsParseTypeOrTypePredicateAnnotation(14);

	          if (_this20.canInsertSemicolon() || !_this20.match(19)) abort();
	          return returnType;
	        });
	        if (result.aborted) return;

	        if (!result.thrown) {
	          if (result.error) this.state = result.failState;
	          node.returnType = result.node;
	        }
	      }

	      return _superClass.prototype.parseArrow.call(this, node);
	    };

	    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	      if (this.eat(17)) {
	        if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
	          this.raise(param.start, TSErrors.PatternIsOptional);
	        }

	        param.optional = true;
	      }

	      var type = this.tsTryParseTypeAnnotation();
	      if (type) param.typeAnnotation = type;
	      this.resetEndLocation(param);
	      return param;
	    };

	    _proto.isAssignable = function isAssignable(node, isBinding) {
	      switch (node.type) {
	        case "TSTypeCastExpression":
	          return this.isAssignable(node.expression, isBinding);

	        case "TSParameterProperty":
	          return true;

	        default:
	          return _superClass.prototype.isAssignable.call(this, node, isBinding);
	      }
	    };

	    _proto.toAssignable = function toAssignable(node, isLHS) {
	      if (isLHS === void 0) {
	        isLHS = false;
	      }

	      switch (node.type) {
	        case "TSTypeCastExpression":
	          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);

	        case "TSParameterProperty":
	          return _superClass.prototype.toAssignable.call(this, node, isLHS);

	        case "ParenthesizedExpression":
	          return this.toAssignableParenthesizedExpression(node, isLHS);

	        case "TSAsExpression":
	        case "TSNonNullExpression":
	        case "TSTypeAssertion":
	          node.expression = this.toAssignable(node.expression, isLHS);
	          return node;

	        default:
	          return _superClass.prototype.toAssignable.call(this, node, isLHS);
	      }
	    };

	    _proto.toAssignableParenthesizedExpression = function toAssignableParenthesizedExpression(node, isLHS) {
	      switch (node.expression.type) {
	        case "TSAsExpression":
	        case "TSNonNullExpression":
	        case "TSTypeAssertion":
	        case "ParenthesizedExpression":
	          node.expression = this.toAssignable(node.expression, isLHS);
	          return node;

	        default:
	          return _superClass.prototype.toAssignable.call(this, node, isLHS);
	      }
	    };

	    _proto.checkLVal = function checkLVal(expr, contextDescription) {
	      var _expr$extra2, _superClass$prototype7;

	      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key5 = 2; _key5 < _len4; _key5++) {
	        args[_key5 - 2] = arguments[_key5];
	      }

	      switch (expr.type) {
	        case "TSTypeCastExpression":
	          return;

	        case "TSParameterProperty":
	          this.checkLVal.apply(this, [expr.parameter, "parameter property"].concat(args));
	          return;

	        case "TSAsExpression":
	        case "TSTypeAssertion":
	          if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
	            this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
	            break;
	          }

	          this.checkLVal.apply(this, [expr.expression, "parenthesized expression"].concat(args));
	          return;

	        case "TSNonNullExpression":
	          this.checkLVal.apply(this, [expr.expression, contextDescription].concat(args));
	          return;

	        default:
	          (_superClass$prototype7 = _superClass.prototype.checkLVal).call.apply(_superClass$prototype7, [this, expr, contextDescription].concat(args));

	          return;
	      }
	    };

	    _proto.parseBindingAtom = function parseBindingAtom() {
	      switch (this.state.type) {
	        case 74:
	          return this.parseIdentifier(true);

	        default:
	          return _superClass.prototype.parseBindingAtom.call(this);
	      }
	    };

	    _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
	      if (this.match(45)) {
	        var typeArguments = this.tsParseTypeArguments();

	        if (this.match(10)) {
	          var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);

	          call.typeParameters = typeArguments;
	          return call;
	        }

	        this.unexpected(this.state.start, 10);
	      }

	      return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);
	    };

	    _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
	      if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
	        this.next();
	      } else {
	        _superClass.prototype.checkCommaAfterRest.call(this, close);
	      }
	    };

	    _proto.isClassMethod = function isClassMethod() {
	      return this.match(45) || _superClass.prototype.isClassMethod.call(this);
	    };

	    _proto.isClassProperty = function isClassProperty() {
	      return this.match(35) || this.match(14) || _superClass.prototype.isClassProperty.call(this);
	    };

	    _proto.parseMaybeDefault = function parseMaybeDefault() {
	      var _superClass$prototype8;

	      for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
	        args[_key6] = arguments[_key6];
	      }

	      var node = (_superClass$prototype8 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype8, [this].concat(args));

	      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
	        this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
	      }

	      return node;
	    };

	    _proto.getTokenFromCode = function getTokenFromCode(code) {
	      if (this.state.inType) {
	        if (code === 62) {
	          return this.finishOp(46, 1);
	        }

	        if (code === 60) {
	          return this.finishOp(45, 1);
	        }
	      }

	      return _superClass.prototype.getTokenFromCode.call(this, code);
	    };

	    _proto.reScan_lt_gt = function reScan_lt_gt() {
	      var type = this.state.type;

	      if (type === 45) {
	        this.state.pos -= 1;
	        this.readToken_lt();
	      } else if (type === 46) {
	        this.state.pos -= 1;
	        this.readToken_gt();
	      }
	    };

	    _proto.toAssignableList = function toAssignableList(exprList) {
	      for (var i = 0; i < exprList.length; i++) {
	        var expr = exprList[i];
	        if (!expr) continue;

	        switch (expr.type) {
	          case "TSTypeCastExpression":
	            exprList[i] = this.typeCastToParameter(expr);
	            break;

	          case "TSAsExpression":
	          case "TSTypeAssertion":
	            if (!this.state.maybeInArrowParameters) {
	              exprList[i] = this.typeCastToParameter(expr);
	            } else {
	              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
	            }

	            break;
	        }
	      }

	      return _superClass.prototype.toAssignableList.apply(this, arguments);
	    };

	    _proto.typeCastToParameter = function typeCastToParameter(node) {
	      node.expression.typeAnnotation = node.typeAnnotation;
	      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
	      return node.expression;
	    };

	    _proto.shouldParseArrow = function shouldParseArrow(params) {
	      var _this21 = this;

	      if (this.match(14)) {
	        return params.every(function (expr) {
	          return _this21.isAssignable(expr, true);
	        });
	      }

	      return _superClass.prototype.shouldParseArrow.call(this, params);
	    };

	    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	      return this.match(14) || _superClass.prototype.shouldParseAsyncArrow.call(this);
	    };

	    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
	      return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
	    };

	    _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
	      var _this22 = this;

	      if (this.match(45)) {
	        var typeArguments = this.tsTryParseAndCatch(function () {
	          return _this22.tsParseTypeArguments();
	        });
	        if (typeArguments) node.typeParameters = typeArguments;
	      }

	      return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
	    };

	    _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
	      var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);

	      var params = this.getObjectOrClassMethodParams(method);
	      var firstParam = params[0];
	      var hasContextParam = firstParam && this.isThisParam(firstParam);
	      return hasContextParam ? baseCount + 1 : baseCount;
	    };

	    _proto.parseCatchClauseParam = function parseCatchClauseParam() {
	      var param = _superClass.prototype.parseCatchClauseParam.call(this);

	      var type = this.tsTryParseTypeAnnotation();

	      if (type) {
	        param.typeAnnotation = type;
	        this.resetEndLocation(param);
	      }

	      return param;
	    };

	    _proto.tsInAmbientContext = function tsInAmbientContext(cb) {
	      var oldIsAmbientContext = this.state.isAmbientContext;
	      this.state.isAmbientContext = true;

	      try {
	        return cb();
	      } finally {
	        this.state.isAmbientContext = oldIsAmbientContext;
	      }
	    };

	    _proto.parseClass = function parseClass(node) {
	      var oldInAbstractClass = this.state.inAbstractClass;
	      this.state.inAbstractClass = !!node["abstract"];

	      try {
	        var _superClass$prototype9;

	        for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {
	          args[_key7 - 1] = arguments[_key7];
	        }

	        return (_superClass$prototype9 = _superClass.prototype.parseClass).call.apply(_superClass$prototype9, [this, node].concat(args));
	      } finally {
	        this.state.inAbstractClass = oldInAbstractClass;
	      }
	    };

	    _proto.tsParseAbstractDeclaration = function tsParseAbstractDeclaration(node) {
	      if (this.match(76)) {
	        node["abstract"] = true;
	        return this.parseClass(node, true, false);
	      } else if (this.isContextual(121)) {
	        if (!this.hasFollowingLineBreak()) {
	          node["abstract"] = true;
	          this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
	          this.next();
	          return this.tsParseInterfaceDeclaration(node);
	        }
	      } else {
	        this.unexpected(null, 76);
	      }
	    };

	    _proto.parseMethod = function parseMethod() {
	      var _superClass$prototype10;

	      for (var _len7 = arguments.length, args = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
	        args[_key8] = arguments[_key8];
	      }

	      var method = (_superClass$prototype10 = _superClass.prototype.parseMethod).call.apply(_superClass$prototype10, [this].concat(args));

	      if (method["abstract"]) {
	        var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

	        if (hasBody) {
	          var _key9 = method.key;
	          this.raise(method.start, TSErrors.AbstractMethodHasImplementation, _key9.type === "Identifier" && !method.computed ? _key9.name : "[" + this.input.slice(_key9.start, _key9.end) + "]");
	        }
	      }

	      return method;
	    };

	    _proto.tsParseTypeParameterName = function tsParseTypeParameterName() {
	      var typeName = this.parseIdentifier();
	      return typeName.name;
	    };

	    _proto.shouldParseAsAmbientContext = function shouldParseAsAmbientContext() {
	      return !!this.getPluginOption("typescript", "dts");
	    };

	    _proto.parse = function parse() {
	      if (this.shouldParseAsAmbientContext()) {
	        this.state.isAmbientContext = true;
	      }

	      return _superClass.prototype.parse.call(this);
	    };

	    _proto.getExpression = function getExpression() {
	      if (this.shouldParseAsAmbientContext()) {
	        this.state.isAmbientContext = true;
	      }

	      return _superClass.prototype.getExpression.call(this);
	    };

	    _proto.parseExportSpecifier = function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	      if (!isString && isMaybeTypeOnly) {
	        this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
	        return this.finishNode(node, "ExportSpecifier");
	      }

	      node.exportKind = "value";
	      return _superClass.prototype.parseExportSpecifier.call(this, node, isString, isInTypeExport, isMaybeTypeOnly);
	    };

	    _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
	      if (!importedIsString && isMaybeTypeOnly) {
	        this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
	        return this.finishNode(specifier, "ImportSpecifier");
	      }

	      specifier.importKind = "value";
	      return _superClass.prototype.parseImportSpecifier.call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
	    };

	    _proto.parseTypeOnlyImportExportSpecifier = function parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
	      var leftOfAsKey = isImport ? "imported" : "local";
	      var rightOfAsKey = isImport ? "local" : "exported";
	      var leftOfAs = node[leftOfAsKey];
	      var rightOfAs;
	      var hasTypeSpecifier = false;
	      var canParseAsKeyword = true;
	      var pos = leftOfAs.start;

	      if (this.isContextual(89)) {
	        var firstAs = this.parseIdentifier();

	        if (this.isContextual(89)) {
	          var secondAs = this.parseIdentifier();

	          if (tokenIsKeywordOrIdentifier(this.state.type)) {
	            hasTypeSpecifier = true;
	            leftOfAs = firstAs;
	            rightOfAs = this.parseIdentifier();
	            canParseAsKeyword = false;
	          } else {
	            rightOfAs = secondAs;
	            canParseAsKeyword = false;
	          }
	        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	          canParseAsKeyword = false;
	          rightOfAs = this.parseIdentifier();
	        } else {
	          hasTypeSpecifier = true;
	          leftOfAs = firstAs;
	        }
	      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
	        hasTypeSpecifier = true;
	        leftOfAs = this.parseIdentifier();
	      }

	      if (hasTypeSpecifier && isInTypeOnlyImportExport) {
	        this.raise(pos, isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports);
	      }

	      node[leftOfAsKey] = leftOfAs;
	      node[rightOfAsKey] = rightOfAs;
	      var kindKey = isImport ? "importKind" : "exportKind";
	      node[kindKey] = hasTypeSpecifier ? "type" : "value";

	      if (canParseAsKeyword && this.eatContextual(89)) {
	        node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
	      }

	      if (!node[rightOfAsKey]) {
	        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
	      }

	      if (isImport) {
	        this.checkLVal(node[rightOfAsKey], "import specifier", BIND_LEXICAL);
	      }
	    };

	    return _class;
	  }(superClass);
	});

	var PlaceHolderErrors = makeErrorTemplates({
	  ClassNameIsRequired: "A class name is required."
	}, ErrorCodes.SyntaxError);
	var placeholders = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
	      if (this.match(136)) {
	        var node = this.startNode();
	        this.next();
	        this.assertNoSpace("Unexpected space in placeholder.");
	        node.name = _superClass.prototype.parseIdentifier.call(this, true);
	        this.assertNoSpace("Unexpected space in placeholder.");
	        this.expect(136);
	        return this.finishPlaceholder(node, expectedNode);
	      }
	    };

	    _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
	      var isFinished = !!(node.expectedNode && node.type === "Placeholder");
	      node.expectedNode = expectedNode;
	      return isFinished ? node : this.finishNode(node, "Placeholder");
	    };

	    _proto.getTokenFromCode = function getTokenFromCode(code) {
	      if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
	        return this.finishOp(136, 2);
	      }

	      return _superClass.prototype.getTokenFromCode.apply(this, arguments);
	    };

	    _proto.parseExprAtom = function parseExprAtom() {
	      return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.apply(this, arguments);
	    };

	    _proto.parseIdentifier = function parseIdentifier() {
	      return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.apply(this, arguments);
	    };

	    _proto.checkReservedWord = function checkReservedWord(word) {
	      if (word !== undefined) _superClass.prototype.checkReservedWord.apply(this, arguments);
	    };

	    _proto.parseBindingAtom = function parseBindingAtom() {
	      return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.apply(this, arguments);
	    };

	    _proto.checkLVal = function checkLVal(expr) {
	      if (expr.type !== "Placeholder") _superClass.prototype.checkLVal.apply(this, arguments);
	    };

	    _proto.toAssignable = function toAssignable(node) {
	      if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
	        node.expectedNode = "Pattern";
	        return node;
	      }

	      return _superClass.prototype.toAssignable.apply(this, arguments);
	    };

	    _proto.isLet = function isLet(context) {
	      if (_superClass.prototype.isLet.call(this, context)) {
	        return true;
	      }

	      if (!this.isContextual(95)) {
	        return false;
	      }

	      if (context) return false;
	      var nextToken = this.lookahead();

	      if (nextToken.type === 136) {
	        return true;
	      }

	      return false;
	    };

	    _proto.verifyBreakContinue = function verifyBreakContinue(node) {
	      if (node.label && node.label.type === "Placeholder") return;

	      _superClass.prototype.verifyBreakContinue.apply(this, arguments);
	    };

	    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	      if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
	        return _superClass.prototype.parseExpressionStatement.apply(this, arguments);
	      }

	      if (this.match(14)) {
	        var stmt = node;
	        stmt.label = this.finishPlaceholder(expr, "Identifier");
	        this.next();
	        stmt.body = this.parseStatement("label");
	        return this.finishNode(stmt, "LabeledStatement");
	      }

	      this.semicolon();
	      node.name = expr.name;
	      return this.finishPlaceholder(node, "Statement");
	    };

	    _proto.parseBlock = function parseBlock() {
	      return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.apply(this, arguments);
	    };

	    _proto.parseFunctionId = function parseFunctionId() {
	      return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.apply(this, arguments);
	    };

	    _proto.parseClass = function parseClass(node, isStatement, optionalId) {
	      var type = isStatement ? "ClassDeclaration" : "ClassExpression";
	      this.next();
	      this.takeDecorators(node);
	      var oldStrict = this.state.strict;
	      var placeholder = this.parsePlaceholder("Identifier");

	      if (placeholder) {
	        if (this.match(77) || this.match(136) || this.match(5)) {
	          node.id = placeholder;
	        } else if (optionalId || !isStatement) {
	          node.id = null;
	          node.body = this.finishPlaceholder(placeholder, "ClassBody");
	          return this.finishNode(node, type);
	        } else {
	          this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
	        }
	      } else {
	        this.parseClassId(node, isStatement, optionalId);
	      }

	      this.parseClassSuper(node);
	      node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
	      return this.finishNode(node, type);
	    };

	    _proto.parseExport = function parseExport(node) {
	      var placeholder = this.parsePlaceholder("Identifier");
	      if (!placeholder) return _superClass.prototype.parseExport.apply(this, arguments);

	      if (!this.isContextual(93) && !this.match(12)) {
	        node.specifiers = [];
	        node.source = null;
	        node.declaration = this.finishPlaceholder(placeholder, "Declaration");
	        return this.finishNode(node, "ExportNamedDeclaration");
	      }

	      this.expectPlugin("exportDefaultFrom");
	      var specifier = this.startNode();
	      specifier.exported = placeholder;
	      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	      return _superClass.prototype.parseExport.call(this, node);
	    };

	    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	      if (this.match(61)) {
	        var next = this.nextTokenStart();

	        if (this.isUnparsedContextual(next, "from")) {
	          if (this.input.startsWith(tokenLabelName(136), this.nextTokenStartSince(next + 4))) {
	            return true;
	          }
	        }
	      }

	      return _superClass.prototype.isExportDefaultSpecifier.call(this);
	    };

	    _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
	      if (node.specifiers && node.specifiers.length > 0) {
	        return true;
	      }

	      return _superClass.prototype.maybeParseExportDefaultSpecifier.apply(this, arguments);
	    };

	    _proto.checkExport = function checkExport(node) {
	      var specifiers = node.specifiers;

	      if (specifiers != null && specifiers.length) {
	        node.specifiers = specifiers.filter(function (node) {
	          return node.exported.type === "Placeholder";
	        });
	      }

	      _superClass.prototype.checkExport.call(this, node);

	      node.specifiers = specifiers;
	    };

	    _proto.parseImport = function parseImport(node) {
	      var placeholder = this.parsePlaceholder("Identifier");
	      if (!placeholder) return _superClass.prototype.parseImport.apply(this, arguments);
	      node.specifiers = [];

	      if (!this.isContextual(93) && !this.match(12)) {
	        node.source = this.finishPlaceholder(placeholder, "StringLiteral");
	        this.semicolon();
	        return this.finishNode(node, "ImportDeclaration");
	      }

	      var specifier = this.startNodeAtNode(placeholder);
	      specifier.local = placeholder;
	      this.finishNode(specifier, "ImportDefaultSpecifier");
	      node.specifiers.push(specifier);

	      if (this.eat(12)) {
	        var hasStarImport = this.maybeParseStarImportSpecifier(node);
	        if (!hasStarImport) this.parseNamedImportSpecifiers(node);
	      }

	      this.expectContextual(93);
	      node.source = this.parseImportSource();
	      this.semicolon();
	      return this.finishNode(node, "ImportDeclaration");
	    };

	    _proto.parseImportSource = function parseImportSource() {
	      return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.apply(this, arguments);
	    };

	    return _class;
	  }(superClass);
	});

	var v8intrinsic = (function (superClass) {
	  return function (_superClass) {
	    _inherits(_class, _superClass);

	    function _class() {
	      return _superClass.apply(this, arguments) || this;
	    }

	    var _proto = _class.prototype;

	    _proto.parseV8Intrinsic = function parseV8Intrinsic() {
	      if (this.match(50)) {
	        var v8IntrinsicStart = this.state.start;
	        var node = this.startNode();
	        this.next();

	        if (tokenIsIdentifier(this.state.type)) {
	          var name = this.parseIdentifierName(this.state.start);
	          var identifier = this.createIdentifier(node, name);
	          identifier.type = "V8IntrinsicIdentifier";

	          if (this.match(10)) {
	            return identifier;
	          }
	        }

	        this.unexpected(v8IntrinsicStart);
	      }
	    };

	    _proto.parseExprAtom = function parseExprAtom() {
	      return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.apply(this, arguments);
	    };

	    return _class;
	  }(superClass);
	});

	function hasPlugin(plugins, expectedConfig) {
	  var _ref = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig,
	      expectedName = _ref[0],
	      expectedOptions = _ref[1];

	  var expectedKeys = Object.keys(expectedOptions);
	  var expectedOptionsIsEmpty = expectedKeys.length === 0;
	  return plugins.some(function (p) {
	    if (typeof p === "string") {
	      return expectedOptionsIsEmpty && p === expectedName;
	    } else {
	      var pluginName = p[0],
	          pluginOptions = p[1];

	      if (pluginName !== expectedName) {
	        return false;
	      }

	      for (var _i2 = 0; _i2 < expectedKeys.length; _i2++) {
	        var key = expectedKeys[_i2];

	        if (pluginOptions[key] !== expectedOptions[key]) {
	          return false;
	        }
	      }

	      return true;
	    }
	  });
	}
	function getPluginOption(plugins, name, option) {
	  var plugin = plugins.find(function (plugin) {
	    if (Array.isArray(plugin)) {
	      return plugin[0] === name;
	    } else {
	      return plugin === name;
	    }
	  });

	  if (plugin && Array.isArray(plugin)) {
	    return plugin[1][option];
	  }

	  return null;
	}
	var PIPELINE_PROPOSALS$1 = ["minimal", "fsharp", "hack", "smart"];
	var TOPIC_TOKENS$1 = ["^", "%", "#"];
	var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
	function validatePlugins(plugins) {
	  if (hasPlugin(plugins, "decorators")) {
	    if (hasPlugin(plugins, "decorators-legacy")) {
	      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
	    }

	    var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

	    if (decoratorsBeforeExport == null) {
	      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
	    } else if (typeof decoratorsBeforeExport !== "boolean") {
	      throw new Error("'decoratorsBeforeExport' must be a boolean.");
	    }
	  }

	  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
	    throw new Error("Cannot combine flow and typescript plugins.");
	  }

	  if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
	    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
	  }

	  if (hasPlugin(plugins, "pipelineOperator")) {
	    var proposal = getPluginOption(plugins, "pipelineOperator", "proposal");

	    if (!PIPELINE_PROPOSALS$1.includes(proposal)) {
	      var proposalList = PIPELINE_PROPOSALS$1.map(function (p) {
	        return "\"" + p + "\"";
	      }).join(", ");
	      throw new Error("\"pipelineOperator\" requires \"proposal\" option whose value must be one of: " + proposalList + ".");
	    }

	    var tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
	      syntaxType: "hash"
	    }]);

	    if (proposal === "hack") {
	      if (hasPlugin(plugins, "placeholders")) {
	        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
	      }

	      if (hasPlugin(plugins, "v8intrinsic")) {
	        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
	      }

	      var topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");

	      if (!TOPIC_TOKENS$1.includes(topicToken)) {
	        var tokenList = TOPIC_TOKENS$1.map(function (t) {
	          return "\"" + t + "\"";
	        }).join(", ");
	        throw new Error("\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: " + tokenList + ".");
	      }

	      if (topicToken === "#" && tupleSyntaxIsHash) {
	        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
	      }
	    } else if (proposal === "smart" && tupleSyntaxIsHash) {
	      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
	    }
	  }

	  if (hasPlugin(plugins, "moduleAttributes")) {
	    {
	      if (hasPlugin(plugins, "importAssertions")) {
	        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
	      }

	      var moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

	      if (moduleAttributesVerionPluginOption !== "may-2020") {
	        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
	      }
	    }
	  }

	  if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
	    throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
	      return "'" + p + "'";
	    }).join(", "));
	  }

	  if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
	    var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
	    error.missingPlugins = "doExpressions";
	    throw error;
	  }
	}
	var mixinPlugins = {
	  estree: estree,
	  jsx: jsx,
	  flow: flow,
	  typescript: typescript,
	  v8intrinsic: v8intrinsic,
	  placeholders: placeholders
	};
	var mixinPluginNames = Object.keys(mixinPlugins);

	var defaultOptions = {
	  sourceType: "script",
	  sourceFilename: undefined,
	  startColumn: 0,
	  startLine: 1,
	  allowAwaitOutsideFunction: false,
	  allowReturnOutsideFunction: false,
	  allowImportExportEverywhere: false,
	  allowSuperOutsideMethod: false,
	  allowUndeclaredExports: false,
	  plugins: [],
	  strictMode: null,
	  ranges: false,
	  tokens: false,
	  createParenthesizedExpressions: false,
	  errorRecovery: false,
	  attachComment: true
	};
	function getOptions(opts) {
	  var options = {};

	  for (var _i2 = 0, _Object$keys2 = Object.keys(defaultOptions); _i2 < _Object$keys2.length; _i2++) {
	    var key = _Object$keys2[_i2];
	    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
	  }

	  return options;
	}

	var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
	  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
	};

	var LValParser = function (_NodeUtils) {
	  _inherits(LValParser, _NodeUtils);

	  function LValParser() {
	    return _NodeUtils.apply(this, arguments) || this;
	  }

	  var _proto = LValParser.prototype;

	  _proto.toAssignable = function toAssignable(node, isLHS) {
	    var _node$extra, _node$extra3;

	    if (isLHS === void 0) {
	      isLHS = false;
	    }

	    var parenthesized = undefined;

	    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
	      parenthesized = unwrapParenthesizedExpression(node);

	      if (isLHS) {
	        if (parenthesized.type === "Identifier") {
	          this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
	        } else if (parenthesized.type !== "MemberExpression") {
	          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
	        }
	      } else {
	        this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
	      }
	    }

	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        break;

	      case "ObjectExpression":
	        node.type = "ObjectPattern";

	        for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
	          var _node$extra2;

	          var prop = node.properties[i];
	          var isLast = i === last;
	          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

	          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
	            this.raiseRestNotLast(node.extra.trailingComma);
	          }
	        }

	        break;

	      case "ObjectProperty":
	        this.toAssignable(node.value, isLHS);
	        break;

	      case "SpreadElement":
	        {
	          this.checkToRestConversion(node);
	          node.type = "RestElement";
	          var arg = node.argument;
	          this.toAssignable(arg, isLHS);
	          break;
	        }

	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
	        break;

	      case "AssignmentExpression":
	        if (node.operator !== "=") {
	          this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
	        }

	        node.type = "AssignmentPattern";
	        delete node.operator;
	        this.toAssignable(node.left, isLHS);
	        break;

	      case "ParenthesizedExpression":
	        this.toAssignable(parenthesized, isLHS);
	        break;
	    }

	    return node;
	  };

	  _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
	    if (prop.type === "ObjectMethod") {
	      var error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
	      this.raise(prop.key.start, error);
	    } else if (prop.type === "SpreadElement" && !isLast) {
	      this.raiseRestNotLast(prop.start);
	    } else {
	      this.toAssignable(prop, isLHS);
	    }
	  };

	  _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
	    var end = exprList.length;

	    if (end) {
	      var last = exprList[end - 1];

	      if ((last == null ? void 0 : last.type) === "RestElement") {
	        --end;
	      } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
	        last.type = "RestElement";
	        var arg = last.argument;
	        this.toAssignable(arg, isLHS);
	        arg = unwrapParenthesizedExpression(arg);

	        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
	          this.unexpected(arg.start);
	        }

	        if (trailingCommaPos) {
	          this.raiseTrailingCommaAfterRest(trailingCommaPos);
	        }

	        --end;
	      }
	    }

	    for (var i = 0; i < end; i++) {
	      var elt = exprList[i];

	      if (elt) {
	        this.toAssignable(elt, isLHS);

	        if (elt.type === "RestElement") {
	          this.raiseRestNotLast(elt.start);
	        }
	      }
	    }

	    return exprList;
	  };

	  _proto.isAssignable = function isAssignable(node, isBinding) {
	    var _this = this;

	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	      case "AssignmentPattern":
	      case "RestElement":
	        return true;

	      case "ObjectExpression":
	        {
	          var last = node.properties.length - 1;
	          return node.properties.every(function (prop, i) {
	            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && _this.isAssignable(prop);
	          });
	        }

	      case "ObjectProperty":
	        return this.isAssignable(node.value);

	      case "SpreadElement":
	        return this.isAssignable(node.argument);

	      case "ArrayExpression":
	        return node.elements.every(function (element) {
	          return element === null || _this.isAssignable(element);
	        });

	      case "AssignmentExpression":
	        return node.operator === "=";

	      case "ParenthesizedExpression":
	        return this.isAssignable(node.expression);

	      case "MemberExpression":
	      case "OptionalMemberExpression":
	        return !isBinding;

	      default:
	        return false;
	    }
	  };

	  _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
	    return exprList;
	  };

	  _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
	    this.toReferencedList(exprList, isParenthesizedExpr);

	    for (var _i2 = 0; _i2 < exprList.length; _i2++) {
	      var expr = exprList[_i2];

	      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
	        this.toReferencedListDeep(expr.elements);
	      }
	    }
	  };

	  _proto.parseSpread = function parseSpread(refExpressionErrors, refNeedsArrowPos) {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
	    return this.finishNode(node, "SpreadElement");
	  };

	  _proto.parseRestBinding = function parseRestBinding() {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseBindingAtom();
	    return this.finishNode(node, "RestElement");
	  };

	  _proto.parseBindingAtom = function parseBindingAtom() {
	    switch (this.state.type) {
	      case 0:
	        {
	          var node = this.startNode();
	          this.next();
	          node.elements = this.parseBindingList(3, 93, true);
	          return this.finishNode(node, "ArrayPattern");
	        }

	      case 5:
	        return this.parseObjectLike(8, true);
	    }

	    return this.parseIdentifier();
	  };

	  _proto.parseBindingList = function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
	    var elts = [];
	    var first = true;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	      }

	      if (allowEmpty && this.match(12)) {
	        elts.push(null);
	      } else if (this.eat(close)) {
	        break;
	      } else if (this.match(21)) {
	        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
	        this.checkCommaAfterRest(closeCharCode);
	        this.expect(close);
	        break;
	      } else {
	        var decorators = [];

	        if (this.match(26) && this.hasPlugin("decorators")) {
	          this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
	        }

	        while (this.match(26)) {
	          decorators.push(this.parseDecorator());
	        }

	        elts.push(this.parseAssignableListItem(allowModifiers, decorators));
	      }
	    }

	    return elts;
	  };

	  _proto.parseBindingRestProperty = function parseBindingRestProperty(prop) {
	    this.next();
	    prop.argument = this.parseIdentifier();
	    this.checkCommaAfterRest(125);
	    return this.finishNode(prop, "RestElement");
	  };

	  _proto.parseBindingProperty = function parseBindingProperty() {
	    var prop = this.startNode();
	    var _this$state = this.state,
	        type = _this$state.type,
	        startPos = _this$state.start,
	        startLoc = _this$state.startLoc;

	    if (type === 21) {
	      return this.parseBindingRestProperty(prop);
	    } else {
	      this.parsePropertyName(prop);
	    }

	    prop.method = false;
	    this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
	    return prop;
	  };

	  _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
	    var left = this.parseMaybeDefault();
	    this.parseAssignableListItemTypes(left);
	    var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

	    if (decorators.length) {
	      left.decorators = decorators;
	    }

	    return elt;
	  };

	  _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
	    return param;
	  };

	  _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
	    var _startLoc, _startPos, _left;

	    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
	    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
	    left = (_left = left) != null ? _left : this.parseBindingAtom();
	    if (!this.eat(29)) return left;
	    var node = this.startNodeAt(startPos, startLoc);
	    node.left = left;
	    node.right = this.parseMaybeAssignAllowIn();
	    return this.finishNode(node, "AssignmentPattern");
	  };

	  _proto.checkLVal = function checkLVal(expr, contextDescription, bindingType, checkClashes, disallowLetBinding, strictModeChanged) {
	    if (bindingType === void 0) {
	      bindingType = BIND_NONE;
	    }

	    if (strictModeChanged === void 0) {
	      strictModeChanged = false;
	    }

	    switch (expr.type) {
	      case "Identifier":
	        {
	          var name = expr.name;

	          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
	            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
	          }

	          if (checkClashes) {
	            if (checkClashes.has(name)) {
	              this.raise(expr.start, ErrorMessages.ParamDupe);
	            } else {
	              checkClashes.add(name);
	            }
	          }

	          if (disallowLetBinding && name === "let") {
	            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
	          }

	          if (!(bindingType & BIND_NONE)) {
	            this.scope.declareName(name, bindingType, expr.start);
	          }

	          break;
	        }

	      case "MemberExpression":
	        if (bindingType !== BIND_NONE) {
	          this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
	        }

	        break;

	      case "ObjectPattern":
	        for (var _i4 = 0, _expr$properties2 = expr.properties; _i4 < _expr$properties2.length; _i4++) {
	          var prop = _expr$properties2[_i4];
	          if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
	          this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
	        }

	        break;

	      case "ArrayPattern":
	        for (var _i6 = 0, _expr$elements2 = expr.elements; _i6 < _expr$elements2.length; _i6++) {
	          var elem = _expr$elements2[_i6];

	          if (elem) {
	            this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
	          }
	        }

	        break;

	      case "AssignmentPattern":
	        this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
	        break;

	      case "RestElement":
	        this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
	        break;

	      case "ParenthesizedExpression":
	        this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
	        break;

	      default:
	        {
	          this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
	        }
	    }
	  };

	  _proto.checkToRestConversion = function checkToRestConversion(node) {
	    if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
	      this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
	    }
	  };

	  _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
	    if (this.match(12)) {
	      if (this.lookaheadCharCode() === close) {
	        this.raiseTrailingCommaAfterRest(this.state.start);
	      } else {
	        this.raiseRestNotLast(this.state.start);
	      }
	    }
	  };

	  _proto.raiseRestNotLast = function raiseRestNotLast(pos) {
	    throw this.raise(pos, ErrorMessages.ElementAfterRest);
	  };

	  _proto.raiseTrailingCommaAfterRest = function raiseTrailingCommaAfterRest(pos) {
	    this.raise(pos, ErrorMessages.RestTrailingComma);
	  };

	  return LValParser;
	}(NodeUtils);

	var invalidHackPipeBodies = new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);

	var ExpressionParser = function (_LValParser) {
	  _inherits(ExpressionParser, _LValParser);

	  function ExpressionParser() {
	    return _LValParser.apply(this, arguments) || this;
	  }

	  var _proto = ExpressionParser.prototype;

	  _proto.checkProto = function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
	    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
	      return;
	    }

	    var key = prop.key;
	    var name = key.type === "Identifier" ? key.name : key.value;

	    if (name === "__proto__") {
	      if (isRecord) {
	        this.raise(key.start, ErrorMessages.RecordNoProto);
	        return;
	      }

	      if (protoRef.used) {
	        if (refExpressionErrors) {
	          if (refExpressionErrors.doubleProto === -1) {
	            refExpressionErrors.doubleProto = key.start;
	          }
	        } else {
	          this.raise(key.start, ErrorMessages.DuplicateProto);
	        }
	      }

	      protoRef.used = true;
	    }
	  };

	  _proto.shouldExitDescending = function shouldExitDescending(expr, potentialArrowAt) {
	    return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
	  };

	  _proto.getExpression = function getExpression() {
	    this.enterInitialScopes();
	    this.nextToken();
	    var expr = this.parseExpression();

	    if (!this.match(131)) {
	      this.unexpected();
	    }

	    this.finalizeRemainingComments();
	    expr.comments = this.state.comments;
	    expr.errors = this.state.errors;

	    if (this.options.tokens) {
	      expr.tokens = this.tokens;
	    }

	    return expr;
	  };

	  _proto.parseExpression = function parseExpression(disallowIn, refExpressionErrors) {
	    var _this = this;

	    if (disallowIn) {
	      return this.disallowInAnd(function () {
	        return _this.parseExpressionBase(refExpressionErrors);
	      });
	    }

	    return this.allowInAnd(function () {
	      return _this.parseExpressionBase(refExpressionErrors);
	    });
	  };

	  _proto.parseExpressionBase = function parseExpressionBase(refExpressionErrors) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var expr = this.parseMaybeAssign(refExpressionErrors);

	    if (this.match(12)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.expressions = [expr];

	      while (this.eat(12)) {
	        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
	      }

	      this.toReferencedList(node.expressions);
	      return this.finishNode(node, "SequenceExpression");
	    }

	    return expr;
	  };

	  _proto.parseMaybeAssignDisallowIn = function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
	    var _this2 = this;

	    return this.disallowInAnd(function () {
	      return _this2.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	    });
	  };

	  _proto.parseMaybeAssignAllowIn = function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
	    var _this3 = this;

	    return this.allowInAnd(function () {
	      return _this3.parseMaybeAssign(refExpressionErrors, afterLeftParse);
	    });
	  };

	  _proto.setOptionalParametersError = function setOptionalParametersError(refExpressionErrors, resultError) {
	    var _resultError$pos;

	    refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
	  };

	  _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;

	    if (this.isContextual(101)) {
	      if (this.prodParam.hasYield) {
	        var _left = this.parseYield();

	        if (afterLeftParse) {
	          _left = afterLeftParse.call(this, _left, startPos, startLoc);
	        }

	        return _left;
	      }
	    }

	    var ownExpressionErrors;

	    if (refExpressionErrors) {
	      ownExpressionErrors = false;
	    } else {
	      refExpressionErrors = new ExpressionErrors();
	      ownExpressionErrors = true;
	    }

	    var type = this.state.type;

	    if (type === 10 || tokenIsIdentifier(type)) {
	      this.state.potentialArrowAt = this.state.start;
	    }

	    var left = this.parseMaybeConditional(refExpressionErrors);

	    if (afterLeftParse) {
	      left = afterLeftParse.call(this, left, startPos, startLoc);
	    }

	    if (tokenIsAssignment(this.state.type)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      var operator = this.state.value;
	      node.operator = operator;

	      if (this.match(29)) {
	        node.left = this.toAssignable(left, true);

	        if (refExpressionErrors.doubleProto >= startPos) {
	          refExpressionErrors.doubleProto = -1;
	        }

	        if (refExpressionErrors.shorthandAssign >= startPos) {
	          refExpressionErrors.shorthandAssign = -1;
	        }
	      } else {
	        node.left = left;
	      }

	      this.checkLVal(left, "assignment expression");
	      this.next();
	      node.right = this.parseMaybeAssign();
	      return this.finishNode(node, "AssignmentExpression");
	    } else if (ownExpressionErrors) {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }

	    return left;
	  };

	  _proto.parseMaybeConditional = function parseMaybeConditional(refExpressionErrors) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseExprOps(refExpressionErrors);

	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }

	    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
	  };

	  _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
	    if (this.eat(17)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.test = expr;
	      node.consequent = this.parseMaybeAssignAllowIn();
	      this.expect(14);
	      node.alternate = this.parseMaybeAssign();
	      return this.finishNode(node, "ConditionalExpression");
	    }

	    return expr;
	  };

	  _proto.parseMaybeUnaryOrPrivate = function parseMaybeUnaryOrPrivate(refExpressionErrors) {
	    return this.match(130) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
	  };

	  _proto.parseExprOps = function parseExprOps(refExpressionErrors) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);

	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }

	    return this.parseExprOp(expr, startPos, startLoc, -1);
	  };

	  _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
	    if (this.isPrivateName(left)) {
	      var value = this.getPrivateNameSV(left);
	      var start = left.start;

	      if (minPrec >= tokenOperatorPrecedence(54) || !this.prodParam.hasIn || !this.match(54)) {
	        this.raise(start, ErrorMessages.PrivateInExpectedIn, value);
	      }

	      this.classScope.usePrivateName(value, start);
	    }

	    var op = this.state.type;

	    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(54))) {
	      var prec = tokenOperatorPrecedence(op);

	      if (prec > minPrec) {
	        if (op === 37) {
	          this.expectPlugin("pipelineOperator");

	          if (this.state.inFSharpPipelineDirectBody) {
	            return left;
	          }

	          this.checkPipelineAtInfixOperator(left, leftStartPos);
	        }

	        var node = this.startNodeAt(leftStartPos, leftStartLoc);
	        node.left = left;
	        node.operator = this.state.value;
	        var logical = op === 39 || op === 40;
	        var coalesce = op === 38;

	        if (coalesce) {
	          prec = tokenOperatorPrecedence(40);
	        }

	        this.next();

	        if (op === 37 && this.hasPlugin(["pipelineOperator", {
	          proposal: "minimal"
	        }])) {
	          if (this.state.type === 92 && this.prodParam.hasAwait) {
	            throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
	          }
	        }

	        node.right = this.parseExprOpRightExpr(op, prec);
	        this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
	        var nextOp = this.state.type;

	        if (coalesce && (nextOp === 39 || nextOp === 40) || logical && nextOp === 38) {
	          throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
	        }

	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
	      }
	    }

	    return left;
	  };

	  _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec) {
	    var _this4 = this;

	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;

	    switch (op) {
	      case 37:
	        switch (this.getPluginOption("pipelineOperator", "proposal")) {
	          case "hack":
	            return this.withTopicBindingContext(function () {
	              return _this4.parseHackPipeBody();
	            });

	          case "smart":
	            return this.withTopicBindingContext(function () {
	              if (_this4.prodParam.hasYield && _this4.isContextual(101)) {
	                throw _this4.raise(_this4.state.start, ErrorMessages.PipeBodyIsTighter, _this4.state.value);
	              }

	              return _this4.parseSmartPipelineBodyInStyle(_this4.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
	            });

	          case "fsharp":
	            return this.withSoloAwaitPermittingContext(function () {
	              return _this4.parseFSharpPipelineBody(prec);
	            });
	        }

	      default:
	        return this.parseExprOpBaseRightExpr(op, prec);
	    }
	  };

	  _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
	  };

	  _proto.parseHackPipeBody = function parseHackPipeBody() {
	    var _body$extra;

	    var start = this.state.start;
	    var body = this.parseMaybeAssign();

	    if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
	      this.raise(start, ErrorMessages.PipeUnparenthesizedBody, invalidHackPipeBodies.get(body.type));
	    }

	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(start, ErrorMessages.PipeTopicUnused);
	    }

	    return body;
	  };

	  _proto.checkExponentialAfterUnary = function checkExponentialAfterUnary(node) {
	    if (this.match(53)) {
	      this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
	    }
	  };

	  _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors, sawUnary) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var isAwait = this.isContextual(92);

	    if (isAwait && this.isAwaitAllowed()) {
	      this.next();

	      var _expr = this.parseAwait(startPos, startLoc);

	      if (!sawUnary) this.checkExponentialAfterUnary(_expr);
	      return _expr;
	    }

	    var update = this.match(34);
	    var node = this.startNode();

	    if (tokenIsPrefix(this.state.type)) {
	      node.operator = this.state.value;
	      node.prefix = true;

	      if (this.match(68)) {
	        this.expectPlugin("throwExpressions");
	      }

	      var isDelete = this.match(85);
	      this.next();
	      node.argument = this.parseMaybeUnary(null, true);
	      this.checkExpressionErrors(refExpressionErrors, true);

	      if (this.state.strict && isDelete) {
	        var arg = node.argument;

	        if (arg.type === "Identifier") {
	          this.raise(node.start, ErrorMessages.StrictDelete);
	        } else if (this.hasPropertyAsPrivateName(arg)) {
	          this.raise(node.start, ErrorMessages.DeletePrivateField);
	        }
	      }

	      if (!update) {
	        if (!sawUnary) this.checkExponentialAfterUnary(node);
	        return this.finishNode(node, "UnaryExpression");
	      }
	    }

	    var expr = this.parseUpdate(node, update, refExpressionErrors);

	    if (isAwait) {
	      var type = this.state.type;
	      var startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(50);

	      if (startsExpr && !this.isAmbiguousAwait()) {
	        this.raiseOverwrite(startPos, ErrorMessages.AwaitNotInAsyncContext);
	        return this.parseAwait(startPos, startLoc);
	      }
	    }

	    return expr;
	  };

	  _proto.parseUpdate = function parseUpdate(node, update, refExpressionErrors) {
	    if (update) {
	      this.checkLVal(node.argument, "prefix operation");
	      return this.finishNode(node, "UpdateExpression");
	    }

	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var expr = this.parseExprSubscripts(refExpressionErrors);
	    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

	    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
	      var _node = this.startNodeAt(startPos, startLoc);

	      _node.operator = this.state.value;
	      _node.prefix = false;
	      _node.argument = expr;
	      this.checkLVal(expr, "postfix operation");
	      this.next();
	      expr = this.finishNode(_node, "UpdateExpression");
	    }

	    return expr;
	  };

	  _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var potentialArrowAt = this.state.potentialArrowAt;
	    var expr = this.parseExprAtom(refExpressionErrors);

	    if (this.shouldExitDescending(expr, potentialArrowAt)) {
	      return expr;
	    }

	    return this.parseSubscripts(expr, startPos, startLoc);
	  };

	  _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
	    var state = {
	      optionalChainMember: false,
	      maybeAsyncArrow: this.atPossibleAsyncArrow(base),
	      stop: false
	    };

	    do {
	      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
	      state.maybeAsyncArrow = false;
	    } while (!state.stop);

	    return base;
	  };

	  _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
	    var type = this.state.type;

	    if (!noCalls && type === 15) {
	      return this.parseBind(base, startPos, startLoc, noCalls, state);
	    } else if (tokenIsTemplate(type)) {
	      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
	    }

	    var optional = false;

	    if (type === 18) {
	      if (noCalls && this.lookaheadCharCode() === 40) {
	        state.stop = true;
	        return base;
	      }

	      state.optionalChainMember = optional = true;
	      this.next();
	    }

	    if (!noCalls && this.match(10)) {
	      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
	    } else {
	      var computed = this.eat(0);

	      if (computed || optional || this.eat(16)) {
	        return this.parseMember(base, startPos, startLoc, state, computed, optional);
	      } else {
	        state.stop = true;
	        return base;
	      }
	    }
	  };

	  _proto.parseMember = function parseMember(base, startPos, startLoc, state, computed, optional) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.object = base;
	    node.computed = computed;

	    if (computed) {
	      node.property = this.parseExpression();
	      this.expect(3);
	    } else if (this.match(130)) {
	      if (base.type === "Super") {
	        this.raise(startPos, ErrorMessages.SuperPrivateField);
	      }

	      this.classScope.usePrivateName(this.state.value, this.state.start);
	      node.property = this.parsePrivateName();
	    } else {
	      node.property = this.parseIdentifier(true);
	    }

	    if (state.optionalChainMember) {
	      node.optional = optional;
	      return this.finishNode(node, "OptionalMemberExpression");
	    } else {
	      return this.finishNode(node, "MemberExpression");
	    }
	  };

	  _proto.parseBind = function parseBind(base, startPos, startLoc, noCalls, state) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.object = base;
	    this.next();
	    node.callee = this.parseNoCallExpr();
	    state.stop = true;
	    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
	  };

	  _proto.parseCoverCallAndAsyncArrowHead = function parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    var refExpressionErrors = null;
	    this.state.maybeInArrowParameters = true;
	    this.next();
	    var node = this.startNodeAt(startPos, startLoc);
	    node.callee = base;

	    if (state.maybeAsyncArrow) {
	      this.expressionScope.enter(newAsyncArrowScope());
	      refExpressionErrors = new ExpressionErrors();
	    }

	    if (state.optionalChainMember) {
	      node.optional = optional;
	    }

	    if (optional) {
	      node.arguments = this.parseCallExpressionArguments(11);
	    } else {
	      node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
	    }

	    this.finishCallExpression(node, state.optionalChainMember);

	    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
	      state.stop = true;
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
	    } else {
	      if (state.maybeAsyncArrow) {
	        this.checkExpressionErrors(refExpressionErrors, true);
	        this.expressionScope.exit();
	      }

	      this.toReferencedArguments(node);
	    }

	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return node;
	  };

	  _proto.toReferencedArguments = function toReferencedArguments(node, isParenthesizedExpr) {
	    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
	  };

	  _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(base, startPos, startLoc, state) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.tag = base;
	    node.quasi = this.parseTemplate(true);

	    if (state.optionalChainMember) {
	      this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
	    }

	    return this.finishNode(node, "TaggedTemplateExpression");
	  };

	  _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
	    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
	  };

	  _proto.finishCallExpression = function finishCallExpression(node, optional) {
	    if (node.callee.type === "Import") {
	      if (node.arguments.length === 2) {
	        {
	          if (!this.hasPlugin("moduleAttributes")) {
	            this.expectPlugin("importAssertions");
	          }
	        }
	      }

	      if (node.arguments.length === 0 || node.arguments.length > 2) {
	        this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
	      } else {
	        for (var _i2 = 0, _node$arguments2 = node.arguments; _i2 < _node$arguments2.length; _i2++) {
	          var arg = _node$arguments2[_i2];

	          if (arg.type === "SpreadElement") {
	            this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
	          }
	        }
	      }
	    }

	    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
	  };

	  _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
	    var elts = [];
	    var first = true;
	    var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);

	        if (this.match(close)) {
	          if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
	            this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
	          }

	          if (nodeForExtra) {
	            this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
	          }

	          this.next();
	          break;
	        }
	      }

	      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
	    }

	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return elts;
	  };

	  _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
	    return this.match(19) && !this.canInsertSemicolon();
	  };

	  _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
	    var _call$extra;

	    this.resetPreviousNodeTrailingComments(call);
	    this.expect(19);
	    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);

	    if (call.innerComments) {
	      setInnerComments(node, call.innerComments);
	    }

	    if (call.callee.trailingComments) {
	      setInnerComments(node, call.callee.trailingComments);
	    }

	    return node;
	  };

	  _proto.parseNoCallExpr = function parseNoCallExpr() {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  };

	  _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
	    var node;
	    var type = this.state.type;

	    switch (type) {
	      case 75:
	        return this.parseSuper();

	      case 79:
	        node = this.startNode();
	        this.next();

	        if (this.match(16)) {
	          return this.parseImportMetaProperty(node);
	        }

	        if (!this.match(10)) {
	          this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
	        }

	        return this.finishNode(node, "Import");

	      case 74:
	        node = this.startNode();
	        this.next();
	        return this.finishNode(node, "ThisExpression");

	      case 86:
	        {
	          return this.parseDo(this.startNode(), false);
	        }

	      case 52:
	      case 31:
	        {
	          this.readRegexp();
	          return this.parseRegExpLiteral(this.state.value);
	        }

	      case 126:
	        return this.parseNumericLiteral(this.state.value);

	      case 127:
	        return this.parseBigIntLiteral(this.state.value);

	      case 128:
	        return this.parseDecimalLiteral(this.state.value);

	      case 125:
	        return this.parseStringLiteral(this.state.value);

	      case 80:
	        return this.parseNullLiteral();

	      case 81:
	        return this.parseBooleanLiteral(true);

	      case 82:
	        return this.parseBooleanLiteral(false);

	      case 10:
	        {
	          var canBeArrow = this.state.potentialArrowAt === this.state.start;
	          return this.parseParenAndDistinguishExpression(canBeArrow);
	        }

	      case 2:
	      case 1:
	        {
	          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
	        }

	      case 0:
	        {
	          return this.parseArrayLike(3, true, false, refExpressionErrors);
	        }

	      case 6:
	      case 7:
	        {
	          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
	        }

	      case 5:
	        {
	          return this.parseObjectLike(8, false, false, refExpressionErrors);
	        }

	      case 64:
	        return this.parseFunctionOrFunctionSent();

	      case 26:
	        this.parseDecorators();

	      case 76:
	        node = this.startNode();
	        this.takeDecorators(node);
	        return this.parseClass(node, false);

	      case 73:
	        return this.parseNewOrNewTarget();

	      case 25:
	      case 24:
	        return this.parseTemplate(false);

	      case 15:
	        {
	          node = this.startNode();
	          this.next();
	          node.object = null;
	          var callee = node.callee = this.parseNoCallExpr();

	          if (callee.type === "MemberExpression") {
	            return this.finishNode(node, "BindExpression");
	          } else {
	            throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
	          }
	        }

	      case 130:
	        {
	          this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, this.state.value);
	          return this.parsePrivateName();
	        }

	      case 33:
	        {
	          return this.parseTopicReferenceThenEqualsSign(50, "%");
	        }

	      case 32:
	        {
	          return this.parseTopicReferenceThenEqualsSign(42, "^");
	        }

	      case 42:
	      case 50:
	      case 27:
	        {
	          var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");

	          if (pipeProposal) {
	            return this.parseTopicReference(pipeProposal);
	          } else {
	            throw this.unexpected();
	          }
	        }

	      case 45:
	        {
	          var lookaheadCh = this.input.codePointAt(this.nextTokenStart());

	          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
	            this.expectOnePlugin(["jsx", "flow", "typescript"]);
	            break;
	          } else {
	            throw this.unexpected();
	          }
	        }

	      default:
	        if (tokenIsIdentifier(type)) {
	          if (this.isContextual(119) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
	            return this.parseModuleExpression();
	          }

	          var _canBeArrow = this.state.potentialArrowAt === this.state.start;

	          var containsEsc = this.state.containsEsc;
	          var id = this.parseIdentifier();

	          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
	            var _type = this.state.type;

	            if (_type === 64) {
	              this.resetPreviousNodeTrailingComments(id);
	              this.next();
	              return this.parseFunction(this.startNodeAtNode(id), undefined, true);
	            } else if (tokenIsIdentifier(_type)) {
	              if (this.lookaheadCharCode() === 61) {
	                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
	              } else {
	                return id;
	              }
	            } else if (_type === 86) {
	              this.resetPreviousNodeTrailingComments(id);
	              return this.parseDo(this.startNodeAtNode(id), true);
	            }
	          }

	          if (_canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
	            this.next();
	            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
	          }

	          return id;
	        } else {
	          throw this.unexpected();
	        }

	    }
	  };

	  _proto.parseTopicReferenceThenEqualsSign = function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
	    var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");

	    if (pipeProposal) {
	      this.state.type = topicTokenType;
	      this.state.value = topicTokenValue;
	      this.state.pos--;
	      this.state.end--;
	      this.state.endLoc.column--;
	      return this.parseTopicReference(pipeProposal);
	    } else {
	      throw this.unexpected();
	    }
	  };

	  _proto.parseTopicReference = function parseTopicReference(pipeProposal) {
	    var node = this.startNode();
	    var start = this.state.start;
	    var tokenType = this.state.type;
	    this.next();
	    return this.finishTopicReference(node, start, pipeProposal, tokenType);
	  };

	  _proto.finishTopicReference = function finishTopicReference(node, start, pipeProposal, tokenType) {
	    if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {
	      var nodeType;

	      if (pipeProposal === "smart") {
	        nodeType = "PipelinePrimaryTopicReference";
	      } else {
	        nodeType = "TopicReference";
	      }

	      if (!this.topicReferenceIsAllowedInCurrentContext()) {
	        if (pipeProposal === "smart") {
	          this.raise(start, ErrorMessages.PrimaryTopicNotAllowed);
	        } else {
	          this.raise(start, ErrorMessages.PipeTopicUnbound);
	        }
	      }

	      this.registerTopicReference();
	      return this.finishNode(node, nodeType);
	    } else {
	      throw this.raise(start, ErrorMessages.PipeTopicUnconfiguredToken, tokenLabelName(tokenType));
	    }
	  };

	  _proto.testTopicReferenceConfiguration = function testTopicReferenceConfiguration(pipeProposal, start, tokenType) {
	    switch (pipeProposal) {
	      case "hack":
	        {
	          return this.hasPlugin(["pipelineOperator", {
	            topicToken: tokenLabelName(tokenType)
	          }]);
	        }

	      case "smart":
	        return tokenType === 27;

	      default:
	        throw this.raise(start, ErrorMessages.PipeTopicRequiresHackPipes);
	    }
	  };

	  _proto.parseAsyncArrowUnaryFunction = function parseAsyncArrowUnaryFunction(node) {
	    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
	    var params = [this.parseIdentifier()];
	    this.prodParam.exit();

	    if (this.hasPrecedingLineBreak()) {
	      this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
	    }

	    this.expect(19);
	    this.parseArrowExpression(node, params, true);
	    return node;
	  };

	  _proto.parseDo = function parseDo(node, isAsync) {
	    this.expectPlugin("doExpressions");

	    if (isAsync) {
	      this.expectPlugin("asyncDoExpressions");
	    }

	    node.async = isAsync;
	    this.next();
	    var oldLabels = this.state.labels;
	    this.state.labels = [];

	    if (isAsync) {
	      this.prodParam.enter(PARAM_AWAIT);
	      node.body = this.parseBlock();
	      this.prodParam.exit();
	    } else {
	      node.body = this.parseBlock();
	    }

	    this.state.labels = oldLabels;
	    return this.finishNode(node, "DoExpression");
	  };

	  _proto.parseSuper = function parseSuper() {
	    var node = this.startNode();
	    this.next();

	    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
	      this.raise(node.start, ErrorMessages.SuperNotAllowed);
	    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
	      this.raise(node.start, ErrorMessages.UnexpectedSuper);
	    }

	    if (!this.match(10) && !this.match(0) && !this.match(16)) {
	      this.raise(node.start, ErrorMessages.UnsupportedSuper);
	    }

	    return this.finishNode(node, "Super");
	  };

	  _proto.parsePrivateName = function parsePrivateName() {
	    var node = this.startNode();
	    var id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
	    var name = this.state.value;
	    this.next();
	    node.id = this.createIdentifier(id, name);
	    return this.finishNode(node, "PrivateName");
	  };

	  _proto.parseFunctionOrFunctionSent = function parseFunctionOrFunctionSent() {
	    var node = this.startNode();
	    this.next();

	    if (this.prodParam.hasYield && this.match(16)) {
	      var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
	      this.next();

	      if (this.match(98)) {
	        this.expectPlugin("functionSent");
	      } else if (!this.hasPlugin("functionSent")) {
	        this.unexpected();
	      }

	      return this.parseMetaProperty(node, meta, "sent");
	    }

	    return this.parseFunction(node);
	  };

	  _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
	    node.meta = meta;
	    var containsEsc = this.state.containsEsc;
	    node.property = this.parseIdentifier(true);

	    if (node.property.name !== propertyName || containsEsc) {
	      this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
	    }

	    return this.finishNode(node, "MetaProperty");
	  };

	  _proto.parseImportMetaProperty = function parseImportMetaProperty(node) {
	    var id = this.createIdentifier(this.startNodeAtNode(node), "import");
	    this.next();

	    if (this.isContextual(96)) {
	      if (!this.inModule) {
	        this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
	      }

	      this.sawUnambiguousESM = true;
	    }

	    return this.parseMetaProperty(node, id, "meta");
	  };

	  _proto.parseLiteralAtNode = function parseLiteralAtNode(value, type, node) {
	    this.addExtra(node, "rawValue", value);
	    this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
	    node.value = value;
	    this.next();
	    return this.finishNode(node, type);
	  };

	  _proto.parseLiteral = function parseLiteral(value, type) {
	    var node = this.startNode();
	    return this.parseLiteralAtNode(value, type, node);
	  };

	  _proto.parseStringLiteral = function parseStringLiteral(value) {
	    return this.parseLiteral(value, "StringLiteral");
	  };

	  _proto.parseNumericLiteral = function parseNumericLiteral(value) {
	    return this.parseLiteral(value, "NumericLiteral");
	  };

	  _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
	    return this.parseLiteral(value, "BigIntLiteral");
	  };

	  _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
	    return this.parseLiteral(value, "DecimalLiteral");
	  };

	  _proto.parseRegExpLiteral = function parseRegExpLiteral(value) {
	    var node = this.parseLiteral(value.value, "RegExpLiteral");
	    node.pattern = value.pattern;
	    node.flags = value.flags;
	    return node;
	  };

	  _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
	    var node = this.startNode();
	    node.value = value;
	    this.next();
	    return this.finishNode(node, "BooleanLiteral");
	  };

	  _proto.parseNullLiteral = function parseNullLiteral() {
	    var node = this.startNode();
	    this.next();
	    return this.finishNode(node, "NullLiteral");
	  };

	  _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    var val;
	    this.next();
	    this.expressionScope.enter(newArrowHeadScope());
	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.maybeInArrowParameters = true;
	    this.state.inFSharpPipelineDirectBody = false;
	    var innerStartPos = this.state.start;
	    var innerStartLoc = this.state.startLoc;
	    var exprList = [];
	    var refExpressionErrors = new ExpressionErrors();
	    var first = true;
	    var spreadStart;
	    var optionalCommaStart;

	    while (!this.match(11)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);

	        if (this.match(11)) {
	          optionalCommaStart = this.state.start;
	          break;
	        }
	      }

	      if (this.match(21)) {
	        var spreadNodeStartPos = this.state.start;
	        var spreadNodeStartLoc = this.state.startLoc;
	        spreadStart = this.state.start;
	        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
	        this.checkCommaAfterRest(41);
	        break;
	      } else {
	        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
	      }
	    }

	    var innerEndPos = this.state.lastTokEnd;
	    var innerEndLoc = this.state.lastTokEndLoc;
	    this.expect(11);
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    var arrowNode = this.startNodeAt(startPos, startLoc);

	    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
	      this.expressionScope.validateAsPattern();
	      this.expressionScope.exit();
	      this.parseArrowExpression(arrowNode, exprList, false);
	      return arrowNode;
	    }

	    this.expressionScope.exit();

	    if (!exprList.length) {
	      this.unexpected(this.state.lastTokStart);
	    }

	    if (optionalCommaStart) this.unexpected(optionalCommaStart);
	    if (spreadStart) this.unexpected(spreadStart);
	    this.checkExpressionErrors(refExpressionErrors, true);
	    this.toReferencedListDeep(exprList, true);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNode(val, "SequenceExpression");
	      this.resetEndLocation(val, innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }

	    if (!this.options.createParenthesizedExpressions) {
	      this.addExtra(val, "parenthesized", true);
	      this.addExtra(val, "parenStart", startPos);
	      this.takeSurroundingComments(val, startPos, this.state.lastTokEnd);
	      return val;
	    }

	    var parenExpression = this.startNodeAt(startPos, startLoc);
	    parenExpression.expression = val;
	    this.finishNode(parenExpression, "ParenthesizedExpression");
	    return parenExpression;
	  };

	  _proto.shouldParseArrow = function shouldParseArrow(params) {
	    return !this.canInsertSemicolon();
	  };

	  _proto.parseArrow = function parseArrow(node) {
	    if (this.eat(19)) {
	      return node;
	    }
	  };

	  _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
	    return node;
	  };

	  _proto.parseNewOrNewTarget = function parseNewOrNewTarget() {
	    var node = this.startNode();
	    this.next();

	    if (this.match(16)) {
	      var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
	      this.next();
	      var metaProp = this.parseMetaProperty(node, meta, "target");

	      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
	        this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
	      }

	      return metaProp;
	    }

	    return this.parseNew(node);
	  };

	  _proto.parseNew = function parseNew(node) {
	    node.callee = this.parseNoCallExpr();

	    if (node.callee.type === "Import") {
	      this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
	    } else if (this.isOptionalChain(node.callee)) {
	      this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
	    } else if (this.eat(18)) {
	      this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
	    }

	    this.parseNewArguments(node);
	    return this.finishNode(node, "NewExpression");
	  };

	  _proto.parseNewArguments = function parseNewArguments(node) {
	    if (this.eat(10)) {
	      var args = this.parseExprList(11);
	      this.toReferencedList(args);
	      node.arguments = args;
	    } else {
	      node.arguments = [];
	    }
	  };

	  _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
	    var _this$state = this.state,
	        start = _this$state.start,
	        end = _this$state.end,
	        value = _this$state.value;
	    var elemStart = start + 1;
	    var elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(this.state.startLoc, 1));

	    if (value === null) {
	      if (!isTagged) {
	        this.raise(start + 2, ErrorMessages.InvalidEscapeSequenceTemplate);
	      }
	    }

	    var isTail = this.match(24);
	    var endOffset = isTail ? -1 : -2;
	    var elemEnd = end + endOffset;
	    elem.value = {
	      raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
	      cooked: value === null ? null : value.slice(1, endOffset)
	    };
	    elem.tail = isTail;
	    this.next();
	    this.finishNode(elem, "TemplateElement");
	    this.resetEndLocation(elem, elemEnd, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
	    return elem;
	  };

	  _proto.parseTemplate = function parseTemplate(isTagged) {
	    var node = this.startNode();
	    node.expressions = [];
	    var curElt = this.parseTemplateElement(isTagged);
	    node.quasis = [curElt];

	    while (!curElt.tail) {
	      node.expressions.push(this.parseTemplateSubstitution());
	      this.readTemplateContinuation();
	      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
	    }

	    return this.finishNode(node, "TemplateLiteral");
	  };

	  _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
	    return this.parseExpression();
	  };

	  _proto.parseObjectLike = function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
	    if (isRecord) {
	      this.expectPlugin("recordAndTuple");
	    }

	    var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    var propHash = Object.create(null);
	    var first = true;
	    var node = this.startNode();
	    node.properties = [];
	    this.next();

	    while (!this.match(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);

	        if (this.match(close)) {
	          this.addExtra(node, "trailingComma", this.state.lastTokStart);
	          break;
	        }
	      }

	      var prop = void 0;

	      if (isPattern) {
	        prop = this.parseBindingProperty();
	      } else {
	        prop = this.parsePropertyDefinition(refExpressionErrors);
	        this.checkProto(prop, isRecord, propHash, refExpressionErrors);
	      }

	      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
	        this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
	      }

	      if (prop.shorthand) {
	        this.addExtra(prop, "shorthand", true);
	      }

	      node.properties.push(prop);
	    }

	    this.next();
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    var type = "ObjectExpression";

	    if (isPattern) {
	      type = "ObjectPattern";
	    } else if (isRecord) {
	      type = "RecordExpression";
	    }

	    return this.finishNode(node, type);
	  };

	  _proto.maybeAsyncOrAccessorProp = function maybeAsyncOrAccessorProp(prop) {
	    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(51));
	  };

	  _proto.parsePropertyDefinition = function parsePropertyDefinition(refExpressionErrors) {
	    var decorators = [];

	    if (this.match(26)) {
	      if (this.hasPlugin("decorators")) {
	        this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
	      }

	      while (this.match(26)) {
	        decorators.push(this.parseDecorator());
	      }
	    }

	    var prop = this.startNode();
	    var isAsync = false;
	    var isAccessor = false;
	    var startPos;
	    var startLoc;

	    if (this.match(21)) {
	      if (decorators.length) this.unexpected();
	      return this.parseSpread();
	    }

	    if (decorators.length) {
	      prop.decorators = decorators;
	      decorators = [];
	    }

	    prop.method = false;

	    if (refExpressionErrors) {
	      startPos = this.state.start;
	      startLoc = this.state.startLoc;
	    }

	    var isGenerator = this.eat(51);
	    this.parsePropertyNamePrefixOperator(prop);
	    var containsEsc = this.state.containsEsc;
	    var key = this.parsePropertyName(prop);

	    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
	      var keyName = key.name;

	      if (keyName === "async" && !this.hasPrecedingLineBreak()) {
	        isAsync = true;
	        this.resetPreviousNodeTrailingComments(key);
	        isGenerator = this.eat(51);
	        this.parsePropertyName(prop);
	      }

	      if (keyName === "get" || keyName === "set") {
	        isAccessor = true;
	        this.resetPreviousNodeTrailingComments(key);
	        prop.kind = keyName;

	        if (this.match(51)) {
	          isGenerator = true;
	          this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
	          this.next();
	        }

	        this.parsePropertyName(prop);
	      }
	    }

	    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
	    return prop;
	  };

	  _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
	    return method.kind === "get" ? 0 : 1;
	  };

	  _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
	    return method.params;
	  };

	  _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
	    var _params;

	    var paramCount = this.getGetterSetterExpectedParamCount(method);
	    var params = this.getObjectOrClassMethodParams(method);
	    var start = method.start;

	    if (params.length !== paramCount) {
	      if (method.kind === "get") {
	        this.raise(start, ErrorMessages.BadGetterArity);
	      } else {
	        this.raise(start, ErrorMessages.BadSetterArity);
	      }
	    }

	    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
	      this.raise(start, ErrorMessages.BadSetterRestParameter);
	    }
	  };

	  _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
	    if (isAccessor) {
	      this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
	      this.checkGetterSetterParams(prop);
	      return prop;
	    }

	    if (isAsync || isGenerator || this.match(10)) {
	      if (isPattern) this.unexpected();
	      prop.kind = "method";
	      prop.method = true;
	      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
	    }
	  };

	  _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
	    prop.shorthand = false;

	    if (this.eat(14)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
	      return this.finishNode(prop, "ObjectProperty");
	    }

	    if (!prop.computed && prop.key.type === "Identifier") {
	      this.checkReservedWord(prop.key.name, prop.key.start, true, false);

	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
	      } else if (this.match(29)) {
	        var shorthandAssign = this.state.start;

	        if (refExpressionErrors != null) {
	          if (refExpressionErrors.shorthandAssign === -1) {
	            refExpressionErrors.shorthandAssign = shorthandAssign;
	          }
	        } else {
	          this.raise(shorthandAssign, ErrorMessages.InvalidCoverInitializedName);
	        }

	        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
	      } else {
	        prop.value = cloneIdentifier(prop.key);
	      }

	      prop.shorthand = true;
	      return this.finishNode(prop, "ObjectProperty");
	    }
	  };

	  _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
	    var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
	    if (!node) this.unexpected();
	    return node;
	  };

	  _proto.parsePropertyName = function parsePropertyName(prop) {
	    if (this.eat(0)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssignAllowIn();
	      this.expect(3);
	    } else {
	      var _this$state2 = this.state,
	          type = _this$state2.type,
	          value = _this$state2.value;
	      var key;

	      if (tokenIsKeywordOrIdentifier(type)) {
	        key = this.parseIdentifier(true);
	      } else {
	        switch (type) {
	          case 126:
	            key = this.parseNumericLiteral(value);
	            break;

	          case 125:
	            key = this.parseStringLiteral(value);
	            break;

	          case 127:
	            key = this.parseBigIntLiteral(value);
	            break;

	          case 128:
	            key = this.parseDecimalLiteral(value);
	            break;

	          case 130:
	            {
	              var privateKeyPos = this.state.start + 1;
	              this.raise(privateKeyPos, ErrorMessages.UnexpectedPrivateField);
	              key = this.parsePrivateName();
	              break;
	            }

	          default:
	            throw this.unexpected();
	        }
	      }

	      prop.key = key;

	      if (type !== 130) {
	        prop.computed = false;
	      }
	    }

	    return prop.key;
	  };

	  _proto.initFunction = function initFunction(node, isAsync) {
	    node.id = null;
	    node.generator = false;
	    node.async = !!isAsync;
	  };

	  _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
	    if (inClassScope === void 0) {
	      inClassScope = false;
	    }

	    this.initFunction(node, isAsync);
	    node.generator = !!isGenerator;
	    var allowModifiers = isConstructor;
	    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	    this.prodParam.enter(functionFlags(isAsync, node.generator));
	    this.parseFunctionParams(node, allowModifiers);
	    this.parseFunctionBodyAndFinish(node, type, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    return node;
	  };

	  _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
	    if (isTuple) {
	      this.expectPlugin("recordAndTuple");
	    }

	    var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = false;
	    var node = this.startNode();
	    this.next();
	    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
	  };

	  _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
	    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
	    var flags = functionFlags(isAsync, false);

	    if (!this.match(0) && this.prodParam.hasIn) {
	      flags |= PARAM_IN;
	    }

	    this.prodParam.enter(flags);
	    this.initFunction(node, isAsync);
	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

	    if (params) {
	      this.state.maybeInArrowParameters = true;
	      this.setArrowFunctionParameters(node, params, trailingCommaPos);
	    }

	    this.state.maybeInArrowParameters = false;
	    this.parseFunctionBody(node, true);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return this.finishNode(node, "ArrowFunctionExpression");
	  };

	  _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaPos) {
	    node.params = this.toAssignableList(params, trailingCommaPos, false);
	  };

	  _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
	    if (isMethod === void 0) {
	      isMethod = false;
	    }

	    this.parseFunctionBody(node, false, isMethod);
	    this.finishNode(node, type);
	  };

	  _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
	    var _this5 = this;

	    if (isMethod === void 0) {
	      isMethod = false;
	    }

	    var isExpression = allowExpression && !this.match(5);
	    this.expressionScope.enter(newExpressionScope());

	    if (isExpression) {
	      node.body = this.parseMaybeAssign();
	      this.checkParams(node, false, allowExpression, false);
	    } else {
	      var oldStrict = this.state.strict;
	      var oldLabels = this.state.labels;
	      this.state.labels = [];
	      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
	      node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
	        var nonSimple = !_this5.isSimpleParamList(node.params);

	        if (hasStrictModeDirective && nonSimple) {
	          var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

	          _this5.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
	        }

	        var strictModeChanged = !oldStrict && _this5.state.strict;

	        _this5.checkParams(node, !_this5.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

	        if (_this5.state.strict && node.id) {
	          _this5.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
	        }
	      });
	      this.prodParam.exit();
	      this.state.labels = oldLabels;
	    }

	    this.expressionScope.exit();
	  };

	  _proto.isSimpleParamList = function isSimpleParamList(params) {
	    for (var i = 0, len = params.length; i < len; i++) {
	      if (params[i].type !== "Identifier") return false;
	    }

	    return true;
	  };

	  _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
	    if (strictModeChanged === void 0) {
	      strictModeChanged = true;
	    }

	    var checkClashes = new Set();

	    for (var _i4 = 0, _node$params2 = node.params; _i4 < _node$params2.length; _i4++) {
	      var param = _node$params2[_i4];
	      this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
	    }
	  };

	  _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
	    var elts = [];
	    var first = true;

	    while (!this.eat(close)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);

	        if (this.match(close)) {
	          if (nodeForExtra) {
	            this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
	          }

	          this.next();
	          break;
	        }
	      }

	      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
	    }

	    return elts;
	  };

	  _proto.parseExprListItem = function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
	    var elt;

	    if (this.match(12)) {
	      if (!allowEmpty) {
	        this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
	      }

	      elt = null;
	    } else if (this.match(21)) {
	      var spreadNodeStartPos = this.state.start;
	      var spreadNodeStartLoc = this.state.startLoc;
	      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
	    } else if (this.match(17)) {
	      this.expectPlugin("partialApplication");

	      if (!allowPlaceholder) {
	        this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
	      }

	      var node = this.startNode();
	      this.next();
	      elt = this.finishNode(node, "ArgumentPlaceholder");
	    } else {
	      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
	    }

	    return elt;
	  };

	  _proto.parseIdentifier = function parseIdentifier(liberal) {
	    var node = this.startNode();
	    var name = this.parseIdentifierName(node.start, liberal);
	    return this.createIdentifier(node, name);
	  };

	  _proto.createIdentifier = function createIdentifier(node, name) {
	    node.name = name;
	    node.loc.identifierName = name;
	    return this.finishNode(node, "Identifier");
	  };

	  _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
	    var name;
	    var _this$state3 = this.state,
	        start = _this$state3.start,
	        type = _this$state3.type;

	    if (tokenIsKeywordOrIdentifier(type)) {
	      name = this.state.value;
	    } else {
	      throw this.unexpected();
	    }

	    var tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);

	    if (liberal) {
	      if (tokenIsKeyword) {
	        this.replaceToken(124);
	      }
	    } else {
	      this.checkReservedWord(name, start, tokenIsKeyword, false);
	    }

	    this.next();
	    return name;
	  };

	  _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
	    if (word.length > 10) {
	      return;
	    }

	    if (!canBeReservedWord(word)) {
	      return;
	    }

	    if (word === "yield") {
	      if (this.prodParam.hasYield) {
	        this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
	        return;
	      }
	    } else if (word === "await") {
	      if (this.prodParam.hasAwait) {
	        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
	        return;
	      } else if (this.scope.inStaticBlock) {
	        this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
	        return;
	      } else {
	        this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
	      }
	    } else if (word === "arguments") {
	      if (this.scope.inClassAndNotInNonArrowFunction) {
	        this.raise(startLoc, ErrorMessages.ArgumentsInClass);
	        return;
	      }
	    }

	    if (checkKeywords && isKeyword(word)) {
	      this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
	      return;
	    }

	    var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

	    if (reservedTest(word, this.inModule)) {
	      this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
	    }
	  };

	  _proto.isAwaitAllowed = function isAwaitAllowed() {
	    if (this.prodParam.hasAwait) return true;

	    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
	      return true;
	    }

	    return false;
	  };

	  _proto.parseAwait = function parseAwait(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);

	    if (this.eat(51)) {
	      this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
	    }

	    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
	      if (this.isAmbiguousAwait()) {
	        this.ambiguousScriptDifferentAst = true;
	      } else {
	        this.sawUnambiguousESM = true;
	      }
	    }

	    if (!this.state.soloAwait) {
	      node.argument = this.parseMaybeUnary(null, true);
	    }

	    return this.finishNode(node, "AwaitExpression");
	  };

	  _proto.isAmbiguousAwait = function isAmbiguousAwait() {
	    if (this.hasPrecedingLineBreak()) return true;
	    var type = this.state.type;
	    return type === 49 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 129 || type === 52 || this.hasPlugin("v8intrinsic") && type === 50;
	  };

	  _proto.parseYield = function parseYield() {
	    var node = this.startNode();
	    this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
	    this.next();
	    var delegating = false;
	    var argument = null;

	    if (!this.hasPrecedingLineBreak()) {
	      delegating = this.eat(51);

	      switch (this.state.type) {
	        case 13:
	        case 131:
	        case 8:
	        case 11:
	        case 3:
	        case 9:
	        case 14:
	        case 12:
	          if (!delegating) break;

	        default:
	          argument = this.parseMaybeAssign();
	      }
	    }

	    node.delegate = delegating;
	    node.argument = argument;
	    return this.finishNode(node, "YieldExpression");
	  };

	  _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartPos) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      if (left.type === "SequenceExpression") {
	        this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
	      }
	    }
	  };

	  _proto.checkHackPipeBodyEarlyErrors = function checkHackPipeBodyEarlyErrors(startPos) {
	    if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(startPos, ErrorMessages.PipeTopicUnused);
	    }
	  };

	  _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
	    var bodyNode = this.startNodeAt(startPos, startLoc);

	    if (this.isSimpleReference(childExpr)) {
	      bodyNode.callee = childExpr;
	      return this.finishNode(bodyNode, "PipelineBareFunction");
	    } else {
	      this.checkSmartPipeTopicBodyEarlyErrors(startPos);
	      bodyNode.expression = childExpr;
	      return this.finishNode(bodyNode, "PipelineTopicExpression");
	    }
	  };

	  _proto.isSimpleReference = function isSimpleReference(expression) {
	    switch (expression.type) {
	      case "MemberExpression":
	        return !expression.computed && this.isSimpleReference(expression.object);

	      case "Identifier":
	        return true;

	      default:
	        return false;
	    }
	  };

	  _proto.checkSmartPipeTopicBodyEarlyErrors = function checkSmartPipeTopicBodyEarlyErrors(startPos) {
	    if (this.match(19)) {
	      throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
	    } else if (!this.topicReferenceWasUsedInCurrentContext()) {
	      this.raise(startPos, ErrorMessages.PipelineTopicUnused);
	    }
	  };

	  _proto.withTopicBindingContext = function withTopicBindingContext(callback) {
	    var outerContextTopicState = this.state.topicContext;
	    this.state.topicContext = {
	      maxNumOfResolvableTopics: 1,
	      maxTopicIndex: null
	    };

	    try {
	      return callback();
	    } finally {
	      this.state.topicContext = outerContextTopicState;
	    }
	  };

	  _proto.withSmartMixTopicForbiddingContext = function withSmartMixTopicForbiddingContext(callback) {
	    if (this.hasPlugin(["pipelineOperator", {
	      proposal: "smart"
	    }])) {
	      var outerContextTopicState = this.state.topicContext;
	      this.state.topicContext = {
	        maxNumOfResolvableTopics: 0,
	        maxTopicIndex: null
	      };

	      try {
	        return callback();
	      } finally {
	        this.state.topicContext = outerContextTopicState;
	      }
	    } else {
	      return callback();
	    }
	  };

	  _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
	    var outerContextSoloAwaitState = this.state.soloAwait;
	    this.state.soloAwait = true;

	    try {
	      return callback();
	    } finally {
	      this.state.soloAwait = outerContextSoloAwaitState;
	    }
	  };

	  _proto.allowInAnd = function allowInAnd(callback) {
	    var flags = this.prodParam.currentFlags();
	    var prodParamToSet = PARAM_IN & ~flags;

	    if (prodParamToSet) {
	      this.prodParam.enter(flags | PARAM_IN);

	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }

	    return callback();
	  };

	  _proto.disallowInAnd = function disallowInAnd(callback) {
	    var flags = this.prodParam.currentFlags();
	    var prodParamToClear = PARAM_IN & flags;

	    if (prodParamToClear) {
	      this.prodParam.enter(flags & ~PARAM_IN);

	      try {
	        return callback();
	      } finally {
	        this.prodParam.exit();
	      }
	    }

	    return callback();
	  };

	  _proto.registerTopicReference = function registerTopicReference() {
	    this.state.topicContext.maxTopicIndex = 0;
	  };

	  _proto.topicReferenceIsAllowedInCurrentContext = function topicReferenceIsAllowedInCurrentContext() {
	    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
	  };

	  _proto.topicReferenceWasUsedInCurrentContext = function topicReferenceWasUsedInCurrentContext() {
	    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
	  };

	  _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec) {
	    var startPos = this.state.start;
	    var startLoc = this.state.startLoc;
	    this.state.potentialArrowAt = this.state.start;
	    var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
	    this.state.inFSharpPipelineDirectBody = true;
	    var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
	    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
	    return ret;
	  };

	  _proto.parseModuleExpression = function parseModuleExpression() {
	    this.expectPlugin("moduleBlocks");
	    var node = this.startNode();
	    this.next();
	    this.eat(5);
	    var revertScopes = this.initializeScopes(true);
	    this.enterInitialScopes();
	    var program = this.startNode();

	    try {
	      node.body = this.parseProgram(program, 8, "module");
	    } finally {
	      revertScopes();
	    }

	    this.eat(8);
	    return this.finishNode(node, "ModuleExpression");
	  };

	  _proto.parsePropertyNamePrefixOperator = function parsePropertyNamePrefixOperator(prop) {};

	  return ExpressionParser;
	}(LValParser);

	var loopLabel = {
	  kind: "loop"
	},
	    switchLabel = {
	  kind: "switch"
	};
	var FUNC_NO_FLAGS = 0,
	    FUNC_STATEMENT = 1,
	    FUNC_HANGING_STATEMENT = 2,
	    FUNC_NULLABLE_ID = 4;
	var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
	var keywordRelationalOperator = new RegExp("in(?:stanceof)?", "y");

	function babel7CompatTokens(tokens, input) {
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];
	    var type = token.type;

	    if (typeof type === "number") {
	      {
	        if (type === 130) {
	          var loc = token.loc,
	              start = token.start,
	              value = token.value,
	              end = token.end;
	          var hashEndPos = start + 1;
	          var hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
	          tokens.splice(i, 1, new Token({
	            type: getExportedToken(27),
	            value: "#",
	            start: start,
	            end: hashEndPos,
	            startLoc: loc.start,
	            endLoc: hashEndLoc
	          }), new Token({
	            type: getExportedToken(124),
	            value: value,
	            start: hashEndPos,
	            end: end,
	            startLoc: hashEndLoc,
	            endLoc: loc.end
	          }));
	          i++;
	          continue;
	        }

	        if (tokenIsTemplate(type)) {
	          var _loc = token.loc,
	              _start = token.start,
	              _value = token.value,
	              _end = token.end;
	          var backquoteEnd = _start + 1;
	          var backquoteEndLoc = createPositionWithColumnOffset(_loc.start, 1);
	          var startToken = void 0;

	          if (input.charCodeAt(_start) === 96) {
	            startToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start: _start,
	              end: backquoteEnd,
	              startLoc: _loc.start,
	              endLoc: backquoteEndLoc
	            });
	          } else {
	            startToken = new Token({
	              type: getExportedToken(8),
	              value: "}",
	              start: _start,
	              end: backquoteEnd,
	              startLoc: _loc.start,
	              endLoc: backquoteEndLoc
	            });
	          }

	          var templateValue = void 0,
	              templateElementEnd = void 0,
	              templateElementEndLoc = void 0,
	              endToken = void 0;

	          if (type === 24) {
	            templateElementEnd = _end - 1;
	            templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -1);
	            templateValue = _value === null ? null : _value.slice(1, -1);
	            endToken = new Token({
	              type: getExportedToken(22),
	              value: "`",
	              start: templateElementEnd,
	              end: _end,
	              startLoc: templateElementEndLoc,
	              endLoc: _loc.end
	            });
	          } else {
	            templateElementEnd = _end - 2;
	            templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -2);
	            templateValue = _value === null ? null : _value.slice(1, -2);
	            endToken = new Token({
	              type: getExportedToken(23),
	              value: "${",
	              start: templateElementEnd,
	              end: _end,
	              startLoc: templateElementEndLoc,
	              endLoc: _loc.end
	            });
	          }

	          tokens.splice(i, 1, startToken, new Token({
	            type: getExportedToken(20),
	            value: templateValue,
	            start: backquoteEnd,
	            end: templateElementEnd,
	            startLoc: backquoteEndLoc,
	            endLoc: templateElementEndLoc
	          }), endToken);
	          i += 2;
	          continue;
	        }
	      }
	      token.type = getExportedToken(type);
	    }
	  }

	  return tokens;
	}

	var StatementParser = function (_ExpressionParser) {
	  _inherits(StatementParser, _ExpressionParser);

	  function StatementParser() {
	    return _ExpressionParser.apply(this, arguments) || this;
	  }

	  var _proto = StatementParser.prototype;

	  _proto.parseTopLevel = function parseTopLevel(file, program) {
	    file.program = this.parseProgram(program);
	    file.comments = this.state.comments;

	    if (this.options.tokens) {
	      file.tokens = babel7CompatTokens(this.tokens, this.input);
	    }

	    return this.finishNode(file, "File");
	  };

	  _proto.parseProgram = function parseProgram(program, end, sourceType) {
	    if (end === void 0) {
	      end = 131;
	    }

	    if (sourceType === void 0) {
	      sourceType = this.options.sourceType;
	    }

	    program.sourceType = sourceType;
	    program.interpreter = this.parseInterpreterDirective();
	    this.parseBlockBody(program, true, true, end);

	    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
	      for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
	        var _Array$from2$_i = _Array$from2[_i2],
	            name = _Array$from2$_i[0];
	        var pos = this.scope.undefinedExports.get(name);
	        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
	      }
	    }

	    return this.finishNode(program, "Program");
	  };

	  _proto.stmtToDirective = function stmtToDirective(stmt) {
	    var directive = stmt;
	    directive.type = "Directive";
	    directive.value = directive.expression;
	    delete directive.expression;
	    var directiveLiteral = directive.value;
	    var expressionValue = directiveLiteral.value;
	    var raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
	    var val = directiveLiteral.value = raw.slice(1, -1);
	    this.addExtra(directiveLiteral, "raw", raw);
	    this.addExtra(directiveLiteral, "rawValue", val);
	    this.addExtra(directiveLiteral, "expressionValue", expressionValue);
	    directiveLiteral.type = "DirectiveLiteral";
	    return directive;
	  };

	  _proto.parseInterpreterDirective = function parseInterpreterDirective() {
	    if (!this.match(28)) {
	      return null;
	    }

	    var node = this.startNode();
	    node.value = this.state.value;
	    this.next();
	    return this.finishNode(node, "InterpreterDirective");
	  };

	  _proto.isLet = function isLet(context) {
	    if (!this.isContextual(95)) {
	      return false;
	    }

	    return this.isLetKeyword(context);
	  };

	  _proto.isLetKeyword = function isLetKeyword(context) {
	    var next = this.nextTokenStart();
	    var nextCh = this.codePointAtPos(next);

	    if (nextCh === 92 || nextCh === 91) {
	      return true;
	    }

	    if (context) return false;
	    if (nextCh === 123) return true;

	    if (isIdentifierStart(nextCh)) {
	      keywordRelationalOperator.lastIndex = next;

	      if (keywordRelationalOperator.test(this.input)) {
	        var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);

	        if (!isIdentifierChar(endCh) && endCh !== 92) {
	          return false;
	        }
	      }

	      return true;
	    }

	    return false;
	  };

	  _proto.parseStatement = function parseStatement(context, topLevel) {
	    if (this.match(26)) {
	      this.parseDecorators(true);
	    }

	    return this.parseStatementContent(context, topLevel);
	  };

	  _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
	    var starttype = this.state.type;
	    var node = this.startNode();
	    var kind;

	    if (this.isLet(context)) {
	      starttype = 70;
	      kind = "let";
	    }

	    switch (starttype) {
	      case 56:
	        return this.parseBreakContinueStatement(node, true);

	      case 59:
	        return this.parseBreakContinueStatement(node, false);

	      case 60:
	        return this.parseDebuggerStatement(node);

	      case 86:
	        return this.parseDoStatement(node);

	      case 87:
	        return this.parseForStatement(node);

	      case 64:
	        if (this.lookaheadCharCode() === 46) break;

	        if (context) {
	          if (this.state.strict) {
	            this.raise(this.state.start, ErrorMessages.StrictFunction);
	          } else if (context !== "if" && context !== "label") {
	            this.raise(this.state.start, ErrorMessages.SloppyFunction);
	          }
	        }

	        return this.parseFunctionStatement(node, false, !context);

	      case 76:
	        if (context) this.unexpected();
	        return this.parseClass(node, true);

	      case 65:
	        return this.parseIfStatement(node);

	      case 66:
	        return this.parseReturnStatement(node);

	      case 67:
	        return this.parseSwitchStatement(node);

	      case 68:
	        return this.parseThrowStatement(node);

	      case 69:
	        return this.parseTryStatement(node);

	      case 71:
	      case 70:
	        kind = kind || this.state.value;

	        if (context && kind !== "var") {
	          this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
	        }

	        return this.parseVarStatement(node, kind);

	      case 88:
	        return this.parseWhileStatement(node);

	      case 72:
	        return this.parseWithStatement(node);

	      case 5:
	        return this.parseBlock();

	      case 13:
	        return this.parseEmptyStatement(node);

	      case 79:
	        {
	          var nextTokenCharCode = this.lookaheadCharCode();

	          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
	            break;
	          }
	        }

	      case 78:
	        {
	          if (!this.options.allowImportExportEverywhere && !topLevel) {
	            this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
	          }

	          this.next();
	          var result;

	          if (starttype === 79) {
	            result = this.parseImport(node);

	            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
	              this.sawUnambiguousESM = true;
	            }
	          } else {
	            result = this.parseExport(node);

	            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
	              this.sawUnambiguousESM = true;
	            }
	          }

	          this.assertModuleNodeAllowed(node);
	          return result;
	        }

	      default:
	        {
	          if (this.isAsyncFunction()) {
	            if (context) {
	              this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
	            }

	            this.next();
	            return this.parseFunctionStatement(node, true, !context);
	          }
	        }
	    }

	    var maybeName = this.state.value;
	    var expr = this.parseExpression();

	    if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
	      return this.parseLabeledStatement(node, maybeName, expr, context);
	    } else {
	      return this.parseExpressionStatement(node, expr);
	    }
	  };

	  _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
	    if (!this.options.allowImportExportEverywhere && !this.inModule) {
	      this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
	    }
	  };

	  _proto.takeDecorators = function takeDecorators(node) {
	    var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    if (decorators.length) {
	      node.decorators = decorators;
	      this.resetStartLocationFromNode(node, decorators[0]);
	      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
	    }
	  };

	  _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
	    return this.match(76);
	  };

	  _proto.parseDecorators = function parseDecorators(allowExport) {
	    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    while (this.match(26)) {
	      var decorator = this.parseDecorator();
	      currentContextDecorators.push(decorator);
	    }

	    if (this.match(78)) {
	      if (!allowExport) {
	        this.unexpected();
	      }

	      if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	        this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
	      }
	    } else if (!this.canHaveLeadingDecorator()) {
	      throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
	    }
	  };

	  _proto.parseDecorator = function parseDecorator() {
	    this.expectOnePlugin(["decorators-legacy", "decorators"]);
	    var node = this.startNode();
	    this.next();

	    if (this.hasPlugin("decorators")) {
	      this.state.decoratorStack.push([]);
	      var startPos = this.state.start;
	      var startLoc = this.state.startLoc;
	      var expr;

	      if (this.eat(10)) {
	        expr = this.parseExpression();
	        this.expect(11);
	      } else {
	        expr = this.parseIdentifier(false);

	        while (this.eat(16)) {
	          var _node = this.startNodeAt(startPos, startLoc);

	          _node.object = expr;
	          _node.property = this.parseIdentifier(true);
	          _node.computed = false;
	          expr = this.finishNode(_node, "MemberExpression");
	        }
	      }

	      node.expression = this.parseMaybeDecoratorArguments(expr);
	      this.state.decoratorStack.pop();
	    } else {
	      node.expression = this.parseExprSubscripts();
	    }

	    return this.finishNode(node, "Decorator");
	  };

	  _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
	    if (this.eat(10)) {
	      var node = this.startNodeAtNode(expr);
	      node.callee = expr;
	      node.arguments = this.parseCallExpressionArguments(11, false);
	      this.toReferencedList(node.arguments);
	      return this.finishNode(node, "CallExpression");
	    }

	    return expr;
	  };

	  _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, isBreak) {
	    this.next();

	    if (this.isLineTerminator()) {
	      node.label = null;
	    } else {
	      node.label = this.parseIdentifier();
	      this.semicolon();
	    }

	    this.verifyBreakContinue(node, isBreak);
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	  };

	  _proto.verifyBreakContinue = function verifyBreakContinue(node, isBreak) {
	    var i;

	    for (i = 0; i < this.state.labels.length; ++i) {
	      var lab = this.state.labels[i];

	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	        if (node.label && isBreak) break;
	      }
	    }

	    if (i === this.state.labels.length) {
	      this.raise(node.start, ErrorMessages.IllegalBreakContinue, isBreak ? "break" : "continue");
	    }
	  };

	  _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
	    this.next();
	    this.semicolon();
	    return this.finishNode(node, "DebuggerStatement");
	  };

	  _proto.parseHeaderExpression = function parseHeaderExpression() {
	    this.expect(10);
	    var val = this.parseExpression();
	    this.expect(11);
	    return val;
	  };

	  _proto.parseDoStatement = function parseDoStatement(node) {
	    var _this = this;

	    this.next();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(function () {
	      return _this.parseStatement("do");
	    });
	    this.state.labels.pop();
	    this.expect(88);
	    node.test = this.parseHeaderExpression();
	    this.eat(13);
	    return this.finishNode(node, "DoWhileStatement");
	  };

	  _proto.parseForStatement = function parseForStatement(node) {
	    this.next();
	    this.state.labels.push(loopLabel);
	    var awaitAt = -1;

	    if (this.isAwaitAllowed() && this.eatContextual(92)) {
	      awaitAt = this.state.lastTokStart;
	    }

	    this.scope.enter(SCOPE_OTHER);
	    this.expect(10);

	    if (this.match(13)) {
	      if (awaitAt > -1) {
	        this.unexpected(awaitAt);
	      }

	      return this.parseFor(node, null);
	    }

	    var startsWithLet = this.isContextual(95);
	    var isLet = startsWithLet && this.isLetKeyword();

	    if (this.match(70) || this.match(71) || isLet) {
	      var _init = this.startNode();

	      var kind = isLet ? "let" : this.state.value;
	      this.next();
	      this.parseVar(_init, true, kind);
	      this.finishNode(_init, "VariableDeclaration");

	      if ((this.match(54) || this.isContextual(97)) && _init.declarations.length === 1) {
	        return this.parseForIn(node, _init, awaitAt);
	      }

	      if (awaitAt > -1) {
	        this.unexpected(awaitAt);
	      }

	      return this.parseFor(node, _init);
	    }

	    var startsWithAsync = this.isContextual(91);
	    var refExpressionErrors = new ExpressionErrors();
	    var init = this.parseExpression(true, refExpressionErrors);
	    var isForOf = this.isContextual(97);

	    if (isForOf) {
	      if (startsWithLet) {
	        this.raise(init.start, ErrorMessages.ForOfLet);
	      } else if (awaitAt === -1 && startsWithAsync && init.type === "Identifier") {
	        this.raise(init.start, ErrorMessages.ForOfAsync);
	      }
	    }

	    if (isForOf || this.match(54)) {
	      this.toAssignable(init, true);
	      var description = isForOf ? "for-of statement" : "for-in statement";
	      this.checkLVal(init, description);
	      return this.parseForIn(node, init, awaitAt);
	    } else {
	      this.checkExpressionErrors(refExpressionErrors, true);
	    }

	    if (awaitAt > -1) {
	      this.unexpected(awaitAt);
	    }

	    return this.parseFor(node, init);
	  };

	  _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, declarationPosition) {
	    this.next();
	    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
	  };

	  _proto.parseIfStatement = function parseIfStatement(node) {
	    this.next();
	    node.test = this.parseHeaderExpression();
	    node.consequent = this.parseStatement("if");
	    node.alternate = this.eat(62) ? this.parseStatement("if") : null;
	    return this.finishNode(node, "IfStatement");
	  };

	  _proto.parseReturnStatement = function parseReturnStatement(node) {
	    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
	      this.raise(this.state.start, ErrorMessages.IllegalReturn);
	    }

	    this.next();

	    if (this.isLineTerminator()) {
	      node.argument = null;
	    } else {
	      node.argument = this.parseExpression();
	      this.semicolon();
	    }

	    return this.finishNode(node, "ReturnStatement");
	  };

	  _proto.parseSwitchStatement = function parseSwitchStatement(node) {
	    this.next();
	    node.discriminant = this.parseHeaderExpression();
	    var cases = node.cases = [];
	    this.expect(5);
	    this.state.labels.push(switchLabel);
	    this.scope.enter(SCOPE_OTHER);
	    var cur;

	    for (var sawDefault; !this.match(8);) {
	      if (this.match(57) || this.match(61)) {
	        var isCase = this.match(57);
	        if (cur) this.finishNode(cur, "SwitchCase");
	        cases.push(cur = this.startNode());
	        cur.consequent = [];
	        this.next();

	        if (isCase) {
	          cur.test = this.parseExpression();
	        } else {
	          if (sawDefault) {
	            this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
	          }

	          sawDefault = true;
	          cur.test = null;
	        }

	        this.expect(14);
	      } else {
	        if (cur) {
	          cur.consequent.push(this.parseStatement(null));
	        } else {
	          this.unexpected();
	        }
	      }
	    }

	    this.scope.exit();
	    if (cur) this.finishNode(cur, "SwitchCase");
	    this.next();
	    this.state.labels.pop();
	    return this.finishNode(node, "SwitchStatement");
	  };

	  _proto.parseThrowStatement = function parseThrowStatement(node) {
	    this.next();

	    if (this.hasPrecedingLineBreak()) {
	      this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
	    }

	    node.argument = this.parseExpression();
	    this.semicolon();
	    return this.finishNode(node, "ThrowStatement");
	  };

	  _proto.parseCatchClauseParam = function parseCatchClauseParam() {
	    var param = this.parseBindingAtom();
	    var simple = param.type === "Identifier";
	    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
	    this.checkLVal(param, "catch clause", BIND_LEXICAL);
	    return param;
	  };

	  _proto.parseTryStatement = function parseTryStatement(node) {
	    var _this2 = this;

	    this.next();
	    node.block = this.parseBlock();
	    node.handler = null;

	    if (this.match(58)) {
	      var clause = this.startNode();
	      this.next();

	      if (this.match(10)) {
	        this.expect(10);
	        clause.param = this.parseCatchClauseParam();
	        this.expect(11);
	      } else {
	        clause.param = null;
	        this.scope.enter(SCOPE_OTHER);
	      }

	      clause.body = this.withSmartMixTopicForbiddingContext(function () {
	        return _this2.parseBlock(false, false);
	      });
	      this.scope.exit();
	      node.handler = this.finishNode(clause, "CatchClause");
	    }

	    node.finalizer = this.eat(63) ? this.parseBlock() : null;

	    if (!node.handler && !node.finalizer) {
	      this.raise(node.start, ErrorMessages.NoCatchOrFinally);
	    }

	    return this.finishNode(node, "TryStatement");
	  };

	  _proto.parseVarStatement = function parseVarStatement(node, kind) {
	    this.next();
	    this.parseVar(node, false, kind);
	    this.semicolon();
	    return this.finishNode(node, "VariableDeclaration");
	  };

	  _proto.parseWhileStatement = function parseWhileStatement(node) {
	    var _this3 = this;

	    this.next();
	    node.test = this.parseHeaderExpression();
	    this.state.labels.push(loopLabel);
	    node.body = this.withSmartMixTopicForbiddingContext(function () {
	      return _this3.parseStatement("while");
	    });
	    this.state.labels.pop();
	    return this.finishNode(node, "WhileStatement");
	  };

	  _proto.parseWithStatement = function parseWithStatement(node) {
	    var _this4 = this;

	    if (this.state.strict) {
	      this.raise(this.state.start, ErrorMessages.StrictWith);
	    }

	    this.next();
	    node.object = this.parseHeaderExpression();
	    node.body = this.withSmartMixTopicForbiddingContext(function () {
	      return _this4.parseStatement("with");
	    });
	    return this.finishNode(node, "WithStatement");
	  };

	  _proto.parseEmptyStatement = function parseEmptyStatement(node) {
	    this.next();
	    return this.finishNode(node, "EmptyStatement");
	  };

	  _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, context) {
	    for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
	      var label = _this$state$labels2[_i4];

	      if (label.name === maybeName) {
	        this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
	      }
	    }

	    var kind = tokenIsLoop(this.state.type) ? "loop" : this.match(67) ? "switch" : null;

	    for (var i = this.state.labels.length - 1; i >= 0; i--) {
	      var _label = this.state.labels[i];

	      if (_label.statementStart === node.start) {
	        _label.statementStart = this.state.start;
	        _label.kind = kind;
	      } else {
	        break;
	      }
	    }

	    this.state.labels.push({
	      name: maybeName,
	      kind: kind,
	      statementStart: this.state.start
	    });
	    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	    this.state.labels.pop();
	    node.label = expr;
	    return this.finishNode(node, "LabeledStatement");
	  };

	  _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
	    node.expression = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExpressionStatement");
	  };

	  _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
	    if (allowDirectives === void 0) {
	      allowDirectives = false;
	    }

	    if (createNewLexicalScope === void 0) {
	      createNewLexicalScope = true;
	    }

	    var node = this.startNode();

	    if (allowDirectives) {
	      this.state.strictErrors.clear();
	    }

	    this.expect(5);

	    if (createNewLexicalScope) {
	      this.scope.enter(SCOPE_OTHER);
	    }

	    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);

	    if (createNewLexicalScope) {
	      this.scope.exit();
	    }

	    return this.finishNode(node, "BlockStatement");
	  };

	  _proto.isValidDirective = function isValidDirective(stmt) {
	    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
	  };

	  _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
	    var body = node.body = [];
	    var directives = node.directives = [];
	    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
	  };

	  _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
	    var oldStrict = this.state.strict;
	    var hasStrictModeDirective = false;
	    var parsedNonDirective = false;

	    while (!this.match(end)) {
	      var stmt = this.parseStatement(null, topLevel);

	      if (directives && !parsedNonDirective) {
	        if (this.isValidDirective(stmt)) {
	          var directive = this.stmtToDirective(stmt);
	          directives.push(directive);

	          if (!hasStrictModeDirective && directive.value.value === "use strict") {
	            hasStrictModeDirective = true;
	            this.setStrict(true);
	          }

	          continue;
	        }

	        parsedNonDirective = true;
	        this.state.strictErrors.clear();
	      }

	      body.push(stmt);
	    }

	    if (afterBlockParse) {
	      afterBlockParse.call(this, hasStrictModeDirective);
	    }

	    if (!oldStrict) {
	      this.setStrict(false);
	    }

	    this.next();
	  };

	  _proto.parseFor = function parseFor(node, init) {
	    var _this5 = this;

	    node.init = init;
	    this.semicolon(false);
	    node.test = this.match(13) ? null : this.parseExpression();
	    this.semicolon(false);
	    node.update = this.match(11) ? null : this.parseExpression();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(function () {
	      return _this5.parseStatement("for");
	    });
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, "ForStatement");
	  };

	  _proto.parseForIn = function parseForIn(node, init, awaitAt) {
	    var _this6 = this;

	    var isForIn = this.match(54);
	    this.next();

	    if (isForIn) {
	      if (awaitAt > -1) this.unexpected(awaitAt);
	    } else {
	      node["await"] = awaitAt > -1;
	    }

	    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
	      this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
	    } else if (init.type === "AssignmentPattern") {
	      this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
	    }

	    node.left = init;
	    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
	    this.expect(11);
	    node.body = this.withSmartMixTopicForbiddingContext(function () {
	      return _this6.parseStatement("for");
	    });
	    this.scope.exit();
	    this.state.labels.pop();
	    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
	  };

	  _proto.parseVar = function parseVar(node, isFor, kind) {
	    var declarations = node.declarations = [];
	    var isTypescript = this.hasPlugin("typescript");
	    node.kind = kind;

	    for (;;) {
	      var decl = this.startNode();
	      this.parseVarId(decl, kind);

	      if (this.eat(29)) {
	        decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
	      } else {
	        if (kind === "const" && !(this.match(54) || this.isContextual(97))) {
	          if (!isTypescript) {
	            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
	          }
	        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(54) || this.isContextual(97)))) {
	          this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
	        }

	        decl.init = null;
	      }

	      declarations.push(this.finishNode(decl, "VariableDeclarator"));
	      if (!this.eat(12)) break;
	    }

	    return node;
	  };

	  _proto.parseVarId = function parseVarId(decl, kind) {
	    decl.id = this.parseBindingAtom();
	    this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
	  };

	  _proto.parseFunction = function parseFunction(node, statement, isAsync) {
	    var _this7 = this;

	    if (statement === void 0) {
	      statement = FUNC_NO_FLAGS;
	    }

	    if (isAsync === void 0) {
	      isAsync = false;
	    }

	    var isStatement = statement & FUNC_STATEMENT;
	    var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
	    var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
	    this.initFunction(node, isAsync);

	    if (this.match(51) && isHangingStatement) {
	      this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
	    }

	    node.generator = this.eat(51);

	    if (isStatement) {
	      node.id = this.parseFunctionId(requireId);
	    }

	    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
	    this.state.maybeInArrowParameters = false;
	    this.scope.enter(SCOPE_FUNCTION);
	    this.prodParam.enter(functionFlags(isAsync, node.generator));

	    if (!isStatement) {
	      node.id = this.parseFunctionId();
	    }

	    this.parseFunctionParams(node, false);
	    this.withSmartMixTopicForbiddingContext(function () {
	      _this7.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	    });
	    this.prodParam.exit();
	    this.scope.exit();

	    if (isStatement && !isHangingStatement) {
	      this.registerFunctionStatementId(node);
	    }

	    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
	    return node;
	  };

	  _proto.parseFunctionId = function parseFunctionId(requireId) {
	    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
	  };

	  _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
	    this.expect(10);
	    this.expressionScope.enter(newParameterDeclarationScope());
	    node.params = this.parseBindingList(11, 41, false, allowModifiers);
	    this.expressionScope.exit();
	  };

	  _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
	    if (!node.id) return;
	    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
	  };

	  _proto.parseClass = function parseClass(node, isStatement, optionalId) {
	    this.next();
	    this.takeDecorators(node);
	    var oldStrict = this.state.strict;
	    this.state.strict = true;
	    this.parseClassId(node, isStatement, optionalId);
	    this.parseClassSuper(node);
	    node.body = this.parseClassBody(!!node.superClass, oldStrict);
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	  };

	  _proto.isClassProperty = function isClassProperty() {
	    return this.match(29) || this.match(13) || this.match(8);
	  };

	  _proto.isClassMethod = function isClassMethod() {
	    return this.match(10);
	  };

	  _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
	    return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
	  };

	  _proto.parseClassBody = function parseClassBody(hadSuperClass, oldStrict) {
	    var _this8 = this;

	    this.classScope.enter();
	    var state = {
	      hadConstructor: false,
	      hadSuperClass: hadSuperClass
	    };
	    var decorators = [];
	    var classBody = this.startNode();
	    classBody.body = [];
	    this.expect(5);
	    this.withSmartMixTopicForbiddingContext(function () {
	      while (!_this8.match(8)) {
	        if (_this8.eat(13)) {
	          if (decorators.length > 0) {
	            throw _this8.raise(_this8.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
	          }

	          continue;
	        }

	        if (_this8.match(26)) {
	          decorators.push(_this8.parseDecorator());
	          continue;
	        }

	        var member = _this8.startNode();

	        if (decorators.length) {
	          member.decorators = decorators;

	          _this8.resetStartLocationFromNode(member, decorators[0]);

	          decorators = [];
	        }

	        _this8.parseClassMember(classBody, member, state);

	        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
	          _this8.raise(member.start, ErrorMessages.DecoratorConstructor);
	        }
	      }
	    });
	    this.state.strict = oldStrict;
	    this.next();

	    if (decorators.length) {
	      throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
	    }

	    this.classScope.exit();
	    return this.finishNode(classBody, "ClassBody");
	  };

	  _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
	    var key = this.parseIdentifier(true);

	    if (this.isClassMethod()) {
	      var method = member;
	      method.kind = "method";
	      method.computed = false;
	      method.key = key;
	      method["static"] = false;
	      this.pushClassMethod(classBody, method, false, false, false, false);
	      return true;
	    } else if (this.isClassProperty()) {
	      var prop = member;
	      prop.computed = false;
	      prop.key = key;
	      prop["static"] = false;
	      classBody.body.push(this.parseClassProperty(prop));
	      return true;
	    }

	    this.resetPreviousNodeTrailingComments(key);
	    return false;
	  };

	  _proto.parseClassMember = function parseClassMember(classBody, member, state) {
	    var isStatic = this.isContextual(100);

	    if (isStatic) {
	      if (this.parseClassMemberFromModifier(classBody, member)) {
	        return;
	      }

	      if (this.eat(5)) {
	        this.parseClassStaticBlock(classBody, member);
	        return;
	      }
	    }

	    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
	  };

	  _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
	    var publicMethod = member;
	    var privateMethod = member;
	    var publicProp = member;
	    var privateProp = member;
	    var method = publicMethod;
	    var publicMember = publicMethod;
	    member["static"] = isStatic;
	    this.parsePropertyNamePrefixOperator(member);

	    if (this.eat(51)) {
	      method.kind = "method";
	      var isPrivateName = this.match(130);
	      this.parseClassElementName(method);

	      if (isPrivateName) {
	        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
	        return;
	      }

	      if (this.isNonstaticConstructor(publicMethod)) {
	        this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
	      }

	      this.pushClassMethod(classBody, publicMethod, true, false, false, false);
	      return;
	    }

	    var isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
	    var isPrivate = this.match(130);
	    var key = this.parseClassElementName(member);
	    var maybeQuestionTokenStart = this.state.start;
	    this.parsePostMemberNameModifiers(publicMember);

	    if (this.isClassMethod()) {
	      method.kind = "method";

	      if (isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	        return;
	      }

	      var isConstructor = this.isNonstaticConstructor(publicMethod);
	      var allowsDirectSuper = false;

	      if (isConstructor) {
	        publicMethod.kind = "constructor";

	        if (state.hadConstructor && !this.hasPlugin("typescript")) {
	          this.raise(key.start, ErrorMessages.DuplicateConstructor);
	        }

	        if (isConstructor && this.hasPlugin("typescript") && member.override) {
	          this.raise(key.start, ErrorMessages.OverrideOnConstructor);
	        }

	        state.hadConstructor = true;
	        allowsDirectSuper = state.hadSuperClass;
	      }

	      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
	    } else if (this.isClassProperty()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
	      this.resetPreviousNodeTrailingComments(key);
	      var isGenerator = this.eat(51);

	      if (publicMember.optional) {
	        this.unexpected(maybeQuestionTokenStart);
	      }

	      method.kind = "method";

	      var _isPrivate = this.match(130);

	      this.parseClassElementName(method);
	      this.parsePostMemberNameModifiers(publicMember);

	      if (_isPrivate) {
	        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
	        }

	        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
	      }
	    } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(51) && this.isLineTerminator())) {
	      this.resetPreviousNodeTrailingComments(key);
	      method.kind = key.name;

	      var _isPrivate2 = this.match(130);

	      this.parseClassElementName(publicMethod);

	      if (_isPrivate2) {
	        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
	      } else {
	        if (this.isNonstaticConstructor(publicMethod)) {
	          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
	        }

	        this.pushClassMethod(classBody, publicMethod, false, false, false, false);
	      }

	      this.checkGetterSetterParams(publicMethod);
	    } else if (this.isLineTerminator()) {
	      if (isPrivate) {
	        this.pushClassPrivateProperty(classBody, privateProp);
	      } else {
	        this.pushClassProperty(classBody, publicProp);
	      }
	    } else {
	      this.unexpected();
	    }
	  };

	  _proto.parseClassElementName = function parseClassElementName(member) {
	    var _this$state = this.state,
	        type = _this$state.type,
	        value = _this$state.value,
	        start = _this$state.start;

	    if ((type === 124 || type === 125) && member["static"] && value === "prototype") {
	      this.raise(start, ErrorMessages.StaticPrototype);
	    }

	    if (type === 130) {
	      if (value === "constructor") {
	        this.raise(start, ErrorMessages.ConstructorClassPrivateField);
	      }

	      var key = this.parsePrivateName();
	      member.key = key;
	      return key;
	    }

	    return this.parsePropertyName(member);
	  };

	  _proto.parseClassStaticBlock = function parseClassStaticBlock(classBody, member) {
	    var _member$decorators;

	    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
	    var oldLabels = this.state.labels;
	    this.state.labels = [];
	    this.prodParam.enter(PARAM);
	    var body = member.body = [];
	    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
	    this.prodParam.exit();
	    this.scope.exit();
	    this.state.labels = oldLabels;
	    classBody.body.push(this.finishNode(member, "StaticBlock"));

	    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
	      this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
	    }
	  };

	  _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
	    if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
	      this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
	    }

	    classBody.body.push(this.parseClassProperty(prop));
	  };

	  _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
	    var node = this.parseClassPrivateProperty(prop);
	    classBody.body.push(node);
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
	  };

	  _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
	    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
	  };

	  _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
	    var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
	    classBody.body.push(node);
	    var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
	    this.declareClassPrivateMethodInScope(node, kind);
	  };

	  _proto.declareClassPrivateMethodInScope = function declareClassPrivateMethodInScope(node, kind) {
	    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
	  };

	  _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

	  _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassPrivateProperty");
	  };

	  _proto.parseClassProperty = function parseClassProperty(node) {
	    this.parseInitializer(node);
	    this.semicolon();
	    return this.finishNode(node, "ClassProperty");
	  };

	  _proto.parseInitializer = function parseInitializer(node) {
	    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
	    this.expressionScope.enter(newExpressionScope());
	    this.prodParam.enter(PARAM);
	    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
	    this.expressionScope.exit();
	    this.prodParam.exit();
	    this.scope.exit();
	  };

	  _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
	    if (bindingType === void 0) {
	      bindingType = BIND_CLASS;
	    }

	    if (tokenIsIdentifier(this.state.type)) {
	      node.id = this.parseIdentifier();

	      if (isStatement) {
	        this.checkLVal(node.id, "class name", bindingType);
	      }
	    } else {
	      if (optionalId || !isStatement) {
	        node.id = null;
	      } else {
	        this.unexpected(null, ErrorMessages.MissingClassName);
	      }
	    }
	  };

	  _proto.parseClassSuper = function parseClassSuper(node) {
	    node.superClass = this.eat(77) ? this.parseExprSubscripts() : null;
	  };

	  _proto.parseExport = function parseExport(node) {
	    var hasDefault = this.maybeParseExportDefaultSpecifier(node);
	    var parseAfterDefault = !hasDefault || this.eat(12);
	    var hasStar = parseAfterDefault && this.eatExportStar(node);
	    var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
	    var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
	    var isFromRequired = hasDefault || hasStar;

	    if (hasStar && !hasNamespace) {
	      if (hasDefault) this.unexpected();
	      this.parseExportFrom(node, true);
	      return this.finishNode(node, "ExportAllDeclaration");
	    }

	    var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

	    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
	      throw this.unexpected(null, 5);
	    }

	    var hasDeclaration;

	    if (isFromRequired || hasSpecifiers) {
	      hasDeclaration = false;
	      this.parseExportFrom(node, isFromRequired);
	    } else {
	      hasDeclaration = this.maybeParseExportDeclaration(node);
	    }

	    if (isFromRequired || hasSpecifiers || hasDeclaration) {
	      this.checkExport(node, true, false, !!node.source);
	      return this.finishNode(node, "ExportNamedDeclaration");
	    }

	    if (this.eat(61)) {
	      node.declaration = this.parseExportDefaultExpression();
	      this.checkExport(node, true, true);
	      return this.finishNode(node, "ExportDefaultDeclaration");
	    }

	    throw this.unexpected(null, 5);
	  };

	  _proto.eatExportStar = function eatExportStar(node) {
	    return this.eat(51);
	  };

	  _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
	    if (this.isExportDefaultSpecifier()) {
	      this.expectPlugin("exportDefaultFrom");
	      var specifier = this.startNode();
	      specifier.exported = this.parseIdentifier(true);
	      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
	      return true;
	    }

	    return false;
	  };

	  _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
	    if (this.isContextual(89)) {
	      if (!node.specifiers) node.specifiers = [];
	      var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
	      this.next();
	      specifier.exported = this.parseModuleExportName();
	      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
	      return true;
	    }

	    return false;
	  };

	  _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
	    if (this.match(5)) {
	      var _node$specifiers;

	      if (!node.specifiers) node.specifiers = [];
	      var isTypeExport = node.exportKind === "type";

	      (_node$specifiers = node.specifiers).push.apply(_node$specifiers, this.parseExportSpecifiers(isTypeExport));

	      node.source = null;
	      node.declaration = null;

	      if (this.hasPlugin("importAssertions")) {
	        node.assertions = [];
	      }

	      return true;
	    }

	    return false;
	  };

	  _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
	    if (this.shouldParseExportDeclaration()) {
	      node.specifiers = [];
	      node.source = null;

	      if (this.hasPlugin("importAssertions")) {
	        node.assertions = [];
	      }

	      node.declaration = this.parseExportDeclaration(node);
	      return true;
	    }

	    return false;
	  };

	  _proto.isAsyncFunction = function isAsyncFunction() {
	    if (!this.isContextual(91)) return false;
	    var next = this.nextTokenStart();
	    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
	  };

	  _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
	    var expr = this.startNode();
	    var isAsync = this.isAsyncFunction();

	    if (this.match(64) || isAsync) {
	      this.next();

	      if (isAsync) {
	        this.next();
	      }

	      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
	    } else if (this.match(76)) {
	      return this.parseClass(expr, true, true);
	    } else if (this.match(26)) {
	      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	        this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
	      }

	      this.parseDecorators(false);
	      return this.parseClass(expr, true, true);
	    } else if (this.match(71) || this.match(70) || this.isLet()) {
	      throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
	    } else {
	      var res = this.parseMaybeAssignAllowIn();
	      this.semicolon();
	      return res;
	    }
	  };

	  _proto.parseExportDeclaration = function parseExportDeclaration(node) {
	    return this.parseStatement(null);
	  };

	  _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
	    var type = this.state.type;

	    if (tokenIsIdentifier(type)) {
	      if (type === 91 && !this.state.containsEsc || type === 95) {
	        return false;
	      }

	      if ((type === 122 || type === 121) && !this.state.containsEsc) {
	        var _this$lookahead = this.lookahead(),
	            nextType = _this$lookahead.type;

	        if (tokenIsIdentifier(nextType) && nextType !== 93 || nextType === 5) {
	          this.expectOnePlugin(["flow", "typescript"]);
	          return false;
	        }
	      }
	    } else if (!this.match(61)) {
	      return false;
	    }

	    var next = this.nextTokenStart();
	    var hasFrom = this.isUnparsedContextual(next, "from");

	    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
	      return true;
	    }

	    if (this.match(61) && hasFrom) {
	      var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
	      return nextAfterFrom === 34 || nextAfterFrom === 39;
	    }

	    return false;
	  };

	  _proto.parseExportFrom = function parseExportFrom(node, expect) {
	    if (this.eatContextual(93)) {
	      node.source = this.parseImportSource();
	      this.checkExport(node);
	      var assertions = this.maybeParseImportAssertions();

	      if (assertions) {
	        node.assertions = assertions;
	      }
	    } else if (expect) {
	      this.unexpected();
	    }

	    this.semicolon();
	  };

	  _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
	    var type = this.state.type;

	    if (type === 26) {
	      this.expectOnePlugin(["decorators", "decorators-legacy"]);

	      if (this.hasPlugin("decorators")) {
	        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
	          this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
	        } else {
	          return true;
	        }
	      }
	    }

	    return type === 70 || type === 71 || type === 64 || type === 76 || this.isLet() || this.isAsyncFunction();
	  };

	  _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
	    if (checkNames) {
	      if (isDefault) {
	        this.checkDuplicateExports(node, "default");

	        if (this.hasPlugin("exportDefaultFrom")) {
	          var _declaration$extra;

	          var declaration = node.declaration;

	          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
	            this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
	          }
	        }
	      } else if (node.specifiers && node.specifiers.length) {
	        for (var _i6 = 0, _node$specifiers3 = node.specifiers; _i6 < _node$specifiers3.length; _i6++) {
	          var specifier = _node$specifiers3[_i6];
	          var exported = specifier.exported;
	          var exportedName = exported.type === "Identifier" ? exported.name : exported.value;
	          this.checkDuplicateExports(specifier, exportedName);

	          if (!isFrom && specifier.local) {
	            var local = specifier.local;

	            if (local.type !== "Identifier") {
	              this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
	            } else {
	              this.checkReservedWord(local.name, local.start, true, false);
	              this.scope.checkLocalExport(local);
	            }
	          }
	        }
	      } else if (node.declaration) {
	        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
	          var id = node.declaration.id;
	          if (!id) throw new Error("Assertion failure");
	          this.checkDuplicateExports(node, id.name);
	        } else if (node.declaration.type === "VariableDeclaration") {
	          for (var _i8 = 0, _node$declaration$dec2 = node.declaration.declarations; _i8 < _node$declaration$dec2.length; _i8++) {
	            var _declaration = _node$declaration$dec2[_i8];
	            this.checkDeclaration(_declaration.id);
	          }
	        }
	      }
	    }

	    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

	    if (currentContextDecorators.length) {
	      throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
	    }
	  };

	  _proto.checkDeclaration = function checkDeclaration(node) {
	    if (node.type === "Identifier") {
	      this.checkDuplicateExports(node, node.name);
	    } else if (node.type === "ObjectPattern") {
	      for (var _i10 = 0, _node$properties2 = node.properties; _i10 < _node$properties2.length; _i10++) {
	        var prop = _node$properties2[_i10];
	        this.checkDeclaration(prop);
	      }
	    } else if (node.type === "ArrayPattern") {
	      for (var _i12 = 0, _node$elements2 = node.elements; _i12 < _node$elements2.length; _i12++) {
	        var elem = _node$elements2[_i12];

	        if (elem) {
	          this.checkDeclaration(elem);
	        }
	      }
	    } else if (node.type === "ObjectProperty") {
	      this.checkDeclaration(node.value);
	    } else if (node.type === "RestElement") {
	      this.checkDeclaration(node.argument);
	    } else if (node.type === "AssignmentPattern") {
	      this.checkDeclaration(node.left);
	    }
	  };

	  _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
	    if (this.exportedIdentifiers.has(name)) {
	      this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
	    }

	    this.exportedIdentifiers.add(name);
	  };

	  _proto.parseExportSpecifiers = function parseExportSpecifiers(isInTypeExport) {
	    var nodes = [];
	    var first = true;
	    this.expect(5);

	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        this.expect(12);
	        if (this.eat(8)) break;
	      }

	      var isMaybeTypeOnly = this.isContextual(122);
	      var isString = this.match(125);
	      var node = this.startNode();
	      node.local = this.parseModuleExportName();
	      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
	    }

	    return nodes;
	  };

	  _proto.parseExportSpecifier = function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
	    if (this.eatContextual(89)) {
	      node.exported = this.parseModuleExportName();
	    } else if (isString) {
	      node.exported = cloneStringLiteral(node.local);
	    } else if (!node.exported) {
	      node.exported = cloneIdentifier(node.local);
	    }

	    return this.finishNode(node, "ExportSpecifier");
	  };

	  _proto.parseModuleExportName = function parseModuleExportName() {
	    if (this.match(125)) {
	      var result = this.parseStringLiteral(this.state.value);
	      var surrogate = result.value.match(loneSurrogate);

	      if (surrogate) {
	        this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
	      }

	      return result;
	    }

	    return this.parseIdentifier(true);
	  };

	  _proto.parseImport = function parseImport(node) {
	    node.specifiers = [];

	    if (!this.match(125)) {
	      var hasDefault = this.maybeParseDefaultImportSpecifier(node);
	      var parseNext = !hasDefault || this.eat(12);
	      var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
	      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
	      this.expectContextual(93);
	    }

	    node.source = this.parseImportSource();
	    var assertions = this.maybeParseImportAssertions();

	    if (assertions) {
	      node.assertions = assertions;
	    } else {
	      var attributes = this.maybeParseModuleAttributes();

	      if (attributes) {
	        node.attributes = attributes;
	      }
	    }

	    this.semicolon();
	    return this.finishNode(node, "ImportDeclaration");
	  };

	  _proto.parseImportSource = function parseImportSource() {
	    if (!this.match(125)) this.unexpected();
	    return this.parseExprAtom();
	  };

	  _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
	    return tokenIsIdentifier(this.state.type);
	  };

	  _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
	    specifier.local = this.parseIdentifier();
	    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
	    node.specifiers.push(this.finishNode(specifier, type));
	  };

	  _proto.parseAssertEntries = function parseAssertEntries() {
	    var attrs = [];
	    var attrNames = new Set();

	    do {
	      if (this.match(8)) {
	        break;
	      }

	      var node = this.startNode();
	      var keyName = this.state.value;

	      if (attrNames.has(keyName)) {
	        this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
	      }

	      attrNames.add(keyName);

	      if (this.match(125)) {
	        node.key = this.parseStringLiteral(keyName);
	      } else {
	        node.key = this.parseIdentifier(true);
	      }

	      this.expect(14);

	      if (!this.match(125)) {
	        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
	      }

	      node.value = this.parseStringLiteral(this.state.value);
	      this.finishNode(node, "ImportAttribute");
	      attrs.push(node);
	    } while (this.eat(12));

	    return attrs;
	  };

	  _proto.maybeParseModuleAttributes = function maybeParseModuleAttributes() {
	    if (this.match(72) && !this.hasPrecedingLineBreak()) {
	      this.expectPlugin("moduleAttributes");
	      this.next();
	    } else {
	      if (this.hasPlugin("moduleAttributes")) return [];
	      return null;
	    }

	    var attrs = [];
	    var attributes = new Set();

	    do {
	      var node = this.startNode();
	      node.key = this.parseIdentifier(true);

	      if (node.key.name !== "type") {
	        this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
	      }

	      if (attributes.has(node.key.name)) {
	        this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
	      }

	      attributes.add(node.key.name);
	      this.expect(14);

	      if (!this.match(125)) {
	        throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
	      }

	      node.value = this.parseStringLiteral(this.state.value);
	      this.finishNode(node, "ImportAttribute");
	      attrs.push(node);
	    } while (this.eat(12));

	    return attrs;
	  };

	  _proto.maybeParseImportAssertions = function maybeParseImportAssertions() {
	    if (this.isContextual(90) && !this.hasPrecedingLineBreak()) {
	      this.expectPlugin("importAssertions");
	      this.next();
	    } else {
	      if (this.hasPlugin("importAssertions")) return [];
	      return null;
	    }

	    this.eat(5);
	    var attrs = this.parseAssertEntries();
	    this.eat(8);
	    return attrs;
	  };

	  _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
	    if (this.shouldParseDefaultImport(node)) {
	      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
	      return true;
	    }

	    return false;
	  };

	  _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
	    if (this.match(51)) {
	      var specifier = this.startNode();
	      this.next();
	      this.expectContextual(89);
	      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
	      return true;
	    }

	    return false;
	  };

	  _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
	    var first = true;
	    this.expect(5);

	    while (!this.eat(8)) {
	      if (first) {
	        first = false;
	      } else {
	        if (this.eat(14)) {
	          throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
	        }

	        this.expect(12);
	        if (this.eat(8)) break;
	      }

	      var specifier = this.startNode();
	      var importedIsString = this.match(125);
	      var isMaybeTypeOnly = this.isContextual(122);
	      specifier.imported = this.parseModuleExportName();
	      var importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
	      node.specifiers.push(importSpecifier);
	    }
	  };

	  _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
	    if (this.eatContextual(89)) {
	      specifier.local = this.parseIdentifier();
	    } else {
	      var imported = specifier.imported;

	      if (importedIsString) {
	        throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
	      }

	      this.checkReservedWord(imported.name, specifier.start, true, true);

	      if (!specifier.local) {
	        specifier.local = cloneIdentifier(imported);
	      }
	    }

	    this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
	    return this.finishNode(specifier, "ImportSpecifier");
	  };

	  _proto.isThisParam = function isThisParam(param) {
	    return param.type === "Identifier" && param.name === "this";
	  };

	  return StatementParser;
	}(ExpressionParser);

	var Parser = function (_StatementParser) {
	  _inherits(Parser, _StatementParser);

	  function Parser(options, input) {
	    var _this;

	    options = getOptions(options);
	    _this = _StatementParser.call(this, options, input) || this;
	    _this.options = options;

	    _this.initializeScopes();

	    _this.plugins = pluginsMap(_this.options.plugins);
	    _this.filename = options.sourceFilename;
	    return _this;
	  }

	  var _proto = Parser.prototype;

	  _proto.getScopeHandler = function getScopeHandler() {
	    return ScopeHandler;
	  };

	  _proto.parse = function parse() {
	    this.enterInitialScopes();
	    var file = this.startNode();
	    var program = this.startNode();
	    this.nextToken();
	    file.errors = null;
	    this.parseTopLevel(file, program);
	    file.errors = this.state.errors;
	    return file;
	  };

	  return Parser;
	}(StatementParser);

	function pluginsMap(plugins) {
	  var pluginMap = new Map();

	  for (var _i2 = 0; _i2 < plugins.length; _i2++) {
	    var plugin = plugins[_i2];

	    var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
	        name = _ref[0],
	        options = _ref[1];

	    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
	  }

	  return pluginMap;
	}

	function parse$5(input, options) {
	  var _options;

	  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
	    options = Object.assign({}, options);

	    try {
	      options.sourceType = "module";
	      var parser = getParser(options, input);
	      var ast = parser.parse();

	      if (parser.sawUnambiguousESM) {
	        return ast;
	      }

	      if (parser.ambiguousScriptDifferentAst) {
	        try {
	          options.sourceType = "script";
	          return getParser(options, input).parse();
	        } catch (_unused) {}
	      } else {
	        ast.program.sourceType = "script";
	      }

	      return ast;
	    } catch (moduleError) {
	      try {
	        options.sourceType = "script";
	        return getParser(options, input).parse();
	      } catch (_unused2) {}

	      throw moduleError;
	    }
	  } else {
	    return getParser(options, input).parse();
	  }
	}

	function generateExportedTokenTypes(internalTokenTypes) {
	  var tokenTypes = {};

	  for (var _i2 = 0, _Object$keys2 = Object.keys(internalTokenTypes); _i2 < _Object$keys2.length; _i2++) {
	    var typeName = _Object$keys2[_i2];
	    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
	  }

	  return tokenTypes;
	}

	var tokTypes = generateExportedTokenTypes(tt);

	function getParser(options, input) {
	  var cls = Parser;

	  if (options != null && options.plugins) {
	    validatePlugins(options.plugins);
	    cls = getParserClass(options.plugins);
	  }

	  return new cls(options, input);
	}

	var parserClassCache = {};

	function getParserClass(pluginsFromOptions) {
	  var pluginList = mixinPluginNames.filter(function (name) {
	    return hasPlugin(pluginsFromOptions, name);
	  });
	  var key = pluginList.join("/");
	  var cls = parserClassCache[key];

	  if (!cls) {
	    cls = Parser;

	    for (var _i4 = 0; _i4 < pluginList.length; _i4++) {
	      var plugin = pluginList[_i4];
	      cls = mixinPlugins[plugin](cls);
	    }

	    parserClassCache[key] = cls;
	  }

	  return cls;
	}

	var assignmentExpression$b = assignmentExpression$c,
	    expressionStatement$9 = expressionStatement$a,
	    identifier$f = identifier$j;
	var visitor$3 = {
	  Scope: function Scope(path, state) {
	    if (state.kind === "let") path.skip();
	  },
	  FunctionParent: function FunctionParent(path) {
	    path.skip();
	  },
	  VariableDeclaration: function (_VariableDeclaration) {
	    function VariableDeclaration(_x, _x2) {
	      return _VariableDeclaration.apply(this, arguments);
	    }

	    VariableDeclaration.toString = function () {
	      return _VariableDeclaration.toString();
	    };

	    return VariableDeclaration;
	  }(function (path, state) {
	    if (state.kind && path.node.kind !== state.kind) return;
	    var nodes = [];
	    var declarations = path.get("declarations");
	    var firstId;

	    for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
	      var declar = _step.value;
	      firstId = declar.node.id;

	      if (declar.node.init) {
	        nodes.push(expressionStatement$9(assignmentExpression$b("=", declar.node.id, declar.node.init)));
	      }

	      for (var _i = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
	        var name = _Object$keys[_i];
	        state.emit(identifier$f(name), name, declar.node.init !== null);
	      }
	    }

	    if (path.parentPath.isFor({
	      left: path.node
	    })) {
	      path.replaceWith(firstId);
	    } else {
	      path.replaceWithMultiple(nodes);
	    }
	  })
	};
	function hoistVariables(path, emit, kind) {
	  if (kind === void 0) {
	    kind = "var";
	  }

	  path.traverse(visitor$3, {
	    kind: kind,
	    emit: emit
	  });
	}

	var FUNCTION_TYPES = FUNCTION_TYPES$1,
	    arrowFunctionExpression$3 = arrowFunctionExpression$4,
	    assignmentExpression$a = assignmentExpression$c,
	    awaitExpression = awaitExpression$1,
	    blockStatement$5 = blockStatement$6,
	    callExpression$c = callExpression$e,
	    cloneNode$f = cloneNode$i,
	    expressionStatement$8 = expressionStatement$a,
	    identifier$e = identifier$j,
	    inheritLeadingComments = inheritLeadingComments$1,
	    inheritTrailingComments = inheritTrailingComments$1,
	    inheritsComments$1 = inheritsComments$2,
	    isExpression$2 = isExpression$4,
	    isProgram = isProgram$2,
	    isStatement$2 = isStatement$7,
	    removeComments$1 = removeComments$2,
	    returnStatement$2 = returnStatement$3,
	    toSequenceExpression = toSequenceExpression$1,
	    validate$4 = validate$6,
	    yieldExpression$1 = yieldExpression$2;
	function replaceWithMultiple(nodes) {
	  var _pathCache$get;

	  this.resync();
	  nodes = this._verifyNodeList(nodes);
	  inheritLeadingComments(nodes[0], this.node);
	  inheritTrailingComments(nodes[nodes.length - 1], this.node);
	  (_pathCache$get = path$3.get(this.parent)) == null ? void 0 : _pathCache$get["delete"](this.node);
	  this.node = this.container[this.key] = null;
	  var paths = this.insertAfter(nodes);

	  if (this.node) {
	    this.requeue();
	  } else {
	    this.remove();
	  }

	  return paths;
	}
	function replaceWithSourceString(replacement) {
	  this.resync();

	  try {
	    replacement = "(" + replacement + ")";
	    replacement = parse$5(replacement);
	  } catch (err) {
	    var loc = err.loc;

	    if (loc) {
	      err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
	        start: {
	          line: loc.line,
	          column: loc.column + 1
	        }
	      });
	      err.code = "BABEL_REPLACE_SOURCE_ERROR";
	    }

	    throw err;
	  }

	  replacement = replacement.program.body[0].expression;
	  traverse.removeProperties(replacement);
	  return this.replaceWith(replacement);
	}
	function replaceWith(replacement) {
	  this.resync();

	  if (this.removed) {
	    throw new Error("You can't replace this node, we've already removed it");
	  }

	  if (replacement instanceof NodePath) {
	    replacement = replacement.node;
	  }

	  if (!replacement) {
	    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
	  }

	  if (this.node === replacement) {
	    return [this];
	  }

	  if (this.isProgram() && !isProgram(replacement)) {
	    throw new Error("You can only replace a Program root node with another Program node");
	  }

	  if (Array.isArray(replacement)) {
	    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
	  }

	  if (typeof replacement === "string") {
	    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
	  }

	  var nodePath = "";

	  if (this.isNodeType("Statement") && isExpression$2(replacement)) {
	    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
	      replacement = expressionStatement$8(replacement);
	      nodePath = "expression";
	    }
	  }

	  if (this.isNodeType("Expression") && isStatement$2(replacement)) {
	    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
	      return this.replaceExpressionWithStatements([replacement]);
	    }
	  }

	  var oldNode = this.node;

	  if (oldNode) {
	    inheritsComments$1(replacement, oldNode);
	    removeComments$1(oldNode);
	  }

	  this._replaceWith(replacement);

	  this.type = replacement.type;
	  this.setScope();
	  this.requeue();
	  return [nodePath ? this.get(nodePath) : this];
	}
	function _replaceWith(node) {
	  var _pathCache$get2;

	  if (!this.container) {
	    throw new ReferenceError("Container is falsy");
	  }

	  if (this.inList) {
	    validate$4(this.parent, this.key, [node]);
	  } else {
	    validate$4(this.parent, this.key, node);
	  }

	  this.debug("Replace with " + (node == null ? void 0 : node.type));
	  (_pathCache$get2 = path$3.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this)["delete"](this.node);
	  this.node = this.container[this.key] = node;
	}
	function replaceExpressionWithStatements(nodes) {
	  var _this = this;

	  this.resync();
	  var nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);

	  if (nodesAsSequenceExpression) {
	    return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
	  }

	  var functionParent = this.getFunctionParent();
	  var isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
	  var isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
	  var container = arrowFunctionExpression$3([], blockStatement$5(nodes));
	  this.replaceWith(callExpression$c(container, []));
	  var callee = this.get("callee");
	  hoistVariables(callee.get("body"), function (id) {
	    _this.scope.push({
	      id: id
	    });
	  }, "var");
	  var completionRecords = this.get("callee").getCompletionRecords();

	  for (var _iterator = _createForOfIteratorHelperLoose(completionRecords), _step; !(_step = _iterator()).done;) {
	    var path = _step.value;
	    if (!path.isExpressionStatement()) continue;
	    var loop = path.findParent(function (path) {
	      return path.isLoop();
	    });

	    if (loop) {
	      var uid = loop.getData("expressionReplacementReturnUid");

	      if (!uid) {
	        uid = callee.scope.generateDeclaredUidIdentifier("ret");
	        callee.get("body").pushContainer("body", returnStatement$2(cloneNode$f(uid)));
	        loop.setData("expressionReplacementReturnUid", uid);
	      } else {
	        uid = identifier$e(uid.name);
	      }

	      path.get("expression").replaceWith(assignmentExpression$a("=", cloneNode$f(uid), path.node.expression));
	    } else {
	      path.replaceWith(returnStatement$2(path.node.expression));
	    }
	  }

	  callee.arrowFunctionToExpression();
	  var newCallee = callee;
	  var needToAwaitFunction = isParentAsync && traverse.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
	  var needToYieldFunction = isParentGenerator && traverse.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);

	  if (needToAwaitFunction) {
	    newCallee.set("async", true);

	    if (!needToYieldFunction) {
	      this.replaceWith(awaitExpression(this.node));
	    }
	  }

	  if (needToYieldFunction) {
	    newCallee.set("generator", true);
	    this.replaceWith(yieldExpression$1(this.node, true));
	  }

	  return newCallee.get("body.body");
	}
	function replaceInline(nodes) {
	  this.resync();

	  if (Array.isArray(nodes)) {
	    if (Array.isArray(this.container)) {
	      nodes = this._verifyNodeList(nodes);

	      var paths = this._containerInsertAfter(nodes);

	      this.remove();
	      return paths;
	    } else {
	      return this.replaceWithMultiple(nodes);
	    }
	  } else {
	    return this.replaceWith(nodes);
	  }
	}

	var NodePath_replacement = /*#__PURE__*/Object.freeze({
		__proto__: null,
		replaceWithMultiple: replaceWithMultiple,
		replaceWithSourceString: replaceWithSourceString,
		replaceWith: replaceWith,
		_replaceWith: _replaceWith,
		replaceExpressionWithStatements: replaceExpressionWithStatements,
		replaceInline: replaceInline
	});

	var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

	var VALID_CALLEES = ["String", "Number", "Math"];
	var INVALID_METHODS = ["random"];
	function evaluateTruthy() {
	  var res = this.evaluate();
	  if (res.confident) return !!res.value;
	}

	function deopt(path, state) {
	  if (!state.confident) return;
	  state.deoptPath = path;
	  state.confident = false;
	}

	function evaluateCached(path, state) {
	  var node = path.node;
	  var seen = state.seen;

	  if (seen.has(node)) {
	    var existing = seen.get(node);

	    if (existing.resolved) {
	      return existing.value;
	    } else {
	      deopt(path, state);
	      return;
	    }
	  } else {
	    var item = {
	      resolved: false
	    };
	    seen.set(node, item);

	    var val = _evaluate(path, state);

	    if (state.confident) {
	      item.resolved = true;
	      item.value = val;
	    }

	    return val;
	  }
	}

	function _evaluate(path, state) {
	  if (!state.confident) return;

	  if (path.isSequenceExpression()) {
	    var exprs = path.get("expressions");
	    return evaluateCached(exprs[exprs.length - 1], state);
	  }

	  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
	    return path.node.value;
	  }

	  if (path.isNullLiteral()) {
	    return null;
	  }

	  if (path.isTemplateLiteral()) {
	    return evaluateQuasis(path, path.node.quasis, state);
	  }

	  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
	    var object = path.get("tag.object");
	    var name = object.node.name;
	    var property = path.get("tag.property");

	    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
	      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
	    }
	  }

	  if (path.isConditionalExpression()) {
	    var testResult = evaluateCached(path.get("test"), state);
	    if (!state.confident) return;

	    if (testResult) {
	      return evaluateCached(path.get("consequent"), state);
	    } else {
	      return evaluateCached(path.get("alternate"), state);
	    }
	  }

	  if (path.isExpressionWrapper()) {
	    return evaluateCached(path.get("expression"), state);
	  }

	  if (path.isMemberExpression() && !path.parentPath.isCallExpression({
	    callee: path.node
	  })) {
	    var _property = path.get("property");

	    var _object = path.get("object");

	    if (_object.isLiteral() && _property.isIdentifier()) {
	      var value = _object.node.value;
	      var type = typeof value;

	      if (type === "number" || type === "string") {
	        return value[_property.node.name];
	      }
	    }
	  }

	  if (path.isReferencedIdentifier()) {
	    var binding = path.scope.getBinding(path.node.name);

	    if (binding && binding.constantViolations.length > 0) {
	      return deopt(binding.path, state);
	    }

	    if (binding && path.node.start < binding.path.node.end) {
	      return deopt(binding.path, state);
	    }

	    if (binding != null && binding.hasValue) {
	      return binding.value;
	    } else {
	      if (path.node.name === "undefined") {
	        return binding ? deopt(binding.path, state) : undefined;
	      } else if (path.node.name === "Infinity") {
	        return binding ? deopt(binding.path, state) : Infinity;
	      } else if (path.node.name === "NaN") {
	        return binding ? deopt(binding.path, state) : NaN;
	      }

	      var resolved = path.resolve();

	      if (resolved === path) {
	        return deopt(path, state);
	      } else {
	        return evaluateCached(resolved, state);
	      }
	    }
	  }

	  if (path.isUnaryExpression({
	    prefix: true
	  })) {
	    if (path.node.operator === "void") {
	      return undefined;
	    }

	    var argument = path.get("argument");

	    if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
	      return "function";
	    }

	    var arg = evaluateCached(argument, state);
	    if (!state.confident) return;

	    switch (path.node.operator) {
	      case "!":
	        return !arg;

	      case "+":
	        return +arg;

	      case "-":
	        return -arg;

	      case "~":
	        return ~arg;

	      case "typeof":
	        return typeof arg;
	    }
	  }

	  if (path.isArrayExpression()) {
	    var arr = [];
	    var elems = path.get("elements");

	    for (var _iterator = _createForOfIteratorHelperLoose(elems), _step; !(_step = _iterator()).done;) {
	      var elem = _step.value;
	      var elemValue = elem.evaluate();

	      if (elemValue.confident) {
	        arr.push(elemValue.value);
	      } else {
	        return deopt(elemValue.deopt, state);
	      }
	    }

	    return arr;
	  }

	  if (path.isObjectExpression()) {
	    var obj = {};
	    var props = path.get("properties");

	    for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
	      var prop = _step2.value;

	      if (prop.isObjectMethod() || prop.isSpreadElement()) {
	        return deopt(prop, state);
	      }

	      var keyPath = prop.get("key");
	      var key = keyPath;

	      if (prop.node.computed) {
	        key = key.evaluate();

	        if (!key.confident) {
	          return deopt(key.deopt, state);
	        }

	        key = key.value;
	      } else if (key.isIdentifier()) {
	        key = key.node.name;
	      } else {
	        key = key.node.value;
	      }

	      var valuePath = prop.get("value");

	      var _value = valuePath.evaluate();

	      if (!_value.confident) {
	        return deopt(_value.deopt, state);
	      }

	      _value = _value.value;
	      obj[key] = _value;
	    }

	    return obj;
	  }

	  if (path.isLogicalExpression()) {
	    var wasConfident = state.confident;
	    var left = evaluateCached(path.get("left"), state);
	    var leftConfident = state.confident;
	    state.confident = wasConfident;
	    var right = evaluateCached(path.get("right"), state);
	    var rightConfident = state.confident;

	    switch (path.node.operator) {
	      case "||":
	        state.confident = leftConfident && (!!left || rightConfident);
	        if (!state.confident) return;
	        return left || right;

	      case "&&":
	        state.confident = leftConfident && (!left || rightConfident);
	        if (!state.confident) return;
	        return left && right;
	    }
	  }

	  if (path.isBinaryExpression()) {
	    var _left = evaluateCached(path.get("left"), state);

	    if (!state.confident) return;

	    var _right = evaluateCached(path.get("right"), state);

	    if (!state.confident) return;

	    switch (path.node.operator) {
	      case "-":
	        return _left - _right;

	      case "+":
	        return _left + _right;

	      case "/":
	        return _left / _right;

	      case "*":
	        return _left * _right;

	      case "%":
	        return _left % _right;

	      case "**":
	        return Math.pow(_left, _right);

	      case "<":
	        return _left < _right;

	      case ">":
	        return _left > _right;

	      case "<=":
	        return _left <= _right;

	      case ">=":
	        return _left >= _right;

	      case "==":
	        return _left == _right;

	      case "!=":
	        return _left != _right;

	      case "===":
	        return _left === _right;

	      case "!==":
	        return _left !== _right;

	      case "|":
	        return _left | _right;

	      case "&":
	        return _left & _right;

	      case "^":
	        return _left ^ _right;

	      case "<<":
	        return _left << _right;

	      case ">>":
	        return _left >> _right;

	      case ">>>":
	        return _left >>> _right;
	    }
	  }

	  if (path.isCallExpression()) {
	    var callee = path.get("callee");
	    var context;
	    var func;

	    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
	      func = global$1[callee.node.name];
	    }

	    if (callee.isMemberExpression()) {
	      var _object2 = callee.get("object");

	      var _property2 = callee.get("property");

	      if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
	        context = global$1[_object2.node.name];
	        func = context[_property2.node.name];
	      }

	      if (_object2.isLiteral() && _property2.isIdentifier()) {
	        var _type = typeof _object2.node.value;

	        if (_type === "string" || _type === "number") {
	          context = _object2.node.value;
	          func = context[_property2.node.name];
	        }
	      }
	    }

	    if (func) {
	      var args = path.get("arguments").map(function (arg) {
	        return evaluateCached(arg, state);
	      });
	      if (!state.confident) return;
	      return func.apply(context, args);
	    }
	  }

	  deopt(path, state);
	}

	function evaluateQuasis(path, quasis, state, raw) {
	  if (raw === void 0) {
	    raw = false;
	  }

	  var str = "";
	  var i = 0;
	  var exprs = path.get("expressions");

	  for (var _iterator3 = _createForOfIteratorHelperLoose(quasis), _step3; !(_step3 = _iterator3()).done;) {
	    var elem = _step3.value;
	    if (!state.confident) break;
	    str += raw ? elem.value.raw : elem.value.cooked;
	    var expr = exprs[i++];
	    if (expr) str += String(evaluateCached(expr, state));
	  }

	  if (!state.confident) return;
	  return str;
	}

	function evaluate$1() {
	  var state = {
	    confident: true,
	    deoptPath: null,
	    seen: new Map()
	  };
	  var value = evaluateCached(this, state);
	  if (!state.confident) value = undefined;
	  return {
	    confident: state.confident,
	    deopt: state.deoptPath,
	    value: value
	  };
	}

	var NodePath_evaluation = /*#__PURE__*/Object.freeze({
		__proto__: null,
		evaluateTruthy: evaluateTruthy,
		evaluate: evaluate$1
	});

	var _skipKey$MethodClass;
	var VISITOR_KEYS$3 = VISITOR_KEYS$6,
	    staticBlock = staticBlock$1;
	function skipAllButComputedKey(path) {
	  if (!path.node.computed) {
	    path.skip();
	    return;
	  }

	  var keys = VISITOR_KEYS$3[path.type];

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    if (key !== "key") path.skipKey(key);
	  }
	}
	var skipKey$1 = (staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation|FunctionDeclaration|FunctionExpression";
	var environmentVisitor = (_skipKey$MethodClass = {}, _skipKey$MethodClass[skipKey$1] = function (path) {
	  return path.skip();
	}, _skipKey$MethodClass["Method|ClassProperty"] = function MethodClassProperty(path) {
	  skipAllButComputedKey(path);
	}, _skipKey$MethodClass);

	var isAssignmentPattern$2 = isAssignmentPattern$4,
	    isRestElement$1 = isRestElement$2;
	function getFunctionArity (node) {
	  var params = node.params;

	  for (var i = 0; i < params.length; i++) {
	    var param = params[i];

	    if (isAssignmentPattern$2(param) || isRestElement$1(param)) {
	      return i;
	    }
	  }

	  return params.length;
	}

	var assertExpressionStatement = assertExpressionStatement$1;

	function makeStatementFormatter(fn) {
	  return {
	    code: function code(str) {
	      return "/* @babel/template */;\n" + str;
	    },
	    validate: function validate() {},
	    unwrap: function unwrap(ast) {
	      return fn(ast.program.body.slice(1));
	    }
	  };
	}

	var smart$1 = makeStatementFormatter(function (body) {
	  if (body.length > 1) {
	    return body;
	  } else {
	    return body[0];
	  }
	});
	var statements$1 = makeStatementFormatter(function (body) {
	  return body;
	});
	var statement$1 = makeStatementFormatter(function (body) {
	  if (body.length === 0) {
	    throw new Error("Found nothing to return.");
	  }

	  if (body.length > 1) {
	    throw new Error("Found multiple statements but wanted one");
	  }

	  return body[0];
	});
	var expression$1 = {
	  code: function code(str) {
	    return "(\n" + str + "\n)";
	  },
	  validate: function validate(ast) {
	    if (ast.program.body.length > 1) {
	      throw new Error("Found multiple statements but wanted one");
	    }

	    if (expression$1.unwrap(ast).start === 0) {
	      throw new Error("Parse result included parens.");
	    }
	  },
	  unwrap: function unwrap(_ref) {
	    var program = _ref.program;

	    var _program$body = _slicedToArray$1(program.body, 1),
	        stmt = _program$body[0];

	    assertExpressionStatement(stmt);
	    return stmt.expression;
	  }
	};
	var program$2 = {
	  code: function code(str) {
	    return str;
	  },
	  validate: function validate() {},
	  unwrap: function unwrap(ast) {
	    return ast.program;
	  }
	};

	var _excluded$3 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
	function merge$1(a, b) {
	  var _b$placeholderWhiteli = b.placeholderWhitelist,
	      placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
	      _b$placeholderPattern = b.placeholderPattern,
	      placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
	      _b$preserveComments = b.preserveComments,
	      preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
	      _b$syntacticPlacehold = b.syntacticPlaceholders,
	      syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
	  return {
	    parser: Object.assign({}, a.parser, b.parser),
	    placeholderWhitelist: placeholderWhitelist,
	    placeholderPattern: placeholderPattern,
	    preserveComments: preserveComments,
	    syntacticPlaceholders: syntacticPlaceholders
	  };
	}
	function validate$3(opts) {
	  if (opts != null && typeof opts !== "object") {
	    throw new Error("Unknown template options.");
	  }

	  var _ref = opts || {},
	      placeholderWhitelist = _ref.placeholderWhitelist,
	      placeholderPattern = _ref.placeholderPattern,
	      preserveComments = _ref.preserveComments,
	      syntacticPlaceholders = _ref.syntacticPlaceholders,
	      parser = _objectWithoutPropertiesLoose(_ref, _excluded$3);

	  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
	    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
	  }

	  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
	    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
	  }

	  if (preserveComments != null && typeof preserveComments !== "boolean") {
	    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
	  }

	  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
	    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
	  }

	  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
	    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
	  }

	  return {
	    parser: parser,
	    placeholderWhitelist: placeholderWhitelist || undefined,
	    placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
	    preserveComments: preserveComments == null ? undefined : preserveComments,
	    syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
	  };
	}
	function normalizeReplacements(replacements) {
	  if (Array.isArray(replacements)) {
	    return replacements.reduce(function (acc, replacement, i) {
	      acc["$" + i] = replacement;
	      return acc;
	    }, {});
	  } else if (typeof replacements === "object" || replacements == null) {
	    return replacements || undefined;
	  }

	  throw new Error("Template replacements must be an array, object, null, or undefined");
	}

	var isCallExpression$1 = isCallExpression$6,
	    isExpressionStatement$1 = isExpressionStatement$4,
	    isFunction$1 = isFunction$4,
	    isIdentifier$9 = isIdentifier$g,
	    isJSXIdentifier$1 = isJSXIdentifier$3,
	    isNewExpression = isNewExpression$4,
	    isPlaceholder = isPlaceholder$1,
	    isStatement$1 = isStatement$7,
	    isStringLiteral$5 = isStringLiteral$7,
	    removePropertiesDeep = removePropertiesDeep$1,
	    traverse$1 = traverse$2;
	var PATTERN = /^[_$A-Z0-9]+$/;
	function parseAndBuildMetadata(formatter, code, opts) {
	  var placeholderWhitelist = opts.placeholderWhitelist,
	      placeholderPattern = opts.placeholderPattern,
	      preserveComments = opts.preserveComments,
	      syntacticPlaceholders = opts.syntacticPlaceholders;
	  var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
	  removePropertiesDeep(ast, {
	    preserveComments: preserveComments
	  });
	  formatter.validate(ast);
	  var syntactic = {
	    placeholders: [],
	    placeholderNames: new Set()
	  };
	  var legacy = {
	    placeholders: [],
	    placeholderNames: new Set()
	  };
	  var isLegacyRef = {
	    value: undefined
	  };
	  traverse$1(ast, placeholderVisitorHandler, {
	    syntactic: syntactic,
	    legacy: legacy,
	    isLegacyRef: isLegacyRef,
	    placeholderWhitelist: placeholderWhitelist,
	    placeholderPattern: placeholderPattern,
	    syntacticPlaceholders: syntacticPlaceholders
	  });
	  return Object.assign({
	    ast: ast
	  }, isLegacyRef.value ? legacy : syntactic);
	}

	function placeholderVisitorHandler(node, ancestors, state) {
	  var _state$placeholderWhi;

	  var name;

	  if (isPlaceholder(node)) {
	    if (state.syntacticPlaceholders === false) {
	      throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
	    } else {
	      name = node.name.name;
	      state.isLegacyRef.value = false;
	    }
	  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
	    return;
	  } else if (isIdentifier$9(node) || isJSXIdentifier$1(node)) {
	    name = node.name;
	    state.isLegacyRef.value = true;
	  } else if (isStringLiteral$5(node)) {
	    name = node.value;
	    state.isLegacyRef.value = true;
	  } else {
	    return;
	  }

	  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
	    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
	  }

	  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
	    return;
	  }

	  ancestors = ancestors.slice();
	  var _ancestors = ancestors[ancestors.length - 1],
	      parent = _ancestors.node,
	      key = _ancestors.key;
	  var type;

	  if (isStringLiteral$5(node) || isPlaceholder(node, {
	    expectedNode: "StringLiteral"
	  })) {
	    type = "string";
	  } else if (isNewExpression(parent) && key === "arguments" || isCallExpression$1(parent) && key === "arguments" || isFunction$1(parent) && key === "params") {
	    type = "param";
	  } else if (isExpressionStatement$1(parent) && !isPlaceholder(node)) {
	    type = "statement";
	    ancestors = ancestors.slice(0, -1);
	  } else if (isStatement$1(node) && isPlaceholder(node)) {
	    type = "statement";
	  } else {
	    type = "other";
	  }

	  var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
	      placeholders = _ref.placeholders,
	      placeholderNames = _ref.placeholderNames;

	  placeholders.push({
	    name: name,
	    type: type,
	    resolve: function resolve(ast) {
	      return resolveAncestors(ast, ancestors);
	    },
	    isDuplicate: placeholderNames.has(name)
	  });
	  placeholderNames.add(name);
	}

	function resolveAncestors(ast, ancestors) {
	  var parent = ast;

	  for (var i = 0; i < ancestors.length - 1; i++) {
	    var _ancestors$i = ancestors[i],
	        _key = _ancestors$i.key,
	        _index = _ancestors$i.index;

	    if (_index === undefined) {
	      parent = parent[_key];
	    } else {
	      parent = parent[_key][_index];
	    }
	  }

	  var _ancestors2 = ancestors[ancestors.length - 1],
	      key = _ancestors2.key,
	      index = _ancestors2.index;
	  return {
	    parent: parent,
	    key: key,
	    index: index
	  };
	}

	function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
	  var plugins = (parserOpts.plugins || []).slice();

	  if (syntacticPlaceholders !== false) {
	    plugins.push("placeholders");
	  }

	  parserOpts = Object.assign({
	    allowReturnOutsideFunction: true,
	    allowSuperOutsideMethod: true,
	    sourceType: "module"
	  }, parserOpts, {
	    plugins: plugins
	  });

	  try {
	    return parse$5(code, parserOpts);
	  } catch (err) {
	    var loc = err.loc;

	    if (loc) {
	      err.message += "\n" + codeFrameColumns(code, {
	        start: loc
	      });
	      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
	    }

	    throw err;
	  }
	}

	var blockStatement$4 = blockStatement$6,
	    cloneNode$e = cloneNode$i,
	    emptyStatement = emptyStatement$1,
	    expressionStatement$7 = expressionStatement$a,
	    identifier$d = identifier$j,
	    isStatement = isStatement$7,
	    isStringLiteral$4 = isStringLiteral$7,
	    stringLiteral$7 = stringLiteral$8,
	    validate$2 = validate$6;
	function populatePlaceholders(metadata, replacements) {
	  var ast = cloneNode$e(metadata.ast);

	  if (replacements) {
	    metadata.placeholders.forEach(function (placeholder) {
	      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
	        var placeholderName = placeholder.name;
	        throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
	      }
	    });
	    Object.keys(replacements).forEach(function (key) {
	      if (!metadata.placeholderNames.has(key)) {
	        throw new Error("Unknown substitution \"" + key + "\" given");
	      }
	    });
	  }

	  metadata.placeholders.slice().reverse().forEach(function (placeholder) {
	    try {
	      applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
	    } catch (e) {
	      e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
	      throw e;
	    }
	  });
	  return ast;
	}

	function applyReplacement(placeholder, ast, replacement) {
	  if (placeholder.isDuplicate) {
	    if (Array.isArray(replacement)) {
	      replacement = replacement.map(function (node) {
	        return cloneNode$e(node);
	      });
	    } else if (typeof replacement === "object") {
	      replacement = cloneNode$e(replacement);
	    }
	  }

	  var _placeholder$resolve = placeholder.resolve(ast),
	      parent = _placeholder$resolve.parent,
	      key = _placeholder$resolve.key,
	      index = _placeholder$resolve.index;

	  if (placeholder.type === "string") {
	    if (typeof replacement === "string") {
	      replacement = stringLiteral$7(replacement);
	    }

	    if (!replacement || !isStringLiteral$4(replacement)) {
	      throw new Error("Expected string substitution");
	    }
	  } else if (placeholder.type === "statement") {
	    if (index === undefined) {
	      if (!replacement) {
	        replacement = emptyStatement();
	      } else if (Array.isArray(replacement)) {
	        replacement = blockStatement$4(replacement);
	      } else if (typeof replacement === "string") {
	        replacement = expressionStatement$7(identifier$d(replacement));
	      } else if (!isStatement(replacement)) {
	        replacement = expressionStatement$7(replacement);
	      }
	    } else {
	      if (replacement && !Array.isArray(replacement)) {
	        if (typeof replacement === "string") {
	          replacement = identifier$d(replacement);
	        }

	        if (!isStatement(replacement)) {
	          replacement = expressionStatement$7(replacement);
	        }
	      }
	    }
	  } else if (placeholder.type === "param") {
	    if (typeof replacement === "string") {
	      replacement = identifier$d(replacement);
	    }

	    if (index === undefined) throw new Error("Assertion failure.");
	  } else {
	    if (typeof replacement === "string") {
	      replacement = identifier$d(replacement);
	    }

	    if (Array.isArray(replacement)) {
	      throw new Error("Cannot replace single expression with an array.");
	    }
	  }

	  if (index === undefined) {
	    validate$2(parent, key, replacement);
	    parent[key] = replacement;
	  } else {
	    var items = parent[key].slice();

	    if (placeholder.type === "statement" || placeholder.type === "param") {
	      if (replacement == null) {
	        items.splice(index, 1);
	      } else if (Array.isArray(replacement)) {
	        items.splice.apply(items, [index, 1].concat(_toConsumableArray(replacement)));
	      } else {
	        items[index] = replacement;
	      }
	    } else {
	      items[index] = replacement;
	    }

	    validate$2(parent, key, items);
	    parent[key] = items;
	  }
	}

	function stringTemplate(formatter, code, opts) {
	  code = formatter.code(code);
	  var metadata;
	  return function (arg) {
	    var replacements = normalizeReplacements(arg);
	    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
	    return formatter.unwrap(populatePlaceholders(metadata, replacements));
	  };
	}

	function literalTemplate(formatter, tpl, opts) {
	  var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
	      metadata = _buildLiteralData.metadata,
	      names = _buildLiteralData.names;

	  return function (arg) {
	    var defaultReplacements = {};
	    arg.forEach(function (replacement, i) {
	      defaultReplacements[names[i]] = replacement;
	    });
	    return function (arg) {
	      var replacements = normalizeReplacements(arg);

	      if (replacements) {
	        Object.keys(replacements).forEach(function (key) {
	          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
	            throw new Error("Unexpected replacement overlap.");
	          }
	        });
	      }

	      return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
	    };
	  };
	}

	function buildLiteralData(formatter, tpl, opts) {
	  var names;
	  var nameSet;
	  var metadata;
	  var prefix = "";

	  do {
	    prefix += "$";
	    var result = buildTemplateCode(tpl, prefix);
	    names = result.names;
	    nameSet = new Set(names);
	    metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
	      parser: opts.parser,
	      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
	      placeholderPattern: opts.placeholderPattern,
	      preserveComments: opts.preserveComments,
	      syntacticPlaceholders: opts.syntacticPlaceholders
	    });
	  } while (metadata.placeholders.some(function (placeholder) {
	    return placeholder.isDuplicate && nameSet.has(placeholder.name);
	  }));

	  return {
	    metadata: metadata,
	    names: names
	  };
	}

	function buildTemplateCode(tpl, prefix) {
	  var names = [];
	  var code = tpl[0];

	  for (var i = 1; i < tpl.length; i++) {
	    var value = "" + prefix + (i - 1);
	    names.push(value);
	    code += value + tpl[i];
	  }

	  return {
	    names: names,
	    code: code
	  };
	}

	var NO_PLACEHOLDER = validate$3({
	  placeholderPattern: false
	});
	function createTemplateBuilder(formatter, defaultOpts) {
	  var templateFnCache = new WeakMap();
	  var templateAstCache = new WeakMap();
	  var cachedOpts = defaultOpts || validate$3(null);
	  return Object.assign(function (tpl) {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    if (typeof tpl === "string") {
	      if (args.length > 1) throw new Error("Unexpected extra params.");
	      return extendedTrace(stringTemplate(formatter, tpl, merge$1(cachedOpts, validate$3(args[0]))));
	    } else if (Array.isArray(tpl)) {
	      var builder = templateFnCache.get(tpl);

	      if (!builder) {
	        builder = literalTemplate(formatter, tpl, cachedOpts);
	        templateFnCache.set(tpl, builder);
	      }

	      return extendedTrace(builder(args));
	    } else if (typeof tpl === "object" && tpl) {
	      if (args.length > 0) throw new Error("Unexpected extra params.");
	      return createTemplateBuilder(formatter, merge$1(cachedOpts, validate$3(tpl)));
	    }

	    throw new Error("Unexpected template param " + typeof tpl);
	  }, {
	    ast: function ast(tpl) {
	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      if (typeof tpl === "string") {
	        if (args.length > 1) throw new Error("Unexpected extra params.");
	        return stringTemplate(formatter, tpl, merge$1(merge$1(cachedOpts, validate$3(args[0])), NO_PLACEHOLDER))();
	      } else if (Array.isArray(tpl)) {
	        var builder = templateAstCache.get(tpl);

	        if (!builder) {
	          builder = literalTemplate(formatter, tpl, merge$1(cachedOpts, NO_PLACEHOLDER));
	          templateAstCache.set(tpl, builder);
	        }

	        return builder(args)();
	      }

	      throw new Error("Unexpected template param " + typeof tpl);
	    }
	  });
	}

	function extendedTrace(fn) {
	  var rootStack = "";

	  try {
	    throw new Error();
	  } catch (error) {
	    if (error.stack) {
	      rootStack = error.stack.split("\n").slice(3).join("\n");
	    }
	  }

	  return function (arg) {
	    try {
	      return fn(arg);
	    } catch (err) {
	      err.stack += "\n    =============\n" + rootStack;
	      throw err;
	    }
	  };
	}

	var smart = createTemplateBuilder(smart$1);
	var statement = createTemplateBuilder(statement$1);
	var statements = createTemplateBuilder(statements$1);
	var expression = createTemplateBuilder(expression$1);
	var program$1 = createTemplateBuilder(program$2);
	var template$2 = Object.assign(smart.bind(undefined), {
	  smart: smart,
	  statement: statement,
	  statements: statements,
	  expression: expression,
	  program: program$1,
	  ast: smart.ast
	});

	var NOT_LOCAL_BINDING = NOT_LOCAL_BINDING$2,
	    cloneNode$d = cloneNode$i,
	    identifier$c = identifier$j,
	    isAssignmentExpression = isAssignmentExpression$3,
	    isFunction = isFunction$4,
	    isIdentifier$8 = isIdentifier$g,
	    isLiteral$3 = isLiteral$7,
	    isNullLiteral = isNullLiteral$1,
	    isObjectMethod$1 = isObjectMethod$2,
	    isObjectProperty$3 = isObjectProperty$4,
	    isRegExpLiteral = isRegExpLiteral$1,
	    isTemplateLiteral = isTemplateLiteral$2,
	    isVariableDeclarator = isVariableDeclarator$2,
	    toBindingIdentifierName = toBindingIdentifierName$1;
	var buildPropertyMethodAssignmentWrapper = template$2("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
	var buildGeneratorPropertyMethodAssignmentWrapper = template$2("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
	var visitor$2 = {
	  "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
	    if (path.node.name !== state.name) return;
	    var localDeclar = path.scope.getBindingIdentifier(state.name);
	    if (localDeclar !== state.outerDeclar) return;
	    state.selfReference = true;
	    path.stop();
	  }
	};

	function getNameFromLiteralId(id) {
	  if (isNullLiteral(id)) {
	    return "null";
	  }

	  if (isRegExpLiteral(id)) {
	    return "_" + id.pattern + "_" + id.flags;
	  }

	  if (isTemplateLiteral(id)) {
	    return id.quasis.map(function (quasi) {
	      return quasi.value.raw;
	    }).join("");
	  }

	  if (id.value !== undefined) {
	    return id.value + "";
	  }

	  return "";
	}

	function wrap$1(state, method, id, scope) {
	  if (state.selfReference) {
	    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
	      scope.rename(id.name);
	    } else {
	      if (!isFunction(method)) return;
	      var build = buildPropertyMethodAssignmentWrapper;

	      if (method.generator) {
	        build = buildGeneratorPropertyMethodAssignmentWrapper;
	      }

	      var _template = build({
	        FUNCTION: method,
	        FUNCTION_ID: id,
	        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
	      }).expression;
	      var params = _template.callee.body.body[0].params;

	      for (var i = 0, len = getFunctionArity(method); i < len; i++) {
	        params.push(scope.generateUidIdentifier("x"));
	      }

	      return _template;
	    }
	  }

	  method.id = id;
	  scope.getProgramParent().references[id.name] = true;
	}

	function visit$2(node, name, scope) {
	  var state = {
	    selfAssignment: false,
	    selfReference: false,
	    outerDeclar: scope.getBindingIdentifier(name),
	    references: [],
	    name: name
	  };
	  var binding = scope.getOwnBinding(name);

	  if (binding) {
	    if (binding.kind === "param") {
	      state.selfReference = true;
	    }
	  } else if (state.outerDeclar || scope.hasGlobal(name)) {
	    scope.traverse(node, visitor$2, state);
	  }

	  return state;
	}

	function nameFunction (_ref, localBinding) {
	  var node = _ref.node,
	      parent = _ref.parent,
	      scope = _ref.scope,
	      id = _ref.id;

	  if (localBinding === void 0) {
	    localBinding = false;
	  }

	  if (node.id) return;

	  if ((isObjectProperty$3(parent) || isObjectMethod$1(parent, {
	    kind: "method"
	  })) && (!parent.computed || isLiteral$3(parent.key))) {
	    id = parent.key;
	  } else if (isVariableDeclarator(parent)) {
	    id = parent.id;

	    if (isIdentifier$8(id) && !localBinding) {
	      var binding = scope.parent.getBinding(id.name);

	      if (binding && binding.constant && scope.getBinding(id.name) === binding) {
	        node.id = cloneNode$d(id);
	        node.id[NOT_LOCAL_BINDING] = true;
	        return;
	      }
	    }
	  } else if (isAssignmentExpression(parent, {
	    operator: "="
	  })) {
	    id = parent.left;
	  } else if (!id) {
	    return;
	  }

	  var name;

	  if (id && isLiteral$3(id)) {
	    name = getNameFromLiteralId(id);
	  } else if (id && isIdentifier$8(id)) {
	    name = id.name;
	  }

	  if (name === undefined) {
	    return;
	  }

	  name = toBindingIdentifierName(name);
	  id = identifier$c(name);
	  id[NOT_LOCAL_BINDING] = true;
	  var state = visit$2(node, name, scope);
	  return wrap$1(state, node, id, scope) || node;
	}

	var DEPRECATED_KEYS = DEPRECATED_KEYS$1,
	    FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS$3,
	    TYPES = TYPES$1;
	function explode$1(visitor) {
	  if (visitor._exploded) return visitor;
	  visitor._exploded = true;

	  for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
	    var nodeType = _Object$keys[_i];
	    if (shouldIgnoreKey(nodeType)) continue;
	    var parts = nodeType.split("|");
	    if (parts.length === 1) continue;
	    var fns = visitor[nodeType];
	    delete visitor[nodeType];

	    for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
	      var part = _step.value;
	      visitor[part] = fns;
	    }
	  }

	  verify(visitor);
	  delete visitor.__esModule;
	  ensureEntranceObjects(visitor);
	  ensureCallbackArrays(visitor);

	  for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {
	    var _nodeType = _Object$keys2[_i2];
	    if (shouldIgnoreKey(_nodeType)) continue;
	    var _wrapper = virtualTypes[_nodeType];
	    if (!_wrapper) continue;
	    var _fns = visitor[_nodeType];

	    for (var _i3 = 0, _Object$keys3 = Object.keys(_fns); _i3 < _Object$keys3.length; _i3++) {
	      var type = _Object$keys3[_i3];
	      _fns[type] = wrapCheck(_wrapper, _fns[type]);
	    }

	    delete visitor[_nodeType];

	    if (_wrapper.types) {
	      for (var _iterator2 = _createForOfIteratorHelperLoose(_wrapper.types), _step2; !(_step2 = _iterator2()).done;) {
	        var _type = _step2.value;

	        if (visitor[_type]) {
	          mergePair(visitor[_type], _fns);
	        } else {
	          visitor[_type] = _fns;
	        }
	      }
	    } else {
	      mergePair(visitor, _fns);
	    }
	  }

	  for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {
	    var _nodeType2 = _Object$keys4[_i4];
	    if (shouldIgnoreKey(_nodeType2)) continue;
	    var _fns2 = visitor[_nodeType2];
	    var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
	    var deprecatedKey = DEPRECATED_KEYS[_nodeType2];

	    if (deprecatedKey) {
	      console.trace("Visitor defined for " + _nodeType2 + " but it has been renamed to " + deprecatedKey);
	      aliases = [deprecatedKey];
	    }

	    if (!aliases) continue;
	    delete visitor[_nodeType2];

	    for (var _iterator3 = _createForOfIteratorHelperLoose(aliases), _step3; !(_step3 = _iterator3()).done;) {
	      var alias = _step3.value;
	      var existing = visitor[alias];

	      if (existing) {
	        mergePair(existing, _fns2);
	      } else {
	        visitor[alias] = Object.assign({}, _fns2);
	      }
	    }
	  }

	  for (var _i5 = 0, _Object$keys5 = Object.keys(visitor); _i5 < _Object$keys5.length; _i5++) {
	    var _nodeType3 = _Object$keys5[_i5];
	    if (shouldIgnoreKey(_nodeType3)) continue;
	    ensureCallbackArrays(visitor[_nodeType3]);
	  }

	  return visitor;
	}
	function verify(visitor) {
	  if (visitor._verified) return;

	  if (typeof visitor === "function") {
	    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
	  }

	  for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {
	    var nodeType = _Object$keys6[_i6];

	    if (nodeType === "enter" || nodeType === "exit") {
	      validateVisitorMethods(nodeType, visitor[nodeType]);
	    }

	    if (shouldIgnoreKey(nodeType)) continue;

	    if (TYPES.indexOf(nodeType) < 0) {
	      throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type");
	    }

	    var _visitors = visitor[nodeType];

	    if (typeof _visitors === "object") {
	      for (var _i7 = 0, _Object$keys7 = Object.keys(_visitors); _i7 < _Object$keys7.length; _i7++) {
	        var visitorKey = _Object$keys7[_i7];

	        if (visitorKey === "enter" || visitorKey === "exit") {
	          validateVisitorMethods(nodeType + "." + visitorKey, _visitors[visitorKey]);
	        } else {
	          throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
	        }
	      }
	    }
	  }

	  visitor._verified = true;
	}

	function validateVisitorMethods(path, val) {
	  var fns = [].concat(val);

	  for (var _iterator4 = _createForOfIteratorHelperLoose(fns), _step4; !(_step4 = _iterator4()).done;) {
	    var fn = _step4.value;

	    if (typeof fn !== "function") {
	      throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
	    }
	  }
	}

	function merge(visitors, states, wrapper) {
	  if (states === void 0) {
	    states = [];
	  }

	  var rootVisitor = {};

	  for (var i = 0; i < visitors.length; i++) {
	    var visitor = visitors[i];
	    var state = states[i];
	    explode$1(visitor);

	    for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {
	      var type = _Object$keys8[_i8];
	      var visitorType = visitor[type];

	      if (state || wrapper) {
	        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
	      }

	      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
	      mergePair(nodeVisitor, visitorType);
	    }
	  }

	  return rootVisitor;
	}

	function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
	  var newVisitor = {};

	  var _loop = function _loop() {
	    var key = _Object$keys9[_i9];
	    var fns = oldVisitor[key];
	    if (!Array.isArray(fns)) return "continue";
	    fns = fns.map(function (fn) {
	      var newFn = fn;

	      if (state) {
	        newFn = function newFn(path) {
	          return fn.call(state, path, state);
	        };
	      }

	      if (wrapper) {
	        newFn = wrapper(state.key, key, newFn);
	      }

	      if (newFn !== fn) {
	        newFn.toString = function () {
	          return fn.toString();
	        };
	      }

	      return newFn;
	    });
	    newVisitor[key] = fns;
	  };

	  for (var _i9 = 0, _Object$keys9 = Object.keys(oldVisitor); _i9 < _Object$keys9.length; _i9++) {
	    var _ret = _loop();

	    if (_ret === "continue") continue;
	  }

	  return newVisitor;
	}

	function ensureEntranceObjects(obj) {
	  for (var _i10 = 0, _Object$keys10 = Object.keys(obj); _i10 < _Object$keys10.length; _i10++) {
	    var key = _Object$keys10[_i10];
	    if (shouldIgnoreKey(key)) continue;
	    var fns = obj[key];

	    if (typeof fns === "function") {
	      obj[key] = {
	        enter: fns
	      };
	    }
	  }
	}

	function ensureCallbackArrays(obj) {
	  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
	  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
	}

	function wrapCheck(wrapper, fn) {
	  var newFn = function newFn(path) {
	    if (wrapper.checkPath(path)) {
	      return fn.apply(this, arguments);
	    }
	  };

	  newFn.toString = function () {
	    return fn.toString();
	  };

	  return newFn;
	}

	function shouldIgnoreKey(key) {
	  if (key[0] === "_") return true;
	  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

	  if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
	    return true;
	  }

	  return false;
	}

	function mergePair(dest, src) {
	  for (var _i11 = 0, _Object$keys11 = Object.keys(src); _i11 < _Object$keys11.length; _i11++) {
	    var key = _Object$keys11[_i11];
	    dest[key] = [].concat(dest[key] || [], src[key]);
	  }
	}

	var visitors = /*#__PURE__*/Object.freeze({
		__proto__: null,
		explode: explode$1,
		verify: verify,
		merge: merge
	});

	var arrowFunctionExpression$2 = arrowFunctionExpression$4,
	    assignmentExpression$9 = assignmentExpression$c,
	    binaryExpression$3 = binaryExpression$4,
	    blockStatement$3 = blockStatement$6,
	    callExpression$b = callExpression$e,
	    conditionalExpression$2 = conditionalExpression$3,
	    expressionStatement$6 = expressionStatement$a,
	    identifier$b = identifier$j,
	    isIdentifier$7 = isIdentifier$g,
	    jsxIdentifier$1 = jsxIdentifier$2,
	    memberExpression$9 = memberExpression$b,
	    metaProperty = metaProperty$1,
	    numericLiteral$6 = numericLiteral$8,
	    objectExpression$3 = objectExpression$4,
	    restElement = restElement$1,
	    returnStatement$1 = returnStatement$3,
	    sequenceExpression$6 = sequenceExpression$7,
	    spreadElement$1 = spreadElement$2,
	    stringLiteral$6 = stringLiteral$8,
	    _super = _super$1,
	    thisExpression$2 = thisExpression$3,
	    toExpression = toExpression$1,
	    unaryExpression$5 = unaryExpression$7;
	function toComputedKey$2() {
	  var key;

	  if (this.isMemberExpression()) {
	    key = this.node.property;
	  } else if (this.isProperty() || this.isMethod()) {
	    key = this.node.key;
	  } else {
	    throw new ReferenceError("todo");
	  }

	  if (!this.node.computed) {
	    if (isIdentifier$7(key)) key = stringLiteral$6(key.name);
	  }

	  return key;
	}
	function ensureBlock() {
	  var body = this.get("body");
	  var bodyNode = body.node;

	  if (Array.isArray(body)) {
	    throw new Error("Can't convert array path to a block statement");
	  }

	  if (!bodyNode) {
	    throw new Error("Can't convert node without a body");
	  }

	  if (body.isBlockStatement()) {
	    return bodyNode;
	  }

	  var statements = [];
	  var stringPath = "body";
	  var key;
	  var listKey;

	  if (body.isStatement()) {
	    listKey = "body";
	    key = 0;
	    statements.push(body.node);
	  } else {
	    stringPath += ".body.0";

	    if (this.isFunction()) {
	      key = "argument";
	      statements.push(returnStatement$1(body.node));
	    } else {
	      key = "expression";
	      statements.push(expressionStatement$6(body.node));
	    }
	  }

	  this.node.body = blockStatement$3(statements);
	  var parentPath = this.get(stringPath);
	  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
	  return this.node;
	}
	function arrowFunctionToShadowed() {
	  if (!this.isArrowFunctionExpression()) return;
	  this.arrowFunctionToExpression();
	}
	function unwrapFunctionEnvironment() {
	  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
	    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
	  }

	  hoistFunctionEnvironment(this);
	}
	function arrowFunctionToExpression(_temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      _ref$allowInsertArrow = _ref.allowInsertArrow,
	      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
	      _ref$specCompliant = _ref.specCompliant,
	      specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant,
	      _ref$noNewArrows = _ref.noNewArrows,
	      noNewArrows = _ref$noNewArrows === void 0 ? !specCompliant : _ref$noNewArrows;

	  if (!this.isArrowFunctionExpression()) {
	    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
	  }

	  var _hoistFunctionEnviron = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow),
	      thisBinding = _hoistFunctionEnviron.thisBinding,
	      fn = _hoistFunctionEnviron.fnPath;

	  fn.ensureBlock();
	  fn.node.type = "FunctionExpression";

	  if (!noNewArrows) {
	    var checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");

	    if (checkBinding) {
	      fn.parentPath.scope.push({
	        id: checkBinding,
	        init: objectExpression$3([])
	      });
	    }

	    fn.get("body").unshiftContainer("body", expressionStatement$6(callExpression$b(this.hub.addHelper("newArrowCheck"), [thisExpression$2(), checkBinding ? identifier$b(checkBinding.name) : identifier$b(thisBinding)])));
	    fn.replaceWith(callExpression$b(memberExpression$9(nameFunction(this, true) || fn.node, identifier$b("bind")), [checkBinding ? identifier$b(checkBinding.name) : thisExpression$2()]));
	  }
	}
	var getSuperCallsVisitor = merge([{
	  CallExpression: function CallExpression(child, _ref2) {
	    var allSuperCalls = _ref2.allSuperCalls;
	    if (!child.get("callee").isSuper()) return;
	    allSuperCalls.push(child);
	  }
	}, environmentVisitor]);

	function hoistFunctionEnvironment(fnPath, noNewArrows, allowInsertArrow) {
	  if (noNewArrows === void 0) {
	    noNewArrows = true;
	  }

	  if (allowInsertArrow === void 0) {
	    allowInsertArrow = true;
	  }

	  var arrowParent;
	  var thisEnvFn = fnPath.findParent(function (p) {
	    if (p.isArrowFunctionExpression()) {
	      var _arrowParent;

	      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
	      return false;
	    }

	    return p.isFunction() || p.isProgram() || p.isClassProperty({
	      "static": false
	    }) || p.isClassPrivateProperty({
	      "static": false
	    });
	  });
	  var inConstructor = thisEnvFn.isClassMethod({
	    kind: "constructor"
	  });

	  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
	    if (arrowParent) {
	      thisEnvFn = arrowParent;
	    } else if (allowInsertArrow) {
	      fnPath.replaceWith(callExpression$b(arrowFunctionExpression$2([], toExpression(fnPath.node)), []));
	      thisEnvFn = fnPath.get("callee");
	      fnPath = thisEnvFn.get("body");
	    } else {
	      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
	    }
	  }

	  var _getScopeInformation = getScopeInformation(fnPath),
	      thisPaths = _getScopeInformation.thisPaths,
	      argumentsPaths = _getScopeInformation.argumentsPaths,
	      newTargetPaths = _getScopeInformation.newTargetPaths,
	      superProps = _getScopeInformation.superProps,
	      superCalls = _getScopeInformation.superCalls;

	  if (inConstructor && superCalls.length > 0) {
	    if (!allowInsertArrow) {
	      throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
	    }

	    var allSuperCalls = [];
	    thisEnvFn.traverse(getSuperCallsVisitor, {
	      allSuperCalls: allSuperCalls
	    });
	    var superBinding = getSuperBinding(thisEnvFn);
	    allSuperCalls.forEach(function (superCall) {
	      var callee = identifier$b(superBinding);
	      callee.loc = superCall.node.callee.loc;
	      superCall.get("callee").replaceWith(callee);
	    });
	  }

	  if (argumentsPaths.length > 0) {
	    var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
	      var args = function args() {
	        return identifier$b("arguments");
	      };

	      if (thisEnvFn.scope.path.isProgram()) {
	        return conditionalExpression$2(binaryExpression$3("===", unaryExpression$5("typeof", args()), stringLiteral$6("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
	      } else {
	        return args();
	      }
	    });
	    argumentsPaths.forEach(function (argumentsChild) {
	      var argsRef = identifier$b(argumentsBinding);
	      argsRef.loc = argumentsChild.node.loc;
	      argumentsChild.replaceWith(argsRef);
	    });
	  }

	  if (newTargetPaths.length > 0) {
	    var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
	      return metaProperty(identifier$b("new"), identifier$b("target"));
	    });
	    newTargetPaths.forEach(function (targetChild) {
	      var targetRef = identifier$b(newTargetBinding);
	      targetRef.loc = targetChild.node.loc;
	      targetChild.replaceWith(targetRef);
	    });
	  }

	  if (superProps.length > 0) {
	    if (!allowInsertArrow) {
	      throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
	    }

	    var flatSuperProps = superProps.reduce(function (acc, superProp) {
	      return acc.concat(standardizeSuperProperty(superProp));
	    }, []);
	    flatSuperProps.forEach(function (superProp) {
	      var key = superProp.node.computed ? "" : superProp.get("property").node.name;
	      var isAssignment = superProp.parentPath.isAssignmentExpression({
	        left: superProp.node
	      });
	      var isCall = superProp.parentPath.isCallExpression({
	        callee: superProp.node
	      });
	      var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
	      var args = [];

	      if (superProp.node.computed) {
	        args.push(superProp.get("property").node);
	      }

	      if (isAssignment) {
	        var value = superProp.parentPath.node.right;
	        args.push(value);
	      }

	      var call = callExpression$b(identifier$b(superBinding), args);

	      if (isCall) {
	        superProp.parentPath.unshiftContainer("arguments", thisExpression$2());
	        superProp.replaceWith(memberExpression$9(call, identifier$b("call")));
	        thisPaths.push(superProp.parentPath.get("arguments.0"));
	      } else if (isAssignment) {
	        superProp.parentPath.replaceWith(call);
	      } else {
	        superProp.replaceWith(call);
	      }
	    });
	  }

	  var thisBinding;

	  if (thisPaths.length > 0 || !noNewArrows) {
	    thisBinding = getThisBinding(thisEnvFn, inConstructor);

	    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
	      thisPaths.forEach(function (thisChild) {
	        var thisRef = thisChild.isJSX() ? jsxIdentifier$1(thisBinding) : identifier$b(thisBinding);
	        thisRef.loc = thisChild.node.loc;
	        thisChild.replaceWith(thisRef);
	      });
	      if (!noNewArrows) thisBinding = null;
	    }
	  }

	  return {
	    thisBinding: thisBinding,
	    fnPath: fnPath
	  };
	}

	function standardizeSuperProperty(superProp) {
	  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
	    var assignmentPath = superProp.parentPath;
	    var op = assignmentPath.node.operator.slice(0, -1);
	    var value = assignmentPath.node.right;
	    assignmentPath.node.operator = "=";

	    if (superProp.node.computed) {
	      var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
	      assignmentPath.get("left").replaceWith(memberExpression$9(superProp.node.object, assignmentExpression$9("=", tmp, superProp.node.property), true));
	      assignmentPath.get("right").replaceWith(binaryExpression$3(op, memberExpression$9(superProp.node.object, identifier$b(tmp.name), true), value));
	    } else {
	      assignmentPath.get("left").replaceWith(memberExpression$9(superProp.node.object, superProp.node.property));
	      assignmentPath.get("right").replaceWith(binaryExpression$3(op, memberExpression$9(superProp.node.object, identifier$b(superProp.node.property.name)), value));
	    }

	    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
	  } else if (superProp.parentPath.isUpdateExpression()) {
	    var updateExpr = superProp.parentPath;

	    var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

	    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
	    var parts = [assignmentExpression$9("=", _tmp, memberExpression$9(superProp.node.object, computedKey ? assignmentExpression$9("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression$9("=", memberExpression$9(superProp.node.object, computedKey ? identifier$b(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression$3("+", identifier$b(_tmp.name), numericLiteral$6(1)))];

	    if (!superProp.parentPath.node.prefix) {
	      parts.push(identifier$b(_tmp.name));
	    }

	    updateExpr.replaceWith(sequenceExpression$6(parts));
	    var left = updateExpr.get("expressions.0.right");
	    var right = updateExpr.get("expressions.1.left");
	    return [left, right];
	  }

	  return [superProp];
	}

	function hasSuperClass(thisEnvFn) {
	  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
	}

	var assignSuperThisVisitor = merge([{
	  CallExpression: function CallExpression(child, _ref3) {
	    var supers = _ref3.supers,
	        thisBinding = _ref3.thisBinding;
	    if (!child.get("callee").isSuper()) return;
	    if (supers.has(child.node)) return;
	    supers.add(child.node);
	    child.replaceWithMultiple([child.node, assignmentExpression$9("=", identifier$b(thisBinding), identifier$b("this"))]);
	  }
	}, environmentVisitor]);

	function getThisBinding(thisEnvFn, inConstructor) {
	  return getBinding(thisEnvFn, "this", function (thisBinding) {
	    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression$2();
	    thisEnvFn.traverse(assignSuperThisVisitor, {
	      supers: new WeakSet(),
	      thisBinding: thisBinding
	    });
	  });
	}

	function getSuperBinding(thisEnvFn) {
	  return getBinding(thisEnvFn, "supercall", function () {
	    var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
	    return arrowFunctionExpression$2([restElement(argsBinding)], callExpression$b(_super(), [spreadElement$1(identifier$b(argsBinding.name))]));
	  });
	}

	function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
	  var op = isAssignment ? "set" : "get";
	  return getBinding(thisEnvFn, "superprop_" + op + ":" + (propName || ""), function () {
	    var argsList = [];
	    var fnBody;

	    if (propName) {
	      fnBody = memberExpression$9(_super(), identifier$b(propName));
	    } else {
	      var method = thisEnvFn.scope.generateUidIdentifier("prop");
	      argsList.unshift(method);
	      fnBody = memberExpression$9(_super(), identifier$b(method.name), true);
	    }

	    if (isAssignment) {
	      var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
	      argsList.push(valueIdent);
	      fnBody = assignmentExpression$9("=", fnBody, identifier$b(valueIdent.name));
	    }

	    return arrowFunctionExpression$2(argsList, fnBody);
	  });
	}

	function getBinding(thisEnvFn, key, init) {
	  var cacheKey = "binding:" + key;
	  var data = thisEnvFn.getData(cacheKey);

	  if (!data) {
	    var id = thisEnvFn.scope.generateUidIdentifier(key);
	    data = id.name;
	    thisEnvFn.setData(cacheKey, data);
	    thisEnvFn.scope.push({
	      id: id,
	      init: init(data)
	    });
	  }

	  return data;
	}

	var getScopeInformationVisitor = merge([{
	  ThisExpression: function ThisExpression(child, _ref4) {
	    var thisPaths = _ref4.thisPaths;
	    thisPaths.push(child);
	  },
	  JSXIdentifier: function JSXIdentifier(child, _ref5) {
	    var thisPaths = _ref5.thisPaths;
	    if (child.node.name !== "this") return;

	    if (!child.parentPath.isJSXMemberExpression({
	      object: child.node
	    }) && !child.parentPath.isJSXOpeningElement({
	      name: child.node
	    })) {
	      return;
	    }

	    thisPaths.push(child);
	  },
	  CallExpression: function CallExpression(child, _ref6) {
	    var superCalls = _ref6.superCalls;
	    if (child.get("callee").isSuper()) superCalls.push(child);
	  },
	  MemberExpression: function MemberExpression(child, _ref7) {
	    var superProps = _ref7.superProps;
	    if (child.get("object").isSuper()) superProps.push(child);
	  },
	  Identifier: function Identifier(child, _ref8) {
	    var argumentsPaths = _ref8.argumentsPaths;
	    if (!child.isReferencedIdentifier({
	      name: "arguments"
	    })) return;
	    var curr = child.scope;

	    do {
	      if (curr.hasOwnBinding("arguments")) {
	        curr.rename("arguments");
	        return;
	      }

	      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
	        break;
	      }
	    } while (curr = curr.parent);

	    argumentsPaths.push(child);
	  },
	  MetaProperty: function MetaProperty(child, _ref9) {
	    var newTargetPaths = _ref9.newTargetPaths;
	    if (!child.get("meta").isIdentifier({
	      name: "new"
	    })) return;
	    if (!child.get("property").isIdentifier({
	      name: "target"
	    })) return;
	    newTargetPaths.push(child);
	  }
	}, environmentVisitor]);

	function getScopeInformation(fnPath) {
	  var thisPaths = [];
	  var argumentsPaths = [];
	  var newTargetPaths = [];
	  var superProps = [];
	  var superCalls = [];
	  fnPath.traverse(getScopeInformationVisitor, {
	    thisPaths: thisPaths,
	    argumentsPaths: argumentsPaths,
	    newTargetPaths: newTargetPaths,
	    superProps: superProps,
	    superCalls: superCalls
	  });
	  return {
	    thisPaths: thisPaths,
	    argumentsPaths: argumentsPaths,
	    newTargetPaths: newTargetPaths,
	    superProps: superProps,
	    superCalls: superCalls
	  };
	}

	var NodePath_conversion = /*#__PURE__*/Object.freeze({
		__proto__: null,
		toComputedKey: toComputedKey$2,
		ensureBlock: ensureBlock,
		arrowFunctionToShadowed: arrowFunctionToShadowed,
		unwrapFunctionEnvironment: unwrapFunctionEnvironment,
		arrowFunctionToExpression: arrowFunctionToExpression
	});

	var STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS$1,
	    VISITOR_KEYS$2 = VISITOR_KEYS$6,
	    isBlockStatement = isBlockStatement$2,
	    isExpression$1 = isExpression$4,
	    isIdentifier$6 = isIdentifier$g,
	    isLiteral$2 = isLiteral$7,
	    isStringLiteral$3 = isStringLiteral$7,
	    isType = isType$2,
	    _matchesPattern = matchesPattern$2;
	function matchesPattern(pattern, allowPartial) {
	  return _matchesPattern(this.node, pattern, allowPartial);
	}
	function has$a(key) {
	  var val = this.node && this.node[key];

	  if (val && Array.isArray(val)) {
	    return !!val.length;
	  } else {
	    return !!val;
	  }
	}
	function isStatic() {
	  return this.scope.isStatic(this.node);
	}
	var is = has$a;
	function isnt(key) {
	  return !this.has(key);
	}
	function equals(key, value) {
	  return this.node[key] === value;
	}
	function isNodeType(type) {
	  return isType(this.type, type);
	}
	function canHaveVariableDeclarationOrExpression() {
	  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
	}
	function canSwapBetweenExpressionAndStatement(replacement) {
	  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
	    return false;
	  }

	  if (this.isExpression()) {
	    return isBlockStatement(replacement);
	  } else if (this.isBlockStatement()) {
	    return isExpression$1(replacement);
	  }

	  return false;
	}
	function isCompletionRecord(allowInsideFunction) {
	  var path = this;
	  var first = true;

	  do {
	    var container = path.container;

	    if (path.isFunction() && !first) {
	      return !!allowInsideFunction;
	    }

	    first = false;

	    if (Array.isArray(container) && path.key !== container.length - 1) {
	      return false;
	    }
	  } while ((path = path.parentPath) && !path.isProgram());

	  return true;
	}
	function isStatementOrBlock() {
	  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
	    return false;
	  } else {
	    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
	  }
	}
	function referencesImport(moduleSource, importName) {
	  if (!this.isReferencedIdentifier()) {
	    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral$3(this.node.property, {
	      value: importName
	    }) : this.node.property.name === importName)) {
	      var object = this.get("object");
	      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
	    }

	    return false;
	  }

	  var binding = this.scope.getBinding(this.node.name);
	  if (!binding || binding.kind !== "module") return false;
	  var path = binding.path;
	  var parent = path.parentPath;
	  if (!parent.isImportDeclaration()) return false;

	  if (parent.node.source.value === moduleSource) {
	    if (!importName) return true;
	  } else {
	    return false;
	  }

	  if (path.isImportDefaultSpecifier() && importName === "default") {
	    return true;
	  }

	  if (path.isImportNamespaceSpecifier() && importName === "*") {
	    return true;
	  }

	  if (path.isImportSpecifier() && isIdentifier$6(path.node.imported, {
	    name: importName
	  })) {
	    return true;
	  }

	  return false;
	}
	function getSource$1() {
	  var node = this.node;

	  if (node.end) {
	    var code = this.hub.getCode();
	    if (code) return code.slice(node.start, node.end);
	  }

	  return "";
	}
	function willIMaybeExecuteBefore(target) {
	  return this._guessExecutionStatusRelativeTo(target) !== "after";
	}

	function getOuterFunction(path) {
	  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
	}

	function isExecutionUncertain(type, key) {
	  switch (type) {
	    case "LogicalExpression":
	      return key === "right";

	    case "ConditionalExpression":
	    case "IfStatement":
	      return key === "consequent" || key === "alternate";

	    case "WhileStatement":
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForOfStatement":
	      return key === "body";

	    case "ForStatement":
	      return key === "body" || key === "update";

	    case "SwitchStatement":
	      return key === "cases";

	    case "TryStatement":
	      return key === "handler";

	    case "AssignmentPattern":
	      return key === "right";

	    case "OptionalMemberExpression":
	      return key === "property";

	    case "OptionalCallExpression":
	      return key === "arguments";

	    default:
	      return false;
	  }
	}

	function isExecutionUncertainInList(paths, maxIndex) {
	  for (var i = 0; i < maxIndex; i++) {
	    var path = paths[i];

	    if (isExecutionUncertain(path.parent.type, path.parentKey)) {
	      return true;
	    }
	  }

	  return false;
	}

	function _guessExecutionStatusRelativeTo(target) {
	  var funcParent = {
	    "this": getOuterFunction(this),
	    target: getOuterFunction(target)
	  };

	  if (funcParent.target.node !== funcParent["this"].node) {
	    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
	  }

	  var paths = {
	    target: target.getAncestry(),
	    "this": this.getAncestry()
	  };
	  if (paths.target.indexOf(this) >= 0) return "after";
	  if (paths["this"].indexOf(target) >= 0) return "before";
	  var commonPath;
	  var commonIndex = {
	    target: 0,
	    "this": 0
	  };

	  while (!commonPath && commonIndex["this"] < paths["this"].length) {
	    var path = paths["this"][commonIndex["this"]];
	    commonIndex.target = paths.target.indexOf(path);

	    if (commonIndex.target >= 0) {
	      commonPath = path;
	    } else {
	      commonIndex["this"]++;
	    }
	  }

	  if (!commonPath) {
	    throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
	  }

	  if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
	    return "unknown";
	  }

	  var divergence = {
	    "this": paths["this"][commonIndex["this"] - 1],
	    target: paths.target[commonIndex.target - 1]
	  };

	  if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
	    return divergence.target.key > divergence["this"].key ? "before" : "after";
	  }

	  var keys = VISITOR_KEYS$2[commonPath.type];
	  var keyPosition = {
	    "this": keys.indexOf(divergence["this"].parentKey),
	    target: keys.indexOf(divergence.target.parentKey)
	  };
	  return keyPosition.target > keyPosition["this"] ? "before" : "after";
	}
	var executionOrderCheckedNodes = new WeakSet();
	function _guessExecutionStatusRelativeToDifferentFunctions(target) {
	  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
	    return "unknown";
	  }

	  var binding = target.scope.getBinding(target.node.id.name);
	  if (!binding.references) return "before";
	  var referencePaths = binding.referencePaths;
	  var allStatus;

	  for (var _iterator = _createForOfIteratorHelperLoose(referencePaths), _step; !(_step = _iterator()).done;) {
	    var path = _step.value;
	    var childOfFunction = !!path.find(function (path) {
	      return path.node === target.node;
	    });
	    if (childOfFunction) continue;

	    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
	      return "unknown";
	    }

	    if (executionOrderCheckedNodes.has(path.node)) continue;
	    executionOrderCheckedNodes.add(path.node);

	    var status = this._guessExecutionStatusRelativeTo(path);

	    executionOrderCheckedNodes["delete"](path.node);

	    if (allStatus && allStatus !== status) {
	      return "unknown";
	    } else {
	      allStatus = status;
	    }
	  }

	  return allStatus;
	}
	function resolve$4(dangerous, resolved) {
	  return this._resolve(dangerous, resolved) || this;
	}
	function _resolve(dangerous, resolved) {
	  if (resolved && resolved.indexOf(this) >= 0) return;
	  resolved = resolved || [];
	  resolved.push(this);

	  if (this.isVariableDeclarator()) {
	    if (this.get("id").isIdentifier()) {
	      return this.get("init").resolve(dangerous, resolved);
	    }
	  } else if (this.isReferencedIdentifier()) {
	    var binding = this.scope.getBinding(this.node.name);
	    if (!binding) return;
	    if (!binding.constant) return;
	    if (binding.kind === "module") return;

	    if (binding.path !== this) {
	      var ret = binding.path.resolve(dangerous, resolved);
	      if (this.find(function (parent) {
	        return parent.node === ret.node;
	      })) return;
	      return ret;
	    }
	  } else if (this.isTypeCastExpression()) {
	    return this.get("expression").resolve(dangerous, resolved);
	  } else if (dangerous && this.isMemberExpression()) {
	    var targetKey = this.toComputedKey();
	    if (!isLiteral$2(targetKey)) return;
	    var targetName = targetKey.value;
	    var target = this.get("object").resolve(dangerous, resolved);

	    if (target.isObjectExpression()) {
	      var props = target.get("properties");

	      for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
	        var prop = _step2.value;
	        if (!prop.isProperty()) continue;
	        var key = prop.get("key");
	        var match = prop.isnt("computed") && key.isIdentifier({
	          name: targetName
	        });
	        match = match || key.isLiteral({
	          value: targetName
	        });
	        if (match) return prop.get("value").resolve(dangerous, resolved);
	      }
	    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
	      var elems = target.get("elements");
	      var elem = elems[targetName];
	      if (elem) return elem.resolve(dangerous, resolved);
	    }
	  }
	}
	function isConstantExpression() {
	  if (this.isIdentifier()) {
	    var binding = this.scope.getBinding(this.node.name);
	    if (!binding) return false;
	    return binding.constant;
	  }

	  if (this.isLiteral()) {
	    if (this.isRegExpLiteral()) {
	      return false;
	    }

	    if (this.isTemplateLiteral()) {
	      return this.get("expressions").every(function (expression) {
	        return expression.isConstantExpression();
	      });
	    }

	    return true;
	  }

	  if (this.isUnaryExpression()) {
	    if (this.node.operator !== "void") {
	      return false;
	    }

	    return this.get("argument").isConstantExpression();
	  }

	  if (this.isBinaryExpression()) {
	    return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
	  }

	  return false;
	}
	function isInStrictMode() {
	  var start = this.isProgram() ? this : this.parentPath;
	  var strictParent = start.find(function (path) {
	    if (path.isProgram({
	      sourceType: "module"
	    })) return true;
	    if (path.isClass()) return true;
	    if (!path.isProgram() && !path.isFunction()) return false;

	    if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
	      return false;
	    }

	    var body = path.isFunction() ? path.node.body : path.node;

	    for (var _iterator3 = _createForOfIteratorHelperLoose(body.directives), _step3; !(_step3 = _iterator3()).done;) {
	      var directive = _step3.value;

	      if (directive.value.value === "use strict") {
	        return true;
	      }
	    }
	  });
	  return !!strictParent;
	}

	var NodePath_introspection = /*#__PURE__*/Object.freeze({
		__proto__: null,
		matchesPattern: matchesPattern,
		has: has$a,
		isStatic: isStatic,
		is: is,
		isnt: isnt,
		equals: equals,
		isNodeType: isNodeType,
		canHaveVariableDeclarationOrExpression: canHaveVariableDeclarationOrExpression,
		canSwapBetweenExpressionAndStatement: canSwapBetweenExpressionAndStatement,
		isCompletionRecord: isCompletionRecord,
		isStatementOrBlock: isStatementOrBlock,
		referencesImport: referencesImport,
		getSource: getSource$1,
		willIMaybeExecuteBefore: willIMaybeExecuteBefore,
		_guessExecutionStatusRelativeTo: _guessExecutionStatusRelativeTo,
		_guessExecutionStatusRelativeToDifferentFunctions: _guessExecutionStatusRelativeToDifferentFunctions,
		resolve: resolve$4,
		_resolve: _resolve,
		isConstantExpression: isConstantExpression,
		isInStrictMode: isInStrictMode
	});

	function call(key) {
	  var opts = this.opts;
	  this.debug(key);

	  if (this.node) {
	    if (this._call(opts[key])) return true;
	  }

	  if (this.node) {
	    return this._call(opts[this.node.type] && opts[this.node.type][key]);
	  }

	  return false;
	}
	function _call(fns) {
	  if (!fns) return false;

	  for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
	    var fn = _step.value;
	    if (!fn) continue;
	    var node = this.node;
	    if (!node) return true;
	    var ret = fn.call(this.state, this, this.state);

	    if (ret && typeof ret === "object" && typeof ret.then === "function") {
	      throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
	    }

	    if (ret) {
	      throw new Error("Unexpected return value from visitor method " + fn);
	    }

	    if (this.node !== node) return true;
	    if (this._traverseFlags > 0) return true;
	  }

	  return false;
	}
	function isDenylisted() {
	  var _this$opts$denylist;

	  var denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
	  return denylist && denylist.indexOf(this.node.type) > -1;
	}

	function restoreContext(path, context) {
	  if (path.context !== context) {
	    path.context = context;
	    path.state = context.state;
	    path.opts = context.opts;
	  }
	}

	function visit$1() {
	  if (!this.node) {
	    return false;
	  }

	  if (this.isDenylisted()) {
	    return false;
	  }

	  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
	    return false;
	  }

	  var currentContext = this.context;

	  if (this.shouldSkip || this.call("enter")) {
	    this.debug("Skip...");
	    return this.shouldStop;
	  }

	  restoreContext(this, currentContext);
	  this.debug("Recursing into...");
	  traverse.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
	  restoreContext(this, currentContext);
	  this.call("exit");
	  return this.shouldStop;
	}
	function skip() {
	  this.shouldSkip = true;
	}
	function skipKey(key) {
	  if (this.skipKeys == null) {
	    this.skipKeys = {};
	  }

	  this.skipKeys[key] = true;
	}
	function stop() {
	  this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
	}
	function setScope() {
	  if (this.opts && this.opts.noScope) return;
	  var path = this.parentPath;
	  if (this.key === "key" && path.isMethod()) path = path.parentPath;
	  var target;

	  while (path && !target) {
	    if (path.opts && path.opts.noScope) return;
	    target = path.scope;
	    path = path.parentPath;
	  }

	  this.scope = this.getScope(target);
	  if (this.scope) this.scope.init();
	}
	function setContext(context) {
	  if (this.skipKeys != null) {
	    this.skipKeys = {};
	  }

	  this._traverseFlags = 0;

	  if (context) {
	    this.context = context;
	    this.state = context.state;
	    this.opts = context.opts;
	  }

	  this.setScope();
	  return this;
	}
	function resync() {
	  if (this.removed) return;

	  this._resyncParent();

	  this._resyncList();

	  this._resyncKey();
	}
	function _resyncParent() {
	  if (this.parentPath) {
	    this.parent = this.parentPath.node;
	  }
	}
	function _resyncKey() {
	  if (!this.container) return;
	  if (this.node === this.container[this.key]) return;

	  if (Array.isArray(this.container)) {
	    for (var i = 0; i < this.container.length; i++) {
	      if (this.container[i] === this.node) {
	        return this.setKey(i);
	      }
	    }
	  } else {
	    for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
	      var key = _Object$keys[_i];

	      if (this.container[key] === this.node) {
	        return this.setKey(key);
	      }
	    }
	  }

	  this.key = null;
	}
	function _resyncList() {
	  if (!this.parent || !this.inList) return;
	  var newContainer = this.parent[this.listKey];
	  if (this.container === newContainer) return;
	  this.container = newContainer || null;
	}
	function _resyncRemoved() {
	  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
	    this._markRemoved();
	  }
	}
	function popContext() {
	  this.contexts.pop();

	  if (this.contexts.length > 0) {
	    this.setContext(this.contexts[this.contexts.length - 1]);
	  } else {
	    this.setContext(undefined);
	  }
	}
	function pushContext(context) {
	  this.contexts.push(context);
	  this.setContext(context);
	}
	function setup(parentPath, container, listKey, key) {
	  this.listKey = listKey;
	  this.container = container;
	  this.parentPath = parentPath || this.parentPath;
	  this.setKey(key);
	}
	function setKey(key) {
	  var _this$node;

	  this.key = key;
	  this.node = this.container[this.key];
	  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
	}
	function requeue(pathToQueue) {
	  if (pathToQueue === void 0) {
	    pathToQueue = this;
	  }

	  if (pathToQueue.removed) return;
	  var contexts = this.contexts;

	  for (var _iterator2 = _createForOfIteratorHelperLoose(contexts), _step2; !(_step2 = _iterator2()).done;) {
	    var context = _step2.value;
	    context.maybeQueue(pathToQueue);
	  }
	}
	function _getQueueContexts() {
	  var path = this;
	  var contexts = this.contexts;

	  while (!contexts.length) {
	    path = path.parentPath;
	    if (!path) break;
	    contexts = path.contexts;
	  }

	  return contexts;
	}

	var NodePath_context = /*#__PURE__*/Object.freeze({
		__proto__: null,
		call: call,
		_call: _call,
		isDenylisted: isDenylisted,
		isBlacklisted: isDenylisted,
		visit: visit$1,
		skip: skip,
		skipKey: skipKey,
		stop: stop,
		setScope: setScope,
		setContext: setContext,
		resync: resync,
		_resyncParent: _resyncParent,
		_resyncKey: _resyncKey,
		_resyncList: _resyncList,
		_resyncRemoved: _resyncRemoved,
		popContext: popContext,
		pushContext: pushContext,
		setup: setup,
		setKey: setKey,
		requeue: requeue,
		_getQueueContexts: _getQueueContexts
	});

	var hooks = [function (self, parent) {
	  var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

	  if (removeParent) {
	    parent.remove();
	    return true;
	  }
	}, function (self, parent) {
	  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
	    parent.replaceWith(parent.node.expressions[0]);
	    return true;
	  }
	}, function (self, parent) {
	  if (parent.isBinary()) {
	    if (self.key === "left") {
	      parent.replaceWith(parent.node.right);
	    } else {
	      parent.replaceWith(parent.node.left);
	    }

	    return true;
	  }
	}, function (self, parent) {
	  if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
	    self.replaceWith({
	      type: "BlockStatement",
	      body: []
	    });
	    return true;
	  }
	}];

	function remove() {
	  var _this$opts;

	  this._assertUnremoved();

	  this.resync();

	  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
	    this._removeFromScope();
	  }

	  if (this._callRemovalHooks()) {
	    this._markRemoved();

	    return;
	  }

	  this.shareCommentsWithSiblings();

	  this._remove();

	  this._markRemoved();
	}
	function _removeFromScope() {
	  var _this = this;

	  var bindings = this.getBindingIdentifiers();
	  Object.keys(bindings).forEach(function (name) {
	    return _this.scope.removeBinding(name);
	  });
	}
	function _callRemovalHooks() {
	  for (var _iterator = _createForOfIteratorHelperLoose(hooks), _step; !(_step = _iterator()).done;) {
	    var fn = _step.value;
	    if (fn(this, this.parentPath)) return true;
	  }
	}
	function _remove() {
	  if (Array.isArray(this.container)) {
	    this.container.splice(this.key, 1);
	    this.updateSiblingKeys(this.key, -1);
	  } else {
	    this._replaceWith(null);
	  }
	}
	function _markRemoved() {
	  this._traverseFlags |= SHOULD_SKIP | REMOVED;
	  if (this.parent) path$3.get(this.parent)["delete"](this.node);
	  this.node = null;
	}
	function _assertUnremoved() {
	  if (this.removed) {
	    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
	  }
	}

	var NodePath_removal = /*#__PURE__*/Object.freeze({
		__proto__: null,
		remove: remove,
		_removeFromScope: _removeFromScope,
		_callRemovalHooks: _callRemovalHooks,
		_remove: _remove,
		_markRemoved: _markRemoved,
		_assertUnremoved: _assertUnremoved
	});

	var react$1 = react$3;
	var cloneNode$c = cloneNode$i,
	    jsxExpressionContainer = jsxExpressionContainer$1,
	    variableDeclaration$5 = variableDeclaration$8,
	    variableDeclarator$5 = variableDeclarator$8;
	var referenceVisitor$1 = {
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    if (path.isJSXIdentifier() && react$1.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
	      return;
	    }

	    if (path.node.name === "this") {
	      var scope = path.scope;

	      do {
	        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
	          break;
	        }
	      } while (scope = scope.parent);

	      if (scope) state.breakOnScopePaths.push(scope.path);
	    }

	    var binding = path.scope.getBinding(path.node.name);
	    if (!binding) return;

	    for (var _iterator = _createForOfIteratorHelperLoose(binding.constantViolations), _step; !(_step = _iterator()).done;) {
	      var violation = _step.value;

	      if (violation.scope !== binding.path.scope) {
	        state.mutableBinding = true;
	        path.stop();
	        return;
	      }
	    }

	    if (binding !== state.scope.getBinding(path.node.name)) return;
	    state.bindings[path.node.name] = binding;
	  }
	};

	var PathHoister = function () {
	  function PathHoister(path, scope) {
	    this.breakOnScopePaths = void 0;
	    this.bindings = void 0;
	    this.mutableBinding = void 0;
	    this.scopes = void 0;
	    this.scope = void 0;
	    this.path = void 0;
	    this.attachAfter = void 0;
	    this.breakOnScopePaths = [];
	    this.bindings = {};
	    this.mutableBinding = false;
	    this.scopes = [];
	    this.scope = scope;
	    this.path = path;
	    this.attachAfter = false;
	  }

	  var _proto = PathHoister.prototype;

	  _proto.isCompatibleScope = function isCompatibleScope(scope) {
	    for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
	      var key = _Object$keys[_i];
	      var binding = this.bindings[key];

	      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
	        return false;
	      }
	    }

	    return true;
	  };

	  _proto.getCompatibleScopes = function getCompatibleScopes() {
	    var scope = this.path.scope;

	    do {
	      if (this.isCompatibleScope(scope)) {
	        this.scopes.push(scope);
	      } else {
	        break;
	      }

	      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
	        break;
	      }
	    } while (scope = scope.parent);
	  };

	  _proto.getAttachmentPath = function getAttachmentPath() {
	    var path = this._getAttachmentPath();

	    if (!path) return;
	    var targetScope = path.scope;

	    if (targetScope.path === path) {
	      targetScope = path.scope.parent;
	    }

	    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
	      for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
	        var name = _Object$keys2[_i2];
	        if (!targetScope.hasOwnBinding(name)) continue;
	        var binding = this.bindings[name];

	        if (binding.kind === "param" || binding.path.parentKey === "params") {
	          continue;
	        }

	        var bindingParentPath = this.getAttachmentParentForPath(binding.path);

	        if (bindingParentPath.key >= path.key) {
	          this.attachAfter = true;
	          path = binding.path;

	          for (var _iterator2 = _createForOfIteratorHelperLoose(binding.constantViolations), _step2; !(_step2 = _iterator2()).done;) {
	            var violationPath = _step2.value;

	            if (this.getAttachmentParentForPath(violationPath).key > path.key) {
	              path = violationPath;
	            }
	          }
	        }
	      }
	    }

	    return path;
	  };

	  _proto._getAttachmentPath = function _getAttachmentPath() {
	    var scopes = this.scopes;
	    var scope = scopes.pop();
	    if (!scope) return;

	    if (scope.path.isFunction()) {
	      if (this.hasOwnParamBindings(scope)) {
	        if (this.scope === scope) return;
	        var bodies = scope.path.get("body").get("body");

	        for (var i = 0; i < bodies.length; i++) {
	          if (bodies[i].node._blockHoist) continue;
	          return bodies[i];
	        }
	      } else {
	        return this.getNextScopeAttachmentParent();
	      }
	    } else if (scope.path.isProgram()) {
	      return this.getNextScopeAttachmentParent();
	    }
	  };

	  _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
	    var scope = this.scopes.pop();
	    if (scope) return this.getAttachmentParentForPath(scope.path);
	  };

	  _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
	    do {
	      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
	        return path;
	      }
	    } while (path = path.parentPath);
	  };

	  _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
	    for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {
	      var name = _Object$keys3[_i3];
	      if (!scope.hasOwnBinding(name)) continue;
	      var binding = this.bindings[name];
	      if (binding.kind === "param" && binding.constant) return true;
	    }

	    return false;
	  };

	  _proto.run = function run() {
	    this.path.traverse(referenceVisitor$1, this);
	    if (this.mutableBinding) return;
	    this.getCompatibleScopes();
	    var attachTo = this.getAttachmentPath();
	    if (!attachTo) return;
	    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
	    var uid = attachTo.scope.generateUidIdentifier("ref");
	    var declarator = variableDeclarator$5(uid, this.path.node);
	    var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

	    var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration$5("var", [declarator])]),
	        _attachTo$insertFn2 = _slicedToArray$1(_attachTo$insertFn, 1),
	        attached = _attachTo$insertFn2[0];

	    var parent = this.path.parentPath;

	    if (parent.isJSXElement() && this.path.container === parent.node.children) {
	      uid = jsxExpressionContainer(uid);
	    }

	    this.path.replaceWith(cloneNode$c(uid));
	    return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
	  };

	  return PathHoister;
	}();

	var arrowFunctionExpression$1 = arrowFunctionExpression$4,
	    assertExpression = assertExpression$1,
	    assignmentExpression$8 = assignmentExpression$c,
	    blockStatement$2 = blockStatement$6,
	    callExpression$a = callExpression$e,
	    cloneNode$b = cloneNode$i,
	    expressionStatement$5 = expressionStatement$a,
	    isExpression = isExpression$4;
	function insertBefore(nodes_) {
	  this._assertUnremoved();

	  var nodes = this._verifyNodeList(nodes_);

	  var parentPath = this.parentPath;

	  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
	    return parentPath.insertBefore(nodes);
	  } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
	    if (this.node) nodes.push(this.node);
	    return this.replaceExpressionWithStatements(nodes);
	  } else if (Array.isArray(this.container)) {
	    return this._containerInsertBefore(nodes);
	  } else if (this.isStatementOrBlock()) {
	    var node = this.node;
	    var shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
	    this.replaceWith(blockStatement$2(shouldInsertCurrentNode ? [node] : []));
	    return this.unshiftContainer("body", nodes);
	  } else {
	    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
	  }
	}
	function _containerInsert(from, nodes) {
	  var _this$container;

	  this.updateSiblingKeys(from, nodes.length);
	  var paths = [];

	  (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(_toConsumableArray(nodes)));

	  for (var i = 0; i < nodes.length; i++) {
	    var to = from + i;
	    var path = this.getSibling(to);
	    paths.push(path);

	    if (this.context && this.context.queue) {
	      path.pushContext(this.context);
	    }
	  }

	  var contexts = this._getQueueContexts();

	  for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
	    var _path = _paths[_i];

	    _path.setScope();

	    _path.debug("Inserted.");

	    for (var _iterator = _createForOfIteratorHelperLoose(contexts), _step; !(_step = _iterator()).done;) {
	      var context = _step.value;
	      context.maybeQueue(_path, true);
	    }
	  }

	  return paths;
	}
	function _containerInsertBefore(nodes) {
	  return this._containerInsert(this.key, nodes);
	}
	function _containerInsertAfter(nodes) {
	  return this._containerInsert(this.key + 1, nodes);
	}
	function insertAfter(nodes_) {
	  this._assertUnremoved();

	  var nodes = this._verifyNodeList(nodes_);

	  var parentPath = this.parentPath;

	  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
	    return parentPath.insertAfter(nodes.map(function (node) {
	      return isExpression(node) ? expressionStatement$5(node) : node;
	    }));
	  } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
	    if (this.node) {
	      var node = this.node;
	      var scope = this.scope;

	      if (scope.path.isPattern()) {
	        assertExpression(node);
	        this.replaceWith(callExpression$a(arrowFunctionExpression$1([], node), []));
	        this.get("callee.body").insertAfter(nodes);
	        return [this];
	      }

	      if (parentPath.isMethod({
	        computed: true,
	        key: node
	      })) {
	        scope = scope.parent;
	      }

	      var temp = scope.generateDeclaredUidIdentifier();
	      nodes.unshift(expressionStatement$5(assignmentExpression$8("=", cloneNode$b(temp), node)));
	      nodes.push(expressionStatement$5(cloneNode$b(temp)));
	    }

	    return this.replaceExpressionWithStatements(nodes);
	  } else if (Array.isArray(this.container)) {
	    return this._containerInsertAfter(nodes);
	  } else if (this.isStatementOrBlock()) {
	    var _node = this.node;
	    var shouldInsertCurrentNode = _node && (!this.isExpressionStatement() || _node.expression != null);
	    this.replaceWith(blockStatement$2(shouldInsertCurrentNode ? [_node] : []));
	    return this.pushContainer("body", nodes);
	  } else {
	    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
	  }
	}
	function updateSiblingKeys(fromIndex, incrementBy) {
	  if (!this.parent) return;
	  var paths = path$3.get(this.parent);

	  for (var _iterator2 = _createForOfIteratorHelperLoose(paths), _step2; !(_step2 = _iterator2()).done;) {
	    var _step2$value = _slicedToArray$1(_step2.value, 2),
	        path = _step2$value[1];

	    if (path.key >= fromIndex) {
	      path.key += incrementBy;
	    }
	  }
	}
	function _verifyNodeList(nodes) {
	  if (!nodes) {
	    return [];
	  }

	  if (!Array.isArray(nodes)) {
	    nodes = [nodes];
	  }

	  for (var i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    var msg = void 0;

	    if (!node) {
	      msg = "has falsy node";
	    } else if (typeof node !== "object") {
	      msg = "contains a non-object node";
	    } else if (!node.type) {
	      msg = "without a type";
	    } else if (node instanceof NodePath) {
	      msg = "has a NodePath when it expected a raw object";
	    }

	    if (msg) {
	      var type = Array.isArray(node) ? "array" : typeof node;
	      throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
	    }
	  }

	  return nodes;
	}
	function unshiftContainer(listKey, nodes) {
	  this._assertUnremoved();

	  nodes = this._verifyNodeList(nodes);
	  var path = NodePath.get({
	    parentPath: this,
	    parent: this.node,
	    container: this.node[listKey],
	    listKey: listKey,
	    key: 0
	  }).setContext(this.context);
	  return path._containerInsertBefore(nodes);
	}
	function pushContainer(listKey, nodes) {
	  this._assertUnremoved();

	  var verifiedNodes = this._verifyNodeList(nodes);

	  var container = this.node[listKey];
	  var path = NodePath.get({
	    parentPath: this,
	    parent: this.node,
	    container: container,
	    listKey: listKey,
	    key: container.length
	  }).setContext(this.context);
	  return path.replaceWithMultiple(verifiedNodes);
	}
	function hoist$3(scope) {
	  if (scope === void 0) {
	    scope = this.scope;
	  }

	  var hoister = new PathHoister(this, scope);
	  return hoister.run();
	}

	var NodePath_modification = /*#__PURE__*/Object.freeze({
		__proto__: null,
		insertBefore: insertBefore,
		_containerInsert: _containerInsert,
		_containerInsertBefore: _containerInsertBefore,
		_containerInsertAfter: _containerInsertAfter,
		insertAfter: insertAfter,
		updateSiblingKeys: updateSiblingKeys,
		_verifyNodeList: _verifyNodeList,
		unshiftContainer: unshiftContainer,
		pushContainer: pushContainer,
		hoist: hoist$3
	});

	var _getBindingIdentifiers = getBindingIdentifiers$2,
	    _getOuterBindingIdentifiers = getOuterBindingIdentifiers$2,
	    isDeclaration = isDeclaration$1,
	    numericLiteral$5 = numericLiteral$8,
	    unaryExpression$4 = unaryExpression$7;
	var NORMAL_COMPLETION = 0;
	var BREAK_COMPLETION = 1;

	function NormalCompletion(path) {
	  return {
	    type: NORMAL_COMPLETION,
	    path: path
	  };
	}

	function BreakCompletion(path) {
	  return {
	    type: BREAK_COMPLETION,
	    path: path
	  };
	}

	function getOpposite() {
	  if (this.key === "left") {
	    return this.getSibling("right");
	  } else if (this.key === "right") {
	    return this.getSibling("left");
	  }

	  return null;
	}

	function addCompletionRecords(path, records, context) {
	  if (path) {
	    records.push.apply(records, _toConsumableArray(_getCompletionRecords(path, context)));
	  }

	  return records;
	}

	function completionRecordForSwitch(cases, records, context) {
	  var lastNormalCompletions = [];

	  for (var i = 0; i < cases.length; i++) {
	    var casePath = cases[i];

	    var caseCompletions = _getCompletionRecords(casePath, context);

	    var normalCompletions = [];
	    var breakCompletions = [];

	    for (var _iterator = _createForOfIteratorHelperLoose(caseCompletions), _step; !(_step = _iterator()).done;) {
	      var c = _step.value;

	      if (c.type === NORMAL_COMPLETION) {
	        normalCompletions.push(c);
	      }

	      if (c.type === BREAK_COMPLETION) {
	        breakCompletions.push(c);
	      }
	    }

	    if (normalCompletions.length) {
	      lastNormalCompletions = normalCompletions;
	    }

	    records.push.apply(records, breakCompletions);
	  }

	  records.push.apply(records, _toConsumableArray(lastNormalCompletions));
	  return records;
	}

	function normalCompletionToBreak(completions) {
	  completions.forEach(function (c) {
	    c.type = BREAK_COMPLETION;
	  });
	}

	function replaceBreakStatementInBreakCompletion(completions, reachable) {
	  completions.forEach(function (c) {
	    if (c.path.isBreakStatement({
	      label: null
	    })) {
	      if (reachable) {
	        c.path.replaceWith(unaryExpression$4("void", numericLiteral$5(0)));
	      } else {
	        c.path.remove();
	      }
	    }
	  });
	}

	function getStatementListCompletion(paths, context) {
	  var completions = [];

	  if (context.canHaveBreak) {
	    var lastNormalCompletions = [];

	    for (var i = 0; i < paths.length; i++) {
	      var path = paths[i];
	      var newContext = Object.assign({}, context, {
	        inCaseClause: false
	      });

	      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
	        newContext.shouldPopulateBreak = true;
	      } else {
	        newContext.shouldPopulateBreak = false;
	      }

	      var statementCompletions = _getCompletionRecords(path, newContext);

	      if (statementCompletions.length > 0 && statementCompletions.every(function (c) {
	        return c.type === BREAK_COMPLETION;
	      })) {
	        if (lastNormalCompletions.length > 0 && statementCompletions.every(function (c) {
	          return c.path.isBreakStatement({
	            label: null
	          });
	        })) {
	          normalCompletionToBreak(lastNormalCompletions);
	          completions.push.apply(completions, _toConsumableArray(lastNormalCompletions));

	          if (lastNormalCompletions.some(function (c) {
	            return c.path.isDeclaration();
	          })) {
	            completions.push.apply(completions, _toConsumableArray(statementCompletions));
	            replaceBreakStatementInBreakCompletion(statementCompletions, true);
	          }

	          replaceBreakStatementInBreakCompletion(statementCompletions, false);
	        } else {
	          completions.push.apply(completions, _toConsumableArray(statementCompletions));

	          if (!context.shouldPopulateBreak) {
	            replaceBreakStatementInBreakCompletion(statementCompletions, true);
	          }
	        }

	        break;
	      }

	      if (i === paths.length - 1) {
	        completions.push.apply(completions, _toConsumableArray(statementCompletions));
	      } else {
	        lastNormalCompletions = [];

	        for (var _i = 0; _i < statementCompletions.length; _i++) {
	          var c = statementCompletions[_i];

	          if (c.type === BREAK_COMPLETION) {
	            completions.push(c);
	          }

	          if (c.type === NORMAL_COMPLETION) {
	            lastNormalCompletions.push(c);
	          }
	        }
	      }
	    }
	  } else if (paths.length) {
	    for (var _i2 = paths.length - 1; _i2 >= 0; _i2--) {
	      var pathCompletions = _getCompletionRecords(paths[_i2], context);

	      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
	        completions.push.apply(completions, _toConsumableArray(pathCompletions));
	        break;
	      }
	    }
	  }

	  return completions;
	}

	function _getCompletionRecords(path, context) {
	  var records = [];

	  if (path.isIfStatement()) {
	    records = addCompletionRecords(path.get("consequent"), records, context);
	    records = addCompletionRecords(path.get("alternate"), records, context);
	  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
	    return addCompletionRecords(path.get("body"), records, context);
	  } else if (path.isProgram() || path.isBlockStatement()) {
	    return getStatementListCompletion(path.get("body"), context);
	  } else if (path.isFunction()) {
	    return _getCompletionRecords(path.get("body"), context);
	  } else if (path.isTryStatement()) {
	    records = addCompletionRecords(path.get("block"), records, context);
	    records = addCompletionRecords(path.get("handler"), records, context);
	  } else if (path.isCatchClause()) {
	    return addCompletionRecords(path.get("body"), records, context);
	  } else if (path.isSwitchStatement()) {
	    return completionRecordForSwitch(path.get("cases"), records, context);
	  } else if (path.isSwitchCase()) {
	    return getStatementListCompletion(path.get("consequent"), {
	      canHaveBreak: true,
	      shouldPopulateBreak: false,
	      inCaseClause: true
	    });
	  } else if (path.isBreakStatement()) {
	    records.push(BreakCompletion(path));
	  } else {
	    records.push(NormalCompletion(path));
	  }

	  return records;
	}

	function getCompletionRecords() {
	  var records = _getCompletionRecords(this, {
	    canHaveBreak: false,
	    shouldPopulateBreak: false,
	    inCaseClause: false
	  });

	  return records.map(function (r) {
	    return r.path;
	  });
	}
	function getSibling(key) {
	  return NodePath.get({
	    parentPath: this.parentPath,
	    parent: this.parent,
	    container: this.container,
	    listKey: this.listKey,
	    key: key
	  }).setContext(this.context);
	}
	function getPrevSibling() {
	  return this.getSibling(this.key - 1);
	}
	function getNextSibling() {
	  return this.getSibling(this.key + 1);
	}
	function getAllNextSiblings() {
	  var _key = this.key;
	  var sibling = this.getSibling(++_key);
	  var siblings = [];

	  while (sibling.node) {
	    siblings.push(sibling);
	    sibling = this.getSibling(++_key);
	  }

	  return siblings;
	}
	function getAllPrevSiblings() {
	  var _key = this.key;
	  var sibling = this.getSibling(--_key);
	  var siblings = [];

	  while (sibling.node) {
	    siblings.push(sibling);
	    sibling = this.getSibling(--_key);
	  }

	  return siblings;
	}

	function get$2(key, context) {
	  if (context === void 0) {
	    context = true;
	  }

	  if (context === true) context = this.context;
	  var parts = key.split(".");

	  if (parts.length === 1) {
	    return this._getKey(key, context);
	  } else {
	    return this._getPattern(parts, context);
	  }
	}
	function _getKey(key, context) {
	  var _this = this;

	  var node = this.node;
	  var container = node[key];

	  if (Array.isArray(container)) {
	    return container.map(function (_, i) {
	      return NodePath.get({
	        listKey: key,
	        parentPath: _this,
	        parent: node,
	        container: container,
	        key: i
	      }).setContext(context);
	    });
	  } else {
	    return NodePath.get({
	      parentPath: this,
	      parent: node,
	      container: node,
	      key: key
	    }).setContext(context);
	  }
	}
	function _getPattern(parts, context) {
	  var path = this;

	  for (var _iterator2 = _createForOfIteratorHelperLoose(parts), _step2; !(_step2 = _iterator2()).done;) {
	    var part = _step2.value;

	    if (part === ".") {
	      path = path.parentPath;
	    } else {
	      if (Array.isArray(path)) {
	        path = path[part];
	      } else {
	        path = path.get(part, context);
	      }
	    }
	  }

	  return path;
	}

	function getBindingIdentifiers(duplicates) {
	  return _getBindingIdentifiers(this.node, duplicates);
	}

	function getOuterBindingIdentifiers$1(duplicates) {
	  return _getOuterBindingIdentifiers(this.node, duplicates);
	}
	function getBindingIdentifierPaths(duplicates, outerOnly) {
	  if (duplicates === void 0) {
	    duplicates = false;
	  }

	  if (outerOnly === void 0) {
	    outerOnly = false;
	  }

	  var path = this;
	  var search = [path];
	  var ids = Object.create(null);

	  while (search.length) {
	    var id = search.shift();
	    if (!id) continue;
	    if (!id.node) continue;
	    var keys = _getBindingIdentifiers.keys[id.node.type];

	    if (id.isIdentifier()) {
	      if (duplicates) {
	        var _ids = ids[id.node.name] = ids[id.node.name] || [];

	        _ids.push(id);
	      } else {
	        ids[id.node.name] = id;
	      }

	      continue;
	    }

	    if (id.isExportDeclaration()) {
	      var declaration = id.get("declaration");

	      if (isDeclaration(declaration)) {
	        search.push(declaration);
	      }

	      continue;
	    }

	    if (outerOnly) {
	      if (id.isFunctionDeclaration()) {
	        search.push(id.get("id"));
	        continue;
	      }

	      if (id.isFunctionExpression()) {
	        continue;
	      }
	    }

	    if (keys) {
	      for (var i = 0; i < keys.length; i++) {
	        var _key2 = keys[i];
	        var child = id.get(_key2);

	        if (Array.isArray(child)) {
	          search.push.apply(search, _toConsumableArray(child));
	        } else if (child.node) {
	          search.push(child);
	        }
	      }
	    }
	  }

	  return ids;
	}
	function getOuterBindingIdentifierPaths(duplicates) {
	  return this.getBindingIdentifierPaths(duplicates, true);
	}

	var NodePath_family = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getOpposite: getOpposite,
		getCompletionRecords: getCompletionRecords,
		getSibling: getSibling,
		getPrevSibling: getPrevSibling,
		getNextSibling: getNextSibling,
		getAllNextSiblings: getAllNextSiblings,
		getAllPrevSiblings: getAllPrevSiblings,
		get: get$2,
		_getKey: _getKey,
		_getPattern: _getPattern,
		getBindingIdentifiers: getBindingIdentifiers,
		getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
		getBindingIdentifierPaths: getBindingIdentifierPaths,
		getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths
	});

	var _addComment = addComment$2,
	    _addComments = addComments$1;
	function shareCommentsWithSiblings() {
	  if (typeof this.key === "string") return;
	  var node = this.node;
	  if (!node) return;
	  var trailing = node.trailingComments;
	  var leading = node.leadingComments;
	  if (!trailing && !leading) return;
	  var prev = this.getSibling(this.key - 1);
	  var next = this.getSibling(this.key + 1);
	  var hasPrev = Boolean(prev.node);
	  var hasNext = Boolean(next.node);

	  if (hasPrev && !hasNext) {
	    prev.addComments("trailing", trailing);
	  } else if (hasNext && !hasPrev) {
	    next.addComments("leading", leading);
	  }
	}
	function addComment$1(type, content, line) {
	  _addComment(this.node, type, content, line);
	}
	function addComments(type, comments) {
	  _addComments(this.node, type, comments);
	}

	var NodePath_comments = /*#__PURE__*/Object.freeze({
		__proto__: null,
		shareCommentsWithSiblings: shareCommentsWithSiblings,
		addComment: addComment$1,
		addComments: addComments
	});

	var validate$1 = validate$6;

	var _debug = browser$3("babel");

	var REMOVED = 1 << 0;
	var SHOULD_STOP = 1 << 1;
	var SHOULD_SKIP = 1 << 2;

	var NodePath = function () {
	  function NodePath(hub, parent) {
	    this.contexts = [];
	    this.state = null;
	    this.opts = null;
	    this._traverseFlags = 0;
	    this.skipKeys = null;
	    this.parentPath = null;
	    this.container = null;
	    this.listKey = null;
	    this.key = null;
	    this.node = null;
	    this.type = null;
	    this.parent = parent;
	    this.hub = hub;
	    this.data = null;
	    this.context = null;
	    this.scope = null;
	  }

	  NodePath.get = function get(_ref) {
	    var hub = _ref.hub,
	        parentPath = _ref.parentPath,
	        parent = _ref.parent,
	        container = _ref.container,
	        listKey = _ref.listKey,
	        key = _ref.key;

	    if (!hub && parentPath) {
	      hub = parentPath.hub;
	    }

	    if (!parent) {
	      throw new Error("To get a node path the parent needs to exist");
	    }

	    var targetNode = container[key];
	    var paths = path$3.get(parent);

	    if (!paths) {
	      paths = new Map();
	      path$3.set(parent, paths);
	    }

	    var path = paths.get(targetNode);

	    if (!path) {
	      path = new NodePath(hub, parent);
	      if (targetNode) paths.set(targetNode, path);
	    }

	    path.setup(parentPath, container, listKey, key);
	    return path;
	  };

	  var _proto = NodePath.prototype;

	  _proto.getScope = function getScope(scope) {
	    return this.isScope() ? new Scope$1(this) : scope;
	  };

	  _proto.setData = function setData(key, val) {
	    if (this.data == null) {
	      this.data = Object.create(null);
	    }

	    return this.data[key] = val;
	  };

	  _proto.getData = function getData(key, def) {
	    if (this.data == null) {
	      this.data = Object.create(null);
	    }

	    var val = this.data[key];
	    if (val === undefined && def !== undefined) val = this.data[key] = def;
	    return val;
	  };

	  _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {
	    if (Error === void 0) {
	      Error = SyntaxError;
	    }

	    return this.hub.buildError(this.node, msg, Error);
	  };

	  _proto.traverse = function traverse$1(visitor, state) {
	    traverse(this.node, visitor, this.scope, state, this);
	  };

	  _proto.set = function set(key, node) {
	    validate$1(this.node, key, node);
	    this.node[key] = node;
	  };

	  _proto.getPathLocation = function getPathLocation() {
	    var parts = [];
	    var path = this;

	    do {
	      var key = path.key;
	      if (path.inList) key = path.listKey + "[" + key + "]";
	      parts.unshift(key);
	    } while (path = path.parentPath);

	    return parts.join(".");
	  };

	  _proto.debug = function debug(message) {
	    if (!_debug.enabled) return;

	    _debug(this.getPathLocation() + " " + this.type + ": " + message);
	  };

	  _proto.toString = function toString() {
	    return generate$1(this.node).code;
	  };

	  _createClass(NodePath, [{
	    key: "inList",
	    get: function get() {
	      return !!this.listKey;
	    },
	    set: function set(inList) {
	      if (!inList) {
	        this.listKey = null;
	      }
	    }
	  }, {
	    key: "parentKey",
	    get: function get() {
	      return this.listKey || this.key;
	    }
	  }, {
	    key: "shouldSkip",
	    get: function get() {
	      return !!(this._traverseFlags & SHOULD_SKIP);
	    },
	    set: function set(v) {
	      if (v) {
	        this._traverseFlags |= SHOULD_SKIP;
	      } else {
	        this._traverseFlags &= ~SHOULD_SKIP;
	      }
	    }
	  }, {
	    key: "shouldStop",
	    get: function get() {
	      return !!(this._traverseFlags & SHOULD_STOP);
	    },
	    set: function set(v) {
	      if (v) {
	        this._traverseFlags |= SHOULD_STOP;
	      } else {
	        this._traverseFlags &= ~SHOULD_STOP;
	      }
	    }
	  }, {
	    key: "removed",
	    get: function get() {
	      return !!(this._traverseFlags & REMOVED);
	    },
	    set: function set(v) {
	      if (v) {
	        this._traverseFlags |= REMOVED;
	      } else {
	        this._traverseFlags &= ~REMOVED;
	      }
	    }
	  }]);

	  return NodePath;
	}();

	Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

	var _loop2 = function _loop2() {
	  var type = _step.value;
	  var typeKey = "is" + type;
	  var fn = t$f[typeKey];

	  NodePath.prototype[typeKey] = function (opts) {
	    return fn(this.node, opts);
	  };

	  NodePath.prototype["assert" + type] = function (opts) {
	    if (!fn(this.node, opts)) {
	      throw new TypeError("Expected node path of type " + type);
	    }
	  };
	};

	for (var _iterator = _createForOfIteratorHelperLoose(TYPES$1), _step; !(_step = _iterator()).done;) {
	  _loop2();
	}

	var _loop = function _loop() {
	  var type = _Object$keys$1[_i$1];
	  if (type[0] === "_") return "continue";
	  if (TYPES$1.indexOf(type) < 0) TYPES$1.push(type);
	  var virtualType = virtualTypes[type];

	  NodePath.prototype["is" + type] = function (opts) {
	    return virtualType.checkPath(this, opts);
	  };
	};

	for (var _i$1 = 0, _Object$keys$1 = Object.keys(virtualTypes); _i$1 < _Object$keys$1.length; _i$1++) {
	  var _ret = _loop();

	  if (_ret === "continue") continue;
	}

	var VISITOR_KEYS$1 = VISITOR_KEYS$6;

	var TraversalContext = function () {
	  function TraversalContext(scope, opts, state, parentPath) {
	    this.queue = null;
	    this.priorityQueue = null;
	    this.parentPath = parentPath;
	    this.scope = scope;
	    this.state = state;
	    this.opts = opts;
	  }

	  var _proto = TraversalContext.prototype;

	  _proto.shouldVisit = function shouldVisit(node) {
	    var opts = this.opts;
	    if (opts.enter || opts.exit) return true;
	    if (opts[node.type]) return true;
	    var keys = VISITOR_KEYS$1[node.type];
	    if (!(keys != null && keys.length)) return false;

	    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	      var key = _step.value;
	      if (node[key]) return true;
	    }

	    return false;
	  };

	  _proto.create = function create(node, obj, key, listKey) {
	    return NodePath.get({
	      parentPath: this.parentPath,
	      parent: node,
	      container: obj,
	      key: key,
	      listKey: listKey
	    });
	  };

	  _proto.maybeQueue = function maybeQueue(path, notPriority) {
	    if (this.queue) {
	      if (notPriority) {
	        this.queue.push(path);
	      } else {
	        this.priorityQueue.push(path);
	      }
	    }
	  };

	  _proto.visitMultiple = function visitMultiple(container, parent, listKey) {
	    if (container.length === 0) return false;
	    var queue = [];

	    for (var key = 0; key < container.length; key++) {
	      var node = container[key];

	      if (node && this.shouldVisit(node)) {
	        queue.push(this.create(parent, container, key, listKey));
	      }
	    }

	    return this.visitQueue(queue);
	  };

	  _proto.visitSingle = function visitSingle(node, key) {
	    if (this.shouldVisit(node[key])) {
	      return this.visitQueue([this.create(node, node, key)]);
	    } else {
	      return false;
	    }
	  };

	  _proto.visitQueue = function visitQueue(queue) {
	    this.queue = queue;
	    this.priorityQueue = [];
	    var visited = new WeakSet();
	    var stop = false;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(queue), _step2; !(_step2 = _iterator2()).done;) {
	      var path = _step2.value;
	      path.resync();

	      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
	        path.pushContext(this);
	      }

	      if (path.key === null) continue;
	      var node = path.node;
	      if (visited.has(node)) continue;
	      if (node) visited.add(node);

	      if (path.visit()) {
	        stop = true;
	        break;
	      }

	      if (this.priorityQueue.length) {
	        stop = this.visitQueue(this.priorityQueue);
	        this.priorityQueue = [];
	        this.queue = queue;
	        if (stop) break;
	      }
	    }

	    for (var _iterator3 = _createForOfIteratorHelperLoose(queue), _step3; !(_step3 = _iterator3()).done;) {
	      var _path = _step3.value;

	      _path.popContext();
	    }

	    this.queue = null;
	    return stop;
	  };

	  _proto.visit = function visit(node, key) {
	    var nodes = node[key];
	    if (!nodes) return false;

	    if (Array.isArray(nodes)) {
	      return this.visitMultiple(nodes, node, key);
	    } else {
	      return this.visitSingle(node, key);
	    }
	  };

	  return TraversalContext;
	}();

	var VISITOR_KEYS = VISITOR_KEYS$6,
	    removeProperties = removeProperties$1,
	    traverseFast$1 = traverseFast$2;

	function traverse(parent, opts, scope, state, parentPath) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  if (!parent) return;

	  if (!opts.noScope && !scope) {
	    if (parent.type !== "Program" && parent.type !== "File") {
	      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + ("Instead of that you tried to traverse a " + parent.type + " node without ") + "passing scope and parentPath.");
	    }
	  }

	  if (!VISITOR_KEYS[parent.type]) {
	    return;
	  }

	  explode$1(opts);
	  traverse.node(parent, opts, scope, state, parentPath);
	}
	traverse.visitors = visitors;
	traverse.verify = verify;
	traverse.explode = explode$1;

	traverse.cheap = function (node, enter) {
	  return traverseFast$1(node, enter);
	};

	traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
	  var keys = VISITOR_KEYS[node.type];
	  if (!keys) return;
	  var context = new TraversalContext(scope, opts, state, parentPath);

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    if (skipKeys && skipKeys[key]) continue;
	    if (context.visit(node, key)) return;
	  }
	};

	traverse.clearNode = function (node, opts) {
	  removeProperties(node, opts);
	  path$3["delete"](node);
	};

	traverse.removeProperties = function (tree, opts) {
	  traverseFast$1(tree, traverse.clearNode, opts);
	  return tree;
	};

	function hasDenylistedType(path, state) {
	  if (path.node.type === state.type) {
	    state.has = true;
	    path.stop();
	  }
	}

	traverse.hasType = function (tree, type, denylistTypes) {
	  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
	  if (tree.type === type) return true;
	  var state = {
	    has: false,
	    type: type
	  };
	  traverse(tree, {
	    noScope: true,
	    denylist: denylistTypes,
	    enter: hasDenylistedType
	  }, null, state);
	  return state.has;
	};

	traverse.cache = cache$2;

	function helper$3(minVersion, source) {
	  return Object.freeze({
	    minVersion: minVersion,
	    ast: function ast() {
	      return template$2.program.ast(source);
	    }
	  });
	}

	var generated = Object.freeze({
	  asyncIterator: helper$3("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'),
	  jsx: helper$3("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'),
	  objectSpread2: helper$3("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'),
	  "typeof": helper$3("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'),
	  wrapRegExp: helper$3("7.2.6", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){return groups[name]=result[g[name]],groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);return result&&(result.groups=buildGroups(result,this)),result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){return"$"+groups[name]})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}')
	});

	var _templateObject$n, _templateObject2$b, _templateObject3$a, _templateObject4$6, _templateObject5$4, _templateObject6$4, _templateObject7$3, _templateObject8$2, _templateObject9$2, _templateObject10$2, _templateObject11$2, _templateObject12$2, _templateObject13$2, _templateObject14$1, _templateObject15$1, _templateObject16$1, _templateObject17$1, _templateObject18$1, _templateObject19$1, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44, _templateObject45, _templateObject46, _templateObject47, _templateObject48, _templateObject49, _templateObject50, _templateObject51, _templateObject52, _templateObject53, _templateObject54, _templateObject55, _templateObject56, _templateObject57, _templateObject58, _templateObject59, _templateObject60, _templateObject61, _templateObject62, _templateObject63, _templateObject64, _templateObject65, _templateObject66, _templateObject67, _templateObject68, _templateObject69, _templateObject70, _templateObject71, _templateObject72, _templateObject73, _templateObject74, _templateObject75, _templateObject76, _templateObject77, _templateObject78, _templateObject79, _templateObject80, _templateObject81, _templateObject82, _templateObject83, _templateObject84, _templateObject85, _templateObject86;
	var helpers$1 = Object.assign({
	  __proto__: null
	}, generated);

	var helper$2 = function helper(minVersion) {
	  return function (tpl) {
	    return {
	      minVersion: minVersion,
	      ast: function ast() {
	        return template$2.program.ast(tpl);
	      }
	    };
	  };
	};

	helpers$1.AwaitValue = helper$2("7.0.0-beta.0")(_templateObject$n || (_templateObject$n = _taggedTemplateLiteralLoose(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"])));
	helpers$1.AsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  AsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () { return this; };\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"])));
	helpers$1.wrapAsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteralLoose(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"])));
	helpers$1.awaitAsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"])));
	helpers$1.asyncGeneratorDelegate = helper$2("7.0.0-beta.0")(_templateObject5$4 || (_templateObject5$4 = _taggedTemplateLiteralLoose(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    iter[typeof Symbol !== \"undefined\" && Symbol.iterator || \"@@iterator\"] = function () { return this; };\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"])));
	helpers$1.asyncToGenerator = helper$2("7.0.0-beta.0")(_templateObject6$4 || (_templateObject6$4 = _taggedTemplateLiteralLoose(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"])));
	helpers$1.classCallCheck = helper$2("7.0.0-beta.0")(_templateObject7$3 || (_templateObject7$3 = _taggedTemplateLiteralLoose(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"])));
	helpers$1.createClass = helper$2("7.0.0-beta.0")(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteralLoose(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", { writable: false });\n    return Constructor;\n  }\n"])));
	helpers$1.defineEnumerableProperties = helper$2("7.0.0-beta.0")(_templateObject9$2 || (_templateObject9$2 = _taggedTemplateLiteralLoose(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"])));
	helpers$1.defaults = helper$2("7.0.0-beta.0")(_templateObject10$2 || (_templateObject10$2 = _taggedTemplateLiteralLoose(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"])));
	helpers$1.defineProperty = helper$2("7.0.0-beta.0")(_templateObject11$2 || (_templateObject11$2 = _taggedTemplateLiteralLoose(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"])));
	helpers$1["extends"] = helper$2("7.0.0-beta.0")(_templateObject12$2 || (_templateObject12$2 = _taggedTemplateLiteralLoose(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"])));
	helpers$1.objectSpread = helper$2("7.0.0-beta.0")(_templateObject13$2 || (_templateObject13$2 = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"])));
	helpers$1.inherits = helper$2("7.0.0-beta.0")(_templateObject14$1 || (_templateObject14$1 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    Object.defineProperty(subClass, \"prototype\", {\n      value: Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: true,\n          configurable: true\n        }\n      }),\n      writable: false,\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"])));
	helpers$1.inheritsLoose = helper$2("7.0.0-beta.0")(_templateObject15$1 || (_templateObject15$1 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    setPrototypeOf(subClass, superClass);\n  }\n"])));
	helpers$1.getPrototypeOf = helper$2("7.0.0-beta.0")(_templateObject16$1 || (_templateObject16$1 = _taggedTemplateLiteralLoose(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"])));
	helpers$1.setPrototypeOf = helper$2("7.0.0-beta.0")(_templateObject17$1 || (_templateObject17$1 = _taggedTemplateLiteralLoose(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"])));
	helpers$1.isNativeReflectConstruct = helper$2("7.9.0")(_templateObject18$1 || (_templateObject18$1 = _taggedTemplateLiteralLoose(["\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Boolean object.\n\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n"])));
	helpers$1.construct = helper$2("7.0.0-beta.0")(_templateObject19$1 || (_templateObject19$1 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"])));
	helpers$1.isNativeFunction = helper$2("7.0.0-beta.0")(_templateObject20 || (_templateObject20 = _taggedTemplateLiteralLoose(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"])));
	helpers$1.wrapNativeSuper = helper$2("7.0.0-beta.0")(_templateObject21 || (_templateObject21 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"])));
	helpers$1["instanceof"] = helper$2("7.0.0-beta.0")(_templateObject22 || (_templateObject22 = _taggedTemplateLiteralLoose(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"])));
	helpers$1.interopRequireDefault = helper$2("7.0.0-beta.0")(_templateObject23 || (_templateObject23 = _taggedTemplateLiteralLoose(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"])));
	helpers$1.interopRequireWildcard = helper$2("7.14.0")(_templateObject24 || (_templateObject24 = _taggedTemplateLiteralLoose(["\n  function _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function (nodeInterop) {\n      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n  }\n\n  export default function _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"])));
	helpers$1.newArrowCheck = helper$2("7.0.0-beta.0")(_templateObject25 || (_templateObject25 = _taggedTemplateLiteralLoose(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"])));
	helpers$1.objectDestructuringEmpty = helper$2("7.0.0-beta.0")(_templateObject26 || (_templateObject26 = _taggedTemplateLiteralLoose(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"])));
	helpers$1.objectWithoutPropertiesLoose = helper$2("7.0.0-beta.0")(_templateObject27 || (_templateObject27 = _taggedTemplateLiteralLoose(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"])));
	helpers$1.objectWithoutProperties = helper$2("7.0.0-beta.0")(_templateObject28 || (_templateObject28 = _taggedTemplateLiteralLoose(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"])));
	helpers$1.assertThisInitialized = helper$2("7.0.0-beta.0")(_templateObject29 || (_templateObject29 = _taggedTemplateLiteralLoose(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"])));
	helpers$1.possibleConstructorReturn = helper$2("7.0.0-beta.0")(_templateObject30 || (_templateObject30 = _taggedTemplateLiteralLoose(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n\n    return assertThisInitialized(self);\n  }\n"])));
	helpers$1.createSuper = helper$2("7.9.0")(_templateObject31 || (_templateObject31 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = getPrototypeOf(Derived), result;\n      if (hasNativeReflectConstruct) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n "])));
	helpers$1.superPropBase = helper$2("7.0.0-beta.0")(_templateObject32 || (_templateObject32 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"])));
	helpers$1.get = helper$2("7.0.0-beta.0")(_templateObject33 || (_templateObject33 = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get() {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          // STEP 3. If receiver is not present, then set receiver to target.\n          return desc.get.call(arguments.length < 3 ? target : receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get.apply(this, arguments);\n  }\n"])));
	helpers$1.set = helper$2("7.0.0-beta.0")(_templateObject34 || (_templateObject34 = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"])));
	helpers$1.taggedTemplateLiteral = helper$2("7.0.0-beta.0")(_templateObject35 || (_templateObject35 = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"])));
	helpers$1.taggedTemplateLiteralLoose = helper$2("7.0.0-beta.0")(_templateObject36 || (_templateObject36 = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"])));
	helpers$1.readOnlyError = helper$2("7.0.0-beta.0")(_templateObject37 || (_templateObject37 = _taggedTemplateLiteralLoose(["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"])));
	helpers$1.writeOnlyError = helper$2("7.12.13")(_templateObject38 || (_templateObject38 = _taggedTemplateLiteralLoose(["\n  export default function _writeOnlyError(name) {\n    throw new TypeError(\"\\\"\" + name + \"\\\" is write-only\");\n  }\n"], ["\n  export default function _writeOnlyError(name) {\n    throw new TypeError(\"\\\\\"\" + name + \"\\\\\" is write-only\");\n  }\n"])));
	helpers$1.classNameTDZError = helper$2("7.0.0-beta.0")(_templateObject39 || (_templateObject39 = _taggedTemplateLiteralLoose(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"])));
	helpers$1.temporalUndefined = helper$2("7.0.0-beta.0")(_templateObject40 || (_templateObject40 = _taggedTemplateLiteralLoose(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"])));
	helpers$1.tdz = helper$2("7.5.5")(_templateObject41 || (_templateObject41 = _taggedTemplateLiteralLoose(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"])));
	helpers$1.temporalRef = helper$2("7.0.0-beta.0")(_templateObject42 || (_templateObject42 = _taggedTemplateLiteralLoose(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"])));
	helpers$1.slicedToArray = helper$2("7.0.0-beta.0")(_templateObject43 || (_templateObject43 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"])));
	helpers$1.slicedToArrayLoose = helper$2("7.0.0-beta.0")(_templateObject44 || (_templateObject44 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"])));
	helpers$1.toArray = helper$2("7.0.0-beta.0")(_templateObject45 || (_templateObject45 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n"])));
	helpers$1.toConsumableArray = helper$2("7.0.0-beta.0")(_templateObject46 || (_templateObject46 = _taggedTemplateLiteralLoose(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n"])));
	helpers$1.arrayWithoutHoles = helper$2("7.0.0-beta.0")(_templateObject47 || (_templateObject47 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n"])));
	helpers$1.arrayWithHoles = helper$2("7.0.0-beta.0")(_templateObject48 || (_templateObject48 = _taggedTemplateLiteralLoose(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"])));
	helpers$1.maybeArrayLike = helper$2("7.9.0")(_templateObject49 || (_templateObject49 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _maybeArrayLike(next, arr, i) {\n    if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n      var len = arr.length;\n      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n    }\n    return next(arr, i);\n  }\n"])));
	helpers$1.iterableToArray = helper$2("7.0.0-beta.0")(_templateObject50 || (_templateObject50 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n"])));
	helpers$1.iterableToArrayLimit = helper$2("7.0.0-beta.0")(_templateObject51 || (_templateObject51 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _i = arr == null ? null : (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _i = arr == null ? null : (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"])));
	helpers$1.iterableToArrayLimitLoose = helper$2("7.0.0-beta.0")(_templateObject52 || (_templateObject52 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"])));
	helpers$1.unsupportedIterableToArray = helper$2("7.9.0")(_templateObject53 || (_templateObject53 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n"])));
	helpers$1.arrayLikeToArray = helper$2("7.9.0")(_templateObject54 || (_templateObject54 = _taggedTemplateLiteralLoose(["\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n"])));
	helpers$1.nonIterableSpread = helper$2("7.0.0-beta.0")(_templateObject55 || (_templateObject55 = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"])));
	helpers$1.nonIterableRest = helper$2("7.0.0-beta.0")(_templateObject56 || (_templateObject56 = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"])));
	helpers$1.createForOfIteratorHelper = helper$2("7.9.0")(_templateObject57 || (_templateObject57 = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = it.call(o);\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = it.call(o);\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"])));
	helpers$1.createForOfIteratorHelperLoose = helper$2("7.9.0")(_templateObject58 || (_templateObject58 = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    // Fallback for engines without symbol support\n    if (\n      Array.isArray(o) ||\n      (it = unsupportedIterableToArray(o)) ||\n      (allowArrayLike && o && typeof o.length === \"number\")\n    ) {\n      if (it) o = it;\n      var i = 0;\n      return function() {\n        if (i >= o.length) return { done: true };\n        return { done: false, value: o[i++] };\n      }\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    // Fallback for engines without symbol support\n    if (\n      Array.isArray(o) ||\n      (it = unsupportedIterableToArray(o)) ||\n      (allowArrayLike && o && typeof o.length === \"number\")\n    ) {\n      if (it) o = it;\n      var i = 0;\n      return function() {\n        if (i >= o.length) return { done: true };\n        return { done: false, value: o[i++] };\n      }\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n"])));
	helpers$1.skipFirstGeneratorNext = helper$2("7.0.0-beta.0")(_templateObject59 || (_templateObject59 = _taggedTemplateLiteralLoose(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"])));
	helpers$1.toPrimitive = helper$2("7.1.5")(_templateObject60 || (_templateObject60 = _taggedTemplateLiteralLoose(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"])));
	helpers$1.toPropertyKey = helper$2("7.1.5")(_templateObject61 || (_templateObject61 = _taggedTemplateLiteralLoose(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"])));
	helpers$1.initializerWarningHelper = helper$2("7.0.0-beta.0")(_templateObject62 || (_templateObject62 = _taggedTemplateLiteralLoose(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"])));
	helpers$1.initializerDefineProperty = helper$2("7.0.0-beta.0")(_templateObject63 || (_templateObject63 = _taggedTemplateLiteralLoose(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"])));
	helpers$1.applyDecoratedDescriptor = helper$2("7.0.0-beta.0")(_templateObject64 || (_templateObject64 = _taggedTemplateLiteralLoose(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"])));
	helpers$1.classPrivateFieldLooseKey = helper$2("7.0.0-beta.0")(_templateObject65 || (_templateObject65 = _taggedTemplateLiteralLoose(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"])));
	helpers$1.classPrivateFieldLooseBase = helper$2("7.0.0-beta.0")(_templateObject66 || (_templateObject66 = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"])));
	helpers$1.classPrivateFieldGet = helper$2("7.0.0-beta.0")(_templateObject67 || (_templateObject67 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorGet from \"classApplyDescriptorGet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"get\");\n    return classApplyDescriptorGet(receiver, descriptor);\n  }\n"])));
	helpers$1.classPrivateFieldSet = helper$2("7.0.0-beta.0")(_templateObject68 || (_templateObject68 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorSet from \"classApplyDescriptorSet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n    classApplyDescriptorSet(receiver, descriptor, value);\n    return value;\n  }\n"])));
	helpers$1.classPrivateFieldDestructureSet = helper$2("7.4.4")(_templateObject69 || (_templateObject69 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorDestructureSet from \"classApplyDescriptorDestructureSet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n    return classApplyDescriptorDestructureSet(receiver, descriptor);\n  }\n"])));
	helpers$1.classExtractFieldDescriptor = helper$2("7.13.10")(_templateObject70 || (_templateObject70 = _taggedTemplateLiteralLoose(["\n  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n  }\n"])));
	helpers$1.classStaticPrivateFieldSpecGet = helper$2("7.0.2")(_templateObject71 || (_templateObject71 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorGet from \"classApplyDescriptorGet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"get\");\n    return classApplyDescriptorGet(receiver, descriptor);\n  }\n"])));
	helpers$1.classStaticPrivateFieldSpecSet = helper$2("7.0.2")(_templateObject72 || (_templateObject72 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorSet from \"classApplyDescriptorSet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n    classApplyDescriptorSet(receiver, descriptor, value);\n    return value;\n  }\n"])));
	helpers$1.classStaticPrivateMethodGet = helper$2("7.3.2")(_templateObject73 || (_templateObject73 = _taggedTemplateLiteralLoose(["\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    return method;\n  }\n"])));
	helpers$1.classStaticPrivateMethodSet = helper$2("7.3.2")(_templateObject74 || (_templateObject74 = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"])));
	helpers$1.classApplyDescriptorGet = helper$2("7.13.10")(_templateObject75 || (_templateObject75 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorGet(receiver, descriptor) {\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"])));
	helpers$1.classApplyDescriptorSet = helper$2("7.13.10")(_templateObject76 || (_templateObject76 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n  }\n"])));
	helpers$1.classApplyDescriptorDestructureSet = helper$2("7.13.10")(_templateObject77 || (_templateObject77 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"])));
	helpers$1.classStaticPrivateFieldDestructureSet = helper$2("7.13.10")(_templateObject78 || (_templateObject78 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorDestructureSet from \"classApplyDescriptorDestructureSet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n    return classApplyDescriptorDestructureSet(receiver, descriptor);\n  }\n"])));
	helpers$1.classCheckPrivateStaticAccess = helper$2("7.13.10")(_templateObject79 || (_templateObject79 = _taggedTemplateLiteralLoose(["\n  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n  }\n"])));
	helpers$1.classCheckPrivateStaticFieldDescriptor = helper$2("7.13.10")(_templateObject80 || (_templateObject80 = _taggedTemplateLiteralLoose(["\n  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\n    if (descriptor === undefined) {\n      throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n    }\n  }\n"])));
	helpers$1.decorate = helper$2("7.1.5")(_templateObject81 || (_templateObject81 = _taggedTemplateLiteralLoose(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"])));
	helpers$1.classPrivateMethodGet = helper$2("7.1.6")(_templateObject82 || (_templateObject82 = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"])));
	helpers$1.checkPrivateRedeclaration = helper$2("7.14.1")(_templateObject83 || (_templateObject83 = _taggedTemplateLiteralLoose(["\n  export default function _checkPrivateRedeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n      throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n  }\n"])));
	helpers$1.classPrivateFieldInitSpec = helper$2("7.14.1")(_templateObject84 || (_templateObject84 = _taggedTemplateLiteralLoose(["\n  import checkPrivateRedeclaration from \"checkPrivateRedeclaration\";\n\n  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {\n    checkPrivateRedeclaration(obj, privateMap);\n    privateMap.set(obj, value);\n  }\n"])));
	helpers$1.classPrivateMethodInitSpec = helper$2("7.14.1")(_templateObject85 || (_templateObject85 = _taggedTemplateLiteralLoose(["\n  import checkPrivateRedeclaration from \"checkPrivateRedeclaration\";\n\n  export default function _classPrivateMethodInitSpec(obj, privateSet) {\n    checkPrivateRedeclaration(obj, privateSet);\n    privateSet.add(obj);\n  }\n"])));
	{
	  helpers$1.classPrivateMethodSet = helper$2("7.1.6")(_templateObject86 || (_templateObject86 = _taggedTemplateLiteralLoose(["\n    export default function _classPrivateMethodSet() {\n      throw new TypeError(\"attempted to reassign private method\");\n    }\n  "])));
	}

	var assignmentExpression$7 = assignmentExpression$c,
	    cloneNode$a = cloneNode$i,
	    expressionStatement$4 = expressionStatement$a,
	    t_file = file$1,
	    identifier$a = identifier$j,
	    variableDeclaration$4 = variableDeclaration$8,
	    variableDeclarator$4 = variableDeclarator$8;

	function makePath(path) {
	  var parts = [];

	  for (; path.parentPath; path = path.parentPath) {
	    parts.push(path.key);
	    if (path.inList) parts.push(path.listKey);
	  }

	  return parts.reverse().join(".");
	}

	var fileClass = undefined;

	function getHelperMetadata(file) {
	  var globals = new Set();
	  var localBindingNames = new Set();
	  var dependencies = new Map();
	  var exportName;
	  var exportPath;
	  var exportBindingAssignments = [];
	  var importPaths = [];
	  var importBindingsReferences = [];
	  var dependencyVisitor = {
	    ImportDeclaration: function ImportDeclaration(child) {
	      var name = child.node.source.value;

	      if (!helpers$1[name]) {
	        throw child.buildCodeFrameError("Unknown helper " + name);
	      }

	      if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
	        throw child.buildCodeFrameError("Helpers can only import a default value");
	      }

	      var bindingIdentifier = child.node.specifiers[0].local;
	      dependencies.set(bindingIdentifier, name);
	      importPaths.push(makePath(child));
	    },
	    ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
	      var decl = child.get("declaration");

	      if (decl.isFunctionDeclaration()) {
	        if (!decl.node.id) {
	          throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
	        }

	        exportName = decl.node.id.name;
	      }

	      exportPath = makePath(child);
	    },
	    ExportAllDeclaration: function ExportAllDeclaration(child) {
	      throw child.buildCodeFrameError("Helpers can only export default");
	    },
	    ExportNamedDeclaration: function ExportNamedDeclaration(child) {
	      throw child.buildCodeFrameError("Helpers can only export default");
	    },
	    Statement: function Statement(child) {
	      if (child.isModuleDeclaration()) return;
	      child.skip();
	    }
	  };
	  var referenceVisitor = {
	    Program: function Program(path) {
	      var bindings = path.scope.getAllBindings();
	      Object.keys(bindings).forEach(function (name) {
	        if (name === exportName) return;
	        if (dependencies.has(bindings[name].identifier)) return;
	        localBindingNames.add(name);
	      });
	    },
	    ReferencedIdentifier: function ReferencedIdentifier(child) {
	      var name = child.node.name;
	      var binding = child.scope.getBinding(name);

	      if (!binding) {
	        globals.add(name);
	      } else if (dependencies.has(binding.identifier)) {
	        importBindingsReferences.push(makePath(child));
	      }
	    },
	    AssignmentExpression: function AssignmentExpression(child) {
	      var left = child.get("left");
	      if (!(exportName in left.getBindingIdentifiers())) return;

	      if (!left.isIdentifier()) {
	        throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
	      }

	      var binding = child.scope.getBinding(exportName);

	      if (binding != null && binding.scope.path.isProgram()) {
	        exportBindingAssignments.push(makePath(child));
	      }
	    }
	  };
	  traverse(file.ast, dependencyVisitor, file.scope);
	  traverse(file.ast, referenceVisitor, file.scope);
	  if (!exportPath) throw new Error("Helpers must default-export something.");
	  exportBindingAssignments.reverse();
	  return {
	    globals: Array.from(globals),
	    localBindingNames: Array.from(localBindingNames),
	    dependencies: dependencies,
	    exportBindingAssignments: exportBindingAssignments,
	    exportPath: exportPath,
	    exportName: exportName,
	    importBindingsReferences: importBindingsReferences,
	    importPaths: importPaths
	  };
	}

	function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
	  if (localBindings && !id) {
	    throw new Error("Unexpected local bindings for module-based helpers.");
	  }

	  if (!id) return;
	  var localBindingNames = metadata.localBindingNames,
	      dependencies = metadata.dependencies,
	      exportBindingAssignments = metadata.exportBindingAssignments,
	      exportPath = metadata.exportPath,
	      exportName = metadata.exportName,
	      importBindingsReferences = metadata.importBindingsReferences,
	      importPaths = metadata.importPaths;
	  var dependenciesRefs = {};
	  dependencies.forEach(function (name, id) {
	    dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
	  });
	  var toRename = {};
	  var bindings = new Set(localBindings || []);
	  localBindingNames.forEach(function (name) {
	    var newName = name;

	    while (bindings.has(newName)) {
	      newName = "_" + newName;
	    }

	    if (newName !== name) toRename[name] = newName;
	  });

	  if (id.type === "Identifier" && exportName !== id.name) {
	    toRename[exportName] = id.name;
	  }

	  var visitor = {
	    Program: function Program(path) {
	      var exp = path.get(exportPath);
	      var imps = importPaths.map(function (p) {
	        return path.get(p);
	      });
	      var impsBindingRefs = importBindingsReferences.map(function (p) {
	        return path.get(p);
	      });
	      var decl = exp.get("declaration");

	      if (id.type === "Identifier") {
	        if (decl.isFunctionDeclaration()) {
	          exp.replaceWith(decl);
	        } else {
	          exp.replaceWith(variableDeclaration$4("var", [variableDeclarator$4(id, decl.node)]));
	        }
	      } else if (id.type === "MemberExpression") {
	        if (decl.isFunctionDeclaration()) {
	          exportBindingAssignments.forEach(function (assignPath) {
	            var assign = path.get(assignPath);
	            assign.replaceWith(assignmentExpression$7("=", id, assign.node));
	          });
	          exp.replaceWith(decl);
	          path.pushContainer("body", expressionStatement$4(assignmentExpression$7("=", id, identifier$a(exportName))));
	        } else {
	          exp.replaceWith(expressionStatement$4(assignmentExpression$7("=", id, decl.node)));
	        }
	      } else {
	        throw new Error("Unexpected helper format.");
	      }

	      Object.keys(toRename).forEach(function (name) {
	        path.scope.rename(name, toRename[name]);
	      });

	      for (var _iterator = _createForOfIteratorHelperLoose(imps), _step; !(_step = _iterator()).done;) {
	        var _path = _step.value;

	        _path.remove();
	      }

	      for (var _iterator2 = _createForOfIteratorHelperLoose(impsBindingRefs), _step2; !(_step2 = _iterator2()).done;) {
	        var _path2 = _step2.value;
	        var node = cloneNode$a(dependenciesRefs[_path2.node.name]);

	        _path2.replaceWith(node);
	      }

	      path.stop();
	    }
	  };
	  traverse(file.ast, visitor, file.scope);
	}

	var helperData = Object.create(null);

	function loadHelper(name) {
	  if (!helperData[name]) {
	    var helper = helpers$1[name];

	    if (!helper) {
	      throw Object.assign(new ReferenceError("Unknown helper " + name), {
	        code: "BABEL_HELPER_UNKNOWN",
	        helper: name
	      });
	    }

	    var fn = function fn() {
	      var file = {
	        ast: t_file(helper.ast())
	      };

	      if (fileClass) {
	        return new fileClass({
	          filename: "babel-helper://" + name
	        }, file);
	      }

	      return file;
	    };

	    var metadata = getHelperMetadata(fn());
	    helperData[name] = {
	      build: function build(getDependency, id, localBindings) {
	        var file = fn();
	        permuteHelperAST(file, metadata, id, localBindings, getDependency);
	        return {
	          nodes: file.ast.program.body,
	          globals: metadata.globals
	        };
	      },
	      minVersion: function minVersion() {
	        return helper.minVersion;
	      },
	      dependencies: metadata.dependencies
	    };
	  }

	  return helperData[name];
	}

	function get$1(name, getDependency, id, localBindings) {
	  return loadHelper(name).build(getDependency, id, localBindings);
	}
	function minVersion$1(name) {
	  return loadHelper(name).minVersion();
	}
	function getDependencies(name) {
	  return Array.from(loadHelper(name).dependencies.values());
	}
	function ensure(name, newFileClass) {
	  if (!fileClass) {
	    fileClass = newFileClass;
	  }

	  loadHelper(name);
	}
	var list = Object.keys(helpers$1).map(function (name) {
	  return name.replace(/^_/, "");
	});

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
	  if (val === null || val === undefined) {
	    throw new TypeError('Object.assign cannot be called with null or undefined');
	  }

	  return Object(val);
	}

	function shouldUseNative() {
	  try {
	    if (!Object.assign) {
	      return false;
	    }

	    var test1 = new String('abc');
	    test1[5] = 'de';

	    if (Object.getOwnPropertyNames(test1)[0] === '5') {
	      return false;
	    }

	    var test2 = {};

	    for (var i = 0; i < 10; i++) {
	      test2['_' + String.fromCharCode(i)] = i;
	    }

	    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
	      return test2[n];
	    });

	    if (order2.join('') !== '0123456789') {
	      return false;
	    }

	    var test3 = {};
	    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
	      test3[letter] = letter;
	    });

	    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    return false;
	  }
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	  var from;
	  var to = toObject(target);
	  var symbols;

	  for (var s = 1; s < arguments.length; s++) {
	    from = Object(arguments[s]);

	    for (var key in from) {
	      if (hasOwnProperty$1.call(from, key)) {
	        to[key] = from[key];
	      }
	    }

	    if (getOwnPropertySymbols) {
	      symbols = getOwnPropertySymbols(from);

	      for (var i = 0; i < symbols.length; i++) {
	        if (propIsEnumerable.call(from, symbols[i])) {
	          to[symbols[i]] = from[symbols[i]];
	        }
	      }
	    }
	  }

	  return to;
	};

	var isBufferBrowser = function isBuffer(arg) {
	  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
	};

	var inherits_browser = createCommonjsModule(function (module) {
	  if (typeof Object.create === 'function') {
	    module.exports = function inherits(ctor, superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    };
	  } else {
	    module.exports = function inherits(ctor, superCtor) {
	      ctor.super_ = superCtor;

	      var TempCtor = function TempCtor() {};

	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    };
	  }
	}, "/$$rollup_base$$/node_modules/util/node_modules/inherits");

	var util$4 = createCommonjsModule(function (module, exports) {
	  var formatRegExp = /%[sdj%]/g;

	  exports.format = function (f) {
	    if (!isString(f)) {
	      var objects = [];

	      for (var i = 0; i < arguments.length; i++) {
	        objects.push(inspect(arguments[i]));
	      }

	      return objects.join(' ');
	    }

	    var i = 1;
	    var args = arguments;
	    var len = args.length;
	    var str = String(f).replace(formatRegExp, function (x) {
	      if (x === '%%') return '%';
	      if (i >= len) return x;

	      switch (x) {
	        case '%s':
	          return String(args[i++]);

	        case '%d':
	          return Number(args[i++]);

	        case '%j':
	          try {
	            return JSON.stringify(args[i++]);
	          } catch (_) {
	            return '[Circular]';
	          }

	        default:
	          return x;
	      }
	    });

	    for (var x = args[i]; i < len; x = args[++i]) {
	      if (isNull(x) || !isObject(x)) {
	        str += ' ' + x;
	      } else {
	        str += ' ' + inspect(x);
	      }
	    }

	    return str;
	  };

	  exports.deprecate = function (fn, msg) {
	    if (isUndefined(commonjsGlobal.process)) {
	      return function () {
	        return exports.deprecate(fn, msg).apply(this, arguments);
	      };
	    }

	    if (browser$4.noDeprecation === true) {
	      return fn;
	    }

	    var warned = false;

	    function deprecated() {
	      if (!warned) {
	        if (browser$4.throwDeprecation) {
	          throw new Error(msg);
	        } else if (browser$4.traceDeprecation) {
	          console.trace(msg);
	        } else {
	          console.error(msg);
	        }

	        warned = true;
	      }

	      return fn.apply(this, arguments);
	    }

	    return deprecated;
	  };

	  var debugs = {};
	  var debugEnviron;

	  exports.debuglog = function (set) {
	    if (isUndefined(debugEnviron)) debugEnviron = browser$4.env.NODE_DEBUG || '';
	    set = set.toUpperCase();

	    if (!debugs[set]) {
	      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	        var pid = browser$4.pid;

	        debugs[set] = function () {
	          var msg = exports.format.apply(exports, arguments);
	          console.error('%s %d: %s', set, pid, msg);
	        };
	      } else {
	        debugs[set] = function () {};
	      }
	    }

	    return debugs[set];
	  };

	  function inspect(obj, opts) {
	    var ctx = {
	      seen: [],
	      stylize: stylizeNoColor
	    };
	    if (arguments.length >= 3) ctx.depth = arguments[2];
	    if (arguments.length >= 4) ctx.colors = arguments[3];

	    if (isBoolean(opts)) {
	      ctx.showHidden = opts;
	    } else if (opts) {
	      exports._extend(ctx, opts);
	    }

	    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	    if (isUndefined(ctx.depth)) ctx.depth = 2;
	    if (isUndefined(ctx.colors)) ctx.colors = false;
	    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	    if (ctx.colors) ctx.stylize = stylizeWithColor;
	    return formatValue(ctx, obj, ctx.depth);
	  }

	  exports.inspect = inspect;
	  inspect.colors = {
	    'bold': [1, 22],
	    'italic': [3, 23],
	    'underline': [4, 24],
	    'inverse': [7, 27],
	    'white': [37, 39],
	    'grey': [90, 39],
	    'black': [30, 39],
	    'blue': [34, 39],
	    'cyan': [36, 39],
	    'green': [32, 39],
	    'magenta': [35, 39],
	    'red': [31, 39],
	    'yellow': [33, 39]
	  };
	  inspect.styles = {
	    'special': 'cyan',
	    'number': 'yellow',
	    'boolean': 'yellow',
	    'undefined': 'grey',
	    'null': 'bold',
	    'string': 'green',
	    'date': 'magenta',
	    'regexp': 'red'
	  };

	  function stylizeWithColor(str, styleType) {
	    var style = inspect.styles[styleType];

	    if (style) {
	      return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
	    } else {
	      return str;
	    }
	  }

	  function stylizeNoColor(str, styleType) {
	    return str;
	  }

	  function arrayToHash(array) {
	    var hash = {};
	    array.forEach(function (val, idx) {
	      hash[val] = true;
	    });
	    return hash;
	  }

	  function formatValue(ctx, value, recurseTimes) {
	    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
	      var ret = value.inspect(recurseTimes, ctx);

	      if (!isString(ret)) {
	        ret = formatValue(ctx, ret, recurseTimes);
	      }

	      return ret;
	    }

	    var primitive = formatPrimitive(ctx, value);

	    if (primitive) {
	      return primitive;
	    }

	    var keys = Object.keys(value);
	    var visibleKeys = arrayToHash(keys);

	    if (ctx.showHidden) {
	      keys = Object.getOwnPropertyNames(value);
	    }

	    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	      return formatError(value);
	    }

	    if (keys.length === 0) {
	      if (isFunction(value)) {
	        var name = value.name ? ': ' + value.name : '';
	        return ctx.stylize('[Function' + name + ']', 'special');
	      }

	      if (isRegExp(value)) {
	        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	      }

	      if (isDate(value)) {
	        return ctx.stylize(Date.prototype.toString.call(value), 'date');
	      }

	      if (isError(value)) {
	        return formatError(value);
	      }
	    }

	    var base = '',
	        array = false,
	        braces = ['{', '}'];

	    if (isArray(value)) {
	      array = true;
	      braces = ['[', ']'];
	    }

	    if (isFunction(value)) {
	      var n = value.name ? ': ' + value.name : '';
	      base = ' [Function' + n + ']';
	    }

	    if (isRegExp(value)) {
	      base = ' ' + RegExp.prototype.toString.call(value);
	    }

	    if (isDate(value)) {
	      base = ' ' + Date.prototype.toUTCString.call(value);
	    }

	    if (isError(value)) {
	      base = ' ' + formatError(value);
	    }

	    if (keys.length === 0 && (!array || value.length == 0)) {
	      return braces[0] + base + braces[1];
	    }

	    if (recurseTimes < 0) {
	      if (isRegExp(value)) {
	        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	      } else {
	        return ctx.stylize('[Object]', 'special');
	      }
	    }

	    ctx.seen.push(value);
	    var output;

	    if (array) {
	      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	    } else {
	      output = keys.map(function (key) {
	        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	      });
	    }

	    ctx.seen.pop();
	    return reduceToSingleString(output, base, braces);
	  }

	  function formatPrimitive(ctx, value) {
	    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

	    if (isString(value)) {
	      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	      return ctx.stylize(simple, 'string');
	    }

	    if (isNumber(value)) return ctx.stylize('' + value, 'number');
	    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
	    if (isNull(value)) return ctx.stylize('null', 'null');
	  }

	  function formatError(value) {
	    return '[' + Error.prototype.toString.call(value) + ']';
	  }

	  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	    var output = [];

	    for (var i = 0, l = value.length; i < l; ++i) {
	      if (hasOwnProperty(value, String(i))) {
	        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	      } else {
	        output.push('');
	      }
	    }

	    keys.forEach(function (key) {
	      if (!key.match(/^\d+$/)) {
	        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	      }
	    });
	    return output;
	  }

	  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	    var name, str, desc;
	    desc = Object.getOwnPropertyDescriptor(value, key) || {
	      value: value[key]
	    };

	    if (desc.get) {
	      if (desc.set) {
	        str = ctx.stylize('[Getter/Setter]', 'special');
	      } else {
	        str = ctx.stylize('[Getter]', 'special');
	      }
	    } else {
	      if (desc.set) {
	        str = ctx.stylize('[Setter]', 'special');
	      }
	    }

	    if (!hasOwnProperty(visibleKeys, key)) {
	      name = '[' + key + ']';
	    }

	    if (!str) {
	      if (ctx.seen.indexOf(desc.value) < 0) {
	        if (isNull(recurseTimes)) {
	          str = formatValue(ctx, desc.value, null);
	        } else {
	          str = formatValue(ctx, desc.value, recurseTimes - 1);
	        }

	        if (str.indexOf('\n') > -1) {
	          if (array) {
	            str = str.split('\n').map(function (line) {
	              return '  ' + line;
	            }).join('\n').substr(2);
	          } else {
	            str = '\n' + str.split('\n').map(function (line) {
	              return '   ' + line;
	            }).join('\n');
	          }
	        }
	      } else {
	        str = ctx.stylize('[Circular]', 'special');
	      }
	    }

	    if (isUndefined(name)) {
	      if (array && key.match(/^\d+$/)) {
	        return str;
	      }

	      name = JSON.stringify('' + key);

	      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	        name = name.substr(1, name.length - 2);
	        name = ctx.stylize(name, 'name');
	      } else {
	        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
	        name = ctx.stylize(name, 'string');
	      }
	    }

	    return name + ': ' + str;
	  }

	  function reduceToSingleString(output, base, braces) {
	    var length = output.reduce(function (prev, cur) {
	      if (cur.indexOf('\n') >= 0) ;
	      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	    }, 0);

	    if (length > 60) {
	      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
	    }

	    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	  }

	  function isArray(ar) {
	    return Array.isArray(ar);
	  }

	  exports.isArray = isArray;

	  function isBoolean(arg) {
	    return typeof arg === 'boolean';
	  }

	  exports.isBoolean = isBoolean;

	  function isNull(arg) {
	    return arg === null;
	  }

	  exports.isNull = isNull;

	  function isNullOrUndefined(arg) {
	    return arg == null;
	  }

	  exports.isNullOrUndefined = isNullOrUndefined;

	  function isNumber(arg) {
	    return typeof arg === 'number';
	  }

	  exports.isNumber = isNumber;

	  function isString(arg) {
	    return typeof arg === 'string';
	  }

	  exports.isString = isString;

	  function isSymbol(arg) {
	    return typeof arg === 'symbol';
	  }

	  exports.isSymbol = isSymbol;

	  function isUndefined(arg) {
	    return arg === void 0;
	  }

	  exports.isUndefined = isUndefined;

	  function isRegExp(re) {
	    return isObject(re) && objectToString(re) === '[object RegExp]';
	  }

	  exports.isRegExp = isRegExp;

	  function isObject(arg) {
	    return typeof arg === 'object' && arg !== null;
	  }

	  exports.isObject = isObject;

	  function isDate(d) {
	    return isObject(d) && objectToString(d) === '[object Date]';
	  }

	  exports.isDate = isDate;

	  function isError(e) {
	    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
	  }

	  exports.isError = isError;

	  function isFunction(arg) {
	    return typeof arg === 'function';
	  }

	  exports.isFunction = isFunction;

	  function isPrimitive(arg) {
	    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
	  }

	  exports.isPrimitive = isPrimitive;
	  exports.isBuffer = isBufferBrowser;

	  function objectToString(o) {
	    return Object.prototype.toString.call(o);
	  }

	  function pad(n) {
	    return n < 10 ? '0' + n.toString(10) : n.toString(10);
	  }

	  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

	  function timestamp() {
	    var d = new Date();
	    var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
	    return [d.getDate(), months[d.getMonth()], time].join(' ');
	  }

	  exports.log = function () {
	    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	  };

	  exports.inherits = inherits_browser;

	  exports._extend = function (origin, add) {
	    if (!add || !isObject(add)) return origin;
	    var keys = Object.keys(add);
	    var i = keys.length;

	    while (i--) {
	      origin[keys[i]] = add[keys[i]];
	    }

	    return origin;
	  };

	  function hasOwnProperty(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	  }
	}, "/$$rollup_base$$/node_modules/util");

	var assert_1 = createCommonjsModule(function (module) {
	  /*!
	   * The buffer module from node.js, for the browser.
	   *
	   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	   * @license  MIT
	   */

	  function compare(a, b) {
	    if (a === b) {
	      return 0;
	    }

	    var x = a.length;
	    var y = b.length;

	    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	      if (a[i] !== b[i]) {
	        x = a[i];
	        y = b[i];
	        break;
	      }
	    }

	    if (x < y) {
	      return -1;
	    }

	    if (y < x) {
	      return 1;
	    }

	    return 0;
	  }

	  function isBuffer(b) {
	    if (commonjsGlobal.Buffer && typeof commonjsGlobal.Buffer.isBuffer === 'function') {
	      return commonjsGlobal.Buffer.isBuffer(b);
	    }

	    return !!(b != null && b._isBuffer);
	  }

	  var hasOwn = Object.prototype.hasOwnProperty;
	  var pSlice = Array.prototype.slice;

	  var functionsHaveNames = function () {
	    return function foo() {}.name === 'foo';
	  }();

	  function pToString(obj) {
	    return Object.prototype.toString.call(obj);
	  }

	  function isView(arrbuf) {
	    if (isBuffer(arrbuf)) {
	      return false;
	    }

	    if (typeof commonjsGlobal.ArrayBuffer !== 'function') {
	      return false;
	    }

	    if (typeof ArrayBuffer.isView === 'function') {
	      return ArrayBuffer.isView(arrbuf);
	    }

	    if (!arrbuf) {
	      return false;
	    }

	    if (arrbuf instanceof DataView) {
	      return true;
	    }

	    if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	      return true;
	    }

	    return false;
	  }

	  var assert = module.exports = ok;
	  var regex = /\s*function\s+([^\(\s]*)\s*/;

	  function getName(func) {
	    if (!util$4.isFunction(func)) {
	      return;
	    }

	    if (functionsHaveNames) {
	      return func.name;
	    }

	    var str = func.toString();
	    var match = str.match(regex);
	    return match && match[1];
	  }

	  assert.AssertionError = function AssertionError(options) {
	    this.name = 'AssertionError';
	    this.actual = options.actual;
	    this.expected = options.expected;
	    this.operator = options.operator;

	    if (options.message) {
	      this.message = options.message;
	      this.generatedMessage = false;
	    } else {
	      this.message = getMessage(this);
	      this.generatedMessage = true;
	    }

	    var stackStartFunction = options.stackStartFunction || fail;

	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, stackStartFunction);
	    } else {
	      var err = new Error();

	      if (err.stack) {
	        var out = err.stack;
	        var fn_name = getName(stackStartFunction);
	        var idx = out.indexOf('\n' + fn_name);

	        if (idx >= 0) {
	          var next_line = out.indexOf('\n', idx + 1);
	          out = out.substring(next_line + 1);
	        }

	        this.stack = out;
	      }
	    }
	  };

	  util$4.inherits(assert.AssertionError, Error);

	  function truncate(s, n) {
	    if (typeof s === 'string') {
	      return s.length < n ? s : s.slice(0, n);
	    } else {
	      return s;
	    }
	  }

	  function inspect(something) {
	    if (functionsHaveNames || !util$4.isFunction(something)) {
	      return util$4.inspect(something);
	    }

	    var rawname = getName(something);
	    var name = rawname ? ': ' + rawname : '';
	    return '[Function' + name + ']';
	  }

	  function getMessage(self) {
	    return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
	  }

	  function fail(actual, expected, message, operator, stackStartFunction) {
	    throw new assert.AssertionError({
	      message: message,
	      actual: actual,
	      expected: expected,
	      operator: operator,
	      stackStartFunction: stackStartFunction
	    });
	  }

	  assert.fail = fail;

	  function ok(value, message) {
	    if (!value) fail(value, true, message, '==', assert.ok);
	  }

	  assert.ok = ok;

	  assert.equal = function equal(actual, expected, message) {
	    if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	  };

	  assert.notEqual = function notEqual(actual, expected, message) {
	    if (actual == expected) {
	      fail(actual, expected, message, '!=', assert.notEqual);
	    }
	  };

	  assert.deepEqual = function deepEqual(actual, expected, message) {
	    if (!_deepEqual(actual, expected, false)) {
	      fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	    }
	  };

	  assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	    if (!_deepEqual(actual, expected, true)) {
	      fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	    }
	  };

	  function _deepEqual(actual, expected, strict, memos) {
	    if (actual === expected) {
	      return true;
	    } else if (isBuffer(actual) && isBuffer(expected)) {
	      return compare(actual, expected) === 0;
	    } else if (util$4.isDate(actual) && util$4.isDate(expected)) {
	      return actual.getTime() === expected.getTime();
	    } else if (util$4.isRegExp(actual) && util$4.isRegExp(expected)) {
	      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
	    } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
	      return strict ? actual === expected : actual == expected;
	    } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
	      return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
	    } else if (isBuffer(actual) !== isBuffer(expected)) {
	      return false;
	    } else {
	      memos = memos || {
	        actual: [],
	        expected: []
	      };
	      var actualIndex = memos.actual.indexOf(actual);

	      if (actualIndex !== -1) {
	        if (actualIndex === memos.expected.indexOf(expected)) {
	          return true;
	        }
	      }

	      memos.actual.push(actual);
	      memos.expected.push(expected);
	      return objEquiv(actual, expected, strict, memos);
	    }
	  }

	  function isArguments(object) {
	    return Object.prototype.toString.call(object) == '[object Arguments]';
	  }

	  function objEquiv(a, b, strict, actualVisitedObjects) {
	    if (a === null || a === undefined || b === null || b === undefined) return false;
	    if (util$4.isPrimitive(a) || util$4.isPrimitive(b)) return a === b;
	    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
	    var aIsArgs = isArguments(a);
	    var bIsArgs = isArguments(b);
	    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

	    if (aIsArgs) {
	      a = pSlice.call(a);
	      b = pSlice.call(b);
	      return _deepEqual(a, b, strict);
	    }

	    var ka = objectKeys(a);
	    var kb = objectKeys(b);
	    var key, i;
	    if (ka.length !== kb.length) return false;
	    ka.sort();
	    kb.sort();

	    for (i = ka.length - 1; i >= 0; i--) {
	      if (ka[i] !== kb[i]) return false;
	    }

	    for (i = ka.length - 1; i >= 0; i--) {
	      key = ka[i];
	      if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
	    }

	    return true;
	  }

	  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	    if (_deepEqual(actual, expected, false)) {
	      fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	    }
	  };

	  assert.notDeepStrictEqual = notDeepStrictEqual;

	  function notDeepStrictEqual(actual, expected, message) {
	    if (_deepEqual(actual, expected, true)) {
	      fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	    }
	  }

	  assert.strictEqual = function strictEqual(actual, expected, message) {
	    if (actual !== expected) {
	      fail(actual, expected, message, '===', assert.strictEqual);
	    }
	  };

	  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	    if (actual === expected) {
	      fail(actual, expected, message, '!==', assert.notStrictEqual);
	    }
	  };

	  function expectedException(actual, expected) {
	    if (!actual || !expected) {
	      return false;
	    }

	    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	      return expected.test(actual);
	    }

	    try {
	      if (actual instanceof expected) {
	        return true;
	      }
	    } catch (e) {}

	    if (Error.isPrototypeOf(expected)) {
	      return false;
	    }

	    return expected.call({}, actual) === true;
	  }

	  function _tryBlock(block) {
	    var error;

	    try {
	      block();
	    } catch (e) {
	      error = e;
	    }

	    return error;
	  }

	  function _throws(shouldThrow, block, expected, message) {
	    var actual;

	    if (typeof block !== 'function') {
	      throw new TypeError('"block" argument must be a function');
	    }

	    if (typeof expected === 'string') {
	      message = expected;
	      expected = null;
	    }

	    actual = _tryBlock(block);
	    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

	    if (shouldThrow && !actual) {
	      fail(actual, expected, 'Missing expected exception' + message);
	    }

	    var userProvidedMessage = typeof message === 'string';
	    var isUnwantedException = !shouldThrow && util$4.isError(actual);
	    var isUnexpectedException = !shouldThrow && actual && !expected;

	    if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
	      fail(actual, expected, 'Got unwanted exception' + message);
	    }

	    if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
	      throw actual;
	    }
	  }

	  assert["throws"] = function (block, error, message) {
	    _throws(true, block, error, message);
	  };

	  assert.doesNotThrow = function (block, error, message) {
	    _throws(false, block, error, message);
	  };

	  assert.ifError = function (err) {
	    if (err) throw err;
	  };

	  function strict(value, message) {
	    if (!value) fail(value, true, message, '==', strict);
	  }

	  assert.strict = objectAssign(strict, assert, {
	    equal: assert.strictEqual,
	    deepEqual: assert.deepStrictEqual,
	    notEqual: assert.notStrictEqual,
	    notDeepEqual: assert.notDeepStrictEqual
	  });
	  assert.strict.strict = assert.strict;

	  var objectKeys = Object.keys || function (obj) {
	    var keys = [];

	    for (var key in obj) {
	      if (hasOwn.call(obj, key)) keys.push(key);
	    }

	    return keys;
	  };
	}, "/$$rollup_base$$/node_modules/assert");

	var callExpression$9 = callExpression$e,
	    cloneNode$9 = cloneNode$i,
	    expressionStatement$3 = expressionStatement$a,
	    identifier$9 = identifier$j,
	    importDeclaration = importDeclaration$1,
	    importDefaultSpecifier = importDefaultSpecifier$1,
	    importNamespaceSpecifier = importNamespaceSpecifier$1,
	    importSpecifier = importSpecifier$1,
	    memberExpression$8 = memberExpression$b,
	    stringLiteral$5 = stringLiteral$8,
	    variableDeclaration$3 = variableDeclaration$8,
	    variableDeclarator$3 = variableDeclarator$8;

	var ImportBuilder = function () {
	  function ImportBuilder(importedSource, scope, hub) {
	    this._statements = [];
	    this._resultName = null;
	    this._scope = null;
	    this._hub = null;
	    this._importedSource = void 0;
	    this._scope = scope;
	    this._hub = hub;
	    this._importedSource = importedSource;
	  }

	  var _proto = ImportBuilder.prototype;

	  _proto.done = function done() {
	    return {
	      statements: this._statements,
	      resultName: this._resultName
	    };
	  };

	  _proto["import"] = function _import() {
	    this._statements.push(importDeclaration([], stringLiteral$5(this._importedSource)));

	    return this;
	  };

	  _proto.require = function require() {
	    this._statements.push(expressionStatement$3(callExpression$9(identifier$9("require"), [stringLiteral$5(this._importedSource)])));

	    return this;
	  };

	  _proto.namespace = function namespace(name) {
	    if (name === void 0) {
	      name = "namespace";
	    }

	    var local = this._scope.generateUidIdentifier(name);

	    var statement = this._statements[this._statements.length - 1];
	    assert_1(statement.type === "ImportDeclaration");
	    assert_1(statement.specifiers.length === 0);
	    statement.specifiers = [importNamespaceSpecifier(local)];
	    this._resultName = cloneNode$9(local);
	    return this;
	  };

	  _proto["default"] = function _default(name) {
	    name = this._scope.generateUidIdentifier(name);
	    var statement = this._statements[this._statements.length - 1];
	    assert_1(statement.type === "ImportDeclaration");
	    assert_1(statement.specifiers.length === 0);
	    statement.specifiers = [importDefaultSpecifier(name)];
	    this._resultName = cloneNode$9(name);
	    return this;
	  };

	  _proto.named = function named(name, importName) {
	    if (importName === "default") return this["default"](name);
	    name = this._scope.generateUidIdentifier(name);
	    var statement = this._statements[this._statements.length - 1];
	    assert_1(statement.type === "ImportDeclaration");
	    assert_1(statement.specifiers.length === 0);
	    statement.specifiers = [importSpecifier(name, identifier$9(importName))];
	    this._resultName = cloneNode$9(name);
	    return this;
	  };

	  _proto["var"] = function _var(name) {
	    name = this._scope.generateUidIdentifier(name);
	    var statement = this._statements[this._statements.length - 1];

	    if (statement.type !== "ExpressionStatement") {
	      assert_1(this._resultName);
	      statement = expressionStatement$3(this._resultName);

	      this._statements.push(statement);
	    }

	    this._statements[this._statements.length - 1] = variableDeclaration$3("var", [variableDeclarator$3(name, statement.expression)]);
	    this._resultName = cloneNode$9(name);
	    return this;
	  };

	  _proto.defaultInterop = function defaultInterop() {
	    return this._interop(this._hub.addHelper("interopRequireDefault"));
	  };

	  _proto.wildcardInterop = function wildcardInterop() {
	    return this._interop(this._hub.addHelper("interopRequireWildcard"));
	  };

	  _proto._interop = function _interop(callee) {
	    var statement = this._statements[this._statements.length - 1];

	    if (statement.type === "ExpressionStatement") {
	      statement.expression = callExpression$9(callee, [statement.expression]);
	    } else if (statement.type === "VariableDeclaration") {
	      assert_1(statement.declarations.length === 1);
	      statement.declarations[0].init = callExpression$9(callee, [statement.declarations[0].init]);
	    } else {
	      assert_1.fail("Unexpected type.");
	    }

	    return this;
	  };

	  _proto.prop = function prop(name) {
	    var statement = this._statements[this._statements.length - 1];

	    if (statement.type === "ExpressionStatement") {
	      statement.expression = memberExpression$8(statement.expression, identifier$9(name));
	    } else if (statement.type === "VariableDeclaration") {
	      assert_1(statement.declarations.length === 1);
	      statement.declarations[0].init = memberExpression$8(statement.declarations[0].init, identifier$9(name));
	    } else {
	      assert_1.fail("Unexpected type:" + statement.type);
	    }

	    return this;
	  };

	  _proto.read = function read(name) {
	    this._resultName = memberExpression$8(this._resultName, identifier$9(name));
	  };

	  return ImportBuilder;
	}();

	function isModule(path) {
	  var sourceType = path.node.sourceType;

	  if (sourceType !== "module" && sourceType !== "script") {
	    throw path.buildCodeFrameError("Unknown sourceType \"" + sourceType + "\", cannot transform.");
	  }

	  return path.node.sourceType === "module";
	}

	var numericLiteral$4 = numericLiteral$8,
	    sequenceExpression$5 = sequenceExpression$7;

	var ImportInjector = function () {
	  function ImportInjector(path, importedSource, opts) {
	    this._defaultOpts = {
	      importedSource: null,
	      importedType: "commonjs",
	      importedInterop: "babel",
	      importingInterop: "babel",
	      ensureLiveReference: false,
	      ensureNoContext: false,
	      importPosition: "before"
	    };
	    var programPath = path.find(function (p) {
	      return p.isProgram();
	    });
	    this._programPath = programPath;
	    this._programScope = programPath.scope;
	    this._hub = programPath.hub;
	    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
	  }

	  var _proto = ImportInjector.prototype;

	  _proto.addDefault = function addDefault(importedSourceIn, opts) {
	    return this.addNamed("default", importedSourceIn, opts);
	  };

	  _proto.addNamed = function addNamed(importName, importedSourceIn, opts) {
	    assert_1(typeof importName === "string");
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
	  };

	  _proto.addNamespace = function addNamespace(importedSourceIn, opts) {
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
	  };

	  _proto.addSideEffect = function addSideEffect(importedSourceIn, opts) {
	    return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
	  };

	  _proto._applyDefaults = function _applyDefaults(importedSource, opts, isInit) {
	    if (isInit === void 0) {
	      isInit = false;
	    }

	    var optsList = [];

	    if (typeof importedSource === "string") {
	      optsList.push({
	        importedSource: importedSource
	      });
	      optsList.push(opts);
	    } else {
	      assert_1(!opts, "Unexpected secondary arguments.");
	      optsList.push(importedSource);
	    }

	    var newOpts = Object.assign({}, this._defaultOpts);

	    var _loop = function _loop() {
	      var opts = _optsList[_i];
	      if (!opts) return "continue";
	      Object.keys(newOpts).forEach(function (key) {
	        if (opts[key] !== undefined) newOpts[key] = opts[key];
	      });

	      if (!isInit) {
	        if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
	        if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
	      }
	    };

	    for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
	      var _ret = _loop();

	      if (_ret === "continue") continue;
	    }

	    return newOpts;
	  };

	  _proto._generateImport = function _generateImport(opts, importName) {
	    var isDefault = importName === "default";
	    var isNamed = !!importName && !isDefault;
	    var isNamespace = importName === null;
	    var importedSource = opts.importedSource,
	        importedType = opts.importedType,
	        importedInterop = opts.importedInterop,
	        importingInterop = opts.importingInterop,
	        ensureLiveReference = opts.ensureLiveReference,
	        ensureNoContext = opts.ensureNoContext,
	        nameHint = opts.nameHint,
	        importPosition = opts.importPosition,
	        blockHoist = opts.blockHoist;
	    var name = nameHint || importName;
	    var isMod = isModule(this._programPath);
	    var isModuleForNode = isMod && importingInterop === "node";
	    var isModuleForBabel = isMod && importingInterop === "babel";

	    if (importPosition === "after" && !isMod) {
	      throw new Error("\"importPosition\": \"after\" is only supported in modules");
	    }

	    var builder = new ImportBuilder(importedSource, this._programScope, this._hub);

	    if (importedType === "es6") {
	      if (!isModuleForNode && !isModuleForBabel) {
	        throw new Error("Cannot import an ES6 module from CommonJS");
	      }

	      builder["import"]();

	      if (isNamespace) {
	        builder.namespace(nameHint || importedSource);
	      } else if (isDefault || isNamed) {
	        builder.named(name, importName);
	      }
	    } else if (importedType !== "commonjs") {
	      throw new Error("Unexpected interopType \"" + importedType + "\"");
	    } else if (importedInterop === "babel") {
	      if (isModuleForNode) {
	        name = name !== "default" ? name : importedSource;
	        var es6Default = importedSource + "$es6Default";
	        builder["import"]();

	        if (isNamespace) {
	          builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
	        } else if (isDefault) {
	          if (ensureLiveReference) {
	            builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
	          } else {
	            builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
	          }
	        } else if (isNamed) {
	          builder["default"](es6Default).read(importName);
	        }
	      } else if (isModuleForBabel) {
	        builder["import"]();

	        if (isNamespace) {
	          builder.namespace(name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();

	        if (isNamespace) {
	          builder["var"](name || importedSource).wildcardInterop();
	        } else if ((isDefault || isNamed) && ensureLiveReference) {
	          if (isDefault) {
	            name = name !== "default" ? name : importedSource;
	            builder["var"](name).read(importName);
	            builder.defaultInterop();
	          } else {
	            builder["var"](importedSource).read(importName);
	          }
	        } else if (isDefault) {
	          builder["var"](name).defaultInterop().prop(importName);
	        } else if (isNamed) {
	          builder["var"](name).prop(importName);
	        }
	      }
	    } else if (importedInterop === "compiled") {
	      if (isModuleForNode) {
	        builder["import"]();

	        if (isNamespace) {
	          builder["default"](name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder["default"](importedSource).read(name);
	        }
	      } else if (isModuleForBabel) {
	        builder["import"]();

	        if (isNamespace) {
	          builder.namespace(name || importedSource);
	        } else if (isDefault || isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();

	        if (isNamespace) {
	          builder["var"](name || importedSource);
	        } else if (isDefault || isNamed) {
	          if (ensureLiveReference) {
	            builder["var"](importedSource).read(name);
	          } else {
	            builder.prop(importName)["var"](name);
	          }
	        }
	      }
	    } else if (importedInterop === "uncompiled") {
	      if (isDefault && ensureLiveReference) {
	        throw new Error("No live reference for commonjs default");
	      }

	      if (isModuleForNode) {
	        builder["import"]();

	        if (isNamespace) {
	          builder["default"](name || importedSource);
	        } else if (isDefault) {
	          builder["default"](name);
	        } else if (isNamed) {
	          builder["default"](importedSource).read(name);
	        }
	      } else if (isModuleForBabel) {
	        builder["import"]();

	        if (isNamespace) {
	          builder["default"](name || importedSource);
	        } else if (isDefault) {
	          builder["default"](name);
	        } else if (isNamed) {
	          builder.named(name, importName);
	        }
	      } else {
	        builder.require();

	        if (isNamespace) {
	          builder["var"](name || importedSource);
	        } else if (isDefault) {
	          builder["var"](name);
	        } else if (isNamed) {
	          if (ensureLiveReference) {
	            builder["var"](importedSource).read(name);
	          } else {
	            builder["var"](name).prop(importName);
	          }
	        }
	      }
	    } else {
	      throw new Error("Unknown importedInterop \"" + importedInterop + "\".");
	    }

	    var _builder$done = builder.done(),
	        statements = _builder$done.statements,
	        resultName = _builder$done.resultName;

	    this._insertStatements(statements, importPosition, blockHoist);

	    if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
	      return sequenceExpression$5([numericLiteral$4(0), resultName]);
	    }

	    return resultName;
	  };

	  _proto._insertStatements = function _insertStatements(statements, importPosition, blockHoist) {
	    if (importPosition === void 0) {
	      importPosition = "before";
	    }

	    if (blockHoist === void 0) {
	      blockHoist = 3;
	    }

	    var body = this._programPath.get("body");

	    if (importPosition === "after") {
	      for (var i = body.length - 1; i >= 0; i--) {
	        if (body[i].isImportDeclaration()) {
	          body[i].insertAfter(statements);
	          return;
	        }
	      }
	    } else {
	      statements.forEach(function (node) {
	        node._blockHoist = blockHoist;
	      });
	      var targetPath = body.find(function (p) {
	        var val = p.node._blockHoist;
	        return Number.isFinite(val) && val < 4;
	      });

	      if (targetPath) {
	        targetPath.insertBefore(statements);
	        return;
	      }
	    }

	    this._programPath.unshiftContainer("body", statements);
	  };

	  return ImportInjector;
	}();

	function addDefault(path, importedSource, opts) {
	  return new ImportInjector(path).addDefault(importedSource, opts);
	}
	function addNamed(path, name, importedSource, opts) {
	  return new ImportInjector(path).addNamed(name, importedSource, opts);
	}
	function addNamespace(path, importedSource, opts) {
	  return new ImportInjector(path).addNamespace(importedSource, opts);
	}

	var numericLiteral$3 = numericLiteral$8,
	    unaryExpression$3 = unaryExpression$7;
	function rewriteThis(programPath) {
	  traverse(programPath.node, Object.assign({}, rewriteThisVisitor, {
	    noScope: true
	  }));
	}
	var rewriteThisVisitor = traverse.visitors.merge([environmentVisitor, {
	  ThisExpression: function (_ThisExpression) {
	    function ThisExpression(_x) {
	      return _ThisExpression.apply(this, arguments);
	    }

	    ThisExpression.toString = function () {
	      return _ThisExpression.toString();
	    };

	    return ThisExpression;
	  }(function (path) {
	    path.replaceWith(unaryExpression$3("void", numericLiteral$3(0), true));
	  })
	}]);

	var LOGICAL_OPERATORS$1 = LOGICAL_OPERATORS$2,
	    assignmentExpression$6 = assignmentExpression$c,
	    binaryExpression$2 = binaryExpression$4,
	    cloneNode$8 = cloneNode$i,
	    identifier$8 = identifier$j,
	    logicalExpression$1 = logicalExpression$2,
	    numericLiteral$2 = numericLiteral$8,
	    sequenceExpression$4 = sequenceExpression$7,
	    unaryExpression$2 = unaryExpression$7;
	function simplifyAccess(path, bindingNames) {
	  path.traverse(simpleAssignmentVisitor, {
	    scope: path.scope,
	    bindingNames: bindingNames,
	    seen: new WeakSet()
	  });
	}
	var simpleAssignmentVisitor = {
	  UpdateExpression: {
	    exit: function exit(path) {
	      var scope = this.scope,
	          bindingNames = this.bindingNames;
	      var arg = path.get("argument");
	      if (!arg.isIdentifier()) return;
	      var localName = arg.node.name;
	      if (!bindingNames.has(localName)) return;

	      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
	        return;
	      }

	      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
	        var operator = path.node.operator == "++" ? "+=" : "-=";
	        path.replaceWith(assignmentExpression$6(operator, arg.node, numericLiteral$2(1)));
	      } else if (path.node.prefix) {
	        path.replaceWith(assignmentExpression$6("=", identifier$8(localName), binaryExpression$2(path.node.operator[0], unaryExpression$2("+", arg.node), numericLiteral$2(1))));
	      } else {
	        var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
	        var varName = old.name;
	        path.scope.push({
	          id: old
	        });
	        var binary = binaryExpression$2(path.node.operator[0], identifier$8(varName), numericLiteral$2(1));
	        path.replaceWith(sequenceExpression$4([assignmentExpression$6("=", identifier$8(varName), unaryExpression$2("+", arg.node)), assignmentExpression$6("=", cloneNode$8(arg.node), binary), identifier$8(varName)]));
	      }
	    }
	  },
	  AssignmentExpression: {
	    exit: function exit(path) {
	      var scope = this.scope,
	          seen = this.seen,
	          bindingNames = this.bindingNames;
	      if (path.node.operator === "=") return;
	      if (seen.has(path.node)) return;
	      seen.add(path.node);
	      var left = path.get("left");
	      if (!left.isIdentifier()) return;
	      var localName = left.node.name;
	      if (!bindingNames.has(localName)) return;

	      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
	        return;
	      }

	      var operator = path.node.operator.slice(0, -1);

	      if (LOGICAL_OPERATORS$1.includes(operator)) {
	        path.replaceWith(logicalExpression$1(operator, path.node.left, assignmentExpression$6("=", cloneNode$8(path.node.left), path.node.right)));
	      } else {
	        path.node.right = binaryExpression$2(operator, cloneNode$8(path.node.left), path.node.right);
	        path.node.operator = "=";
	      }
	    }
	  }
	};

	var _templateObject$m;
	var assignmentExpression$5 = assignmentExpression$c,
	    callExpression$8 = callExpression$e,
	    cloneNode$7 = cloneNode$i,
	    expressionStatement$2 = expressionStatement$a,
	    getOuterBindingIdentifiers = getOuterBindingIdentifiers$2,
	    identifier$7 = identifier$j,
	    isMemberExpression$2 = isMemberExpression$8,
	    isVariableDeclaration = isVariableDeclaration$3,
	    jsxIdentifier = jsxIdentifier$2,
	    jsxMemberExpression = jsxMemberExpression$1,
	    memberExpression$7 = memberExpression$b,
	    numericLiteral$1 = numericLiteral$8,
	    sequenceExpression$3 = sequenceExpression$7,
	    stringLiteral$4 = stringLiteral$8,
	    variableDeclaration$2 = variableDeclaration$8,
	    variableDeclarator$2 = variableDeclarator$8;

	function isInType$1(path) {
	  do {
	    switch (path.parent.type) {
	      case "TSTypeAnnotation":
	      case "TSTypeAliasDeclaration":
	      case "TSTypeReference":
	      case "TypeAnnotation":
	      case "TypeAlias":
	        return true;

	      case "ExportSpecifier":
	        return path.parentPath.parent.exportKind === "type";

	      default:
	        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {
	          return false;
	        }

	    }
	  } while (path = path.parentPath);
	}

	function rewriteLiveReferences(programPath, metadata) {
	  var imported = new Map();
	  var exported = new Map();

	  var requeueInParent = function requeueInParent(path) {
	    programPath.requeue(path);
	  };

	  for (var _iterator = _createForOfIteratorHelperLoose(metadata.source), _step; !(_step = _iterator()).done;) {
	    var _step$value = _slicedToArray$1(_step.value, 2),
	        source = _step$value[0],
	        data = _step$value[1];

	    for (var _iterator3 = _createForOfIteratorHelperLoose(data.imports), _step3; !(_step3 = _iterator3()).done;) {
	      var _step3$value = _slicedToArray$1(_step3.value, 2),
	          localName = _step3$value[0],
	          importName = _step3$value[1];

	      imported.set(localName, [source, importName, null]);
	    }

	    for (var _iterator4 = _createForOfIteratorHelperLoose(data.importsNamespace), _step4; !(_step4 = _iterator4()).done;) {
	      var _localName = _step4.value;
	      imported.set(_localName, [source, null, _localName]);
	    }
	  }

	  for (var _iterator2 = _createForOfIteratorHelperLoose(metadata.local), _step2; !(_step2 = _iterator2()).done;) {
	    var _exportMeta;

	    var _step2$value = _slicedToArray$1(_step2.value, 2),
	        local = _step2$value[0],
	        _data = _step2$value[1];

	    var exportMeta = exported.get(local);

	    if (!exportMeta) {
	      exportMeta = [];
	      exported.set(local, exportMeta);
	    }

	    (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));
	  }

	  var rewriteBindingInitVisitorState = {
	    metadata: metadata,
	    requeueInParent: requeueInParent,
	    scope: programPath.scope,
	    exported: exported
	  };
	  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
	  simplifyAccess(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))));
	  var rewriteReferencesVisitorState = {
	    seen: new WeakSet(),
	    metadata: metadata,
	    requeueInParent: requeueInParent,
	    scope: programPath.scope,
	    imported: imported,
	    exported: exported,
	    buildImportReference: function buildImportReference(_ref, identNode) {
	      var _ref2 = _slicedToArray$1(_ref, 3),
	          source = _ref2[0],
	          importName = _ref2[1],
	          localName = _ref2[2];

	      var meta = metadata.source.get(source);

	      if (localName) {
	        if (meta.lazy) identNode = callExpression$8(identNode, []);
	        return identNode;
	      }

	      var namespace = identifier$7(meta.name);
	      if (meta.lazy) namespace = callExpression$8(namespace, []);

	      if (importName === "default" && meta.interop === "node-default") {
	        return namespace;
	      }

	      var computed = metadata.stringSpecifiers.has(importName);
	      return memberExpression$7(namespace, computed ? stringLiteral$4(importName) : identifier$7(importName), computed);
	    }
	  };
	  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
	}
	var rewriteBindingInitVisitor = {
	  Scope: function Scope(path) {
	    path.skip();
	  },
	  ClassDeclaration: function ClassDeclaration(path) {
	    var requeueInParent = this.requeueInParent,
	        exported = this.exported,
	        metadata = this.metadata;
	    var id = path.node.id;
	    if (!id) throw new Error("Expected class to have a name");
	    var localName = id.name;
	    var exportNames = exported.get(localName) || [];

	    if (exportNames.length > 0) {
	      var statement = expressionStatement$2(buildBindingExportAssignmentExpression(metadata, exportNames, identifier$7(localName)));
	      statement._blockHoist = path.node._blockHoist;
	      requeueInParent(path.insertAfter(statement)[0]);
	    }
	  },
	  VariableDeclaration: function VariableDeclaration(path) {
	    var requeueInParent = this.requeueInParent,
	        exported = this.exported,
	        metadata = this.metadata;
	    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
	      var exportNames = exported.get(localName) || [];

	      if (exportNames.length > 0) {
	        var statement = expressionStatement$2(buildBindingExportAssignmentExpression(metadata, exportNames, identifier$7(localName)));
	        statement._blockHoist = path.node._blockHoist;
	        requeueInParent(path.insertAfter(statement)[0]);
	      }
	    });
	  }
	};

	var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
	  return (exportNames || []).reduce(function (expr, exportName) {
	    var stringSpecifiers = metadata.stringSpecifiers;
	    var computed = stringSpecifiers.has(exportName);
	    return assignmentExpression$5("=", memberExpression$7(identifier$7(metadata.exportName), computed ? stringLiteral$4(exportName) : identifier$7(exportName), computed), expr);
	  }, localExpr);
	};

	var buildImportThrow = function buildImportThrow(localName) {
	  return template$2.expression.ast(_templateObject$m || (_templateObject$m = _taggedTemplateLiteralLoose(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "])), localName);
	};

	var rewriteReferencesVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(path) {
	    var seen = this.seen,
	        buildImportReference = this.buildImportReference,
	        scope = this.scope,
	        imported = this.imported,
	        requeueInParent = this.requeueInParent;
	    if (seen.has(path.node)) return;
	    seen.add(path.node);
	    var localName = path.node.name;
	    var importData = imported.get(localName);

	    if (importData) {
	      if (isInType$1(path)) {
	        throw path.buildCodeFrameError("Cannot transform the imported binding \"" + localName + "\" since it's also used in a type annotation. " + "Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.");
	      }

	      var localBinding = path.scope.getBinding(localName);
	      var rootBinding = scope.getBinding(localName);
	      if (rootBinding !== localBinding) return;
	      var ref = buildImportReference(importData, path.node);
	      ref.loc = path.node.loc;

	      if ((path.parentPath.isCallExpression({
	        callee: path.node
	      }) || path.parentPath.isOptionalCallExpression({
	        callee: path.node
	      }) || path.parentPath.isTaggedTemplateExpression({
	        tag: path.node
	      })) && isMemberExpression$2(ref)) {
	        path.replaceWith(sequenceExpression$3([numericLiteral$1(0), ref]));
	      } else if (path.isJSXIdentifier() && isMemberExpression$2(ref)) {
	        var object = ref.object,
	            property = ref.property;
	        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
	      } else {
	        path.replaceWith(ref);
	      }

	      requeueInParent(path);
	      path.skip();
	    }
	  },
	  AssignmentExpression: {
	    exit: function exit(path) {
	      var _this = this;

	      var scope = this.scope,
	          seen = this.seen,
	          imported = this.imported,
	          exported = this.exported,
	          requeueInParent = this.requeueInParent,
	          buildImportReference = this.buildImportReference;
	      if (seen.has(path.node)) return;
	      seen.add(path.node);
	      var left = path.get("left");
	      if (left.isMemberExpression()) return;

	      if (left.isIdentifier()) {
	        var localName = left.node.name;

	        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
	          return;
	        }

	        var exportedNames = exported.get(localName);
	        var importData = imported.get(localName);

	        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
	          assert_1(path.node.operator === "=", "Path was not simplified");
	          var assignment = path.node;

	          if (importData) {
	            assignment.left = buildImportReference(importData, assignment.left);
	            assignment.right = sequenceExpression$3([assignment.right, buildImportThrow(localName)]);
	          }

	          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
	          requeueInParent(path);
	        }
	      } else {
	        var ids = left.getOuterBindingIdentifiers();
	        var programScopeIds = Object.keys(ids).filter(function (localName) {
	          return scope.getBinding(localName) === path.scope.getBinding(localName);
	        });
	        var id = programScopeIds.find(function (localName) {
	          return imported.has(localName);
	        });

	        if (id) {
	          path.node.right = sequenceExpression$3([path.node.right, buildImportThrow(id)]);
	        }

	        var items = [];
	        programScopeIds.forEach(function (localName) {
	          var exportedNames = exported.get(localName) || [];

	          if (exportedNames.length > 0) {
	            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier$7(localName)));
	          }
	        });

	        if (items.length > 0) {
	          var node = sequenceExpression$3(items);

	          if (path.parentPath.isExpressionStatement()) {
	            node = expressionStatement$2(node);
	            node._blockHoist = path.parentPath.node._blockHoist;
	          }

	          var statement = path.insertAfter(node)[0];
	          requeueInParent(statement);
	        }
	      }
	    }
	  },
	  "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
	    var scope = path.scope,
	        node = path.node;
	    var left = node.left;
	    var exported = this.exported,
	        imported = this.imported,
	        programScope = this.scope;

	    if (!isVariableDeclaration(left)) {
	      var didTransformExport = false,
	          importConstViolationName;
	      var loopBodyScope = path.get("body").scope;

	      for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {
	        var name = _Object$keys[_i];

	        if (programScope.getBinding(name) === scope.getBinding(name)) {
	          if (exported.has(name)) {
	            didTransformExport = true;

	            if (loopBodyScope.hasOwnBinding(name)) {
	              loopBodyScope.rename(name);
	            }
	          }

	          if (imported.has(name) && !importConstViolationName) {
	            importConstViolationName = name;
	          }
	        }
	      }

	      if (!didTransformExport && !importConstViolationName) {
	        return;
	      }

	      path.ensureBlock();
	      var bodyPath = path.get("body");
	      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
	      path.get("left").replaceWith(variableDeclaration$2("let", [variableDeclarator$2(cloneNode$7(newLoopId))]));
	      scope.registerDeclaration(path.get("left"));

	      if (didTransformExport) {
	        bodyPath.unshiftContainer("body", expressionStatement$2(assignmentExpression$5("=", left, newLoopId)));
	      }

	      if (importConstViolationName) {
	        bodyPath.unshiftContainer("body", expressionStatement$2(buildImportThrow(importConstViolationName)));
	      }
	    }
	  }
	};

	function normalizeArray(parts, allowAboveRoot) {
	  var up = 0;

	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];

	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

	var splitPath = function splitPath(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	function resolve$3() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = i >= 0 ? arguments[i] : '/';

	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
	}
	function normalize$1(path) {
	  var isPathAbsolute = isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	  path = normalizeArray(filter(path.split('/'), function (p) {
	    return !!p;
	  }), !isPathAbsolute).join('/');

	  if (!path && !isPathAbsolute) {
	    path = '.';
	  }

	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isPathAbsolute ? '/' : '') + path;
	}
	function isAbsolute(path) {
	  return path.charAt(0) === '/';
	}
	function join() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return normalize$1(filter(paths, function (p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }

	    return p;
	  }).join('/'));
	}
	function relative(from, to) {
	  from = resolve$3(from).substr(1);
	  to = resolve$3(to).substr(1);

	  function trim(arr) {
	    var start = 0;

	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;

	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;

	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];

	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	  return outputParts.join('/');
	}
	var sep$1 = '/';
	var delimiter = ':';
	function dirname(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    return '.';
	  }

	  if (dir) {
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	}
	function basename(path, ext) {
	  var f = splitPath(path)[2];

	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }

	  return f;
	}
	function extname(path) {
	  return splitPath(path)[3];
	}
	var path$1 = {
	  extname: extname,
	  basename: basename,
	  dirname: dirname,
	  sep: sep$1,
	  delimiter: delimiter,
	  relative: relative,
	  join: join,
	  isAbsolute: isAbsolute,
	  normalize: normalize$1,
	  resolve: resolve$3
	};

	function filter(xs, f) {
	  if (xs.filter) return xs.filter(f);
	  var res = [];

	  for (var i = 0; i < xs.length; i++) {
	    if (f(xs[i], i, xs)) res.push(xs[i]);
	  }

	  return res;
	}

	var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
	  return str.substr(start, len);
	} : function (str, start, len) {
	  if (start < 0) start = str.length + start;
	  return str.substr(start, len);
	};

	var path$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		resolve: resolve$3,
		normalize: normalize$1,
		isAbsolute: isAbsolute,
		join: join,
		relative: relative,
		sep: sep$1,
		delimiter: delimiter,
		dirname: dirname,
		basename: basename,
		extname: extname,
		'default': path$1
	});

	function hasExports(metadata) {
	  return metadata.hasExports;
	}
	function isSideEffectImport(source) {
	  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
	}
	function validateImportInteropOption(importInterop) {
	  if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
	    throw new Error(".importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received " + importInterop + ").");
	  }

	  return importInterop;
	}

	function resolveImportInterop(importInterop, source) {
	  if (typeof importInterop === "function") {
	    return validateImportInteropOption(importInterop(source));
	  }

	  return importInterop;
	}

	function normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {
	  var importInterop = _ref.importInterop,
	      _ref$initializeReexpo = _ref.initializeReexports,
	      initializeReexports = _ref$initializeReexpo === void 0 ? false : _ref$initializeReexpo,
	      _ref$lazy = _ref.lazy,
	      lazy = _ref$lazy === void 0 ? false : _ref$lazy,
	      _ref$esNamespaceOnly = _ref.esNamespaceOnly,
	      esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

	  if (!exportName) {
	    exportName = programPath.scope.generateUidIdentifier("exports").name;
	  }

	  var stringSpecifiers = new Set();
	  nameAnonymousExports(programPath);

	  var _getModuleMetadata = getModuleMetadata(programPath, {
	    initializeReexports: initializeReexports,
	    lazy: lazy
	  }, stringSpecifiers),
	      local = _getModuleMetadata.local,
	      source = _getModuleMetadata.source,
	      hasExports = _getModuleMetadata.hasExports;

	  removeModuleDeclarations(programPath);

	  for (var _iterator = _createForOfIteratorHelperLoose(source), _step; !(_step = _iterator()).done;) {
	    var _step$value = _slicedToArray$1(_step.value, 2),
	        metadata = _step$value[1];

	    if (metadata.importsNamespace.size > 0) {
	      metadata.name = metadata.importsNamespace.values().next().value;
	    }

	    var resolvedInterop = resolveImportInterop(importInterop, metadata.source);

	    if (resolvedInterop === "none") {
	      metadata.interop = "none";
	    } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
	      metadata.interop = "node-namespace";
	    } else if (resolvedInterop === "node" && metadata.interop === "default") {
	      metadata.interop = "node-default";
	    } else if (esNamespaceOnly && metadata.interop === "namespace") {
	      metadata.interop = "default";
	    }
	  }

	  return {
	    exportName: exportName,
	    exportNameListName: null,
	    hasExports: hasExports,
	    local: local,
	    source: source,
	    stringSpecifiers: stringSpecifiers
	  };
	}

	function getExportSpecifierName$1(path, stringSpecifiers) {
	  if (path.isIdentifier()) {
	    return path.node.name;
	  } else if (path.isStringLiteral()) {
	    var stringValue = path.node.value;

	    if (!isIdentifierName(stringValue)) {
	      stringSpecifiers.add(stringValue);
	    }

	    return stringValue;
	  } else {
	    throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + path.node.type);
	  }
	}

	function assertExportSpecifier(path) {
	  if (path.isExportSpecifier()) {
	    return;
	  } else if (path.isExportNamespaceSpecifier()) {
	    throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.");
	  } else {
	    throw path.buildCodeFrameError("Unexpected export specifier type");
	  }
	}

	function getModuleMetadata(programPath, _ref2, stringSpecifiers) {
	  var lazy = _ref2.lazy,
	      initializeReexports = _ref2.initializeReexports;
	  var localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
	  var sourceData = new Map();

	  var getData = function getData(sourceNode) {
	    var source = sourceNode.value;
	    var data = sourceData.get(source);

	    if (!data) {
	      data = {
	        name: programPath.scope.generateUidIdentifier(basename(source, extname(source))).name,
	        interop: "none",
	        loc: null,
	        imports: new Map(),
	        importsNamespace: new Set(),
	        reexports: new Map(),
	        reexportNamespace: new Set(),
	        reexportAll: null,
	        lazy: false,
	        source: source
	      };
	      sourceData.set(source, data);
	    }

	    return data;
	  };

	  var hasExports = false;
	  programPath.get("body").forEach(function (child) {
	    if (child.isImportDeclaration()) {
	      var data = getData(child.node.source);
	      if (!data.loc) data.loc = child.node.loc;
	      child.get("specifiers").forEach(function (spec) {
	        if (spec.isImportDefaultSpecifier()) {
	          var localName = spec.get("local").node.name;
	          data.imports.set(localName, "default");
	          var reexport = localData.get(localName);

	          if (reexport) {
	            localData["delete"](localName);
	            reexport.names.forEach(function (name) {
	              data.reexports.set(name, "default");
	            });
	          }
	        } else if (spec.isImportNamespaceSpecifier()) {
	          var _localName = spec.get("local").node.name;
	          data.importsNamespace.add(_localName);

	          var _reexport = localData.get(_localName);

	          if (_reexport) {
	            localData["delete"](_localName);

	            _reexport.names.forEach(function (name) {
	              data.reexportNamespace.add(name);
	            });
	          }
	        } else if (spec.isImportSpecifier()) {
	          var importName = getExportSpecifierName$1(spec.get("imported"), stringSpecifiers);
	          var _localName2 = spec.get("local").node.name;
	          data.imports.set(_localName2, importName);

	          var _reexport2 = localData.get(_localName2);

	          if (_reexport2) {
	            localData["delete"](_localName2);

	            _reexport2.names.forEach(function (name) {
	              data.reexports.set(name, importName);
	            });
	          }
	        }
	      });
	    } else if (child.isExportAllDeclaration()) {
	      hasExports = true;

	      var _data = getData(child.node.source);

	      if (!_data.loc) _data.loc = child.node.loc;
	      _data.reexportAll = {
	        loc: child.node.loc
	      };
	    } else if (child.isExportNamedDeclaration() && child.node.source) {
	      hasExports = true;

	      var _data2 = getData(child.node.source);

	      if (!_data2.loc) _data2.loc = child.node.loc;
	      child.get("specifiers").forEach(function (spec) {
	        assertExportSpecifier(spec);
	        var importName = getExportSpecifierName$1(spec.get("local"), stringSpecifiers);
	        var exportName = getExportSpecifierName$1(spec.get("exported"), stringSpecifiers);

	        _data2.reexports.set(exportName, importName);

	        if (exportName === "__esModule") {
	          throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
	        }
	      });
	    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
	      hasExports = true;
	    }
	  });

	  for (var _iterator2 = _createForOfIteratorHelperLoose(sourceData.values()), _step2; !(_step2 = _iterator2()).done;) {
	    var metadata = _step2.value;
	    var needsDefault = false;
	    var needsNamed = false;

	    if (metadata.importsNamespace.size > 0) {
	      needsDefault = true;
	      needsNamed = true;
	    }

	    if (metadata.reexportAll) {
	      needsNamed = true;
	    }

	    for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.imports.values()), _step4; !(_step4 = _iterator4()).done;) {
	      var importName = _step4.value;
	      if (importName === "default") needsDefault = true;else needsNamed = true;
	    }

	    for (var _iterator5 = _createForOfIteratorHelperLoose(metadata.reexports.values()), _step5; !(_step5 = _iterator5()).done;) {
	      var _importName = _step5.value;
	      if (_importName === "default") needsDefault = true;else needsNamed = true;
	    }

	    if (needsDefault && needsNamed) {
	      metadata.interop = "namespace";
	    } else if (needsDefault) {
	      metadata.interop = "default";
	    }
	  }

	  for (var _iterator3 = _createForOfIteratorHelperLoose(sourceData), _step3; !(_step3 = _iterator3()).done;) {
	    var _step3$value = _slicedToArray$1(_step3.value, 2),
	        source = _step3$value[0],
	        _metadata = _step3$value[1];

	    if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
	      if (lazy === true) {
	        _metadata.lazy = !/\./.test(source);
	      } else if (Array.isArray(lazy)) {
	        _metadata.lazy = lazy.indexOf(source) !== -1;
	      } else if (typeof lazy === "function") {
	        _metadata.lazy = lazy(source);
	      } else {
	        throw new Error(".lazy must be a boolean, string array, or function");
	      }
	    }
	  }

	  return {
	    hasExports: hasExports,
	    local: localData,
	    source: sourceData
	  };
	}

	function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
	  var bindingKindLookup = new Map();
	  programPath.get("body").forEach(function (child) {
	    var kind;

	    if (child.isImportDeclaration()) {
	      kind = "import";
	    } else {
	      if (child.isExportDefaultDeclaration()) child = child.get("declaration");

	      if (child.isExportNamedDeclaration()) {
	        if (child.node.declaration) {
	          child = child.get("declaration");
	        } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
	          child.get("specifiers").forEach(function (spec) {
	            assertExportSpecifier(spec);
	            bindingKindLookup.set(spec.get("local").node.name, "block");
	          });
	          return;
	        }
	      }

	      if (child.isFunctionDeclaration()) {
	        kind = "hoisted";
	      } else if (child.isClassDeclaration()) {
	        kind = "block";
	      } else if (child.isVariableDeclaration({
	        kind: "var"
	      })) {
	        kind = "var";
	      } else if (child.isVariableDeclaration()) {
	        kind = "block";
	      } else {
	        return;
	      }
	    }

	    Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
	      bindingKindLookup.set(name, kind);
	    });
	  });
	  var localMetadata = new Map();

	  var getLocalMetadata = function getLocalMetadata(idPath) {
	    var localName = idPath.node.name;
	    var metadata = localMetadata.get(localName);

	    if (!metadata) {
	      var kind = bindingKindLookup.get(localName);

	      if (kind === undefined) {
	        throw idPath.buildCodeFrameError("Exporting local \"" + localName + "\", which is not declared.");
	      }

	      metadata = {
	        names: [],
	        kind: kind
	      };
	      localMetadata.set(localName, metadata);
	    }

	    return metadata;
	  };

	  programPath.get("body").forEach(function (child) {
	    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
	      if (child.node.declaration) {
	        var declaration = child.get("declaration");
	        var ids = declaration.getOuterBindingIdentifierPaths();
	        Object.keys(ids).forEach(function (name) {
	          if (name === "__esModule") {
	            throw declaration.buildCodeFrameError('Illegal export "__esModule".');
	          }

	          getLocalMetadata(ids[name]).names.push(name);
	        });
	      } else {
	        child.get("specifiers").forEach(function (spec) {
	          var local = spec.get("local");
	          var exported = spec.get("exported");
	          var localMetadata = getLocalMetadata(local);
	          var exportName = getExportSpecifierName$1(exported, stringSpecifiers);

	          if (exportName === "__esModule") {
	            throw exported.buildCodeFrameError('Illegal export "__esModule".');
	          }

	          localMetadata.names.push(exportName);
	        });
	      }
	    } else if (child.isExportDefaultDeclaration()) {
	      var _declaration = child.get("declaration");

	      if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
	        getLocalMetadata(_declaration.get("id")).names.push("default");
	      } else {
	        throw _declaration.buildCodeFrameError("Unexpected default expression export.");
	      }
	    }
	  });
	  return localMetadata;
	}

	function nameAnonymousExports(programPath) {
	  programPath.get("body").forEach(function (child) {
	    if (!child.isExportDefaultDeclaration()) return;
	    splitExportDeclaration(child);
	  });
	}

	function removeModuleDeclarations(programPath) {
	  programPath.get("body").forEach(function (child) {
	    if (child.isImportDeclaration()) {
	      child.remove();
	    } else if (child.isExportNamedDeclaration()) {
	      if (child.node.declaration) {
	        child.node.declaration._blockHoist = child.node._blockHoist;
	        child.replaceWith(child.node.declaration);
	      } else {
	        child.remove();
	      }
	    } else if (child.isExportDefaultDeclaration()) {
	      var declaration = child.get("declaration");

	      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
	        declaration._blockHoist = child.node._blockHoist;
	        child.replaceWith(declaration);
	      } else {
	        throw declaration.buildCodeFrameError("Unexpected default expression export.");
	      }
	    } else if (child.isExportAllDeclaration()) {
	      child.remove();
	    }
	  });
	}

	{
	  var originalGetModuleName = getModuleName;

	  getModuleName = function getModuleName(rootOpts, pluginOpts) {
	    var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;

	    return originalGetModuleName(rootOpts, {
	      moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
	      moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
	      getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
	      moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
	    });
	  };
	}
	function getModuleName(rootOpts, pluginOpts) {
	  var filename = rootOpts.filename,
	      _rootOpts$filenameRel = rootOpts.filenameRelative,
	      filenameRelative = _rootOpts$filenameRel === void 0 ? filename : _rootOpts$filenameRel,
	      _rootOpts$sourceRoot = rootOpts.sourceRoot,
	      sourceRoot = _rootOpts$sourceRoot === void 0 ? pluginOpts.moduleRoot : _rootOpts$sourceRoot;
	  var moduleId = pluginOpts.moduleId,
	      _pluginOpts$moduleIds2 = pluginOpts.moduleIds,
	      moduleIds = _pluginOpts$moduleIds2 === void 0 ? !!moduleId : _pluginOpts$moduleIds2,
	      getModuleId = pluginOpts.getModuleId,
	      _pluginOpts$moduleRoo2 = pluginOpts.moduleRoot,
	      moduleRoot = _pluginOpts$moduleRoo2 === void 0 ? sourceRoot : _pluginOpts$moduleRoo2;
	  if (!moduleIds) return null;

	  if (moduleId != null && !getModuleId) {
	    return moduleId;
	  }

	  var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

	  if (filenameRelative) {
	    var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
	    moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
	  }

	  moduleName = moduleName.replace(/\\/g, "/");

	  if (getModuleId) {
	    return getModuleId(moduleName) || moduleName;
	  } else {
	    return moduleName;
	  }
	}

	var _templateObject$l, _templateObject2$a, _templateObject3$9, _templateObject4$5, _templateObject5$3, _templateObject6$3, _templateObject7$2, _templateObject8$1, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12$1, _templateObject13$1;
	var booleanLiteral$4 = booleanLiteral$5,
	    callExpression$7 = callExpression$e,
	    cloneNode$6 = cloneNode$i,
	    directive = directive$1,
	    directiveLiteral = directiveLiteral$1,
	    expressionStatement$1 = expressionStatement$a,
	    identifier$6 = identifier$j,
	    isIdentifier$5 = isIdentifier$g,
	    memberExpression$6 = memberExpression$b,
	    stringLiteral$3 = stringLiteral$8,
	    valueToNode = valueToNode$1,
	    variableDeclaration$1 = variableDeclaration$8,
	    variableDeclarator$1 = variableDeclarator$8;
	function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
	  var loose = _ref.loose,
	      exportName = _ref.exportName,
	      strict = _ref.strict,
	      allowTopLevelThis = _ref.allowTopLevelThis,
	      strictMode = _ref.strictMode,
	      noInterop = _ref.noInterop,
	      _ref$importInterop = _ref.importInterop,
	      importInterop = _ref$importInterop === void 0 ? noInterop ? "none" : "babel" : _ref$importInterop,
	      lazy = _ref.lazy,
	      esNamespaceOnly = _ref.esNamespaceOnly,
	      _ref$constantReexport = _ref.constantReexports,
	      constantReexports = _ref$constantReexport === void 0 ? loose : _ref$constantReexport,
	      _ref$enumerableModule = _ref.enumerableModuleMeta,
	      enumerableModuleMeta = _ref$enumerableModule === void 0 ? loose : _ref$enumerableModule,
	      noIncompleteNsImportDetection = _ref.noIncompleteNsImportDetection;
	  validateImportInteropOption(importInterop);
	  assert_1(isModule(path), "Cannot process module statements in a script");
	  path.node.sourceType = "script";
	  var meta = normalizeModuleAndLoadMetadata(path, exportName, {
	    importInterop: importInterop,
	    initializeReexports: constantReexports,
	    lazy: lazy,
	    esNamespaceOnly: esNamespaceOnly
	  });

	  if (!allowTopLevelThis) {
	    rewriteThis(path);
	  }

	  rewriteLiveReferences(path, meta);

	  if (strictMode !== false) {
	    var hasStrict = path.node.directives.some(function (directive) {
	      return directive.value.value === "use strict";
	    });

	    if (!hasStrict) {
	      path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
	    }
	  }

	  var headers = [];

	  if (hasExports(meta) && !strict) {
	    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
	  }

	  var nameList = buildExportNameListDeclaration(path, meta);

	  if (nameList) {
	    meta.exportNameListName = nameList.name;
	    headers.push(nameList.statement);
	  }

	  headers.push.apply(headers, _toConsumableArray(buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection)));
	  return {
	    meta: meta,
	    headers: headers
	  };
	}
	function ensureStatementsHoisted(statements) {
	  statements.forEach(function (header) {
	    header._blockHoist = 3;
	  });
	}
	function wrapInterop(programPath, expr, type) {
	  if (type === "none") {
	    return null;
	  }

	  if (type === "node-namespace") {
	    return callExpression$7(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral$4(true)]);
	  } else if (type === "node-default") {
	    return null;
	  }

	  var helper;

	  if (type === "default") {
	    helper = "interopRequireDefault";
	  } else if (type === "namespace") {
	    helper = "interopRequireWildcard";
	  } else {
	    throw new Error("Unknown interop: " + type);
	  }

	  return callExpression$7(programPath.hub.addHelper(helper), [expr]);
	}
	function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports) {
	  if (constantReexports === void 0) {
	    constantReexports = false;
	  }

	  var statements = [];
	  var srcNamespace = identifier$6(sourceMetadata.name);
	  if (sourceMetadata.lazy) srcNamespace = callExpression$7(srcNamespace, []);

	  for (var _iterator = _createForOfIteratorHelperLoose(sourceMetadata.importsNamespace), _step; !(_step = _iterator()).done;) {
	    var localName = _step.value;
	    if (localName === sourceMetadata.name) continue;
	    statements.push(template$2.statement(_templateObject$l || (_templateObject$l = _taggedTemplateLiteralLoose(["var NAME = SOURCE;"])))({
	      NAME: localName,
	      SOURCE: cloneNode$6(srcNamespace)
	    }));
	  }

	  if (constantReexports) {
	    statements.push.apply(statements, _toConsumableArray(buildReexportsFromMeta(metadata, sourceMetadata, true)));
	  }

	  for (var _iterator2 = _createForOfIteratorHelperLoose(sourceMetadata.reexportNamespace), _step2; !(_step2 = _iterator2()).done;) {
	    var exportName = _step2.value;
	    statements.push((sourceMetadata.lazy ? template$2.statement(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteralLoose(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]))) : template$2.statement(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteralLoose(["EXPORTS.NAME = NAMESPACE;"]))))({
	      EXPORTS: metadata.exportName,
	      NAME: exportName,
	      NAMESPACE: cloneNode$6(srcNamespace)
	    }));
	  }

	  if (sourceMetadata.reexportAll) {
	    var statement = buildNamespaceReexport(metadata, cloneNode$6(srcNamespace), constantReexports);
	    statement.loc = sourceMetadata.reexportAll.loc;
	    statements.push(statement);
	  }

	  return statements;
	}
	var ReexportTemplate = {
	  constant: template$2.statement(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteralLoose(["EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;"]))),
	  constantComputed: template$2.statement(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteralLoose(["EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;"]))),
	  spec: template$2.statement(_templateObject6$3 || (_templateObject6$3 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    "])))
	};

	var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, constantReexports) {
	  var namespace = metadata.lazy ? callExpression$7(identifier$6(metadata.name), []) : identifier$6(metadata.name);
	  var stringSpecifiers = meta.stringSpecifiers;
	  return Array.from(metadata.reexports, function (_ref2) {
	    var _ref3 = _slicedToArray$1(_ref2, 2),
	        exportName = _ref3[0],
	        importName = _ref3[1];

	    var NAMESPACE_IMPORT = cloneNode$6(namespace);

	    if (importName === "default" && metadata.interop === "node-default") ; else if (stringSpecifiers.has(importName)) {
	      NAMESPACE_IMPORT = memberExpression$6(NAMESPACE_IMPORT, stringLiteral$3(importName), true);
	    } else {
	      NAMESPACE_IMPORT = memberExpression$6(NAMESPACE_IMPORT, identifier$6(importName));
	    }

	    var astNodes = {
	      EXPORTS: meta.exportName,
	      EXPORT_NAME: exportName,
	      NAMESPACE_IMPORT: NAMESPACE_IMPORT
	    };

	    if (constantReexports || isIdentifier$5(NAMESPACE_IMPORT)) {
	      if (stringSpecifiers.has(exportName)) {
	        return ReexportTemplate.constantComputed(astNodes);
	      } else {
	        return ReexportTemplate.constant(astNodes);
	      }
	    } else {
	      return ReexportTemplate.spec(astNodes);
	    }
	  });
	};

	function buildESModuleHeader(metadata, enumerableModuleMeta) {
	  if (enumerableModuleMeta === void 0) {
	    enumerableModuleMeta = false;
	  }

	  return (enumerableModuleMeta ? template$2.statement(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteralLoose(["\n        EXPORTS.__esModule = true;\n      "]))) : template$2.statement(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]))))({
	    EXPORTS: metadata.exportName
	  });
	}

	function buildNamespaceReexport(metadata, namespace, constantReexports) {
	  return (constantReexports ? template$2.statement(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]))) : template$2.statement(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]))))({
	    NAMESPACE: namespace,
	    EXPORTS: metadata.exportName,
	    VERIFY_NAME_LIST: metadata.exportNameListName ? template$2(_templateObject11$1 || (_templateObject11$1 = _taggedTemplateLiteralLoose(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "])))({
	      EXPORTS_LIST: metadata.exportNameListName
	    }) : null
	  });
	}

	function buildExportNameListDeclaration(programPath, metadata) {
	  var exportedVars = Object.create(null);

	  for (var _iterator3 = _createForOfIteratorHelperLoose(metadata.local.values()), _step3; !(_step3 = _iterator3()).done;) {
	    var data = _step3.value;

	    for (var _iterator5 = _createForOfIteratorHelperLoose(data.names), _step5; !(_step5 = _iterator5()).done;) {
	      var _name = _step5.value;
	      exportedVars[_name] = true;
	    }
	  }

	  var hasReexport = false;

	  for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.source.values()), _step4; !(_step4 = _iterator4()).done;) {
	    var _data = _step4.value;

	    for (var _iterator6 = _createForOfIteratorHelperLoose(_data.reexports.keys()), _step6; !(_step6 = _iterator6()).done;) {
	      var exportName = _step6.value;
	      exportedVars[exportName] = true;
	    }

	    for (var _iterator7 = _createForOfIteratorHelperLoose(_data.reexportNamespace), _step7; !(_step7 = _iterator7()).done;) {
	      var _exportName = _step7.value;
	      exportedVars[_exportName] = true;
	    }

	    hasReexport = hasReexport || !!_data.reexportAll;
	  }

	  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
	  var name = programPath.scope.generateUidIdentifier("exportNames");
	  delete exportedVars["default"];
	  return {
	    name: name.name,
	    statement: variableDeclaration$1("var", [variableDeclarator$1(name, valueToNode(exportedVars))])
	  };
	}

	function buildExportInitializationStatements(programPath, metadata, constantReexports, noIncompleteNsImportDetection) {
	  if (constantReexports === void 0) {
	    constantReexports = false;
	  }

	  if (noIncompleteNsImportDetection === void 0) {
	    noIncompleteNsImportDetection = false;
	  }

	  var initStatements = [];

	  for (var _iterator8 = _createForOfIteratorHelperLoose(metadata.local), _step8; !(_step8 = _iterator8()).done;) {
	    var _step8$value = _slicedToArray$1(_step8.value, 2),
	        localName = _step8$value[0],
	        data = _step8$value[1];

	    if (data.kind === "import") ; else if (data.kind === "hoisted") {
	      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier$6(localName))]);
	    } else if (!noIncompleteNsImportDetection) {
	      for (var _iterator11 = _createForOfIteratorHelperLoose(data.names), _step11; !(_step11 = _iterator11()).done;) {
	        var _exportName2 = _step11.value;
	        initStatements.push([_exportName2, null]);
	      }
	    }
	  }

	  for (var _iterator9 = _createForOfIteratorHelperLoose(metadata.source.values()), _step9; !(_step9 = _iterator9()).done;) {
	    var _data2 = _step9.value;

	    if (!constantReexports) {
	      var reexportsStatements = buildReexportsFromMeta(metadata, _data2, false);

	      var reexports = _toConsumableArray(_data2.reexports.keys());

	      for (var _i = 0; _i < reexportsStatements.length; _i++) {
	        initStatements.push([reexports[_i], reexportsStatements[_i]]);
	      }
	    }

	    if (!noIncompleteNsImportDetection) {
	      for (var _iterator12 = _createForOfIteratorHelperLoose(_data2.reexportNamespace), _step12; !(_step12 = _iterator12()).done;) {
	        var _exportName3 = _step12.value;
	        initStatements.push([_exportName3, null]);
	      }
	    }
	  }

	  initStatements.sort(function (a, b) {
	    return a[0] > b[0] ? 1 : -1;
	  });
	  var results = [];

	  if (noIncompleteNsImportDetection) {
	    for (var _iterator10 = _createForOfIteratorHelperLoose(initStatements), _step10; !(_step10 = _iterator10()).done;) {
	      var _step10$value = _slicedToArray$1(_step10.value, 2),
	          initStatement = _step10$value[1];

	      results.push(initStatement);
	    }
	  } else {
	    var chunkSize = 100;

	    for (var i = 0, uninitializedExportNames = []; i < initStatements.length; i += chunkSize) {
	      for (var j = 0; j < chunkSize && i + j < initStatements.length; j++) {
	        var _initStatements = _slicedToArray$1(initStatements[i + j], 2),
	            exportName = _initStatements[0],
	            _initStatement = _initStatements[1];

	        if (_initStatement !== null) {
	          if (uninitializedExportNames.length > 0) {
	            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
	            uninitializedExportNames = [];
	          }

	          results.push(_initStatement);
	        } else {
	          uninitializedExportNames.push(exportName);
	        }
	      }

	      if (uninitializedExportNames.length > 0) {
	        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
	      }
	    }
	  }

	  return results;
	}

	var InitTemplate = {
	  computed: template$2.expression(_templateObject12$1 || (_templateObject12$1 = _taggedTemplateLiteralLoose(["EXPORTS[\"NAME\"] = VALUE"]))),
	  "default": template$2.expression(_templateObject13$1 || (_templateObject13$1 = _taggedTemplateLiteralLoose(["EXPORTS.NAME = VALUE"])))
	};

	function buildInitStatement(metadata, exportNames, initExpr) {
	  var stringSpecifiers = metadata.stringSpecifiers,
	      EXPORTS = metadata.exportName;
	  return expressionStatement$1(exportNames.reduce(function (acc, exportName) {
	    var params = {
	      EXPORTS: EXPORTS,
	      NAME: exportName,
	      VALUE: acc
	    };

	    if (stringSpecifiers.has(exportName)) {
	      return InitTemplate.computed(params);
	    } else {
	      return InitTemplate["default"](params);
	    }
	  }, initExpr));
	}

	var SEMVER_SPEC_VERSION$1 = '2.0.0';
	var MAX_LENGTH$5 = 256;
	var MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
	var MAX_SAFE_COMPONENT_LENGTH$1 = 16;
	var constants$1 = {
	  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$1,
	  MAX_LENGTH: MAX_LENGTH$5,
	  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
	  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$1
	};

	var debug$3 = typeof browser$4 === 'object' && browser$4.env && browser$4.env.NODE_DEBUG && /\bsemver\b/i.test(browser$4.env.NODE_DEBUG) ? function () {
	  var _console;

	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
	} : function () {};
	var debug_1$1 = debug$3;

	var re_1$1 = createCommonjsModule(function (module, exports) {
	  var MAX_SAFE_COMPONENT_LENGTH = constants$1.MAX_SAFE_COMPONENT_LENGTH;
	  exports = module.exports = {};
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var t = exports.t = {};
	  var R = 0;

	  var createToken = function createToken(name, value, isGlobal) {
	    var index = R++;
	    debug_1$1(index, value);
	    t[name] = index;
	    src[index] = value;
	    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
	  };

	  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
	  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
	  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
	  createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
	  createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
	  createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
	  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
	  createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
	  createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
	  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
	  createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
	  createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
	  createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
	  createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
	  createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
	  createToken('GTLT', '((?:<|>)?=?)');
	  createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
	  createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
	  createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
	  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
	  createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
	  createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
	  createToken('COERCERTL', src[t.COERCE], true);
	  createToken('LONETILDE', '(?:~>?)');
	  createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
	  exports.tildeTrimReplace = '$1~';
	  createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
	  createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('LONECARET', '(?:\\^)');
	  createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
	  exports.caretTrimReplace = '$1^';
	  createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
	  createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
	  createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
	  createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
	  exports.comparatorTrimReplace = '$1$2$3';
	  createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
	  createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
	  createToken('STAR', '(<|>)?=?\\s*\\*');
	  createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
	  createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
	}, "/$$rollup_base$$/node_modules/semver-BABEL_8_BREAKING-true/internal");

	var opts = ['includePrerelease', 'loose', 'rtl'];

	var parseOptions = function parseOptions(options) {
	  return !options ? {} : typeof options !== 'object' ? {
	    loose: true
	  } : opts.filter(function (k) {
	    return options[k];
	  }).reduce(function (options, k) {
	    options[k] = true;
	    return options;
	  }, {});
	};

	var parseOptions_1 = parseOptions;

	var numeric$1 = /^[0-9]+$/;

	var compareIdentifiers$3 = function compareIdentifiers(a, b) {
	  var anum = numeric$1.test(a);
	  var bnum = numeric$1.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	};

	var rcompareIdentifiers$1 = function rcompareIdentifiers(a, b) {
	  return compareIdentifiers$3(b, a);
	};

	var identifiers$1 = {
	  compareIdentifiers: compareIdentifiers$3,
	  rcompareIdentifiers: rcompareIdentifiers$1
	};

	var MAX_LENGTH$4 = constants$1.MAX_LENGTH,
	    MAX_SAFE_INTEGER$2 = constants$1.MAX_SAFE_INTEGER;
	var re$7 = re_1$1.re,
	    t$e = re_1$1.t;
	var compareIdentifiers$2 = identifiers$1.compareIdentifiers;

	var SemVer$1 = function () {
	  function SemVer(version, options) {
	    options = parseOptions_1(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
	        return version;
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError("Invalid Version: " + version);
	    }

	    if (version.length > MAX_LENGTH$4) {
	      throw new TypeError("version is longer than " + MAX_LENGTH$4 + " characters");
	    }

	    debug_1$1('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    var m = version.trim().match(options.loose ? re$7[t$e.LOOSE] : re$7[t$e.FULL]);

	    if (!m) {
	      throw new TypeError("Invalid Version: " + version);
	    }

	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
	      throw new TypeError('Invalid major version');
	    }

	    if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
	      throw new TypeError('Invalid minor version');
	    }

	    if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
	      throw new TypeError('Invalid patch version');
	    }

	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map(function (id) {
	        if (/^[0-9]+$/.test(id)) {
	          var num = +id;

	          if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
	            return num;
	          }
	        }

	        return id;
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  var _proto = SemVer.prototype;

	  _proto.format = function format() {
	    this.version = this.major + "." + this.minor + "." + this.patch;

	    if (this.prerelease.length) {
	      this.version += "-" + this.prerelease.join('.');
	    }

	    return this.version;
	  };

	  _proto.toString = function toString() {
	    return this.version;
	  };

	  _proto.compare = function compare(other) {
	    debug_1$1('SemVer.compare', this.version, this.options, other);

	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0;
	      }

	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0;
	    }

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  _proto.compareMain = function compareMain(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return compareIdentifiers$2(this.major, other.major) || compareIdentifiers$2(this.minor, other.minor) || compareIdentifiers$2(this.patch, other.patch);
	  };

	  _proto.comparePre = function comparePre(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1;
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1;
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0;
	    }

	    var i = 0;

	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      debug_1$1('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers$2(a, b);
	      }
	    } while (++i);
	  };

	  _proto.compareBuild = function compareBuild(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    var i = 0;

	    do {
	      var a = this.build[i];
	      var b = other.build[i];
	      debug_1$1('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers$2(a, b);
	      }
	    } while (++i);
	  };

	  _proto.inc = function inc(release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;

	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;

	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier);
	        }

	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
	          this.major++;
	        }

	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }

	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }

	        this.prerelease = [];
	        break;

	      case 'pre':
	        if (this.prerelease.length === 0) {
	          this.prerelease = [0];
	        } else {
	          var i = this.prerelease.length;

	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }

	          if (i === -1) {
	            this.prerelease.push(0);
	          }
	        }

	        if (identifier) {
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = [identifier, 0];
	            }
	          } else {
	            this.prerelease = [identifier, 0];
	          }
	        }

	        break;

	      default:
	        throw new Error("invalid increment argument: " + release);
	    }

	    this.format();
	    this.raw = this.version;
	    return this;
	  };

	  return SemVer;
	}();

	var semver$6 = SemVer$1;

	var MAX_LENGTH$3 = constants$1.MAX_LENGTH;
	var re$6 = re_1$1.re,
	    t$d = re_1$1.t;

	var parse$4 = function parse(version, options) {
	  options = parseOptions_1(options);

	  if (version instanceof semver$6) {
	    return version;
	  }

	  if (typeof version !== 'string') {
	    return null;
	  }

	  if (version.length > MAX_LENGTH$3) {
	    return null;
	  }

	  var r = options.loose ? re$6[t$d.LOOSE] : re$6[t$d.FULL];

	  if (!r.test(version)) {
	    return null;
	  }

	  try {
	    return new semver$6(version, options);
	  } catch (er) {
	    return null;
	  }
	};

	var parse_1$1 = parse$4;

	var valid$1 = function valid(version, options) {
	  var v = parse_1$1(version, options);
	  return v ? v.version : null;
	};

	var valid_1 = valid$1;

	var clean = function clean(version, options) {
	  var s = parse_1$1(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null;
	};

	var clean_1 = clean;

	var inc = function inc(version, release, options, identifier) {
	  if (typeof options === 'string') {
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new semver$6(version, options).inc(release, identifier).version;
	  } catch (er) {
	    return null;
	  }
	};

	var inc_1 = inc;

	var compare$4 = function compare(a, b, loose) {
	  return new semver$6(a, loose).compare(new semver$6(b, loose));
	};

	var compare_1$1 = compare$4;

	var eq$1 = function eq(a, b, loose) {
	  return compare_1$1(a, b, loose) === 0;
	};

	var eq_1$1 = eq$1;

	var diff = function diff(version1, version2) {
	  if (eq_1$1(version1, version2)) {
	    return null;
	  } else {
	    var v1 = parse_1$1(version1);
	    var v2 = parse_1$1(version2);
	    var hasPre = v1.prerelease.length || v2.prerelease.length;
	    var prefix = hasPre ? 'pre' : '';
	    var defaultResult = hasPre ? 'prerelease' : '';

	    for (var key in v1) {
	      if (key === 'major' || key === 'minor' || key === 'patch') {
	        if (v1[key] !== v2[key]) {
	          return prefix + key;
	        }
	      }
	    }

	    return defaultResult;
	  }
	};

	var diff_1 = diff;

	var major = function major(a, loose) {
	  return new semver$6(a, loose).major;
	};

	var major_1 = major;

	var minor = function minor(a, loose) {
	  return new semver$6(a, loose).minor;
	};

	var minor_1 = minor;

	var patch = function patch(a, loose) {
	  return new semver$6(a, loose).patch;
	};

	var patch_1 = patch;

	var prerelease = function prerelease(version, options) {
	  var parsed = parse_1$1(version, options);
	  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	};

	var prerelease_1 = prerelease;

	var rcompare = function rcompare(a, b, loose) {
	  return compare_1$1(b, a, loose);
	};

	var rcompare_1 = rcompare;

	var compareLoose = function compareLoose(a, b) {
	  return compare_1$1(a, b, true);
	};

	var compareLoose_1 = compareLoose;

	var compareBuild = function compareBuild(a, b, loose) {
	  var versionA = new semver$6(a, loose);
	  var versionB = new semver$6(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB);
	};

	var compareBuild_1 = compareBuild;

	var sort = function sort(list, loose) {
	  return list.sort(function (a, b) {
	    return compareBuild_1(a, b, loose);
	  });
	};

	var sort_1 = sort;

	var rsort = function rsort(list, loose) {
	  return list.sort(function (a, b) {
	    return compareBuild_1(b, a, loose);
	  });
	};

	var rsort_1 = rsort;

	var gt$1 = function gt(a, b, loose) {
	  return compare_1$1(a, b, loose) > 0;
	};

	var gt_1$1 = gt$1;

	var lt$1 = function lt(a, b, loose) {
	  return compare_1$1(a, b, loose) < 0;
	};

	var lt_1$1 = lt$1;

	var neq$1 = function neq(a, b, loose) {
	  return compare_1$1(a, b, loose) !== 0;
	};

	var neq_1$1 = neq$1;

	var gte$1 = function gte(a, b, loose) {
	  return compare_1$1(a, b, loose) >= 0;
	};

	var gte_1$1 = gte$1;

	var lte$1 = function lte(a, b, loose) {
	  return compare_1$1(a, b, loose) <= 0;
	};

	var lte_1$1 = lte$1;

	var cmp$1 = function cmp(a, op, b, loose) {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      return a === b;

	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      return a !== b;

	    case '':
	    case '=':
	    case '==':
	      return eq_1$1(a, b, loose);

	    case '!=':
	      return neq_1$1(a, b, loose);

	    case '>':
	      return gt_1$1(a, b, loose);

	    case '>=':
	      return gte_1$1(a, b, loose);

	    case '<':
	      return lt_1$1(a, b, loose);

	    case '<=':
	      return lte_1$1(a, b, loose);

	    default:
	      throw new TypeError("Invalid operator: " + op);
	  }
	};

	var cmp_1$1 = cmp$1;

	var re$5 = re_1$1.re,
	    t$c = re_1$1.t;

	var coerce$1 = function coerce(version, options) {
	  if (version instanceof semver$6) {
	    return version;
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null;
	  }

	  options = options || {};
	  var match = null;

	  if (!options.rtl) {
	    match = version.match(re$5[t$c.COERCE]);
	  } else {
	    var next;

	    while ((next = re$5[t$c.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
	      if (!match || next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }

	      re$5[t$c.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
	    }

	    re$5[t$c.COERCERTL].lastIndex = -1;
	  }

	  if (match === null) return null;
	  return parse_1$1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
	};

	var coerce_1$1 = coerce$1;

	var iterator = function iterator(Yallist) {
	  Yallist.prototype[Symbol.iterator] = regenerator.mark(function _callee() {
	    var walker;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            walker = this.head;

	          case 1:
	            if (!walker) {
	              _context.next = 7;
	              break;
	            }

	            _context.next = 4;
	            return walker.value;

	          case 4:
	            walker = walker.next;
	            _context.next = 1;
	            break;

	          case 7:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  });
	};

	var yallist = Yallist;
	Yallist.Node = Node;
	Yallist.create = Yallist;

	function Yallist(list) {
	  var self = this;

	  if (!(self instanceof Yallist)) {
	    self = new Yallist();
	  }

	  self.tail = null;
	  self.head = null;
	  self.length = 0;

	  if (list && typeof list.forEach === 'function') {
	    list.forEach(function (item) {
	      self.push(item);
	    });
	  } else if (arguments.length > 0) {
	    for (var i = 0, l = arguments.length; i < l; i++) {
	      self.push(arguments[i]);
	    }
	  }

	  return self;
	}

	Yallist.prototype.removeNode = function (node) {
	  if (node.list !== this) {
	    throw new Error('removing node which does not belong to this list');
	  }

	  var next = node.next;
	  var prev = node.prev;

	  if (next) {
	    next.prev = prev;
	  }

	  if (prev) {
	    prev.next = next;
	  }

	  if (node === this.head) {
	    this.head = next;
	  }

	  if (node === this.tail) {
	    this.tail = prev;
	  }

	  node.list.length--;
	  node.next = null;
	  node.prev = null;
	  node.list = null;
	  return next;
	};

	Yallist.prototype.unshiftNode = function (node) {
	  if (node === this.head) {
	    return;
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var head = this.head;
	  node.list = this;
	  node.next = head;

	  if (head) {
	    head.prev = node;
	  }

	  this.head = node;

	  if (!this.tail) {
	    this.tail = node;
	  }

	  this.length++;
	};

	Yallist.prototype.pushNode = function (node) {
	  if (node === this.tail) {
	    return;
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var tail = this.tail;
	  node.list = this;
	  node.prev = tail;

	  if (tail) {
	    tail.next = node;
	  }

	  this.tail = node;

	  if (!this.head) {
	    this.head = node;
	  }

	  this.length++;
	};

	Yallist.prototype.push = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    push$1(this, arguments[i]);
	  }

	  return this.length;
	};

	Yallist.prototype.unshift = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    unshift(this, arguments[i]);
	  }

	  return this.length;
	};

	Yallist.prototype.pop = function () {
	  if (!this.tail) {
	    return undefined;
	  }

	  var res = this.tail.value;
	  this.tail = this.tail.prev;

	  if (this.tail) {
	    this.tail.next = null;
	  } else {
	    this.head = null;
	  }

	  this.length--;
	  return res;
	};

	Yallist.prototype.shift = function () {
	  if (!this.head) {
	    return undefined;
	  }

	  var res = this.head.value;
	  this.head = this.head.next;

	  if (this.head) {
	    this.head.prev = null;
	  } else {
	    this.tail = null;
	  }

	  this.length--;
	  return res;
	};

	Yallist.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this;

	  for (var walker = this.head, i = 0; walker !== null; i++) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.next;
	  }
	};

	Yallist.prototype.forEachReverse = function (fn, thisp) {
	  thisp = thisp || this;

	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.prev;
	  }
	};

	Yallist.prototype.get = function (n) {
	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
	    walker = walker.next;
	  }

	  if (i === n && walker !== null) {
	    return walker.value;
	  }
	};

	Yallist.prototype.getReverse = function (n) {
	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
	    walker = walker.prev;
	  }

	  if (i === n && walker !== null) {
	    return walker.value;
	  }
	};

	Yallist.prototype.map = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();

	  for (var walker = this.head; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.next;
	  }

	  return res;
	};

	Yallist.prototype.mapReverse = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();

	  for (var walker = this.tail; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.prev;
	  }

	  return res;
	};

	Yallist.prototype.reduce = function (fn, initial) {
	  var acc;
	  var walker = this.head;

	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.head) {
	    walker = this.head.next;
	    acc = this.head.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value');
	  }

	  for (var i = 0; walker !== null; i++) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.next;
	  }

	  return acc;
	};

	Yallist.prototype.reduceReverse = function (fn, initial) {
	  var acc;
	  var walker = this.tail;

	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.tail) {
	    walker = this.tail.prev;
	    acc = this.tail.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value');
	  }

	  for (var i = this.length - 1; walker !== null; i--) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.prev;
	  }

	  return acc;
	};

	Yallist.prototype.toArray = function () {
	  var arr = new Array(this.length);

	  for (var i = 0, walker = this.head; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.next;
	  }

	  return arr;
	};

	Yallist.prototype.toArrayReverse = function () {
	  var arr = new Array(this.length);

	  for (var i = 0, walker = this.tail; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.prev;
	  }

	  return arr;
	};

	Yallist.prototype.slice = function (from, to) {
	  to = to || this.length;

	  if (to < 0) {
	    to += this.length;
	  }

	  from = from || 0;

	  if (from < 0) {
	    from += this.length;
	  }

	  var ret = new Yallist();

	  if (to < from || to < 0) {
	    return ret;
	  }

	  if (from < 0) {
	    from = 0;
	  }

	  if (to > this.length) {
	    to = this.length;
	  }

	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
	    walker = walker.next;
	  }

	  for (; walker !== null && i < to; i++, walker = walker.next) {
	    ret.push(walker.value);
	  }

	  return ret;
	};

	Yallist.prototype.sliceReverse = function (from, to) {
	  to = to || this.length;

	  if (to < 0) {
	    to += this.length;
	  }

	  from = from || 0;

	  if (from < 0) {
	    from += this.length;
	  }

	  var ret = new Yallist();

	  if (to < from || to < 0) {
	    return ret;
	  }

	  if (from < 0) {
	    from = 0;
	  }

	  if (to > this.length) {
	    to = this.length;
	  }

	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
	    walker = walker.prev;
	  }

	  for (; walker !== null && i > from; i--, walker = walker.prev) {
	    ret.push(walker.value);
	  }

	  return ret;
	};

	Yallist.prototype.splice = function (start, deleteCount) {
	  if (start > this.length) {
	    start = this.length - 1;
	  }

	  if (start < 0) {
	    start = this.length + start;
	  }

	  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
	    walker = walker.next;
	  }

	  var ret = [];

	  for (var i = 0; walker && i < deleteCount; i++) {
	    ret.push(walker.value);
	    walker = this.removeNode(walker);
	  }

	  if (walker === null) {
	    walker = this.tail;
	  }

	  if (walker !== this.head && walker !== this.tail) {
	    walker = walker.prev;
	  }

	  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
	    walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
	  }

	  return ret;
	};

	Yallist.prototype.reverse = function () {
	  var head = this.head;
	  var tail = this.tail;

	  for (var walker = head; walker !== null; walker = walker.prev) {
	    var p = walker.prev;
	    walker.prev = walker.next;
	    walker.next = p;
	  }

	  this.head = tail;
	  this.tail = head;
	  return this;
	};

	function insert(self, node, value) {
	  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

	  if (inserted.next === null) {
	    self.tail = inserted;
	  }

	  if (inserted.prev === null) {
	    self.head = inserted;
	  }

	  self.length++;
	  return inserted;
	}

	function push$1(self, item) {
	  self.tail = new Node(item, self.tail, null, self);

	  if (!self.head) {
	    self.head = self.tail;
	  }

	  self.length++;
	}

	function unshift(self, item) {
	  self.head = new Node(item, null, self.head, self);

	  if (!self.tail) {
	    self.tail = self.head;
	  }

	  self.length++;
	}

	function Node(value, prev, next, list) {
	  if (!(this instanceof Node)) {
	    return new Node(value, prev, next, list);
	  }

	  this.list = list;
	  this.value = value;

	  if (prev) {
	    prev.next = this;
	    this.prev = prev;
	  } else {
	    this.prev = null;
	  }

	  if (next) {
	    next.prev = this;
	    this.next = next;
	  } else {
	    this.next = null;
	  }
	}

	try {
	  iterator(Yallist);
	} catch (er) {}

	var MAX = Symbol('max');
	var LENGTH = Symbol('length');
	var LENGTH_CALCULATOR = Symbol('lengthCalculator');
	var ALLOW_STALE = Symbol('allowStale');
	var MAX_AGE = Symbol('maxAge');
	var DISPOSE = Symbol('dispose');
	var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
	var LRU_LIST = Symbol('lruList');
	var CACHE = Symbol('cache');
	var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

	var naiveLength = function naiveLength() {
	  return 1;
	};

	var LRUCache = function () {
	  function LRUCache(options) {
	    if (typeof options === 'number') options = {
	      max: options
	    };
	    if (!options) options = {};
	    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
	    this[MAX] = options.max || Infinity;
	    var lc = options.length || naiveLength;
	    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
	    this[ALLOW_STALE] = options.stale || false;
	    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
	    this[MAX_AGE] = options.maxAge || 0;
	    this[DISPOSE] = options.dispose;
	    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
	    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
	    this.reset();
	  }

	  var _proto = LRUCache.prototype;

	  _proto.rforEach = function rforEach(fn, thisp) {
	    thisp = thisp || this;

	    for (var walker = this[LRU_LIST].tail; walker !== null;) {
	      var prev = walker.prev;
	      forEachStep(this, fn, walker, thisp);
	      walker = prev;
	    }
	  };

	  _proto.forEach = function forEach(fn, thisp) {
	    thisp = thisp || this;

	    for (var walker = this[LRU_LIST].head; walker !== null;) {
	      var next = walker.next;
	      forEachStep(this, fn, walker, thisp);
	      walker = next;
	    }
	  };

	  _proto.keys = function keys() {
	    return this[LRU_LIST].toArray().map(function (k) {
	      return k.key;
	    });
	  };

	  _proto.values = function values() {
	    return this[LRU_LIST].toArray().map(function (k) {
	      return k.value;
	    });
	  };

	  _proto.reset = function reset() {
	    var _this = this;

	    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
	      this[LRU_LIST].forEach(function (hit) {
	        return _this[DISPOSE](hit.key, hit.value);
	      });
	    }

	    this[CACHE] = new Map();
	    this[LRU_LIST] = new yallist();
	    this[LENGTH] = 0;
	  };

	  _proto.dump = function dump() {
	    var _this2 = this;

	    return this[LRU_LIST].map(function (hit) {
	      return isStale(_this2, hit) ? false : {
	        k: hit.key,
	        v: hit.value,
	        e: hit.now + (hit.maxAge || 0)
	      };
	    }).toArray().filter(function (h) {
	      return h;
	    });
	  };

	  _proto.dumpLru = function dumpLru() {
	    return this[LRU_LIST];
	  };

	  _proto.set = function set(key, value, maxAge) {
	    maxAge = maxAge || this[MAX_AGE];
	    if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
	    var now = maxAge ? Date.now() : 0;
	    var len = this[LENGTH_CALCULATOR](value, key);

	    if (this[CACHE].has(key)) {
	      if (len > this[MAX]) {
	        _del(this, this[CACHE].get(key));

	        return false;
	      }

	      var node = this[CACHE].get(key);
	      var item = node.value;

	      if (this[DISPOSE]) {
	        if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
	      }

	      item.now = now;
	      item.maxAge = maxAge;
	      item.value = value;
	      this[LENGTH] += len - item.length;
	      item.length = len;
	      this.get(key);
	      trim(this);
	      return true;
	    }

	    var hit = new Entry$1(key, value, len, now, maxAge);

	    if (hit.length > this[MAX]) {
	      if (this[DISPOSE]) this[DISPOSE](key, value);
	      return false;
	    }

	    this[LENGTH] += hit.length;
	    this[LRU_LIST].unshift(hit);
	    this[CACHE].set(key, this[LRU_LIST].head);
	    trim(this);
	    return true;
	  };

	  _proto.has = function has(key) {
	    if (!this[CACHE].has(key)) return false;
	    var hit = this[CACHE].get(key).value;
	    return !isStale(this, hit);
	  };

	  _proto.get = function get(key) {
	    return _get(this, key, true);
	  };

	  _proto.peek = function peek(key) {
	    return _get(this, key, false);
	  };

	  _proto.pop = function pop() {
	    var node = this[LRU_LIST].tail;
	    if (!node) return null;

	    _del(this, node);

	    return node.value;
	  };

	  _proto.del = function del(key) {
	    _del(this, this[CACHE].get(key));
	  };

	  _proto.load = function load(arr) {
	    this.reset();
	    var now = Date.now();

	    for (var l = arr.length - 1; l >= 0; l--) {
	      var hit = arr[l];
	      var expiresAt = hit.e || 0;
	      if (expiresAt === 0) this.set(hit.k, hit.v);else {
	        var maxAge = expiresAt - now;

	        if (maxAge > 0) {
	          this.set(hit.k, hit.v, maxAge);
	        }
	      }
	    }
	  };

	  _proto.prune = function prune() {
	    var _this3 = this;

	    this[CACHE].forEach(function (value, key) {
	      return _get(_this3, key, false);
	    });
	  };

	  _createClass(LRUCache, [{
	    key: "max",
	    get: function get() {
	      return this[MAX];
	    },
	    set: function set(mL) {
	      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
	      this[MAX] = mL || Infinity;
	      trim(this);
	    }
	  }, {
	    key: "allowStale",
	    get: function get() {
	      return this[ALLOW_STALE];
	    },
	    set: function set(allowStale) {
	      this[ALLOW_STALE] = !!allowStale;
	    }
	  }, {
	    key: "maxAge",
	    get: function get() {
	      return this[MAX_AGE];
	    },
	    set: function set(mA) {
	      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
	      this[MAX_AGE] = mA;
	      trim(this);
	    }
	  }, {
	    key: "lengthCalculator",
	    get: function get() {
	      return this[LENGTH_CALCULATOR];
	    },
	    set: function set(lC) {
	      var _this4 = this;

	      if (typeof lC !== 'function') lC = naiveLength;

	      if (lC !== this[LENGTH_CALCULATOR]) {
	        this[LENGTH_CALCULATOR] = lC;
	        this[LENGTH] = 0;
	        this[LRU_LIST].forEach(function (hit) {
	          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
	          _this4[LENGTH] += hit.length;
	        });
	      }

	      trim(this);
	    }
	  }, {
	    key: "length",
	    get: function get() {
	      return this[LENGTH];
	    }
	  }, {
	    key: "itemCount",
	    get: function get() {
	      return this[LRU_LIST].length;
	    }
	  }]);

	  return LRUCache;
	}();

	var _get = function _get(self, key, doUse) {
	  var node = self[CACHE].get(key);

	  if (node) {
	    var hit = node.value;

	    if (isStale(self, hit)) {
	      _del(self, node);

	      if (!self[ALLOW_STALE]) return undefined;
	    } else {
	      if (doUse) {
	        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
	        self[LRU_LIST].unshiftNode(node);
	      }
	    }

	    return hit.value;
	  }
	};

	var isStale = function isStale(self, hit) {
	  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
	  var diff = Date.now() - hit.now;
	  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
	};

	var trim = function trim(self) {
	  if (self[LENGTH] > self[MAX]) {
	    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
	      var prev = walker.prev;

	      _del(self, walker);

	      walker = prev;
	    }
	  }
	};

	var _del = function _del(self, node) {
	  if (node) {
	    var hit = node.value;
	    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
	    self[LENGTH] -= hit.length;
	    self[CACHE]["delete"](hit.key);
	    self[LRU_LIST].removeNode(node);
	  }
	};

	var Entry$1 = function Entry(key, value, length, now, maxAge) {
	  this.key = key;
	  this.value = value;
	  this.length = length;
	  this.now = now;
	  this.maxAge = maxAge || 0;
	};

	var forEachStep = function forEachStep(self, fn, node, thisp) {
	  var hit = node.value;

	  if (isStale(self, hit)) {
	    _del(self, node);

	    if (!self[ALLOW_STALE]) hit = undefined;
	  }

	  if (hit) fn.call(thisp, hit.value, hit.key, self);
	};

	var lruCache = LRUCache;

	var Range = function () {
	  function Range(range, options) {
	    var _this = this;

	    options = parseOptions_1(options);

	    if (range instanceof Range) {
	      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
	        return range;
	      } else {
	        return new Range(range.raw, options);
	      }
	    }

	    if (range instanceof comparator) {
	      this.raw = range.value;
	      this.set = [[range]];
	      this.format();
	      return this;
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    this.raw = range;
	    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
	      return _this.parseRange(range.trim());
	    }).filter(function (c) {
	      return c.length;
	    });

	    if (!this.set.length) {
	      throw new TypeError("Invalid SemVer Range: " + range);
	    }

	    if (this.set.length > 1) {
	      var first = this.set[0];
	      this.set = this.set.filter(function (c) {
	        return !isNullSet(c[0]);
	      });
	      if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
	        for (var _iterator = _createForOfIteratorHelperLoose(this.set), _step; !(_step = _iterator()).done;) {
	          var c = _step.value;

	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break;
	          }
	        }
	      }
	    }

	    this.format();
	  }

	  var _proto = Range.prototype;

	  _proto.format = function format() {
	    this.range = this.set.map(function (comps) {
	      return comps.join(' ').trim();
	    }).join('||').trim();
	    return this.range;
	  };

	  _proto.toString = function toString() {
	    return this.range;
	  };

	  _proto.parseRange = function parseRange(range) {
	    var _this2 = this;

	    range = range.trim();
	    var memoOpts = Object.keys(this.options).join(',');
	    var memoKey = "parseRange:" + memoOpts + ":" + range;
	    var cached = cache$1.get(memoKey);
	    if (cached) return cached;
	    var loose = this.options.loose;
	    var hr = loose ? re$4[t$b.HYPHENRANGELOOSE] : re$4[t$b.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug_1$1('hyphen replace', range);
	    range = range.replace(re$4[t$b.COMPARATORTRIM], comparatorTrimReplace);
	    debug_1$1('comparator trim', range, re$4[t$b.COMPARATORTRIM]);
	    range = range.replace(re$4[t$b.TILDETRIM], tildeTrimReplace);
	    range = range.replace(re$4[t$b.CARETTRIM], caretTrimReplace);
	    range = range.split(/\s+/).join(' ');
	    var compRe = loose ? re$4[t$b.COMPARATORLOOSE] : re$4[t$b.COMPARATOR];
	    var rangeList = range.split(' ').map(function (comp) {
	      return parseComparator(comp, _this2.options);
	    }).join(' ').split(/\s+/).map(function (comp) {
	      return replaceGTE0(comp, _this2.options);
	    }).filter(this.options.loose ? function (comp) {
	      return !!comp.match(compRe);
	    } : function () {
	      return true;
	    }).map(function (comp) {
	      return new comparator(comp, _this2.options);
	    });
	    rangeList.length;
	    var rangeMap = new Map();

	    for (var _iterator2 = _createForOfIteratorHelperLoose(rangeList), _step2; !(_step2 = _iterator2()).done;) {
	      var comp = _step2.value;
	      if (isNullSet(comp)) return [comp];
	      rangeMap.set(comp.value, comp);
	    }

	    if (rangeMap.size > 1 && rangeMap.has('')) rangeMap["delete"]('');

	    var result = _toConsumableArray(rangeMap.values());

	    cache$1.set(memoKey, result);
	    return result;
	  };

	  _proto.intersects = function intersects(range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required');
	    }

	    return this.set.some(function (thisComparators) {
	      return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
	        return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
	          return rangeComparators.every(function (rangeComparator) {
	            return thisComparator.intersects(rangeComparator, options);
	          });
	        });
	      });
	    });
	  };

	  _proto.test = function test(version) {
	    if (!version) {
	      return false;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new semver$6(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    for (var i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  return Range;
	}();

	var range = Range;
	var cache$1 = new lruCache({
	  max: 1000
	});
	var re$4 = re_1$1.re,
	    t$b = re_1$1.t,
	    comparatorTrimReplace = re_1$1.comparatorTrimReplace,
	    tildeTrimReplace = re_1$1.tildeTrimReplace,
	    caretTrimReplace = re_1$1.caretTrimReplace;

	var isNullSet = function isNullSet(c) {
	  return c.value === '<0.0.0-0';
	};

	var isAny = function isAny(c) {
	  return c.value === '';
	};

	var isSatisfiable = function isSatisfiable(comparators, options) {
	  var result = true;
	  var remainingComparators = comparators.slice();
	  var testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every(function (otherComparator) {
	      return testComparator.intersects(otherComparator, options);
	    });
	    testComparator = remainingComparators.pop();
	  }

	  return result;
	};

	var parseComparator = function parseComparator(comp, options) {
	  debug_1$1('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug_1$1('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug_1$1('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug_1$1('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug_1$1('stars', comp);
	  return comp;
	};

	var isX = function isX(id) {
	  return !id || id.toLowerCase() === 'x' || id === '*';
	};

	var replaceTildes = function replaceTildes(comp, options) {
	  return comp.trim().split(/\s+/).map(function (comp) {
	    return replaceTilde(comp, options);
	  }).join(' ');
	};

	var replaceTilde = function replaceTilde(comp, options) {
	  var r = options.loose ? re$4[t$b.TILDELOOSE] : re$4[t$b.TILDE];
	  return comp.replace(r, function (_, M, m, p, pr) {
	    debug_1$1('tilde', comp, _, M, m, p, pr);
	    var ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0-0";
	    } else if (isX(p)) {
	      ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0-0";
	    } else if (pr) {
	      debug_1$1('replaceTilde pr', pr);
	      ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
	    } else {
	      ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0-0";
	    }

	    debug_1$1('tilde return', ret);
	    return ret;
	  });
	};

	var replaceCarets = function replaceCarets(comp, options) {
	  return comp.trim().split(/\s+/).map(function (comp) {
	    return replaceCaret(comp, options);
	  }).join(' ');
	};

	var replaceCaret = function replaceCaret(comp, options) {
	  debug_1$1('caret', comp, options);
	  var r = options.loose ? re$4[t$b.CARETLOOSE] : re$4[t$b.CARET];
	  var z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, function (_, M, m, p, pr) {
	    debug_1$1('caret', comp, _, M, m, p, pr);
	    var ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = ">=" + M + ".0.0" + z + " <" + (+M + 1) + ".0.0-0";
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = ">=" + M + "." + m + ".0" + z + " <" + M + "." + (+m + 1) + ".0-0";
	      } else {
	        ret = ">=" + M + "." + m + ".0" + z + " <" + (+M + 1) + ".0.0-0";
	      }
	    } else if (pr) {
	      debug_1$1('replaceCaret pr', pr);

	      if (M === '0') {
	        if (m === '0') {
	          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) + "-0";
	        } else {
	          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
	        }
	      } else {
	        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0-0";
	      }
	    } else {
	      debug_1$1('no pr');

	      if (M === '0') {
	        if (m === '0') {
	          ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + m + "." + (+p + 1) + "-0";
	        } else {
	          ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + (+m + 1) + ".0-0";
	        }
	      } else {
	        ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0-0";
	      }
	    }

	    debug_1$1('caret return', ret);
	    return ret;
	  });
	};

	var replaceXRanges = function replaceXRanges(comp, options) {
	  debug_1$1('replaceXRanges', comp, options);
	  return comp.split(/\s+/).map(function (comp) {
	    return replaceXRange(comp, options);
	  }).join(' ');
	};

	var replaceXRange = function replaceXRange(comp, options) {
	  comp = comp.trim();
	  var r = options.loose ? re$4[t$b.XRANGELOOSE] : re$4[t$b.XRANGE];
	  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
	    debug_1$1('xRange', comp, ret, gtlt, M, m, p, pr);
	    var xM = isX(M);
	    var xm = xM || isX(m);
	    var xp = xm || isX(p);
	    var anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        ret = '<0.0.0-0';
	      } else {
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      if (xm) {
	        m = 0;
	      }

	      p = 0;

	      if (gtlt === '>') {
	        gtlt = '>=';

	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        gtlt = '<';

	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') pr = '-0';
	      ret = gtlt + M + "." + m + "." + p + pr;
	    } else if (xm) {
	      ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0-0";
	    } else if (xp) {
	      ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0-0";
	    }

	    debug_1$1('xRange return', ret);
	    return ret;
	  });
	};

	var replaceStars = function replaceStars(comp, options) {
	  debug_1$1('replaceStars', comp, options);
	  return comp.trim().replace(re$4[t$b.STAR], '');
	};

	var replaceGTE0 = function replaceGTE0(comp, options) {
	  debug_1$1('replaceGTE0', comp, options);
	  return comp.trim().replace(re$4[options.includePrerelease ? t$b.GTE0PRE : t$b.GTE0], '');
	};

	var hyphenReplace = function hyphenReplace(incPr) {
	  return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
	    if (isX(fM)) {
	      from = '';
	    } else if (isX(fm)) {
	      from = ">=" + fM + ".0.0" + (incPr ? '-0' : '');
	    } else if (isX(fp)) {
	      from = ">=" + fM + "." + fm + ".0" + (incPr ? '-0' : '');
	    } else if (fpr) {
	      from = ">=" + from;
	    } else {
	      from = ">=" + from + (incPr ? '-0' : '');
	    }

	    if (isX(tM)) {
	      to = '';
	    } else if (isX(tm)) {
	      to = "<" + (+tM + 1) + ".0.0-0";
	    } else if (isX(tp)) {
	      to = "<" + tM + "." + (+tm + 1) + ".0-0";
	    } else if (tpr) {
	      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
	    } else if (incPr) {
	      to = "<" + tM + "." + tm + "." + (+tp + 1) + "-0";
	    } else {
	      to = "<=" + to;
	    }

	    return (from + " " + to).trim();
	  };
	};

	var testSet = function testSet(set, version, options) {
	  for (var i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false;
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    for (var _i = 0; _i < set.length; _i++) {
	      debug_1$1(set[_i].semver);

	      if (set[_i].semver === comparator.ANY) {
	        continue;
	      }

	      if (set[_i].semver.prerelease.length > 0) {
	        var allowed = set[_i].semver;

	        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return true;
	};

	var ANY$2 = Symbol('SemVer ANY');

	var Comparator = function () {
	  function Comparator(comp, options) {
	    options = parseOptions_1(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp;
	      } else {
	        comp = comp.value;
	      }
	    }

	    debug_1$1('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY$2) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug_1$1('comp', this);
	  }

	  var _proto = Comparator.prototype;

	  _proto.parse = function parse(comp) {
	    var r = this.options.loose ? re$3[t$a.COMPARATORLOOSE] : re$3[t$a.COMPARATOR];
	    var m = comp.match(r);

	    if (!m) {
	      throw new TypeError("Invalid comparator: " + comp);
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';

	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    if (!m[2]) {
	      this.semver = ANY$2;
	    } else {
	      this.semver = new semver$6(m[2], this.options.loose);
	    }
	  };

	  _proto.toString = function toString() {
	    return this.value;
	  };

	  _proto.test = function test(version) {
	    debug_1$1('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY$2 || version === ANY$2) {
	      return true;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new semver$6(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    return cmp_1$1(version, this.operator, this.semver, this.options);
	  };

	  _proto.intersects = function intersects(comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required');
	    }

	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true;
	      }

	      return new range(comp.value, options).test(this.value);
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true;
	      }

	      return new range(this.value, options).test(comp.semver);
	    }

	    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
	    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
	    var sameSemVer = this.semver.version === comp.semver.version;
	    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
	    var oppositeDirectionsLessThan = cmp_1$1(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
	    var oppositeDirectionsGreaterThan = cmp_1$1(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
	    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
	  };

	  _createClass(Comparator, null, [{
	    key: "ANY",
	    get: function get() {
	      return ANY$2;
	    }
	  }]);

	  return Comparator;
	}();

	var comparator = Comparator;
	var re$3 = re_1$1.re,
	    t$a = re_1$1.t;

	var satisfies = function satisfies(version, range$1, options) {
	  try {
	    range$1 = new range(range$1, options);
	  } catch (er) {
	    return false;
	  }

	  return range$1.test(version);
	};

	var satisfies_1 = satisfies;

	var toComparators = function toComparators(range$1, options) {
	  return new range(range$1, options).set.map(function (comp) {
	    return comp.map(function (c) {
	      return c.value;
	    }).join(' ').trim().split(' ');
	  });
	};

	var toComparators_1 = toComparators;

	var maxSatisfying = function maxSatisfying(versions, range$1, options) {
	  var max = null;
	  var maxSV = null;
	  var rangeObj = null;

	  try {
	    rangeObj = new range(range$1, options);
	  } catch (er) {
	    return null;
	  }

	  versions.forEach(function (v) {
	    if (rangeObj.test(v)) {
	      if (!max || maxSV.compare(v) === -1) {
	        max = v;
	        maxSV = new semver$6(max, options);
	      }
	    }
	  });
	  return max;
	};

	var maxSatisfying_1 = maxSatisfying;

	var minSatisfying = function minSatisfying(versions, range$1, options) {
	  var min = null;
	  var minSV = null;
	  var rangeObj = null;

	  try {
	    rangeObj = new range(range$1, options);
	  } catch (er) {
	    return null;
	  }

	  versions.forEach(function (v) {
	    if (rangeObj.test(v)) {
	      if (!min || minSV.compare(v) === 1) {
	        min = v;
	        minSV = new semver$6(min, options);
	      }
	    }
	  });
	  return min;
	};

	var minSatisfying_1 = minSatisfying;

	var minVersion = function minVersion(range$1, loose) {
	  range$1 = new range(range$1, loose);
	  var minver = new semver$6('0.0.0');

	  if (range$1.test(minver)) {
	    return minver;
	  }

	  minver = new semver$6('0.0.0-0');

	  if (range$1.test(minver)) {
	    return minver;
	  }

	  minver = null;

	  var _loop = function _loop(i) {
	    var comparators = range$1.set[i];
	    var setMin = null;
	    comparators.forEach(function (comparator) {
	      var compver = new semver$6(comparator.semver.version);

	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }

	          compver.raw = compver.format();

	        case '':
	        case '>=':
	          if (!setMin || gt_1$1(compver, setMin)) {
	            setMin = compver;
	          }

	          break;

	        case '<':
	        case '<=':
	          break;

	        default:
	          throw new Error("Unexpected operation: " + comparator.operator);
	      }
	    });
	    if (setMin && (!minver || gt_1$1(minver, setMin))) minver = setMin;
	  };

	  for (var i = 0; i < range$1.set.length; ++i) {
	    _loop(i);
	  }

	  if (minver && range$1.test(minver)) {
	    return minver;
	  }

	  return null;
	};

	var minVersion_1 = minVersion;

	var validRange = function validRange(range$1, options) {
	  try {
	    return new range(range$1, options).range || '*';
	  } catch (er) {
	    return null;
	  }
	};

	var valid = validRange;

	var ANY$1 = comparator.ANY;

	var outside = function outside(version, range$1, hilo, options) {
	  version = new semver$6(version, options);
	  range$1 = new range(range$1, options);
	  var gtfn, ltefn, ltfn, comp, ecomp;

	  switch (hilo) {
	    case '>':
	      gtfn = gt_1$1;
	      ltefn = lte_1$1;
	      ltfn = lt_1$1;
	      comp = '>';
	      ecomp = '>=';
	      break;

	    case '<':
	      gtfn = lt_1$1;
	      ltefn = gte_1$1;
	      ltfn = gt_1$1;
	      comp = '<';
	      ecomp = '<=';
	      break;

	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"');
	  }

	  if (satisfies_1(version, range$1, options)) {
	    return false;
	  }

	  var _loop = function _loop(i) {
	    var comparators = range$1.set[i];
	    var high = null;
	    var low = null;
	    comparators.forEach(function (comparator$1) {
	      if (comparator$1.semver === ANY$1) {
	        comparator$1 = new comparator('>=0.0.0');
	      }

	      high = high || comparator$1;
	      low = low || comparator$1;

	      if (gtfn(comparator$1.semver, high.semver, options)) {
	        high = comparator$1;
	      } else if (ltfn(comparator$1.semver, low.semver, options)) {
	        low = comparator$1;
	      }
	    });

	    if (high.operator === comp || high.operator === ecomp) {
	      return {
	        v: false
	      };
	    }

	    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
	      return {
	        v: false
	      };
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return {
	        v: false
	      };
	    }
	  };

	  for (var i = 0; i < range$1.set.length; ++i) {
	    var _ret = _loop(i);

	    if (typeof _ret === "object") return _ret.v;
	  }

	  return true;
	};

	var outside_1 = outside;

	var gtr = function gtr(version, range, options) {
	  return outside_1(version, range, '>', options);
	};

	var gtr_1 = gtr;

	var ltr = function ltr(version, range, options) {
	  return outside_1(version, range, '<', options);
	};

	var ltr_1 = ltr;

	var intersects = function intersects(r1, r2, options) {
	  r1 = new range(r1, options);
	  r2 = new range(r2, options);
	  return r1.intersects(r2);
	};

	var intersects_1 = intersects;

	var simplify = function simplify(versions, range, options) {
	  var set = [];
	  var min = null;
	  var prev = null;
	  var v = versions.sort(function (a, b) {
	    return compare_1$1(a, b, options);
	  });

	  for (var _iterator = _createForOfIteratorHelperLoose(v), _step; !(_step = _iterator()).done;) {
	    var version = _step.value;
	    var included = satisfies_1(version, range, options);

	    if (included) {
	      prev = version;
	      if (!min) min = version;
	    } else {
	      if (prev) {
	        set.push([min, prev]);
	      }

	      prev = null;
	      min = null;
	    }
	  }

	  if (min) set.push([min, null]);
	  var ranges = [];

	  for (var _i = 0, _set = set; _i < _set.length; _i++) {
	    var _set$_i = _slicedToArray$1(_set[_i], 2),
	        _min = _set$_i[0],
	        max = _set$_i[1];

	    if (_min === max) ranges.push(_min);else if (!max && _min === v[0]) ranges.push('*');else if (!max) ranges.push(">=" + _min);else if (_min === v[0]) ranges.push("<=" + max);else ranges.push(_min + " - " + max);
	  }

	  var simplified = ranges.join(' || ');
	  var original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range;
	};

	var ANY = comparator.ANY;

	var subset = function subset(sub, dom, options) {
	  if (sub === dom) return true;
	  sub = new range(sub, options);
	  dom = new range(dom, options);
	  var sawNonNull = false;

	  OUTER: for (var _iterator = _createForOfIteratorHelperLoose(sub.set), _step; !(_step = _iterator()).done;) {
	    var simpleSub = _step.value;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(dom.set), _step2; !(_step2 = _iterator2()).done;) {
	      var simpleDom = _step2.value;
	      var isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) continue OUTER;
	    }

	    if (sawNonNull) return false;
	  }

	  return true;
	};

	var simpleSubset = function simpleSubset(sub, dom, options) {
	  if (sub === dom) return true;
	  if (sub.length === 1 && sub[0].semver === ANY) return dom.length === 1 && dom[0].semver === ANY;
	  var eqSet = new Set();
	  var gt, lt;

	  for (var _iterator3 = _createForOfIteratorHelperLoose(sub), _step3; !(_step3 = _iterator3()).done;) {
	    var c = _step3.value;
	    if (c.operator === '>' || c.operator === '>=') gt = higherGT(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = lowerLT(lt, c, options);else eqSet.add(c.semver);
	  }

	  if (eqSet.size > 1) return null;
	  var gtltComp;

	  if (gt && lt) {
	    gtltComp = compare_1$1(gt.semver, lt.semver, options);
	    if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;
	  }

	  for (var _iterator4 = _createForOfIteratorHelperLoose(eqSet), _step4; !(_step4 = _iterator4()).done;) {
	    var eq = _step4.value;
	    if (gt && !satisfies_1(eq, String(gt), options)) return null;
	    if (lt && !satisfies_1(eq, String(lt), options)) return null;

	    for (var _iterator6 = _createForOfIteratorHelperLoose(dom), _step6; !(_step6 = _iterator6()).done;) {
	      var _c = _step6.value;
	      if (!satisfies_1(eq, String(_c), options)) return false;
	    }

	    return true;
	  }

	  var higher, lower;
	  var hasDomLT, hasDomGT;

	  for (var _iterator5 = _createForOfIteratorHelperLoose(dom), _step5; !(_step5 = _iterator5()).done;) {
	    var _c2 = _step5.value;
	    hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
	    hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

	    if (gt) {
	      if (_c2.operator === '>' || _c2.operator === '>=') {
	        higher = higherGT(gt, _c2, options);
	        if (higher === _c2 && higher !== gt) return false;
	      } else if (gt.operator === '>=' && !satisfies_1(gt.semver, String(_c2), options)) return false;
	    }

	    if (lt) {
	      if (_c2.operator === '<' || _c2.operator === '<=') {
	        lower = lowerLT(lt, _c2, options);
	        if (lower === _c2 && lower !== lt) return false;
	      } else if (lt.operator === '<=' && !satisfies_1(lt.semver, String(_c2), options)) return false;
	    }

	    if (!_c2.operator && (lt || gt) && gtltComp !== 0) return false;
	  }

	  if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
	  if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
	  return true;
	};

	var higherGT = function higherGT(a, b, options) {
	  if (!a) return b;
	  var comp = compare_1$1(a.semver, b.semver, options);
	  return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
	};

	var lowerLT = function lowerLT(a, b, options) {
	  if (!a) return b;
	  var comp = compare_1$1(a.semver, b.semver, options);
	  return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
	};

	var subset_1 = subset;

	({
	  re: re_1$1.re,
	  src: re_1$1.src,
	  tokens: re_1$1.t,
	  SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
	  SemVer: semver$6,
	  compareIdentifiers: identifiers$1.compareIdentifiers,
	  rcompareIdentifiers: identifiers$1.rcompareIdentifiers,
	  parse: parse_1$1,
	  valid: valid_1,
	  clean: clean_1,
	  inc: inc_1,
	  diff: diff_1,
	  major: major_1,
	  minor: minor_1,
	  patch: patch_1,
	  prerelease: prerelease_1,
	  compare: compare_1$1,
	  rcompare: rcompare_1,
	  compareLoose: compareLoose_1,
	  compareBuild: compareBuild_1,
	  sort: sort_1,
	  rsort: rsort_1,
	  gt: gt_1$1,
	  lt: lt_1$1,
	  eq: eq_1$1,
	  neq: neq_1$1,
	  gte: gte_1$1,
	  lte: lte_1$1,
	  cmp: cmp_1$1,
	  coerce: coerce_1$1,
	  Comparator: comparator,
	  Range: range,
	  satisfies: satisfies_1,
	  toComparators: toComparators_1,
	  maxSatisfying: maxSatisfying_1,
	  minSatisfying: minSatisfying_1,
	  minVersion: minVersion_1,
	  validRange: valid,
	  outside: outside_1,
	  gtr: gtr_1,
	  ltr: ltr_1,
	  intersects: intersects_1,
	  simplifyRange: simplify,
	  subset: subset_1
	});

	var semver$5 = createCommonjsModule(function (module, exports) {
	  exports = module.exports = SemVer;
	  var debug;

	  if (typeof browser$4 === 'object' && browser$4.env && browser$4.env.NODE_DEBUG && /\bsemver\b/i.test(browser$4.env.NODE_DEBUG)) {
	    debug = function debug() {
	      var args = Array.prototype.slice.call(arguments, 0);
	      args.unshift('SEMVER');
	      console.log.apply(console, args);
	    };
	  } else {
	    debug = function debug() {};
	  }

	  exports.SEMVER_SPEC_VERSION = '2.0.0';
	  var MAX_LENGTH = 256;
	  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	  var MAX_SAFE_COMPONENT_LENGTH = 16;
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var t = exports.tokens = {};
	  var R = 0;

	  function tok(n) {
	    t[n] = R++;
	  }

	  tok('NUMERICIDENTIFIER');
	  src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	  tok('NUMERICIDENTIFIERLOOSE');
	  src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
	  tok('NONNUMERICIDENTIFIER');
	  src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
	  tok('MAINVERSION');
	  src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
	  tok('MAINVERSIONLOOSE');
	  src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
	  tok('PRERELEASEIDENTIFIER');
	  src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASEIDENTIFIERLOOSE');
	  src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASE');
	  src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
	  tok('PRERELEASELOOSE');
	  src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
	  tok('BUILDIDENTIFIER');
	  src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
	  tok('BUILD');
	  src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
	  tok('FULL');
	  tok('FULLPLAIN');
	  src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
	  src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
	  tok('LOOSEPLAIN');
	  src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
	  tok('LOOSE');
	  src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
	  tok('GTLT');
	  src[t.GTLT] = '((?:<|>)?=?)';
	  tok('XRANGEIDENTIFIERLOOSE');
	  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	  tok('XRANGEIDENTIFIER');
	  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
	  tok('XRANGEPLAIN');
	  src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGEPLAINLOOSE');
	  src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGE');
	  src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
	  tok('XRANGELOOSE');
	  src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COERCE');
	  src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
	  tok('COERCERTL');
	  re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
	  tok('LONETILDE');
	  src[t.LONETILDE] = '(?:~>?)';
	  tok('TILDETRIM');
	  src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
	  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
	  var tildeTrimReplace = '$1~';
	  tok('TILDE');
	  src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
	  tok('TILDELOOSE');
	  src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('LONECARET');
	  src[t.LONECARET] = '(?:\\^)';
	  tok('CARETTRIM');
	  src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
	  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
	  var caretTrimReplace = '$1^';
	  tok('CARET');
	  src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
	  tok('CARETLOOSE');
	  src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COMPARATORLOOSE');
	  src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
	  tok('COMPARATOR');
	  src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
	  tok('COMPARATORTRIM');
	  src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
	  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
	  var comparatorTrimReplace = '$1$2$3';
	  tok('HYPHENRANGE');
	  src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
	  tok('HYPHENRANGELOOSE');
	  src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
	  tok('STAR');
	  src[t.STAR] = '(<|>)?=?\\s*\\*';

	  for (var i = 0; i < R; i++) {
	    debug(i, src[i]);

	    if (!re[i]) {
	      re[i] = new RegExp(src[i]);
	    }
	  }

	  exports.parse = parse;

	  function parse(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    if (version.length > MAX_LENGTH) {
	      return null;
	    }

	    var r = options.loose ? re[t.LOOSE] : re[t.FULL];

	    if (!r.test(version)) {
	      return null;
	    }

	    try {
	      return new SemVer(version, options);
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.valid = valid;

	  function valid(version, options) {
	    var v = parse(version, options);
	    return v ? v.version : null;
	  }

	  exports.clean = clean;

	  function clean(version, options) {
	    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
	    return s ? s.version : null;
	  }

	  exports.SemVer = SemVer;

	  function SemVer(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      if (version.loose === options.loose) {
	        return version;
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
	    }

	    if (!(this instanceof SemVer)) {
	      return new SemVer(version, options);
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version');
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version');
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version');
	    }

	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map(function (id) {
	        if (/^[0-9]+$/.test(id)) {
	          var num = +id;

	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num;
	          }
	        }

	        return id;
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  SemVer.prototype.format = function () {
	    this.version = this.major + '.' + this.minor + '.' + this.patch;

	    if (this.prerelease.length) {
	      this.version += '-' + this.prerelease.join('.');
	    }

	    return this.version;
	  };

	  SemVer.prototype.toString = function () {
	    return this.version;
	  };

	  SemVer.prototype.compare = function (other) {
	    debug('SemVer.compare', this.version, this.options, other);

	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  SemVer.prototype.compareMain = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
	  };

	  SemVer.prototype.comparePre = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1;
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1;
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0;
	    }

	    var i = 0;

	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.compareBuild = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    var i = 0;

	    do {
	      var a = this.build[i];
	      var b = other.build[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.inc = function (release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;

	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;

	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier);
	        }

	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
	          this.major++;
	        }

	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }

	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }

	        this.prerelease = [];
	        break;

	      case 'pre':
	        if (this.prerelease.length === 0) {
	          this.prerelease = [0];
	        } else {
	          var i = this.prerelease.length;

	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }

	          if (i === -1) {
	            this.prerelease.push(0);
	          }
	        }

	        if (identifier) {
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = [identifier, 0];
	            }
	          } else {
	            this.prerelease = [identifier, 0];
	          }
	        }

	        break;

	      default:
	        throw new Error('invalid increment argument: ' + release);
	    }

	    this.format();
	    this.raw = this.version;
	    return this;
	  };

	  exports.inc = inc;

	  function inc(version, release, loose, identifier) {
	    if (typeof loose === 'string') {
	      identifier = loose;
	      loose = undefined;
	    }

	    try {
	      return new SemVer(version, loose).inc(release, identifier).version;
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.diff = diff;

	  function diff(version1, version2) {
	    if (eq(version1, version2)) {
	      return null;
	    } else {
	      var v1 = parse(version1);
	      var v2 = parse(version2);
	      var prefix = '';

	      if (v1.prerelease.length || v2.prerelease.length) {
	        prefix = 'pre';
	        var defaultResult = 'prerelease';
	      }

	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return prefix + key;
	          }
	        }
	      }

	      return defaultResult;
	    }
	  }

	  exports.compareIdentifiers = compareIdentifiers;
	  var numeric = /^[0-9]+$/;

	  function compareIdentifiers(a, b) {
	    var anum = numeric.test(a);
	    var bnum = numeric.test(b);

	    if (anum && bnum) {
	      a = +a;
	      b = +b;
	    }

	    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	  }

	  exports.rcompareIdentifiers = rcompareIdentifiers;

	  function rcompareIdentifiers(a, b) {
	    return compareIdentifiers(b, a);
	  }

	  exports.major = major;

	  function major(a, loose) {
	    return new SemVer(a, loose).major;
	  }

	  exports.minor = minor;

	  function minor(a, loose) {
	    return new SemVer(a, loose).minor;
	  }

	  exports.patch = patch;

	  function patch(a, loose) {
	    return new SemVer(a, loose).patch;
	  }

	  exports.compare = compare;

	  function compare(a, b, loose) {
	    return new SemVer(a, loose).compare(new SemVer(b, loose));
	  }

	  exports.compareLoose = compareLoose;

	  function compareLoose(a, b) {
	    return compare(a, b, true);
	  }

	  exports.compareBuild = compareBuild;

	  function compareBuild(a, b, loose) {
	    var versionA = new SemVer(a, loose);
	    var versionB = new SemVer(b, loose);
	    return versionA.compare(versionB) || versionA.compareBuild(versionB);
	  }

	  exports.rcompare = rcompare;

	  function rcompare(a, b, loose) {
	    return compare(b, a, loose);
	  }

	  exports.sort = sort;

	  function sort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(a, b, loose);
	    });
	  }

	  exports.rsort = rsort;

	  function rsort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(b, a, loose);
	    });
	  }

	  exports.gt = gt;

	  function gt(a, b, loose) {
	    return compare(a, b, loose) > 0;
	  }

	  exports.lt = lt;

	  function lt(a, b, loose) {
	    return compare(a, b, loose) < 0;
	  }

	  exports.eq = eq;

	  function eq(a, b, loose) {
	    return compare(a, b, loose) === 0;
	  }

	  exports.neq = neq;

	  function neq(a, b, loose) {
	    return compare(a, b, loose) !== 0;
	  }

	  exports.gte = gte;

	  function gte(a, b, loose) {
	    return compare(a, b, loose) >= 0;
	  }

	  exports.lte = lte;

	  function lte(a, b, loose) {
	    return compare(a, b, loose) <= 0;
	  }

	  exports.cmp = cmp;

	  function cmp(a, op, b, loose) {
	    switch (op) {
	      case '===':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a === b;

	      case '!==':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a !== b;

	      case '':
	      case '=':
	      case '==':
	        return eq(a, b, loose);

	      case '!=':
	        return neq(a, b, loose);

	      case '>':
	        return gt(a, b, loose);

	      case '>=':
	        return gte(a, b, loose);

	      case '<':
	        return lt(a, b, loose);

	      case '<=':
	        return lte(a, b, loose);

	      default:
	        throw new TypeError('Invalid operator: ' + op);
	    }
	  }

	  exports.Comparator = Comparator;

	  function Comparator(comp, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp;
	      } else {
	        comp = comp.value;
	      }
	    }

	    if (!(this instanceof Comparator)) {
	      return new Comparator(comp, options);
	    }

	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  var ANY = {};

	  Comparator.prototype.parse = function (comp) {
	    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var m = comp.match(r);

	    if (!m) {
	      throw new TypeError('Invalid comparator: ' + comp);
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';

	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  };

	  Comparator.prototype.toString = function () {
	    return this.value;
	  };

	  Comparator.prototype.test = function (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options);
	  };

	  Comparator.prototype.intersects = function (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required');
	    }

	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    var rangeTmp;

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(comp.value, options);
	      return satisfies(this.value, rangeTmp, options);
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(this.value, options);
	      return satisfies(comp.semver, rangeTmp, options);
	    }

	    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
	    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
	    var sameSemVer = this.semver.version === comp.semver.version;
	    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
	    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
	    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
	    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
	  };

	  exports.Range = Range;

	  function Range(range, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (range instanceof Range) {
	      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
	        return range;
	      } else {
	        return new Range(range.raw, options);
	      }
	    }

	    if (range instanceof Comparator) {
	      return new Range(range.value, options);
	    }

	    if (!(this instanceof Range)) {
	      return new Range(range, options);
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    this.raw = range;
	    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
	      return this.parseRange(range.trim());
	    }, this).filter(function (c) {
	      return c.length;
	    });

	    if (!this.set.length) {
	      throw new TypeError('Invalid SemVer Range: ' + range);
	    }

	    this.format();
	  }

	  Range.prototype.format = function () {
	    this.range = this.set.map(function (comps) {
	      return comps.join(' ').trim();
	    }).join('||').trim();
	    return this.range;
	  };

	  Range.prototype.toString = function () {
	    return this.range;
	  };

	  Range.prototype.parseRange = function (range) {
	    var loose = this.options.loose;
	    range = range.trim();
	    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace);
	    debug('hyphen replace', range);
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range, re[t.COMPARATORTRIM]);
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    range = range.split(/\s+/).join(' ');
	    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var set = range.split(' ').map(function (comp) {
	      return parseComparator(comp, this.options);
	    }, this).join(' ').split(/\s+/);

	    if (this.options.loose) {
	      set = set.filter(function (comp) {
	        return !!comp.match(compRe);
	      });
	    }

	    set = set.map(function (comp) {
	      return new Comparator(comp, this.options);
	    }, this);
	    return set;
	  };

	  Range.prototype.intersects = function (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required');
	    }

	    return this.set.some(function (thisComparators) {
	      return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
	        return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
	          return rangeComparators.every(function (rangeComparator) {
	            return thisComparator.intersects(rangeComparator, options);
	          });
	        });
	      });
	    });
	  };

	  function isSatisfiable(comparators, options) {
	    var result = true;
	    var remainingComparators = comparators.slice();
	    var testComparator = remainingComparators.pop();

	    while (result && remainingComparators.length) {
	      result = remainingComparators.every(function (otherComparator) {
	        return testComparator.intersects(otherComparator, options);
	      });
	      testComparator = remainingComparators.pop();
	    }

	    return result;
	  }

	  exports.toComparators = toComparators;

	  function toComparators(range, options) {
	    return new Range(range, options).set.map(function (comp) {
	      return comp.map(function (c) {
	        return c.value;
	      }).join(' ').trim().split(' ');
	    });
	  }

	  function parseComparator(comp, options) {
	    debug('comp', comp, options);
	    comp = replaceCarets(comp, options);
	    debug('caret', comp);
	    comp = replaceTildes(comp, options);
	    debug('tildes', comp);
	    comp = replaceXRanges(comp, options);
	    debug('xrange', comp);
	    comp = replaceStars(comp, options);
	    debug('stars', comp);
	    return comp;
	  }

	  function isX(id) {
	    return !id || id.toLowerCase() === 'x' || id === '*';
	  }

	  function replaceTildes(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceTilde(comp, options);
	    }).join(' ');
	  }

	  function replaceTilde(comp, options) {
	    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('tilde', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      } else if (pr) {
	        debug('replaceTilde pr', pr);
	        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	      } else {
	        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	      }

	      debug('tilde return', ret);
	      return ret;
	    });
	  }

	  function replaceCarets(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceCaret(comp, options);
	    }).join(' ');
	  }

	  function replaceCaret(comp, options) {
	    debug('caret', comp, options);
	    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('caret', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        if (M === '0') {
	          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	        } else {
	          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	        }
	      } else if (pr) {
	        debug('replaceCaret pr', pr);

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
	        }
	      } else {
	        debug('no pr');

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
	        }
	      }

	      debug('caret return', ret);
	      return ret;
	    });
	  }

	  function replaceXRanges(comp, options) {
	    debug('replaceXRanges', comp, options);
	    return comp.split(/\s+/).map(function (comp) {
	      return replaceXRange(comp, options);
	    }).join(' ');
	  }

	  function replaceXRange(comp, options) {
	    comp = comp.trim();
	    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
	      debug('xRange', comp, ret, gtlt, M, m, p, pr);
	      var xM = isX(M);
	      var xm = xM || isX(m);
	      var xp = xm || isX(p);
	      var anyX = xp;

	      if (gtlt === '=' && anyX) {
	        gtlt = '';
	      }

	      pr = options.includePrerelease ? '-0' : '';

	      if (xM) {
	        if (gtlt === '>' || gtlt === '<') {
	          ret = '<0.0.0-0';
	        } else {
	          ret = '*';
	        }
	      } else if (gtlt && anyX) {
	        if (xm) {
	          m = 0;
	        }

	        p = 0;

	        if (gtlt === '>') {
	          gtlt = '>=';

	          if (xm) {
	            M = +M + 1;
	            m = 0;
	            p = 0;
	          } else {
	            m = +m + 1;
	            p = 0;
	          }
	        } else if (gtlt === '<=') {
	          gtlt = '<';

	          if (xm) {
	            M = +M + 1;
	          } else {
	            m = +m + 1;
	          }
	        }

	        ret = gtlt + M + '.' + m + '.' + p + pr;
	      } else if (xm) {
	        ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
	      } else if (xp) {
	        ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
	      }

	      debug('xRange return', ret);
	      return ret;
	    });
	  }

	  function replaceStars(comp, options) {
	    debug('replaceStars', comp, options);
	    return comp.trim().replace(re[t.STAR], '');
	  }

	  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
	    if (isX(fM)) {
	      from = '';
	    } else if (isX(fm)) {
	      from = '>=' + fM + '.0.0';
	    } else if (isX(fp)) {
	      from = '>=' + fM + '.' + fm + '.0';
	    } else {
	      from = '>=' + from;
	    }

	    if (isX(tM)) {
	      to = '';
	    } else if (isX(tm)) {
	      to = '<' + (+tM + 1) + '.0.0';
	    } else if (isX(tp)) {
	      to = '<' + tM + '.' + (+tm + 1) + '.0';
	    } else if (tpr) {
	      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	    } else {
	      to = '<=' + to;
	    }

	    return (from + ' ' + to).trim();
	  }

	  Range.prototype.test = function (version) {
	    if (!version) {
	      return false;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    for (var i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  function testSet(set, version, options) {
	    for (var i = 0; i < set.length; i++) {
	      if (!set[i].test(version)) {
	        return false;
	      }
	    }

	    if (version.prerelease.length && !options.includePrerelease) {
	      for (i = 0; i < set.length; i++) {
	        debug(set[i].semver);

	        if (set[i].semver === ANY) {
	          continue;
	        }

	        if (set[i].semver.prerelease.length > 0) {
	          var allowed = set[i].semver;

	          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
	            return true;
	          }
	        }
	      }

	      return false;
	    }

	    return true;
	  }

	  exports.satisfies = satisfies;

	  function satisfies(version, range, options) {
	    try {
	      range = new Range(range, options);
	    } catch (er) {
	      return false;
	    }

	    return range.test(version);
	  }

	  exports.maxSatisfying = maxSatisfying;

	  function maxSatisfying(versions, range, options) {
	    var max = null;
	    var maxSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!max || maxSV.compare(v) === -1) {
	          max = v;
	          maxSV = new SemVer(max, options);
	        }
	      }
	    });
	    return max;
	  }

	  exports.minSatisfying = minSatisfying;

	  function minSatisfying(versions, range, options) {
	    var min = null;
	    var minSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!min || minSV.compare(v) === 1) {
	          min = v;
	          minSV = new SemVer(min, options);
	        }
	      }
	    });
	    return min;
	  }

	  exports.minVersion = minVersion;

	  function minVersion(range, loose) {
	    range = new Range(range, loose);
	    var minver = new SemVer('0.0.0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = new SemVer('0.0.0-0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = null;

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      comparators.forEach(function (comparator) {
	        var compver = new SemVer(comparator.semver.version);

	        switch (comparator.operator) {
	          case '>':
	            if (compver.prerelease.length === 0) {
	              compver.patch++;
	            } else {
	              compver.prerelease.push(0);
	            }

	            compver.raw = compver.format();

	          case '':
	          case '>=':
	            if (!minver || gt(minver, compver)) {
	              minver = compver;
	            }

	            break;

	          case '<':
	          case '<=':
	            break;

	          default:
	            throw new Error('Unexpected operation: ' + comparator.operator);
	        }
	      });
	    }

	    if (minver && range.test(minver)) {
	      return minver;
	    }

	    return null;
	  }

	  exports.validRange = validRange;

	  function validRange(range, options) {
	    try {
	      return new Range(range, options).range || '*';
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.ltr = ltr;

	  function ltr(version, range, options) {
	    return outside(version, range, '<', options);
	  }

	  exports.gtr = gtr;

	  function gtr(version, range, options) {
	    return outside(version, range, '>', options);
	  }

	  exports.outside = outside;

	  function outside(version, range, hilo, options) {
	    version = new SemVer(version, options);
	    range = new Range(range, options);
	    var gtfn, ltefn, ltfn, comp, ecomp;

	    switch (hilo) {
	      case '>':
	        gtfn = gt;
	        ltefn = lte;
	        ltfn = lt;
	        comp = '>';
	        ecomp = '>=';
	        break;

	      case '<':
	        gtfn = lt;
	        ltefn = gte;
	        ltfn = gt;
	        comp = '<';
	        ecomp = '<=';
	        break;

	      default:
	        throw new TypeError('Must provide a hilo val of "<" or ">"');
	    }

	    if (satisfies(version, range, options)) {
	      return false;
	    }

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      var high = null;
	      var low = null;
	      comparators.forEach(function (comparator) {
	        if (comparator.semver === ANY) {
	          comparator = new Comparator('>=0.0.0');
	        }

	        high = high || comparator;
	        low = low || comparator;

	        if (gtfn(comparator.semver, high.semver, options)) {
	          high = comparator;
	        } else if (ltfn(comparator.semver, low.semver, options)) {
	          low = comparator;
	        }
	      });

	      if (high.operator === comp || high.operator === ecomp) {
	        return false;
	      }

	      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
	        return false;
	      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  exports.prerelease = prerelease;

	  function prerelease(version, options) {
	    var parsed = parse(version, options);
	    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	  }

	  exports.intersects = intersects;

	  function intersects(r1, r2, options) {
	    r1 = new Range(r1, options);
	    r2 = new Range(r2, options);
	    return r1.intersects(r2);
	  }

	  exports.coerce = coerce;

	  function coerce(version, options) {
	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version === 'number') {
	      version = String(version);
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    options = options || {};
	    var match = null;

	    if (!options.rtl) {
	      match = version.match(re[t.COERCE]);
	    } else {
	      var next;

	      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
	        if (!match || next.index + next[0].length !== match.index + match[0].length) {
	          match = next;
	        }

	        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
	      }

	      re[t.COERCERTL].lastIndex = -1;
	    }

	    if (match === null) {
	      return null;
	    }

	    return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
	  }
	}, "/$$rollup_base$$/node_modules/semver-BABEL_8_BREAKING-false");

	var semver$4 = semver$5;

	var cloneNode$5 = cloneNode$i,
	    interpreterDirective = interpreterDirective$1;
	var errorVisitor = {
	  enter: function enter(path, state) {
	    var loc = path.node.loc;

	    if (loc) {
	      state.loc = loc;
	      path.stop();
	    }
	  }
	};

	var File = function () {
	  function File(options, _ref) {
	    var _this = this;

	    var code = _ref.code,
	        ast = _ref.ast,
	        inputMap = _ref.inputMap;
	    this._map = new Map();
	    this.opts = void 0;
	    this.declarations = {};
	    this.path = null;
	    this.ast = {};
	    this.scope = void 0;
	    this.metadata = {};
	    this.code = "";
	    this.inputMap = null;
	    this.hub = {
	      file: this,
	      getCode: function getCode() {
	        return _this.code;
	      },
	      getScope: function getScope() {
	        return _this.scope;
	      },
	      addHelper: this.addHelper.bind(this),
	      buildError: this.buildCodeFrameError.bind(this)
	    };
	    this.opts = options;
	    this.code = code;
	    this.ast = ast;
	    this.inputMap = inputMap;
	    this.path = NodePath.get({
	      hub: this.hub,
	      parentPath: null,
	      parent: this.ast,
	      container: this.ast,
	      key: "program"
	    }).setContext();
	    this.scope = this.path.scope;
	  }

	  var _proto = File.prototype;

	  _proto.set = function set(key, val) {
	    if (key === "helpersNamespace") {
	      throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
	    }

	    this._map.set(key, val);
	  };

	  _proto.get = function get(key) {
	    return this._map.get(key);
	  };

	  _proto.has = function has(key) {
	    return this._map.has(key);
	  };

	  _proto.getModuleName = function getModuleName$1() {
	    return getModuleName(this.opts, this.opts);
	  };

	  _proto.addImport = function addImport() {
	    throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
	  };

	  _proto.availableHelper = function availableHelper(name, versionRange) {
	    var minVersion;

	    try {
	      minVersion = minVersion$1(name);
	    } catch (err) {
	      if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
	      return false;
	    }

	    if (typeof versionRange !== "string") return true;
	    if (semver$4.valid(versionRange)) versionRange = "^" + versionRange;
	    return !semver$4.intersects("<" + minVersion, versionRange) && !semver$4.intersects(">=8.0.0", versionRange);
	  };

	  _proto.addHelper = function addHelper(name) {
	    var _this2 = this;

	    var declar = this.declarations[name];
	    if (declar) return cloneNode$5(declar);
	    var generator = this.get("helperGenerator");

	    if (generator) {
	      var res = generator(name);
	      if (res) return res;
	    }

	    ensure(name, File);
	    var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
	    var dependencies = {};

	    for (var _iterator = _createForOfIteratorHelperLoose(getDependencies(name)), _step; !(_step = _iterator()).done;) {
	      var dep = _step.value;
	      dependencies[dep] = this.addHelper(dep);
	    }

	    var _helpers$get = get$1(name, function (dep) {
	      return dependencies[dep];
	    }, uid, Object.keys(this.scope.getAllBindings())),
	        nodes = _helpers$get.nodes,
	        globals = _helpers$get.globals;

	    globals.forEach(function (name) {
	      if (_this2.path.scope.hasBinding(name, true)) {
	        _this2.path.scope.rename(name);
	      }
	    });
	    nodes.forEach(function (node) {
	      node._compact = true;
	    });
	    this.path.unshiftContainer("body", nodes);
	    this.path.get("body").forEach(function (path) {
	      if (nodes.indexOf(path.node) === -1) return;
	      if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
	    });
	    return uid;
	  };

	  _proto.addTemplateObject = function addTemplateObject() {
	    throw new Error("This function has been moved into the template literal transform itself.");
	  };

	  _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, _Error) {
	    if (_Error === void 0) {
	      _Error = SyntaxError;
	    }

	    var loc = node && (node.loc || node._loc);

	    if (!loc && node) {
	      var state = {
	        loc: null
	      };
	      traverse(node, errorVisitor, this.scope, state);
	      loc = state.loc;
	      var txt = "This is an error on an internal node. Probably an internal error.";
	      if (loc) txt += " Location has been estimated.";
	      msg += " (" + txt + ")";
	    }

	    if (loc) {
	      var _this$opts$highlightC = this.opts.highlightCode,
	          highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
	      msg += "\n" + codeFrameColumns(this.code, {
	        start: {
	          line: loc.start.line,
	          column: loc.start.column + 1
	        },
	        end: loc.end && loc.start.line === loc.end.line ? {
	          line: loc.end.line,
	          column: loc.end.column + 1
	        } : undefined
	      }, {
	        highlightCode: highlightCode
	      });
	    }

	    return new _Error(msg);
	  };

	  _createClass(File, [{
	    key: "shebang",
	    get: function get() {
	      var interpreter = this.path.node.interpreter;
	      return interpreter ? interpreter.value : "";
	    },
	    set: function set(value) {
	      if (value) {
	        this.path.get("interpreter").replaceWith(interpreterDirective(value));
	      } else {
	        this.path.get("interpreter").remove();
	      }
	    }
	  }]);

	  return File;
	}();

	var _templateObject$k;
	var arrayExpression$1 = arrayExpression$2,
	    assignmentExpression$4 = assignmentExpression$c,
	    binaryExpression$1 = binaryExpression$4,
	    blockStatement$1 = blockStatement$6,
	    callExpression$6 = callExpression$e,
	    cloneNode$4 = cloneNode$i,
	    conditionalExpression$1 = conditionalExpression$3,
	    exportNamedDeclaration = exportNamedDeclaration$2,
	    exportSpecifier = exportSpecifier$2,
	    expressionStatement = expressionStatement$a,
	    functionExpression$2 = functionExpression$3,
	    identifier$5 = identifier$j,
	    memberExpression$5 = memberExpression$b,
	    objectExpression$2 = objectExpression$4,
	    program = program$3,
	    stringLiteral$2 = stringLiteral$8,
	    unaryExpression$1 = unaryExpression$7,
	    variableDeclaration = variableDeclaration$8,
	    variableDeclarator = variableDeclarator$8;

	var buildUmdWrapper = function buildUmdWrapper(replacements) {
	  return template$2.statement(_templateObject$k || (_templateObject$k = _taggedTemplateLiteralLoose(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "])))(replacements);
	};

	function buildGlobal(allowlist) {
	  var namespace = identifier$5("babelHelpers");
	  var body = [];
	  var container = functionExpression$2(null, [identifier$5("global")], blockStatement$1(body));
	  var tree = program([expressionStatement(callExpression$6(container, [conditionalExpression$1(binaryExpression$1("===", unaryExpression$1("typeof", identifier$5("global")), stringLiteral$2("undefined")), identifier$5("self"), identifier$5("global"))]))]);
	  body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression$4("=", memberExpression$5(identifier$5("global"), namespace), objectExpression$2([])))]));
	  buildHelpers(body, namespace, allowlist);
	  return tree;
	}

	function buildModule(allowlist) {
	  var body = [];
	  var refs = buildHelpers(body, null, allowlist);
	  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(function (name) {
	    return exportSpecifier(cloneNode$4(refs[name]), identifier$5(name));
	  })));
	  return program(body, [], "module");
	}

	function buildUmd(allowlist) {
	  var namespace = identifier$5("babelHelpers");
	  var body = [];
	  body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier$5("global"))]));
	  buildHelpers(body, namespace, allowlist);
	  return program([buildUmdWrapper({
	    FACTORY_PARAMETERS: identifier$5("global"),
	    BROWSER_ARGUMENTS: assignmentExpression$4("=", memberExpression$5(identifier$5("root"), namespace), objectExpression$2([])),
	    COMMON_ARGUMENTS: identifier$5("exports"),
	    AMD_ARGUMENTS: arrayExpression$1([stringLiteral$2("exports")]),
	    FACTORY_BODY: body,
	    UMD_ROOT: identifier$5("this")
	  })]);
	}

	function buildVar(allowlist) {
	  var namespace = identifier$5("babelHelpers");
	  var body = [];
	  body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression$2([]))]));
	  var tree = program(body);
	  buildHelpers(body, namespace, allowlist);
	  body.push(expressionStatement(namespace));
	  return tree;
	}

	function buildHelpers(body, namespace, allowlist) {
	  var getHelperReference = function getHelperReference(name) {
	    return namespace ? memberExpression$5(namespace, identifier$5(name)) : identifier$5("_" + name);
	  };

	  var refs = {};
	  list.forEach(function (name) {
	    if (allowlist && allowlist.indexOf(name) < 0) return;
	    var ref = refs[name] = getHelperReference(name);
	    ensure(name, File);

	    var _helpers$get = get$1(name, getHelperReference, ref),
	        nodes = _helpers$get.nodes;

	    body.push.apply(body, _toConsumableArray(nodes));
	  });
	  return refs;
	}

	function babelBuildExternalHelpers (allowlist, outputType) {
	  if (outputType === void 0) {
	    outputType = "global";
	  }

	  var tree;
	  var build = {
	    global: buildGlobal,
	    module: buildModule,
	    umd: buildUmd,
	    "var": buildVar
	  }[outputType];

	  if (build) {
	    tree = build(allowlist);
	  } else {
	    throw new Error("Unsupported output type " + outputType);
	  }

	  return generate$1(tree).code;
	}

	var _marked$9 = regenerator.mark(findPackageData),
	    _marked2$5 = regenerator.mark(findRelativeConfig),
	    _marked3$3 = regenerator.mark(findRootConfig),
	    _marked4$2 = regenerator.mark(loadConfig$1),
	    _marked5$2 = regenerator.mark(resolveShowConfigPath);

	function findConfigUpwards(rootDir) {
	  return null;
	}
	function findPackageData(filepath) {
	  return regenerator.wrap(function findPackageData$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.abrupt("return", {
	            filepath: filepath,
	            directories: [],
	            pkg: null,
	            isPackage: false
	          });

	        case 1:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$9);
	}
	function findRelativeConfig(pkgData, envName, caller) {
	  return regenerator.wrap(function findRelativeConfig$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          return _context2.abrupt("return", {
	            config: null,
	            ignore: null
	          });

	        case 1:
	        case "end":
	          return _context2.stop();
	      }
	    }
	  }, _marked2$5);
	}
	function findRootConfig(dirname, envName, caller) {
	  return regenerator.wrap(function findRootConfig$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          return _context3.abrupt("return", null);

	        case 1:
	        case "end":
	          return _context3.stop();
	      }
	    }
	  }, _marked3$3);
	}
	function loadConfig$1(name, dirname, envName, caller) {
	  return regenerator.wrap(function loadConfig$(_context4) {
	    while (1) {
	      switch (_context4.prev = _context4.next) {
	        case 0:
	          throw new Error("Cannot load " + name + " relative to " + dirname + " in a browser");

	        case 1:
	        case "end":
	          return _context4.stop();
	      }
	    }
	  }, _marked4$2);
	}
	function resolveShowConfigPath(dirname) {
	  return regenerator.wrap(function resolveShowConfigPath$(_context5) {
	    while (1) {
	      switch (_context5.prev = _context5.next) {
	        case 0:
	          return _context5.abrupt("return", null);

	        case 1:
	        case "end":
	          return _context5.stop();
	      }
	    }
	  }, _marked5$2);
	}
	var ROOT_CONFIG_FILENAMES = [];
	function resolvePlugin(name, dirname) {
	  return null;
	}
	function resolvePreset(name, dirname) {
	  return null;
	}
	function loadPlugin(name, dirname) {
	  throw new Error("Cannot load plugin " + name + " relative to " + dirname + " in a browser");
	}
	function loadPreset(name, dirname) {
	  throw new Error("Cannot load preset " + name + " relative to " + dirname + " in a browser");
	}

	function getEnv(defaultValue) {
	  if (defaultValue === void 0) {
	    defaultValue = "development";
	  }

	  return browser$4.env.BABEL_ENV || undefined || defaultValue;
	}

	var GENSYNC_START = Symbol["for"]("gensync:v1:start");
	var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
	var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
	var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
	var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
	var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
	var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
	var gensync = Object.assign(function gensync(optsOrFn) {
	  var genFn = optsOrFn;

	  if (typeof optsOrFn !== "function") {
	    genFn = newGenerator(optsOrFn);
	  } else {
	    genFn = wrapGenerator(optsOrFn);
	  }

	  return Object.assign(genFn, makeFunctionAPI(genFn));
	}, {
	  all: buildOperation({
	    name: "all",
	    arity: 1,
	    sync: function sync(args) {
	      var items = Array.from(args[0]);
	      return items.map(function (item) {
	        return evaluateSync(item);
	      });
	    },
	    async: function async(args, resolve, reject) {
	      var items = Array.from(args[0]);

	      if (items.length === 0) {
	        Promise.resolve().then(function () {
	          return resolve([]);
	        });
	        return;
	      }

	      var count = 0;
	      var results = items.map(function () {
	        return undefined;
	      });
	      items.forEach(function (item, i) {
	        evaluateAsync(item, function (val) {
	          results[i] = val;
	          count += 1;
	          if (count === results.length) resolve(results);
	        }, reject);
	      });
	    }
	  }),
	  race: buildOperation({
	    name: "race",
	    arity: 1,
	    sync: function sync(args) {
	      var items = Array.from(args[0]);

	      if (items.length === 0) {
	        throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
	      }

	      return evaluateSync(items[0]);
	    },
	    async: function async(args, resolve, reject) {
	      var items = Array.from(args[0]);

	      if (items.length === 0) {
	        throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
	      }

	      for (var _i = 0, _items = items; _i < _items.length; _i++) {
	        var item = _items[_i];
	        evaluateAsync(item, resolve, reject);
	      }
	    }
	  })
	});

	function makeFunctionAPI(genFn) {
	  var fns = {
	    sync: function sync() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return evaluateSync(genFn.apply(this, args));
	    },
	    async: function async() {
	      var _this = this;

	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return new Promise(function (resolve, reject) {
	        evaluateAsync(genFn.apply(_this, args), resolve, reject);
	      });
	    },
	    errback: function errback() {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      var cb = args.pop();

	      if (typeof cb !== "function") {
	        throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
	      }

	      var gen;

	      try {
	        gen = genFn.apply(this, args);
	      } catch (err) {
	        cb(err);
	        return;
	      }

	      evaluateAsync(gen, function (val) {
	        return cb(undefined, val);
	      }, function (err) {
	        return cb(err);
	      });
	    }
	  };
	  return fns;
	}

	function assertTypeof(type, name, value, allowUndefined) {
	  if (typeof value === type || allowUndefined && typeof value === "undefined") {
	    return;
	  }

	  var msg;

	  if (allowUndefined) {
	    msg = "Expected opts." + name + " to be either a " + type + ", or undefined.";
	  } else {
	    msg = "Expected opts." + name + " to be a " + type + ".";
	  }

	  throw makeError(msg, GENSYNC_OPTIONS_ERROR);
	}

	function makeError(msg, code) {
	  return Object.assign(new Error(msg), {
	    code: code
	  });
	}

	function newGenerator(_ref) {
	  var name = _ref.name,
	      arity = _ref.arity,
	      _sync = _ref.sync,
	      _async = _ref.async,
	      errback = _ref.errback;
	  assertTypeof("string", "name", name, true);
	  assertTypeof("number", "arity", arity, true);
	  assertTypeof("function", "sync", _sync);
	  assertTypeof("function", "async", _async, true);
	  assertTypeof("function", "errback", errback, true);

	  if (_async && errback) {
	    throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
	  }

	  if (typeof name !== "string") {
	    var fnName;

	    if (errback && errback.name && errback.name !== "errback") {
	      fnName = errback.name;
	    }

	    if (_async && _async.name && _async.name !== "async") {
	      fnName = _async.name.replace(/Async$/, "");
	    }

	    if (_sync && _sync.name && _sync.name !== "sync") {
	      fnName = _sync.name.replace(/Sync$/, "");
	    }

	    if (typeof fnName === "string") {
	      name = fnName;
	    }
	  }

	  if (typeof arity !== "number") {
	    arity = _sync.length;
	  }

	  return buildOperation({
	    name: name,
	    arity: arity,
	    sync: function sync(args) {
	      return _sync.apply(this, args);
	    },
	    async: function async(args, resolve, reject) {
	      if (_async) {
	        _async.apply(this, args).then(resolve, reject);
	      } else if (errback) {
	        errback.call.apply(errback, [this].concat(_toConsumableArray(args), [function (err, value) {
	          if (err == null) resolve(value);else reject(err);
	        }]));
	      } else {
	        resolve(_sync.apply(this, args));
	      }
	    }
	  });
	}

	function wrapGenerator(genFn) {
	  return setFunctionMetadata(genFn.name, genFn.length, function () {
	    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      args[_key4] = arguments[_key4];
	    }

	    return genFn.apply(this, args);
	  });
	}

	function buildOperation(_ref2) {
	  var name = _ref2.name,
	      arity = _ref2.arity,
	      sync = _ref2.sync,
	      async = _ref2.async;
	  return setFunctionMetadata(name, arity, regenerator.mark(function _callee() {
	    var resume,
	        _len5,
	        args,
	        _key5,
	        res,
	        result,
	        _args = arguments;

	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return GENSYNC_START;

	          case 2:
	            resume = _context.sent;

	            for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	              args[_key5] = _args[_key5];
	            }

	            if (resume) {
	              _context.next = 7;
	              break;
	            }

	            res = sync.call(this, args);
	            return _context.abrupt("return", res);

	          case 7:
	            try {
	              async.call(this, args, function (value) {
	                if (result) return;
	                result = {
	                  value: value
	                };
	                resume();
	              }, function (err) {
	                if (result) return;
	                result = {
	                  err: err
	                };
	                resume();
	              });
	            } catch (err) {
	              result = {
	                err: err
	              };
	              resume();
	            }

	            _context.next = 10;
	            return GENSYNC_SUSPEND;

	          case 10:
	            if (!result.hasOwnProperty("err")) {
	              _context.next = 12;
	              break;
	            }

	            throw result.err;

	          case 12:
	            return _context.abrupt("return", result.value);

	          case 13:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	}

	function evaluateSync(gen) {
	  var value;

	  while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
	    var _gen$next;

	    assertStart(value, gen);
	  }

	  return value;
	}

	function evaluateAsync(gen, resolve, reject) {
	  (function step() {
	    try {
	      var value;

	      var _loop = function _loop() {
	        assertStart(value, gen);
	        var sync = true;
	        var didSyncResume = false;
	        var out = gen.next(function () {
	          if (sync) {
	            didSyncResume = true;
	          } else {
	            step();
	          }
	        });
	        sync = false;
	        assertSuspend(out, gen);

	        if (!didSyncResume) {
	          return {
	            v: void 0
	          };
	        }
	      };

	      while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
	        var _gen$next2;

	        var _ret = _loop();

	        if (typeof _ret === "object") return _ret.v;
	      }

	      return resolve(value);
	    } catch (err) {
	      return reject(err);
	    }
	  })();
	}

	function assertStart(value, gen) {
	  if (value === GENSYNC_START) return;
	  throwError(gen, makeError("Got unexpected yielded value in gensync generator: " + JSON.stringify(value) + ". Did you perhaps mean to use 'yield*' instead of 'yield'?", GENSYNC_EXPECTED_START));
	}

	function assertSuspend(_ref3, gen) {
	  var value = _ref3.value,
	      done = _ref3.done;
	  if (!done && value === GENSYNC_SUSPEND) return;
	  throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got " + JSON.stringify(value) + ". If you get this, it is probably a gensync bug.", GENSYNC_EXPECTED_SUSPEND));
	}

	function throwError(gen, err) {
	  if (gen["throw"]) gen["throw"](err);
	  throw err;
	}

	function setFunctionMetadata(name, arity, fn) {
	  if (typeof name === "string") {
	    var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

	    if (!nameDesc || nameDesc.configurable) {
	      Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
	        configurable: true,
	        value: name
	      }));
	    }
	  }

	  if (typeof arity === "number") {
	    var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

	    if (!lengthDesc || lengthDesc.configurable) {
	      Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
	        configurable: true,
	        value: arity
	      }));
	    }
	  }

	  return fn;
	}

	var id = function id(x) {
	  return x;
	};

	var runGenerator = gensync(regenerator.mark(function _callee(item) {
	  return regenerator.wrap(function _callee$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(item, "t0", 1);

	        case 1:
	          return _context.abrupt("return", _context.t0);

	        case 2:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _callee);
	}));
	var isAsync = gensync({
	  sync: function sync() {
	    return false;
	  },
	  errback: function errback(cb) {
	    return cb(null, true);
	  }
	});
	function maybeAsync(fn, message) {
	  return gensync({
	    sync: function sync() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      var result = fn.apply(this, args);
	      if (isThenable$1(result)) throw new Error(message);
	      return result;
	    },
	    async: function async() {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return Promise.resolve(fn.apply(this, args));
	    }
	  });
	}
	var withKind = gensync({
	  sync: function sync(cb) {
	    return cb("sync");
	  },
	  async: function async(cb) {
	    return cb("async");
	  }
	});
	function forwardAsync(action, cb) {
	  var g = gensync(action);
	  return withKind(function (kind) {
	    var adapted = g[kind];
	    return cb(adapted);
	  });
	}
	var onFirstPause = gensync({
	  name: "onFirstPause",
	  arity: 2,
	  sync: function sync(item) {
	    return runGenerator.sync(item);
	  },
	  errback: function errback(item, firstPause, cb) {
	    var completed = false;
	    runGenerator.errback(item, function (err, value) {
	      completed = true;
	      cb(err, value);
	    });

	    if (!completed) {
	      firstPause();
	    }
	  }
	});
	var waitFor = gensync({
	  sync: id,
	  async: id
	});
	function isThenable$1(val) {
	  return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
	}

	function mergeOptions(target, source) {
	  for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
	    var k = _Object$keys[_i];

	    if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
	      var parserOpts = source[k];
	      var targetObj = target[k] || (target[k] = {});
	      mergeDefaultFields(targetObj, parserOpts);
	    } else {
	      var val = source[k];
	      if (val !== undefined) target[k] = val;
	    }
	  }
	}

	function mergeDefaultFields(target, source) {
	  for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
	    var k = _Object$keys2[_i2];
	    var val = source[k];
	    if (val !== undefined) target[k] = val;
	  }
	}

	function isIterableIterator(value) {
	  return !!value && typeof value.next === "function" && typeof value[Symbol.iterator] === "function";
	}

	var Plugin$1 = function Plugin(plugin, options, key) {
	  this.key = void 0;
	  this.manipulateOptions = void 0;
	  this.post = void 0;
	  this.pre = void 0;
	  this.visitor = void 0;
	  this.parserOverride = void 0;
	  this.generatorOverride = void 0;
	  this.options = void 0;
	  this.key = plugin.name || key;
	  this.manipulateOptions = plugin.manipulateOptions;
	  this.post = plugin.post;
	  this.pre = plugin.pre;
	  this.visitor = plugin.visitor || {};
	  this.parserOverride = plugin.parserOverride;
	  this.generatorOverride = plugin.generatorOverride;
	  this.options = options;
	};

	var _marked$8 = regenerator.mark(genTrue),
	    _marked2$4 = regenerator.mark(getCachedValue),
	    _marked3$2 = regenerator.mark(getCachedValueOrWait);

	var synchronize = function synchronize(gen) {
	  return gensync(gen).sync;
	};

	function genTrue() {
	  return regenerator.wrap(function genTrue$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.abrupt("return", true);

	        case 1:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$8);
	}

	function makeWeakCache(handler) {
	  return makeCachedFunction(WeakMap, handler);
	}
	function makeWeakCacheSync(handler) {
	  return synchronize(makeWeakCache(handler));
	}
	function makeStrongCache(handler) {
	  return makeCachedFunction(Map, handler);
	}
	function makeStrongCacheSync(handler) {
	  return synchronize(makeStrongCache(handler));
	}

	function makeCachedFunction(CallCache, handler) {
	  var callCacheSync = new CallCache();
	  var callCacheAsync = new CallCache();
	  var futureCache = new CallCache();
	  return regenerator.mark(function cachedFunction(arg, data) {
	    var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;
	    return regenerator.wrap(function cachedFunction$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            return _context2.delegateYield(isAsync(), "t0", 1);

	          case 1:
	            asyncContext = _context2.t0;
	            callCache = asyncContext ? callCacheAsync : callCacheSync;
	            return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), "t1", 4);

	          case 4:
	            cached = _context2.t1;

	            if (!cached.valid) {
	              _context2.next = 7;
	              break;
	            }

	            return _context2.abrupt("return", cached.value);

	          case 7:
	            cache = new CacheConfigurator(data);
	            handlerResult = handler(arg, cache);

	            if (!isIterableIterator(handlerResult)) {
	              _context2.next = 15;
	              break;
	            }

	            gen = handlerResult;
	            return _context2.delegateYield(onFirstPause(gen, function () {
	              finishLock = setupAsyncLocks(cache, futureCache, arg);
	            }), "t2", 12);

	          case 12:
	            value = _context2.t2;
	            _context2.next = 16;
	            break;

	          case 15:
	            value = handlerResult;

	          case 16:
	            updateFunctionCache(callCache, cache, arg, value);

	            if (finishLock) {
	              futureCache["delete"](arg);
	              finishLock.release(value);
	            }

	            return _context2.abrupt("return", value);

	          case 19:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, cachedFunction);
	  });
	}

	function getCachedValue(cache, arg, data) {
	  var cachedValue, _iterator, _step, _step$value, _value, valid;

	  return regenerator.wrap(function getCachedValue$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          cachedValue = cache.get(arg);

	          if (!cachedValue) {
	            _context3.next = 10;
	            break;
	          }

	          _iterator = _createForOfIteratorHelperLoose(cachedValue);

	        case 3:
	          if ((_step = _iterator()).done) {
	            _context3.next = 10;
	            break;
	          }

	          _step$value = _step.value, _value = _step$value.value, valid = _step$value.valid;
	          return _context3.delegateYield(valid(data), "t0", 6);

	        case 6:
	          if (!_context3.t0) {
	            _context3.next = 8;
	            break;
	          }

	          return _context3.abrupt("return", {
	            valid: true,
	            value: _value
	          });

	        case 8:
	          _context3.next = 3;
	          break;

	        case 10:
	          return _context3.abrupt("return", {
	            valid: false,
	            value: null
	          });

	        case 11:
	        case "end":
	          return _context3.stop();
	      }
	    }
	  }, _marked2$4);
	}

	function getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
	  var cached, _cached, _value2;

	  return regenerator.wrap(function getCachedValueOrWait$(_context4) {
	    while (1) {
	      switch (_context4.prev = _context4.next) {
	        case 0:
	          return _context4.delegateYield(getCachedValue(callCache, arg, data), "t0", 1);

	        case 1:
	          cached = _context4.t0;

	          if (!cached.valid) {
	            _context4.next = 4;
	            break;
	          }

	          return _context4.abrupt("return", cached);

	        case 4:
	          if (!asyncContext) {
	            _context4.next = 11;
	            break;
	          }

	          return _context4.delegateYield(getCachedValue(futureCache, arg, data), "t1", 6);

	        case 6:
	          _cached = _context4.t1;

	          if (!_cached.valid) {
	            _context4.next = 11;
	            break;
	          }

	          return _context4.delegateYield(waitFor(_cached.value.promise), "t2", 9);

	        case 9:
	          _value2 = _context4.t2;
	          return _context4.abrupt("return", {
	            valid: true,
	            value: _value2
	          });

	        case 11:
	          return _context4.abrupt("return", {
	            valid: false,
	            value: null
	          });

	        case 12:
	        case "end":
	          return _context4.stop();
	      }
	    }
	  }, _marked3$2);
	}

	function setupAsyncLocks(config, futureCache, arg) {
	  var finishLock = new Lock();
	  updateFunctionCache(futureCache, config, arg, finishLock);
	  return finishLock;
	}

	function updateFunctionCache(cache, config, arg, value) {
	  if (!config.configured()) config.forever();
	  var cachedValue = cache.get(arg);
	  config.deactivate();

	  switch (config.mode()) {
	    case "forever":
	      cachedValue = [{
	        value: value,
	        valid: genTrue
	      }];
	      cache.set(arg, cachedValue);
	      break;

	    case "invalidate":
	      cachedValue = [{
	        value: value,
	        valid: config.validator()
	      }];
	      cache.set(arg, cachedValue);
	      break;

	    case "valid":
	      if (cachedValue) {
	        cachedValue.push({
	          value: value,
	          valid: config.validator()
	        });
	      } else {
	        cachedValue = [{
	          value: value,
	          valid: config.validator()
	        }];
	        cache.set(arg, cachedValue);
	      }

	  }
	}

	var CacheConfigurator = function () {
	  function CacheConfigurator(data) {
	    this._active = true;
	    this._never = false;
	    this._forever = false;
	    this._invalidate = false;
	    this._configured = false;
	    this._pairs = [];
	    this._data = void 0;
	    this._data = data;
	  }

	  var _proto = CacheConfigurator.prototype;

	  _proto.simple = function simple() {
	    return makeSimpleConfigurator(this);
	  };

	  _proto.mode = function mode() {
	    if (this._never) return "never";
	    if (this._forever) return "forever";
	    if (this._invalidate) return "invalidate";
	    return "valid";
	  };

	  _proto.forever = function forever() {
	    if (!this._active) {
	      throw new Error("Cannot change caching after evaluation has completed.");
	    }

	    if (this._never) {
	      throw new Error("Caching has already been configured with .never()");
	    }

	    this._forever = true;
	    this._configured = true;
	  };

	  _proto.never = function never() {
	    if (!this._active) {
	      throw new Error("Cannot change caching after evaluation has completed.");
	    }

	    if (this._forever) {
	      throw new Error("Caching has already been configured with .forever()");
	    }

	    this._never = true;
	    this._configured = true;
	  };

	  _proto.using = function using(handler) {
	    var _this = this;

	    if (!this._active) {
	      throw new Error("Cannot change caching after evaluation has completed.");
	    }

	    if (this._never || this._forever) {
	      throw new Error("Caching has already been configured with .never or .forever()");
	    }

	    this._configured = true;
	    var key = handler(this._data);
	    var fn = maybeAsync(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");

	    if (isThenable$1(key)) {
	      return key.then(function (key) {
	        _this._pairs.push([key, fn]);

	        return key;
	      });
	    }

	    this._pairs.push([key, fn]);

	    return key;
	  };

	  _proto.invalidate = function invalidate(handler) {
	    this._invalidate = true;
	    return this.using(handler);
	  };

	  _proto.validator = function validator() {
	    var pairs = this._pairs;
	    return regenerator.mark(function _callee(data) {
	      var _iterator2, _step2, _step2$value, key, fn;

	      return regenerator.wrap(function _callee$(_context5) {
	        while (1) {
	          switch (_context5.prev = _context5.next) {
	            case 0:
	              _iterator2 = _createForOfIteratorHelperLoose(pairs);

	            case 1:
	              if ((_step2 = _iterator2()).done) {
	                _context5.next = 10;
	                break;
	              }

	              _step2$value = _slicedToArray$1(_step2.value, 2), key = _step2$value[0], fn = _step2$value[1];
	              _context5.t0 = key;
	              return _context5.delegateYield(fn(data), "t1", 5);

	            case 5:
	              _context5.t2 = _context5.t1;

	              if (!(_context5.t0 !== _context5.t2)) {
	                _context5.next = 8;
	                break;
	              }

	              return _context5.abrupt("return", false);

	            case 8:
	              _context5.next = 1;
	              break;

	            case 10:
	              return _context5.abrupt("return", true);

	            case 11:
	            case "end":
	              return _context5.stop();
	          }
	        }
	      }, _callee);
	    });
	  };

	  _proto.deactivate = function deactivate() {
	    this._active = false;
	  };

	  _proto.configured = function configured() {
	    return this._configured;
	  };

	  return CacheConfigurator;
	}();

	function makeSimpleConfigurator(cache) {
	  function cacheFn(val) {
	    if (typeof val === "boolean") {
	      if (val) cache.forever();else cache.never();
	      return;
	    }

	    return cache.using(function () {
	      return assertSimpleType(val());
	    });
	  }

	  cacheFn.forever = function () {
	    return cache.forever();
	  };

	  cacheFn.never = function () {
	    return cache.never();
	  };

	  cacheFn.using = function (cb) {
	    return cache.using(function () {
	      return assertSimpleType(cb());
	    });
	  };

	  cacheFn.invalidate = function (cb) {
	    return cache.invalidate(function () {
	      return assertSimpleType(cb());
	    });
	  };

	  return cacheFn;
	}

	function assertSimpleType(value) {
	  if (isThenable$1(value)) {
	    throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
	  }

	  if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
	    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
	  }

	  return value;
	}

	var Lock = function () {
	  function Lock() {
	    var _this2 = this;

	    this.released = false;
	    this.promise = void 0;
	    this._resolve = void 0;
	    this.promise = new Promise(function (resolve) {
	      _this2._resolve = resolve;
	    });
	  }

	  var _proto2 = Lock.prototype;

	  _proto2.release = function release(value) {
	    this.released = true;

	    this._resolve(value);
	  };

	  return Lock;
	}();

	var jsReleases = [
		{
			name: "nodejs",
			version: "0.2.0",
			date: "2011-08-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.3.0",
			date: "2011-08-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.4.0",
			date: "2011-08-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.5.0",
			date: "2011-08-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.6.0",
			date: "2011-11-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.7.0",
			date: "2012-01-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.8.0",
			date: "2012-06-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.9.0",
			date: "2012-07-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.10.0",
			date: "2013-03-11",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.11.0",
			date: "2013-03-28",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "0.12.0",
			date: "2015-02-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "4.0.0",
			date: "2015-09-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "4.1.0",
			date: "2015-09-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "4.2.0",
			date: "2015-10-12",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.3.0",
			date: "2016-02-09",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.4.0",
			date: "2016-03-08",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.5.0",
			date: "2016-08-16",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.6.0",
			date: "2016-09-27",
			lts: "Argon",
			security: true
		},
		{
			name: "nodejs",
			version: "4.7.0",
			date: "2016-12-06",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.8.0",
			date: "2017-02-21",
			lts: "Argon",
			security: false
		},
		{
			name: "nodejs",
			version: "4.9.0",
			date: "2018-03-28",
			lts: "Argon",
			security: true
		},
		{
			name: "nodejs",
			version: "5.0.0",
			date: "2015-10-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.1.0",
			date: "2015-11-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.2.0",
			date: "2015-12-09",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.3.0",
			date: "2015-12-15",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.4.0",
			date: "2016-01-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.5.0",
			date: "2016-01-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.6.0",
			date: "2016-02-09",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.7.0",
			date: "2016-02-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.8.0",
			date: "2016-03-09",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.9.0",
			date: "2016-03-16",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.10.0",
			date: "2016-04-01",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.11.0",
			date: "2016-04-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "5.12.0",
			date: "2016-06-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.0.0",
			date: "2016-04-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.1.0",
			date: "2016-05-05",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.2.0",
			date: "2016-05-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.3.0",
			date: "2016-07-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.4.0",
			date: "2016-08-12",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.5.0",
			date: "2016-08-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.6.0",
			date: "2016-09-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.7.0",
			date: "2016-09-27",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "6.8.0",
			date: "2016-10-12",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "6.9.0",
			date: "2016-10-18",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.10.0",
			date: "2017-02-21",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.11.0",
			date: "2017-06-06",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.12.0",
			date: "2017-11-06",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.13.0",
			date: "2018-02-10",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.14.0",
			date: "2018-03-28",
			lts: "Boron",
			security: true
		},
		{
			name: "nodejs",
			version: "6.15.0",
			date: "2018-11-27",
			lts: "Boron",
			security: true
		},
		{
			name: "nodejs",
			version: "6.16.0",
			date: "2018-12-26",
			lts: "Boron",
			security: false
		},
		{
			name: "nodejs",
			version: "6.17.0",
			date: "2019-02-28",
			lts: "Boron",
			security: true
		},
		{
			name: "nodejs",
			version: "7.0.0",
			date: "2016-10-25",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.1.0",
			date: "2016-11-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.2.0",
			date: "2016-11-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.3.0",
			date: "2016-12-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.4.0",
			date: "2017-01-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.5.0",
			date: "2017-01-31",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.6.0",
			date: "2017-02-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.7.0",
			date: "2017-02-28",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.8.0",
			date: "2017-03-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.9.0",
			date: "2017-04-11",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "7.10.0",
			date: "2017-05-02",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.0.0",
			date: "2017-05-30",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.1.0",
			date: "2017-06-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.2.0",
			date: "2017-07-19",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.3.0",
			date: "2017-08-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.4.0",
			date: "2017-08-15",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.5.0",
			date: "2017-09-12",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.6.0",
			date: "2017-09-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.7.0",
			date: "2017-10-11",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.8.0",
			date: "2017-10-24",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "8.9.0",
			date: "2017-10-31",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.10.0",
			date: "2018-03-06",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.11.0",
			date: "2018-03-28",
			lts: "Carbon",
			security: true
		},
		{
			name: "nodejs",
			version: "8.12.0",
			date: "2018-09-10",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.13.0",
			date: "2018-11-20",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.14.0",
			date: "2018-11-27",
			lts: "Carbon",
			security: true
		},
		{
			name: "nodejs",
			version: "8.15.0",
			date: "2018-12-26",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.16.0",
			date: "2019-04-16",
			lts: "Carbon",
			security: false
		},
		{
			name: "nodejs",
			version: "8.17.0",
			date: "2019-12-17",
			lts: "Carbon",
			security: true
		},
		{
			name: "nodejs",
			version: "9.0.0",
			date: "2017-10-31",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.1.0",
			date: "2017-11-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.2.0",
			date: "2017-11-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.3.0",
			date: "2017-12-12",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.4.0",
			date: "2018-01-10",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.5.0",
			date: "2018-01-31",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.6.0",
			date: "2018-02-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.7.0",
			date: "2018-03-01",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.8.0",
			date: "2018-03-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.9.0",
			date: "2018-03-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "9.10.0",
			date: "2018-03-28",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "9.11.0",
			date: "2018-04-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.0.0",
			date: "2018-04-24",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.1.0",
			date: "2018-05-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.2.0",
			date: "2018-05-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.3.0",
			date: "2018-05-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.4.0",
			date: "2018-06-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.5.0",
			date: "2018-06-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.6.0",
			date: "2018-07-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.7.0",
			date: "2018-07-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.8.0",
			date: "2018-08-01",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.9.0",
			date: "2018-08-15",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.10.0",
			date: "2018-09-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.11.0",
			date: "2018-09-19",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.12.0",
			date: "2018-10-10",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "10.13.0",
			date: "2018-10-30",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.14.0",
			date: "2018-11-27",
			lts: "Dubnium",
			security: true
		},
		{
			name: "nodejs",
			version: "10.15.0",
			date: "2018-12-26",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.16.0",
			date: "2019-05-28",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.17.0",
			date: "2019-10-22",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.18.0",
			date: "2019-12-17",
			lts: "Dubnium",
			security: true
		},
		{
			name: "nodejs",
			version: "10.19.0",
			date: "2020-02-05",
			lts: "Dubnium",
			security: true
		},
		{
			name: "nodejs",
			version: "10.20.0",
			date: "2020-03-26",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.21.0",
			date: "2020-06-02",
			lts: "Dubnium",
			security: true
		},
		{
			name: "nodejs",
			version: "10.22.0",
			date: "2020-07-21",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.23.0",
			date: "2020-10-27",
			lts: "Dubnium",
			security: false
		},
		{
			name: "nodejs",
			version: "10.24.0",
			date: "2021-02-23",
			lts: "Dubnium",
			security: true
		},
		{
			name: "nodejs",
			version: "11.0.0",
			date: "2018-10-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.1.0",
			date: "2018-10-30",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.2.0",
			date: "2018-11-15",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.3.0",
			date: "2018-11-27",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "11.4.0",
			date: "2018-12-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.5.0",
			date: "2018-12-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.6.0",
			date: "2018-12-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.7.0",
			date: "2019-01-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.8.0",
			date: "2019-01-24",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.9.0",
			date: "2019-01-30",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.10.0",
			date: "2019-02-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.11.0",
			date: "2019-03-05",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.12.0",
			date: "2019-03-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.13.0",
			date: "2019-03-28",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.14.0",
			date: "2019-04-10",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "11.15.0",
			date: "2019-04-30",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.0.0",
			date: "2019-04-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.1.0",
			date: "2019-04-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.2.0",
			date: "2019-05-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.3.0",
			date: "2019-05-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.4.0",
			date: "2019-06-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.5.0",
			date: "2019-06-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.6.0",
			date: "2019-07-03",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.7.0",
			date: "2019-07-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.8.0",
			date: "2019-08-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.9.0",
			date: "2019-08-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.10.0",
			date: "2019-09-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.11.0",
			date: "2019-09-25",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.12.0",
			date: "2019-10-11",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "12.13.0",
			date: "2019-10-21",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "12.14.0",
			date: "2019-12-17",
			lts: "Erbium",
			security: true
		},
		{
			name: "nodejs",
			version: "12.15.0",
			date: "2020-02-05",
			lts: "Erbium",
			security: true
		},
		{
			name: "nodejs",
			version: "12.16.0",
			date: "2020-02-11",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "12.17.0",
			date: "2020-05-26",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "12.18.0",
			date: "2020-06-02",
			lts: "Erbium",
			security: true
		},
		{
			name: "nodejs",
			version: "12.19.0",
			date: "2020-10-06",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "12.20.0",
			date: "2020-11-24",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "12.21.0",
			date: "2021-02-23",
			lts: "Erbium",
			security: true
		},
		{
			name: "nodejs",
			version: "12.22.0",
			date: "2021-03-30",
			lts: "Erbium",
			security: false
		},
		{
			name: "nodejs",
			version: "13.0.0",
			date: "2019-10-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.1.0",
			date: "2019-11-05",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.2.0",
			date: "2019-11-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.3.0",
			date: "2019-12-03",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.4.0",
			date: "2019-12-17",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "13.5.0",
			date: "2019-12-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.6.0",
			date: "2020-01-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.7.0",
			date: "2020-01-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.8.0",
			date: "2020-02-05",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "13.9.0",
			date: "2020-02-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.10.0",
			date: "2020-03-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.11.0",
			date: "2020-03-12",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.12.0",
			date: "2020-03-26",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.13.0",
			date: "2020-04-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "13.14.0",
			date: "2020-04-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.0.0",
			date: "2020-04-21",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.1.0",
			date: "2020-04-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.2.0",
			date: "2020-05-05",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.3.0",
			date: "2020-05-19",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.4.0",
			date: "2020-06-02",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "14.5.0",
			date: "2020-06-30",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.6.0",
			date: "2020-07-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.7.0",
			date: "2020-07-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.8.0",
			date: "2020-08-11",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.9.0",
			date: "2020-08-27",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.10.0",
			date: "2020-09-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.11.0",
			date: "2020-09-15",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "14.12.0",
			date: "2020-09-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.13.0",
			date: "2020-09-29",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.14.0",
			date: "2020-10-15",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "14.15.0",
			date: "2020-10-27",
			lts: "Fermium",
			security: false
		},
		{
			name: "nodejs",
			version: "14.16.0",
			date: "2021-02-23",
			lts: "Fermium",
			security: true
		},
		{
			name: "nodejs",
			version: "14.17.0",
			date: "2021-05-11",
			lts: "Fermium",
			security: false
		},
		{
			name: "nodejs",
			version: "14.18.0",
			date: "2021-09-28",
			lts: "Fermium",
			security: false
		},
		{
			name: "nodejs",
			version: "15.0.0",
			date: "2020-10-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.1.0",
			date: "2020-11-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.2.0",
			date: "2020-11-10",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.3.0",
			date: "2020-11-24",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.4.0",
			date: "2020-12-09",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.5.0",
			date: "2020-12-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.6.0",
			date: "2021-01-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.7.0",
			date: "2021-01-25",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.8.0",
			date: "2021-02-02",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.9.0",
			date: "2021-02-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.10.0",
			date: "2021-02-23",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "15.11.0",
			date: "2021-03-03",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.12.0",
			date: "2021-03-17",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.13.0",
			date: "2021-03-31",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "15.14.0",
			date: "2021-04-06",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.0.0",
			date: "2021-04-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.1.0",
			date: "2021-05-04",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.2.0",
			date: "2021-05-19",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.3.0",
			date: "2021-06-03",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.4.0",
			date: "2021-06-23",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.5.0",
			date: "2021-07-14",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.6.0",
			date: "2021-07-29",
			lts: false,
			security: true
		},
		{
			name: "nodejs",
			version: "16.7.0",
			date: "2021-08-18",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.8.0",
			date: "2021-08-25",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.9.0",
			date: "2021-09-07",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.10.0",
			date: "2021-09-22",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.11.0",
			date: "2021-10-08",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "16.12.0",
			date: "2021-10-20",
			lts: false,
			security: false
		},
		{
			name: "nodejs",
			version: "17.0.0",
			date: "2021-10-19",
			lts: false,
			security: false
		}
	];

	var browsers$2 = {
	  A: "ie",
	  B: "edge",
	  C: "firefox",
	  D: "chrome",
	  E: "safari",
	  F: "opera",
	  G: "ios_saf",
	  H: "op_mini",
	  I: "android",
	  J: "bb",
	  K: "op_mob",
	  L: "and_chr",
	  M: "and_ff",
	  N: "ie_mob",
	  O: "and_uc",
	  P: "samsung",
	  Q: "and_qq",
	  R: "baidu",
	  S: "kaios"
	};

	var browsers_1 = browsers$2;
	var browsers$1 = {
	  browsers: browsers_1
	};

	var browserVersions$1 = {
	  "0": "39",
	  "1": "40",
	  "2": "41",
	  "3": "42",
	  "4": "43",
	  "5": "44",
	  "6": "45",
	  "7": "46",
	  "8": "47",
	  "9": "48",
	  A: "10",
	  B: "11",
	  C: "12",
	  D: "15",
	  E: "7",
	  F: "8",
	  G: "9",
	  H: "94",
	  I: "4",
	  J: "6",
	  K: "13",
	  L: "14",
	  M: "16",
	  N: "17",
	  O: "18",
	  P: "79",
	  Q: "80",
	  R: "92",
	  S: "64",
	  T: "81",
	  U: "83",
	  V: "84",
	  W: "85",
	  X: "86",
	  Y: "87",
	  Z: "88",
	  a: "89",
	  b: "90",
	  c: "91",
	  d: "93",
	  e: "95",
	  f: "5",
	  g: "19",
	  h: "20",
	  i: "21",
	  j: "22",
	  k: "23",
	  l: "24",
	  m: "25",
	  n: "26",
	  o: "27",
	  p: "28",
	  q: "29",
	  r: "30",
	  s: "31",
	  t: "32",
	  u: "33",
	  v: "34",
	  w: "35",
	  x: "36",
	  y: "37",
	  z: "38",
	  AB: "49",
	  BB: "50",
	  CB: "51",
	  DB: "52",
	  EB: "53",
	  FB: "54",
	  GB: "55",
	  HB: "56",
	  IB: "57",
	  JB: "58",
	  KB: "60",
	  LB: "62",
	  MB: "63",
	  NB: "65",
	  OB: "66",
	  PB: "67",
	  QB: "68",
	  RB: "69",
	  SB: "70",
	  TB: "71",
	  UB: "72",
	  VB: "73",
	  WB: "74",
	  XB: "75",
	  YB: "76",
	  ZB: "77",
	  aB: "78",
	  bB: "11.1",
	  cB: "12.1",
	  dB: "3",
	  eB: "59",
	  fB: "61",
	  gB: "3.2",
	  hB: "10.1",
	  iB: "11.5",
	  jB: "4.2-4.3",
	  kB: "5.5",
	  lB: "2",
	  mB: "82",
	  nB: "3.5",
	  oB: "3.6",
	  pB: "96",
	  qB: "97",
	  rB: "98",
	  sB: "3.1",
	  tB: "5.1",
	  uB: "6.1",
	  vB: "7.1",
	  wB: "9.1",
	  xB: "13.1",
	  yB: "14.1",
	  zB: "TP",
	  "0B": "9.5-9.6",
	  "1B": "10.0-10.1",
	  "2B": "10.5",
	  "3B": "10.6",
	  "4B": "11.6",
	  "5B": "4.0-4.1",
	  "6B": "5.0-5.1",
	  "7B": "6.0-6.1",
	  "8B": "7.0-7.1",
	  "9B": "8.1-8.4",
	  AC: "9.0-9.2",
	  BC: "9.3",
	  CC: "10.0-10.2",
	  DC: "10.3",
	  EC: "11.0-11.2",
	  FC: "11.3-11.4",
	  GC: "12.0-12.1",
	  HC: "12.2-12.5",
	  IC: "13.0-13.1",
	  JC: "13.2",
	  KC: "13.3",
	  LC: "13.4-13.7",
	  MC: "14.0-14.4",
	  NC: "14.5-14.8",
	  OC: "all",
	  PC: "2.1",
	  QC: "2.2",
	  RC: "2.3",
	  SC: "4.1",
	  TC: "4.4",
	  UC: "4.4.3-4.4.4",
	  VC: "12.12",
	  WC: "5.0-5.4",
	  XC: "6.2-6.4",
	  YC: "7.2-7.4",
	  ZC: "8.2",
	  aC: "9.2",
	  bC: "11.1-11.2",
	  cC: "12.0",
	  dC: "13.0",
	  eC: "14.0",
	  fC: "15.0",
	  gC: "10.4",
	  hC: "7.12",
	  iC: "2.5"
	};

	var browserVersions_1 = browserVersions$1;
	var browserVersions = {
	  browserVersions: browserVersions_1
	};

	var agents$2 = {
	  A: {
	    A: {
	      J: 0.0131217,
	      E: 0.00621152,
	      F: 0.0414881,
	      G: 0.11755,
	      A: 0.020744,
	      B: 0.726041,
	      kB: 0.009298
	    },
	    B: "ms",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "kB", "J", "E", "F", "G", "A", "B", "", "", ""],
	    E: "IE",
	    F: {
	      kB: 962323200,
	      J: 998870400,
	      E: 1161129600,
	      F: 1237420800,
	      G: 1300060800,
	      A: 1346716800,
	      B: 1381968000
	    }
	  },
	  B: {
	    A: {
	      C: 0.008586,
	      K: 0.004267,
	      L: 0.004293,
	      D: 0.008586,
	      M: 0.008586,
	      N: 0.017172,
	      O: 0.090153,
	      P: 0,
	      Q: 0.004298,
	      T: 0.00944,
	      U: 0.004043,
	      V: 0.012879,
	      W: 0.008586,
	      X: 0.008586,
	      Y: 0.012879,
	      Z: 0.004293,
	      a: 0.017172,
	      b: 0.008586,
	      c: 0.030051,
	      R: 0.570969,
	      d: 2.53287,
	      H: 0.523746,
	      e: 0
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "D", "M", "N", "O", "P", "Q", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "R", "d", "H", "e", "", "", ""],
	    E: "Edge",
	    F: {
	      C: 1438128000,
	      K: 1447286400,
	      L: 1470096000,
	      D: 1491868800,
	      M: 1508198400,
	      N: 1525046400,
	      O: 1542067200,
	      P: 1579046400,
	      Q: 1581033600,
	      T: 1586736000,
	      U: 1590019200,
	      V: 1594857600,
	      W: 1598486400,
	      X: 1602201600,
	      Y: 1605830400,
	      Z: 1611360000,
	      a: 1614816000,
	      b: 1618358400,
	      c: 1622073600,
	      R: 1626912000,
	      d: 1630627200,
	      H: 1632441600,
	      e: 1634774400
	    },
	    D: {
	      C: "ms",
	      K: "ms",
	      L: "ms",
	      D: "ms",
	      M: "ms",
	      N: "ms",
	      O: "ms"
	    }
	  },
	  C: {
	    A: {
	      "0": 0.004783,
	      "1": 0.00487,
	      "2": 0.005029,
	      "3": 0.0047,
	      "4": 0.038637,
	      "5": 0.004293,
	      "6": 0.004293,
	      "7": 0.004525,
	      "8": 0.004293,
	      "9": 0.008586,
	      lB: 0.004293,
	      dB: 0.004271,
	      I: 0.021465,
	      f: 0.004879,
	      J: 0.020136,
	      E: 0.005725,
	      F: 0.004525,
	      G: 0.00533,
	      A: 0.004283,
	      B: 0.008586,
	      C: 0.004471,
	      K: 0.004486,
	      L: 0.00453,
	      D: 0.004293,
	      M: 0.004417,
	      N: 0.004425,
	      O: 0.004293,
	      g: 0.004443,
	      h: 0.004283,
	      i: 0.004293,
	      j: 0.013698,
	      k: 0.004293,
	      l: 0.008786,
	      m: 0.008586,
	      n: 0.004317,
	      o: 0.004393,
	      p: 0.004418,
	      q: 0.008834,
	      r: 0.004293,
	      s: 0.008928,
	      t: 0.004471,
	      u: 0.009284,
	      v: 0.004707,
	      w: 0.009076,
	      x: 0.004425,
	      y: 0.004783,
	      z: 0.004271,
	      AB: 0.004538,
	      BB: 0.008282,
	      CB: 0.008586,
	      DB: 0.072981,
	      EB: 0.004335,
	      FB: 0.008586,
	      GB: 0.004293,
	      HB: 0.008586,
	      IB: 0.004425,
	      JB: 0.004293,
	      eB: 0.004293,
	      KB: 0.008586,
	      fB: 0.00472,
	      LB: 0.004425,
	      MB: 0.008586,
	      S: 0.00415,
	      NB: 0.004267,
	      OB: 0.004293,
	      PB: 0.004267,
	      QB: 0.012879,
	      RB: 0.00415,
	      SB: 0.004293,
	      TB: 0.004425,
	      UB: 0.008586,
	      VB: 0.00415,
	      WB: 0.00415,
	      XB: 0.004141,
	      YB: 0.004043,
	      ZB: 0.004293,
	      aB: 0.150255,
	      P: 0.012879,
	      Q: 0.012879,
	      T: 0.012879,
	      mB: 0.012879,
	      U: 0.008586,
	      V: 0.017172,
	      W: 0.008586,
	      X: 0.008586,
	      Y: 0.012879,
	      Z: 0.030051,
	      a: 0.047223,
	      b: 0.047223,
	      c: 0.841428,
	      R: 1.77301,
	      d: 0.025758,
	      H: 0,
	      e: 0,
	      nB: 0.008786,
	      oB: 0.00487
	    },
	    B: "moz",
	    C: ["lB", "dB", "nB", "oB", "I", "f", "J", "E", "F", "G", "A", "B", "C", "K", "L", "D", "M", "N", "O", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "eB", "KB", "fB", "LB", "MB", "S", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "P", "Q", "T", "mB", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "R", "d", "H", "e", ""],
	    E: "Firefox",
	    F: {
	      "0": 1435881600,
	      "1": 1439251200,
	      "2": 1442880000,
	      "3": 1446508800,
	      "4": 1450137600,
	      "5": 1453852800,
	      "6": 1457395200,
	      "7": 1461628800,
	      "8": 1465257600,
	      "9": 1470096000,
	      lB: 1161648000,
	      dB: 1213660800,
	      nB: 1246320000,
	      oB: 1264032000,
	      I: 1300752000,
	      f: 1308614400,
	      J: 1313452800,
	      E: 1317081600,
	      F: 1317081600,
	      G: 1320710400,
	      A: 1324339200,
	      B: 1327968000,
	      C: 1331596800,
	      K: 1335225600,
	      L: 1338854400,
	      D: 1342483200,
	      M: 1346112000,
	      N: 1349740800,
	      O: 1353628800,
	      g: 1357603200,
	      h: 1361232000,
	      i: 1364860800,
	      j: 1368489600,
	      k: 1372118400,
	      l: 1375747200,
	      m: 1379376000,
	      n: 1386633600,
	      o: 1391472000,
	      p: 1395100800,
	      q: 1398729600,
	      r: 1402358400,
	      s: 1405987200,
	      t: 1409616000,
	      u: 1413244800,
	      v: 1417392000,
	      w: 1421107200,
	      x: 1424736000,
	      y: 1428278400,
	      z: 1431475200,
	      AB: 1474329600,
	      BB: 1479168000,
	      CB: 1485216000,
	      DB: 1488844800,
	      EB: 1492560000,
	      FB: 1497312000,
	      GB: 1502150400,
	      HB: 1506556800,
	      IB: 1510617600,
	      JB: 1516665600,
	      eB: 1520985600,
	      KB: 1525824000,
	      fB: 1529971200,
	      LB: 1536105600,
	      MB: 1540252800,
	      S: 1544486400,
	      NB: 1548720000,
	      OB: 1552953600,
	      PB: 1558396800,
	      QB: 1562630400,
	      RB: 1567468800,
	      SB: 1571788800,
	      TB: 1575331200,
	      UB: 1578355200,
	      VB: 1581379200,
	      WB: 1583798400,
	      XB: 1586304000,
	      YB: 1588636800,
	      ZB: 1591056000,
	      aB: 1593475200,
	      P: 1595894400,
	      Q: 1598313600,
	      T: 1600732800,
	      mB: 1603152000,
	      U: 1605571200,
	      V: 1607990400,
	      W: 1611619200,
	      X: 1614038400,
	      Y: 1616457600,
	      Z: 1618790400,
	      a: 1622505600,
	      b: 1626134400,
	      c: 1628553600,
	      R: 1630972800,
	      d: 1633392000,
	      H: null,
	      e: null
	    }
	  },
	  D: {
	    A: {
	      "0": 0.004464,
	      "1": 0.012879,
	      "2": 0.0236,
	      "3": 0.004293,
	      "4": 0.008586,
	      "5": 0.004465,
	      "6": 0.004642,
	      "7": 0.004891,
	      "8": 0.012879,
	      "9": 0.021465,
	      I: 0.004706,
	      f: 0.004879,
	      J: 0.004879,
	      E: 0.005591,
	      F: 0.005591,
	      G: 0.005591,
	      A: 0.004534,
	      B: 0.004464,
	      C: 0.010424,
	      K: 0.0083,
	      L: 0.004706,
	      D: 0.015087,
	      M: 0.004393,
	      N: 0.004393,
	      O: 0.008652,
	      g: 0.004293,
	      h: 0.004393,
	      i: 0.004317,
	      j: 0.008586,
	      k: 0.008786,
	      l: 0.017172,
	      m: 0.004461,
	      n: 0.004141,
	      o: 0.004326,
	      p: 0.0047,
	      q: 0.004538,
	      r: 0.004293,
	      s: 0.008596,
	      t: 0.004566,
	      u: 0.008586,
	      v: 0.008586,
	      w: 0.017172,
	      x: 0.004335,
	      y: 0.004464,
	      z: 0.025758,
	      AB: 0.188892,
	      BB: 0.004293,
	      CB: 0.008586,
	      DB: 0.008586,
	      EB: 0.017172,
	      FB: 0.012879,
	      GB: 0.012879,
	      HB: 0.055809,
	      IB: 0.008586,
	      JB: 0.008586,
	      eB: 0.008586,
	      KB: 0.012879,
	      fB: 0.08586,
	      LB: 0.012879,
	      MB: 0.017172,
	      S: 0.021465,
	      NB: 0.025758,
	      OB: 0.025758,
	      PB: 0.017172,
	      QB: 0.012879,
	      RB: 0.068688,
	      SB: 0.051516,
	      TB: 0.021465,
	      UB: 0.047223,
	      VB: 0.012879,
	      WB: 0.077274,
	      XB: 0.090153,
	      YB: 0.060102,
	      ZB: 0.025758,
	      aB: 0.051516,
	      P: 0.206064,
	      Q: 0.08586,
	      T: 0.060102,
	      U: 0.103032,
	      V: 0.137376,
	      W: 0.218943,
	      X: 0.154548,
	      Y: 0.407835,
	      Z: 0.115911,
	      a: 0.184599,
	      b: 0.197478,
	      c: 0.588141,
	      R: 5.26751,
	      d: 15.97,
	      H: 2.60156,
	      e: 0.017172,
	      pB: 0.012879,
	      qB: 0,
	      rB: 0
	    },
	    B: "webkit",
	    C: ["", "", "", "I", "f", "J", "E", "F", "G", "A", "B", "C", "K", "L", "D", "M", "N", "O", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "eB", "KB", "fB", "LB", "MB", "S", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "P", "Q", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "R", "d", "H", "e", "pB", "qB", "rB"],
	    E: "Chrome",
	    F: {
	      "0": 1416268800,
	      "1": 1421798400,
	      "2": 1425513600,
	      "3": 1429401600,
	      "4": 1432080000,
	      "5": 1437523200,
	      "6": 1441152000,
	      "7": 1444780800,
	      "8": 1449014400,
	      "9": 1453248000,
	      I: 1264377600,
	      f: 1274745600,
	      J: 1283385600,
	      E: 1287619200,
	      F: 1291248000,
	      G: 1296777600,
	      A: 1299542400,
	      B: 1303862400,
	      C: 1307404800,
	      K: 1312243200,
	      L: 1316131200,
	      D: 1316131200,
	      M: 1319500800,
	      N: 1323734400,
	      O: 1328659200,
	      g: 1332892800,
	      h: 1337040000,
	      i: 1340668800,
	      j: 1343692800,
	      k: 1348531200,
	      l: 1352246400,
	      m: 1357862400,
	      n: 1361404800,
	      o: 1364428800,
	      p: 1369094400,
	      q: 1374105600,
	      r: 1376956800,
	      s: 1384214400,
	      t: 1389657600,
	      u: 1392940800,
	      v: 1397001600,
	      w: 1400544000,
	      x: 1405468800,
	      y: 1409011200,
	      z: 1412640000,
	      AB: 1456963200,
	      BB: 1460592000,
	      CB: 1464134400,
	      DB: 1469059200,
	      EB: 1472601600,
	      FB: 1476230400,
	      GB: 1480550400,
	      HB: 1485302400,
	      IB: 1489017600,
	      JB: 1492560000,
	      eB: 1496707200,
	      KB: 1500940800,
	      fB: 1504569600,
	      LB: 1508198400,
	      MB: 1512518400,
	      S: 1516752000,
	      NB: 1520294400,
	      OB: 1523923200,
	      PB: 1527552000,
	      QB: 1532390400,
	      RB: 1536019200,
	      SB: 1539648000,
	      TB: 1543968000,
	      UB: 1548720000,
	      VB: 1552348800,
	      WB: 1555977600,
	      XB: 1559606400,
	      YB: 1564444800,
	      ZB: 1568073600,
	      aB: 1571702400,
	      P: 1575936000,
	      Q: 1580860800,
	      T: 1586304000,
	      U: 1589846400,
	      V: 1594684800,
	      W: 1598313600,
	      X: 1601942400,
	      Y: 1605571200,
	      Z: 1611014400,
	      a: 1614556800,
	      b: 1618272000,
	      c: 1621987200,
	      R: 1626739200,
	      d: 1630368000,
	      H: 1632268800,
	      e: 1634601600,
	      pB: null,
	      qB: null,
	      rB: null
	    }
	  },
	  E: {
	    A: {
	      I: 0,
	      f: 0.004293,
	      J: 0.004656,
	      E: 0.004465,
	      F: 0.004043,
	      G: 0.004891,
	      A: 0.004425,
	      B: 0.004293,
	      C: 0.008586,
	      K: 0.072981,
	      L: 0.437886,
	      D: 0.197478,
	      sB: 0,
	      gB: 0.008692,
	      tB: 0.012879,
	      uB: 0.00456,
	      vB: 0.004283,
	      wB: 0.021465,
	      hB: 0.017172,
	      bB: 0.047223,
	      cB: 0.077274,
	      xB: 0.536625,
	      yB: 2.58868,
	      zB: 0
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "sB", "gB", "I", "f", "tB", "J", "uB", "E", "vB", "F", "G", "wB", "A", "hB", "B", "bB", "C", "cB", "K", "xB", "L", "yB", "D", "zB", "", ""],
	    E: "Safari",
	    F: {
	      sB: 1205798400,
	      gB: 1226534400,
	      I: 1244419200,
	      f: 1275868800,
	      tB: 1311120000,
	      J: 1343174400,
	      uB: 1382400000,
	      E: 1382400000,
	      vB: 1410998400,
	      F: 1413417600,
	      G: 1443657600,
	      wB: 1458518400,
	      A: 1474329600,
	      hB: 1490572800,
	      B: 1505779200,
	      bB: 1522281600,
	      C: 1537142400,
	      cB: 1553472000,
	      K: 1568851200,
	      xB: 1585008000,
	      L: 1600214400,
	      yB: 1619395200,
	      D: 1632096000,
	      zB: null
	    }
	  },
	  F: {
	    A: {
	      "0": 0.004534,
	      "1": 0.008586,
	      "2": 0.004227,
	      "3": 0.004418,
	      "4": 0.004293,
	      "5": 0.004227,
	      "6": 0.004725,
	      "7": 0.008586,
	      "8": 0.008942,
	      "9": 0.004707,
	      G: 0.0082,
	      B: 0.016581,
	      C: 0.004317,
	      D: 0.00685,
	      M: 0.00685,
	      N: 0.00685,
	      O: 0.005014,
	      g: 0.006015,
	      h: 0.004879,
	      i: 0.006597,
	      j: 0.006597,
	      k: 0.013434,
	      l: 0.006702,
	      m: 0.006015,
	      n: 0.005595,
	      o: 0.004393,
	      p: 0.008652,
	      q: 0.004879,
	      r: 0.004879,
	      s: 0.004293,
	      t: 0.005152,
	      u: 0.005014,
	      v: 0.009758,
	      w: 0.004879,
	      x: 0.008586,
	      y: 0.004283,
	      z: 0.004367,
	      AB: 0.004827,
	      BB: 0.004707,
	      CB: 0.004707,
	      DB: 0.004326,
	      EB: 0.008922,
	      FB: 0.014349,
	      GB: 0.004425,
	      HB: 0.00472,
	      IB: 0.004425,
	      JB: 0.004425,
	      KB: 0.00472,
	      LB: 0.004532,
	      MB: 0.004566,
	      S: 0.02283,
	      NB: 0.00867,
	      OB: 0.004656,
	      PB: 0.004642,
	      QB: 0.004293,
	      RB: 0.00944,
	      SB: 0.004293,
	      TB: 0.004293,
	      UB: 0.004298,
	      VB: 0.096692,
	      WB: 0.004201,
	      XB: 0.004141,
	      YB: 0.004043,
	      ZB: 0.017172,
	      aB: 0.759861,
	      P: 0.17172,
	      Q: 0,
	      "0B": 0.00685,
	      "1B": 0.004293,
	      "2B": 0.008392,
	      "3B": 0.004706,
	      bB: 0.006229,
	      iB: 0.004879,
	      "4B": 0.008786,
	      cB: 0.00472
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "0B", "1B", "2B", "3B", "B", "bB", "iB", "4B", "C", "cB", "D", "M", "N", "O", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "S", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "P", "Q", "", "", ""],
	    E: "Opera",
	    F: {
	      "0": 1470096000,
	      "1": 1474329600,
	      "2": 1477267200,
	      "3": 1481587200,
	      "4": 1486425600,
	      "5": 1490054400,
	      "6": 1494374400,
	      "7": 1498003200,
	      "8": 1502236800,
	      "9": 1506470400,
	      G: 1150761600,
	      "0B": 1223424000,
	      "1B": 1251763200,
	      "2B": 1267488000,
	      "3B": 1277942400,
	      B: 1292457600,
	      bB: 1302566400,
	      iB: 1309219200,
	      "4B": 1323129600,
	      C: 1323129600,
	      cB: 1352073600,
	      D: 1372723200,
	      M: 1377561600,
	      N: 1381104000,
	      O: 1386288000,
	      g: 1390867200,
	      h: 1393891200,
	      i: 1399334400,
	      j: 1401753600,
	      k: 1405987200,
	      l: 1409616000,
	      m: 1413331200,
	      n: 1417132800,
	      o: 1422316800,
	      p: 1425945600,
	      q: 1430179200,
	      r: 1433808000,
	      s: 1438646400,
	      t: 1442448000,
	      u: 1445904000,
	      v: 1449100800,
	      w: 1454371200,
	      x: 1457308800,
	      y: 1462320000,
	      z: 1465344000,
	      AB: 1510099200,
	      BB: 1515024000,
	      CB: 1517961600,
	      DB: 1521676800,
	      EB: 1525910400,
	      FB: 1530144000,
	      GB: 1534982400,
	      HB: 1537833600,
	      IB: 1543363200,
	      JB: 1548201600,
	      KB: 1554768000,
	      LB: 1561593600,
	      MB: 1566259200,
	      S: 1570406400,
	      NB: 1573689600,
	      OB: 1578441600,
	      PB: 1583971200,
	      QB: 1587513600,
	      RB: 1592956800,
	      SB: 1595894400,
	      TB: 1600128000,
	      UB: 1603238400,
	      VB: 1613520000,
	      WB: 1612224000,
	      XB: 1616544000,
	      YB: 1619568000,
	      ZB: 1623715200,
	      aB: 1627948800,
	      P: 1631577600,
	      Q: 1633392000
	    },
	    D: {
	      G: "o",
	      B: "o",
	      C: "o",
	      "0B": "o",
	      "1B": "o",
	      "2B": "o",
	      "3B": "o",
	      bB: "o",
	      iB: "o",
	      "4B": "o",
	      cB: "o"
	    }
	  },
	  G: {
	    A: {
	      F: 0,
	      D: 0.586471,
	      gB: 0,
	      "5B": 0,
	      jB: 0.00276637,
	      "6B": 0.00829912,
	      "7B": 0.0968231,
	      "8B": 0.0248974,
	      "9B": 0.0138319,
	      AC: 0.0179814,
	      BC: 0.116188,
	      CC: 0.0428788,
	      DC: 0.131403,
	      EC: 0.0829912,
	      FC: 0.0539443,
	      GC: 0.0567107,
	      HC: 0.709575,
	      IC: 0.044262,
	      JC: 0.022131,
	      KC: 0.116188,
	      LC: 0.374844,
	      MC: 1.32924,
	      NC: 9.99906
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gB", "5B", "jB", "6B", "7B", "8B", "F", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "KC", "LC", "MC", "NC", "D", "", "", ""],
	    E: "Safari on iOS",
	    F: {
	      gB: 1270252800,
	      "5B": 1283904000,
	      jB: 1299628800,
	      "6B": 1331078400,
	      "7B": 1359331200,
	      "8B": 1394409600,
	      F: 1410912000,
	      "9B": 1413763200,
	      AC: 1442361600,
	      BC: 1458518400,
	      CC: 1473724800,
	      DC: 1490572800,
	      EC: 1505779200,
	      FC: 1522281600,
	      GC: 1537142400,
	      HC: 1553472000,
	      IC: 1568851200,
	      JC: 1572220800,
	      KC: 1580169600,
	      LC: 1585008000,
	      MC: 1600214400,
	      NC: 1619395200,
	      D: 1632096000
	    }
	  },
	  H: {
	    A: {
	      OC: 1.18887
	    },
	    B: "o",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OC", "", "", ""],
	    E: "Opera Mini",
	    F: {
	      OC: 1426464000
	    }
	  },
	  I: {
	    A: {
	      dB: 0,
	      I: 0.0066069,
	      H: 0,
	      PC: 0,
	      QC: 0,
	      RC: 0,
	      SC: 0.0110115,
	      jB: 0.0484506,
	      TC: 0,
	      UC: 0.213623
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "PC", "QC", "RC", "dB", "I", "SC", "jB", "TC", "UC", "H", "", "", ""],
	    E: "Android Browser",
	    F: {
	      PC: 1256515200,
	      QC: 1274313600,
	      RC: 1291593600,
	      dB: 1298332800,
	      I: 1318896000,
	      SC: 1341792000,
	      jB: 1374624000,
	      TC: 1386547200,
	      UC: 1401667200,
	      H: 1632355200
	    }
	  },
	  J: {
	    A: {
	      E: 0,
	      A: 0
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "A", "", "", ""],
	    E: "Blackberry Browser",
	    F: {
	      E: 1325376000,
	      A: 1359504000
	    }
	  },
	  K: {
	    A: {
	      A: 0,
	      B: 0,
	      C: 0,
	      S: 0.0111391,
	      bB: 0,
	      iB: 0,
	      cB: 0
	    },
	    B: "o",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "bB", "iB", "C", "cB", "S", "", "", ""],
	    E: "Opera Mobile",
	    F: {
	      A: 1287100800,
	      B: 1300752000,
	      bB: 1314835200,
	      iB: 1318291200,
	      C: 1330300800,
	      cB: 1349740800,
	      S: 1613433600
	    },
	    D: {
	      S: "webkit"
	    }
	  },
	  L: {
	    A: {
	      H: 38.0375
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""],
	    E: "Chrome for Android",
	    F: {
	      H: 1632182400
	    }
	  },
	  M: {
	    A: {
	      R: 0.279692
	    },
	    B: "moz",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "R", "", "", ""],
	    E: "Firefox for Android",
	    F: {
	      R: 1630972800
	    }
	  },
	  N: {
	    A: {
	      A: 0.0115934,
	      B: 0.022664
	    },
	    B: "ms",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
	    E: "IE Mobile",
	    F: {
	      A: 1340150400,
	      B: 1353456000
	    }
	  },
	  O: {
	    A: {
	      VC: 1.0674
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "VC", "", "", ""],
	    E: "UC Browser for Android",
	    F: {
	      VC: 1471392000
	    },
	    D: {
	      VC: "webkit"
	    }
	  },
	  P: {
	    A: {
	      I: 0.241599,
	      WC: 0.0103543,
	      XC: 0.010304,
	      YC: 0.0735301,
	      ZC: 0.0103584,
	      aC: 0.0315129,
	      hB: 0.0105043,
	      bC: 0.126052,
	      cC: 0.0630258,
	      dC: 0.168069,
	      eC: 0.399164,
	      fC: 1.91178
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "WC", "XC", "YC", "ZC", "aC", "hB", "bC", "cC", "dC", "eC", "fC", "", "", ""],
	    E: "Samsung Internet",
	    F: {
	      I: 1461024000,
	      WC: 1481846400,
	      XC: 1509408000,
	      YC: 1528329600,
	      ZC: 1546128000,
	      aC: 1554163200,
	      hB: 1567900800,
	      bC: 1582588800,
	      cC: 1593475200,
	      dC: 1605657600,
	      eC: 1618531200,
	      fC: 1629072000
	    }
	  },
	  Q: {
	    A: {
	      gC: 0.176948
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gC", "", "", ""],
	    E: "QQ Browser",
	    F: {
	      gC: 1589846400
	    }
	  },
	  R: {
	    A: {
	      hC: 0
	    },
	    B: "webkit",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "hC", "", "", ""],
	    E: "Baidu Browser",
	    F: {
	      hC: 1491004800
	    }
	  },
	  S: {
	    A: {
	      iC: 0.097036
	    },
	    B: "moz",
	    C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "iC", "", "", ""],
	    E: "KaiOS Browser",
	    F: {
	      iC: 1527811200
	    }
	  }
	};

	var browsers = browsers$1.browsers;
	var versions$1 = browserVersions.browserVersions;

	function unpackBrowserVersions(versionsData) {
	  return Object.keys(versionsData).reduce(function (usage, version) {
	    usage[versions$1[version]] = versionsData[version];
	    return usage;
	  }, {});
	}

	var agents_1 = Object.keys(agents$2).reduce(function (map, key) {
	  var versionsData = agents$2[key];
	  map[browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
	    if (entry === 'A') {
	      data.usage_global = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === 'C') {
	      data.versions = versionsData[entry].reduce(function (list, version) {
	        if (version === '') {
	          list.push(null);
	        } else {
	          list.push(versions$1[version]);
	        }

	        return list;
	      }, []);
	    } else if (entry === 'D') {
	      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
	    } else if (entry === 'E') {
	      data.browser = versionsData[entry];
	    } else if (entry === 'F') {
	      data.release_date = Object.keys(versionsData[entry]).reduce(function (map2, key2) {
	        map2[versions$1[key2]] = versionsData[entry][key2];
	        return map2;
	      }, {});
	    } else {
	      data.prefix = versionsData[entry];
	    }

	    return data;
	  }, {});
	  return map;
	}, {});
	var agents$1 = {
	  agents: agents_1
	};

	var v4 = {
		start: "2015-09-08",
		lts: "2015-10-12",
		maintenance: "2017-04-01",
		end: "2018-04-30",
		codename: "Argon"
	};
	var v5 = {
		start: "2015-10-29",
		maintenance: "2016-04-30",
		end: "2016-06-30"
	};
	var v6 = {
		start: "2016-04-26",
		lts: "2016-10-18",
		maintenance: "2018-04-30",
		end: "2019-04-30",
		codename: "Boron"
	};
	var v7 = {
		start: "2016-10-25",
		maintenance: "2017-04-30",
		end: "2017-06-30"
	};
	var v8 = {
		start: "2017-05-30",
		lts: "2017-10-31",
		maintenance: "2019-01-01",
		end: "2019-12-31",
		codename: "Carbon"
	};
	var v9 = {
		start: "2017-10-01",
		maintenance: "2018-04-01",
		end: "2018-06-30"
	};
	var v10 = {
		start: "2018-04-24",
		lts: "2018-10-30",
		maintenance: "2020-05-19",
		end: "2021-04-30",
		codename: "Dubnium"
	};
	var v11 = {
		start: "2018-10-23",
		maintenance: "2019-04-22",
		end: "2019-06-01"
	};
	var v12 = {
		start: "2019-04-23",
		lts: "2019-10-21",
		maintenance: "2020-11-30",
		end: "2022-04-30",
		codename: "Erbium"
	};
	var v13 = {
		start: "2019-10-22",
		maintenance: "2020-04-01",
		end: "2020-06-01"
	};
	var v14 = {
		start: "2020-04-21",
		lts: "2020-10-27",
		maintenance: "2021-10-19",
		end: "2023-04-30",
		codename: "Fermium"
	};
	var v15 = {
		start: "2020-10-20",
		maintenance: "2021-04-01",
		end: "2021-06-01"
	};
	var v16 = {
		start: "2021-04-20",
		lts: "2021-10-26",
		maintenance: "2022-10-18",
		end: "2024-04-30",
		codename: ""
	};
	var v17 = {
		start: "2021-10-19",
		maintenance: "2022-04-01",
		end: "2022-06-01"
	};
	var v18 = {
		start: "2022-04-19",
		lts: "2022-10-25",
		maintenance: "2023-10-18",
		end: "2025-04-30",
		codename: ""
	};
	var jsEOL = {
		"v0.8": {
		start: "2012-06-25",
		end: "2014-07-31"
	},
		"v0.10": {
		start: "2013-03-11",
		end: "2016-10-31"
	},
		"v0.12": {
		start: "2015-02-06",
		end: "2016-12-31"
	},
		v4: v4,
		v5: v5,
		v6: v6,
		v7: v7,
		v8: v8,
		v9: v9,
		v10: v10,
		v11: v11,
		v12: v12,
		v13: v13,
		v14: v14,
		v15: v15,
		v16: v16,
		v17: v17,
		v18: v18
	};

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var versions = {
	  "0.20": "39",
	  "0.21": "41",
	  "0.22": "41",
	  "0.23": "41",
	  "0.24": "41",
	  "0.25": "42",
	  "0.26": "42",
	  "0.27": "43",
	  "0.28": "43",
	  "0.29": "43",
	  "0.30": "44",
	  "0.31": "45",
	  "0.32": "45",
	  "0.33": "45",
	  "0.34": "45",
	  "0.35": "45",
	  "0.36": "47",
	  "0.37": "49",
	  "1.0": "49",
	  "1.1": "50",
	  "1.2": "51",
	  "1.3": "52",
	  "1.4": "53",
	  "1.5": "54",
	  "1.6": "56",
	  "1.7": "58",
	  "1.8": "59",
	  "2.0": "61",
	  "2.1": "61",
	  "3.0": "66",
	  "3.1": "66",
	  "4.0": "69",
	  "4.1": "69",
	  "4.2": "69",
	  "5.0": "73",
	  "6.0": "76",
	  "6.1": "76",
	  "7.0": "78",
	  "7.1": "78",
	  "7.2": "78",
	  "7.3": "78",
	  "8.0": "80",
	  "8.1": "80",
	  "8.2": "80",
	  "8.3": "80",
	  "8.4": "80",
	  "8.5": "80",
	  "9.0": "83",
	  "9.1": "83",
	  "9.2": "83",
	  "9.3": "83",
	  "9.4": "83",
	  "10.0": "85",
	  "10.1": "85",
	  "10.2": "85",
	  "10.3": "85",
	  "10.4": "85",
	  "11.0": "87",
	  "11.1": "87",
	  "11.2": "87",
	  "11.3": "87",
	  "11.4": "87",
	  "12.0": "89",
	  "13.0": "91",
	  "13.1": "91",
	  "14.0": "92"
	};

	function BrowserslistError(message) {
	  this.name = 'BrowserslistError';
	  this.message = message;
	  this.browserslist = true;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, BrowserslistError);
	  }
	}

	BrowserslistError.prototype = Error.prototype;
	var error = BrowserslistError;

	function noop() {}

	var browser = {
	  loadQueries: function loadQueries() {
	    throw new error('Sharable configs are not supported in client-side build of Browserslist');
	  },
	  getStat: function getStat(opts) {
	    return opts.stats;
	  },
	  loadConfig: function loadConfig(opts) {
	    if (opts.config) {
	      throw new error('Browserslist config are not supported in client-side build');
	    }
	  },
	  loadCountry: function loadCountry() {
	    throw new error('Country statistics are not supported ' + 'in client-side build of Browserslist');
	  },
	  loadFeature: function loadFeature() {
	    throw new error('Supports queries are not available in client-side build of Browserslist');
	  },
	  currentNode: function currentNode(resolve, context) {
	    return resolve(['maintained node versions'], context)[0];
	  },
	  parseConfig: noop,
	  readConfig: noop,
	  findConfig: noop,
	  clearCaches: noop,
	  oldDataWarning: noop
	};

	var fs$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	var agents = agents$1.agents;
	var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
	var ANDROID_EVERGREEN_FIRST = 37;
	var QUERY_OR = 1;
	var QUERY_AND = 2;

	function isVersionsMatch(versionA, versionB) {
	  return (versionA + '.').indexOf(versionB + '.') === 0;
	}

	function isEolReleased(name) {
	  var version = name.slice(1);
	  return jsReleases.some(function (i) {
	    return isVersionsMatch(i.version, version);
	  });
	}

	function normalize(versions) {
	  return versions.filter(function (version) {
	    return typeof version === 'string';
	  });
	}

	function normalizeElectron(version) {
	  var versionToUse = version;

	  if (version.split('.').length === 3) {
	    versionToUse = version.split('.').slice(0, -1).join('.');
	  }

	  return versionToUse;
	}

	function nameMapper(name) {
	  return function mapName(version) {
	    return name + ' ' + version;
	  };
	}

	function getMajor(version) {
	  return parseInt(version.split('.')[0]);
	}

	function getMajorVersions(released, number) {
	  if (released.length === 0) return [];
	  var majorVersions = uniq(released.map(getMajor));
	  var minimum = majorVersions[majorVersions.length - number];

	  if (!minimum) {
	    return released;
	  }

	  var selected = [];

	  for (var i = released.length - 1; i >= 0; i--) {
	    if (minimum > getMajor(released[i])) break;
	    selected.unshift(released[i]);
	  }

	  return selected;
	}

	function uniq(array) {
	  var filtered = [];

	  for (var i = 0; i < array.length; i++) {
	    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
	  }

	  return filtered;
	}

	function fillUsage(result, name, data) {
	  for (var i in data) {
	    result[name + ' ' + i] = data[i];
	  }
	}

	function generateFilter(sign, version) {
	  version = parseFloat(version);

	  if (sign === '>') {
	    return function (v) {
	      return parseFloat(v) > version;
	    };
	  } else if (sign === '>=') {
	    return function (v) {
	      return parseFloat(v) >= version;
	    };
	  } else if (sign === '<') {
	    return function (v) {
	      return parseFloat(v) < version;
	    };
	  } else {
	    return function (v) {
	      return parseFloat(v) <= version;
	    };
	  }
	}

	function generateSemverFilter(sign, version) {
	  version = version.split('.').map(parseSimpleInt);
	  version[1] = version[1] || 0;
	  version[2] = version[2] || 0;

	  if (sign === '>') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(v, version) > 0;
	    };
	  } else if (sign === '>=') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(v, version) >= 0;
	    };
	  } else if (sign === '<') {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(version, v) > 0;
	    };
	  } else {
	    return function (v) {
	      v = v.split('.').map(parseSimpleInt);
	      return compareSemver(version, v) >= 0;
	    };
	  }
	}

	function parseSimpleInt(x) {
	  return parseInt(x);
	}

	function compare$3(a, b) {
	  if (a < b) return -1;
	  if (a > b) return +1;
	  return 0;
	}

	function compareSemver(a, b) {
	  return compare$3(parseInt(a[0]), parseInt(b[0])) || compare$3(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare$3(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
	}

	function semverFilterLoose(operator, range) {
	  range = range.split('.').map(parseSimpleInt);

	  if (typeof range[1] === 'undefined') {
	    range[1] = 'x';
	  }

	  switch (operator) {
	    case '<=':
	      return function (version) {
	        version = version.split('.').map(parseSimpleInt);
	        return compareSemverLoose(version, range) <= 0;
	      };

	    default:
	    case '>=':
	      return function (version) {
	        version = version.split('.').map(parseSimpleInt);
	        return compareSemverLoose(version, range) >= 0;
	      };
	  }
	}

	function compareSemverLoose(version, range) {
	  if (version[0] !== range[0]) {
	    return version[0] < range[0] ? -1 : +1;
	  }

	  if (range[1] === 'x') {
	    return 0;
	  }

	  if (version[1] !== range[1]) {
	    return version[1] < range[1] ? -1 : +1;
	  }

	  return 0;
	}

	function resolveVersion(data, version) {
	  if (data.versions.indexOf(version) !== -1) {
	    return version;
	  } else if (browserslist.versionAliases[data.name][version]) {
	    return browserslist.versionAliases[data.name][version];
	  } else {
	    return false;
	  }
	}

	function normalizeVersion(data, version) {
	  var resolved = resolveVersion(data, version);

	  if (resolved) {
	    return resolved;
	  } else if (data.versions.length === 1) {
	    return data.versions[0];
	  } else {
	    return false;
	  }
	}

	function filterByYear(since, context) {
	  since = since / 1000;
	  return Object.keys(agents).reduce(function (selected, name) {
	    var data = byName(name, context);
	    if (!data) return selected;
	    var versions = Object.keys(data.releaseDate).filter(function (v) {
	      return data.releaseDate[v] >= since;
	    });
	    return selected.concat(versions.map(nameMapper(data.name)));
	  }, []);
	}

	function cloneData(data) {
	  return {
	    name: data.name,
	    versions: data.versions,
	    released: data.released,
	    releaseDate: data.releaseDate
	  };
	}

	function mapVersions(data, map) {
	  data.versions = data.versions.map(function (i) {
	    return map[i] || i;
	  });
	  data.released = data.versions.map(function (i) {
	    return map[i] || i;
	  });
	  var fixedDate = {};

	  for (var i in data.releaseDate) {
	    fixedDate[map[i] || i] = data.releaseDate[i];
	  }

	  data.releaseDate = fixedDate;
	  return data;
	}

	function byName(name, context) {
	  name = name.toLowerCase();
	  name = browserslist.aliases[name] || name;

	  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
	    var desktop = browserslist.data[browserslist.desktopNames[name]];

	    if (name === 'android') {
	      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
	    } else {
	      var cloned = cloneData(desktop);
	      cloned.name = name;

	      if (name === 'op_mob') {
	        cloned = mapVersions(cloned, {
	          '10.0-10.1': '10'
	        });
	      }

	      return cloned;
	    }
	  }

	  return browserslist.data[name];
	}

	function normalizeAndroidVersions(androidVersions, chromeVersions) {
	  var firstEvergreen = ANDROID_EVERGREEN_FIRST;
	  var last = chromeVersions[chromeVersions.length - 1];
	  return androidVersions.filter(function (version) {
	    return /^(?:[2-4]\.|[34]$)/.test(version);
	  }).concat(chromeVersions.slice(firstEvergreen - last - 1));
	}

	function normalizeAndroidData(android, chrome) {
	  android.released = normalizeAndroidVersions(android.released, chrome.released);
	  android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
	  return android;
	}

	function checkName(name, context) {
	  var data = byName(name, context);
	  if (!data) throw new error('Unknown browser ' + name);
	  return data;
	}

	function unknownQuery(query) {
	  return new error('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
	}

	function filterAndroid(list, versions, context) {
	  if (context.mobileToDesktop) return list;
	  var released = browserslist.data.android.released;
	  var last = released[released.length - 1];
	  var diff = last - ANDROID_EVERGREEN_FIRST - versions;

	  if (diff > 0) {
	    return list.slice(-1);
	  } else {
	    return list.slice(diff - 1);
	  }
	}

	function resolve$2(queries, context) {
	  if (Array.isArray(queries)) {
	    queries = flatten$1(queries.map(parse$3));
	  } else {
	    queries = parse$3(queries);
	  }

	  return queries.reduce(function (result, query, index) {
	    var selection = query.queryString;
	    var isExclude = selection.indexOf('not ') === 0;

	    if (isExclude) {
	      if (index === 0) {
	        throw new error('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
	      }

	      selection = selection.slice(4);
	    }

	    for (var i = 0; i < QUERIES.length; i++) {
	      var type = QUERIES[i];
	      var match = selection.match(type.regexp);

	      if (match) {
	        var args = [context].concat(match.slice(1));
	        var array = type.select.apply(browserslist, args).map(function (j) {
	          var parts = j.split(' ');

	          if (parts[1] === '0') {
	            return parts[0] + ' ' + byName(parts[0], context).versions[0];
	          } else {
	            return j;
	          }
	        });

	        switch (query.type) {
	          case QUERY_AND:
	            if (isExclude) {
	              return result.filter(function (j) {
	                return array.indexOf(j) === -1;
	              });
	            } else {
	              return result.filter(function (j) {
	                return array.indexOf(j) !== -1;
	              });
	            }

	          case QUERY_OR:
	          default:
	            if (isExclude) {
	              var filter = {};
	              array.forEach(function (j) {
	                filter[j] = true;
	              });
	              return result.filter(function (j) {
	                return !filter[j];
	              });
	            }

	            return result.concat(array);
	        }
	      }
	    }

	    throw unknownQuery(selection);
	  }, []);
	}

	var cache = {};

	function browserslist(queries, opts) {
	  if (typeof opts === 'undefined') opts = {};

	  if (typeof opts.path === 'undefined') {
	    opts.path = fs$1.resolve ? fs$1.resolve('.') : '.';
	  }

	  if (typeof queries === 'undefined' || queries === null) {
	    var config = browserslist.loadConfig(opts);

	    if (config) {
	      queries = config;
	    } else {
	      queries = browserslist.defaults;
	    }
	  }

	  if (!(typeof queries === 'string' || Array.isArray(queries))) {
	    throw new error('Browser queries must be an array or string. Got ' + typeof queries + '.');
	  }

	  var context = {
	    ignoreUnknownVersions: opts.ignoreUnknownVersions,
	    dangerousExtend: opts.dangerousExtend,
	    mobileToDesktop: opts.mobileToDesktop,
	    path: opts.path,
	    env: opts.env
	  };
	  var stats = browser.getStat(opts, browserslist.data);

	  if (stats) {
	    context.customUsage = {};

	    for (var browser$1 in stats) {
	      fillUsage(context.customUsage, browser$1, stats[browser$1]);
	    }
	  }

	  var cacheKey = JSON.stringify([queries, context]);
	  if (cache[cacheKey]) return cache[cacheKey];
	  var result = uniq(resolve$2(queries, context)).sort(function (name1, name2) {
	    name1 = name1.split(' ');
	    name2 = name2.split(' ');

	    if (name1[0] === name2[0]) {
	      var version1 = name1[1].split('-')[0];
	      var version2 = name2[1].split('-')[0];
	      return compareSemver(version2.split('.'), version1.split('.'));
	    } else {
	      return compare$3(name1[0], name2[0]);
	    }
	  });

	  if (!browser$4.env.BROWSERSLIST_DISABLE_CACHE) {
	    cache[cacheKey] = result;
	  }

	  return result;
	}

	function parse$3(queries) {
	  var qs = [];

	  do {
	    queries = doMatch(queries, qs);
	  } while (queries);

	  return qs;
	}

	function doMatch(string, qs) {
	  var or = /^(?:,\s*|\s+or\s+)(.*)/i;
	  var and = /^\s+and\s+(.*)/i;
	  return find(string, function (parsed, n, max) {
	    if (and.test(parsed)) {
	      qs.unshift({
	        type: QUERY_AND,
	        queryString: parsed.match(and)[1]
	      });
	      return true;
	    } else if (or.test(parsed)) {
	      qs.unshift({
	        type: QUERY_OR,
	        queryString: parsed.match(or)[1]
	      });
	      return true;
	    } else if (n === max) {
	      qs.unshift({
	        type: QUERY_OR,
	        queryString: parsed.trim()
	      });
	      return true;
	    }

	    return false;
	  });
	}

	function find(string, predicate) {
	  for (var n = 1, max = string.length; n <= max; n++) {
	    var parsed = string.substr(-n, n);

	    if (predicate(parsed, n, max)) {
	      return string.slice(0, -n);
	    }
	  }

	  return '';
	}

	function flatten$1(array) {
	  if (!Array.isArray(array)) return [array];
	  return array.reduce(function (a, b) {
	    return a.concat(flatten$1(b));
	  }, []);
	}

	browserslist.cache = {};
	browserslist.data = {};
	browserslist.usage = {
	  global: {},
	  custom: null
	};
	browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];
	browserslist.aliases = {
	  fx: 'firefox',
	  ff: 'firefox',
	  ios: 'ios_saf',
	  explorer: 'ie',
	  blackberry: 'bb',
	  explorermobile: 'ie_mob',
	  operamini: 'op_mini',
	  operamobile: 'op_mob',
	  chromeandroid: 'and_chr',
	  firefoxandroid: 'and_ff',
	  ucandroid: 'and_uc',
	  qqandroid: 'and_qq'
	};
	browserslist.desktopNames = {
	  and_chr: 'chrome',
	  and_ff: 'firefox',
	  ie_mob: 'ie',
	  op_mob: 'opera',
	  android: 'chrome'
	};
	browserslist.versionAliases = {};
	browserslist.clearCaches = browser.clearCaches;
	browserslist.parseConfig = browser.parseConfig;
	browserslist.readConfig = browser.readConfig;
	browserslist.findConfig = browser.findConfig;
	browserslist.loadConfig = browser.loadConfig;

	browserslist.coverage = function (browsers, stats) {
	  var data;

	  if (typeof stats === 'undefined') {
	    data = browserslist.usage.global;
	  } else if (stats === 'my stats') {
	    var opts = {};
	    opts.path = fs$1.resolve ? fs$1.resolve('.') : '.';
	    var customStats = browser.getStat(opts);

	    if (!customStats) {
	      throw new error('Custom usage statistics was not provided');
	    }

	    data = {};

	    for (var browser$1 in customStats) {
	      fillUsage(data, browser$1, customStats[browser$1]);
	    }
	  } else if (typeof stats === 'string') {
	    if (stats.length > 2) {
	      stats = stats.toLowerCase();
	    } else {
	      stats = stats.toUpperCase();
	    }

	    browser.loadCountry(browserslist.usage, stats, browserslist.data);
	    data = browserslist.usage[stats];
	  } else {
	    if ('dataByBrowser' in stats) {
	      stats = stats.dataByBrowser;
	    }

	    data = {};

	    for (var name in stats) {
	      for (var version in stats[name]) {
	        data[name + ' ' + version] = stats[name][version];
	      }
	    }
	  }

	  return browsers.reduce(function (all, i) {
	    var usage = data[i];

	    if (usage === undefined) {
	      usage = data[i.replace(/ \S+$/, ' 0')];
	    }

	    return all + (usage || 0);
	  }, 0);
	};

	function nodeQuery(context, version) {
	  var nodeReleases = jsReleases.filter(function (i) {
	    return i.name === 'nodejs';
	  });
	  var matched = nodeReleases.filter(function (i) {
	    return isVersionsMatch(i.version, version);
	  });

	  if (matched.length === 0) {
	    if (context.ignoreUnknownVersions) {
	      return [];
	    } else {
	      throw new error('Unknown version ' + version + ' of Node.js');
	    }
	  }

	  return ['node ' + matched[matched.length - 1].version];
	}

	function sinceQuery(context, year, month, date) {
	  year = parseInt(year);
	  month = parseInt(month || '01') - 1;
	  date = parseInt(date || '01');
	  return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
	}

	function coverQuery(context, coverage, statMode) {
	  coverage = parseFloat(coverage);
	  var usage = browserslist.usage.global;

	  if (statMode) {
	    if (statMode.match(/^my\s+stats$/)) {
	      if (!context.customUsage) {
	        throw new error('Custom usage statistics was not provided');
	      }

	      usage = context.customUsage;
	    } else {
	      var place;

	      if (statMode.length === 2) {
	        place = statMode.toUpperCase();
	      } else {
	        place = statMode.toLowerCase();
	      }

	      browser.loadCountry(browserslist.usage, place, browserslist.data);
	      usage = browserslist.usage[place];
	    }
	  }

	  var versions = Object.keys(usage).sort(function (a, b) {
	    return usage[b] - usage[a];
	  });
	  var coveraged = 0;
	  var result = [];
	  var version;

	  for (var i = 0; i <= versions.length; i++) {
	    version = versions[i];
	    if (usage[version] === 0) break;
	    coveraged += usage[version];
	    result.push(version);
	    if (coveraged >= coverage) break;
	  }

	  return result;
	}

	var QUERIES = [{
	  regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
	  select: function select(context, versions) {
	    return Object.keys(agents).reduce(function (selected, name) {
	      var data = byName(name, context);
	      if (!data) return selected;
	      var list = getMajorVersions(data.released, versions);
	      list = list.map(nameMapper(data.name));

	      if (data.name === 'android') {
	        list = filterAndroid(list, versions, context);
	      }

	      return selected.concat(list);
	    }, []);
	  }
	}, {
	  regexp: /^last\s+(\d+)\s+versions?$/i,
	  select: function select(context, versions) {
	    return Object.keys(agents).reduce(function (selected, name) {
	      var data = byName(name, context);
	      if (!data) return selected;
	      var list = data.released.slice(-versions);
	      list = list.map(nameMapper(data.name));

	      if (data.name === 'android') {
	        list = filterAndroid(list, versions, context);
	      }

	      return selected.concat(list);
	    }, []);
	  }
	}, {
	  regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
	  select: function select(context, versions$1) {
	    var validVersions = getMajorVersions(Object.keys(versions), versions$1);
	    return validVersions.map(function (i) {
	      return 'chrome ' + versions[i];
	    });
	  }
	}, {
	  regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
	  select: function select(context, versions, name) {
	    var data = checkName(name, context);
	    var validVersions = getMajorVersions(data.released, versions);
	    var list = validVersions.map(nameMapper(data.name));

	    if (data.name === 'android') {
	      list = filterAndroid(list, versions, context);
	    }

	    return list;
	  }
	}, {
	  regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
	  select: function select(context, versions$1) {
	    return Object.keys(versions).slice(-versions$1).map(function (i) {
	      return 'chrome ' + versions[i];
	    });
	  }
	}, {
	  regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
	  select: function select(context, versions, name) {
	    var data = checkName(name, context);
	    var list = data.released.slice(-versions).map(nameMapper(data.name));

	    if (data.name === 'android') {
	      list = filterAndroid(list, versions, context);
	    }

	    return list;
	  }
	}, {
	  regexp: /^unreleased\s+versions$/i,
	  select: function select(context) {
	    return Object.keys(agents).reduce(function (selected, name) {
	      var data = byName(name, context);
	      if (!data) return selected;
	      var list = data.versions.filter(function (v) {
	        return data.released.indexOf(v) === -1;
	      });
	      list = list.map(nameMapper(data.name));
	      return selected.concat(list);
	    }, []);
	  }
	}, {
	  regexp: /^unreleased\s+electron\s+versions?$/i,
	  select: function select() {
	    return [];
	  }
	}, {
	  regexp: /^unreleased\s+(\w+)\s+versions?$/i,
	  select: function select(context, name) {
	    var data = checkName(name, context);
	    return data.versions.filter(function (v) {
	      return data.released.indexOf(v) === -1;
	    }).map(nameMapper(data.name));
	  }
	}, {
	  regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
	  select: function select(context, years) {
	    return filterByYear(Date.now() - YEAR * years, context);
	  }
	}, {
	  regexp: /^since (\d+)$/i,
	  select: sinceQuery
	}, {
	  regexp: /^since (\d+)-(\d+)$/i,
	  select: sinceQuery
	}, {
	  regexp: /^since (\d+)-(\d+)-(\d+)$/i,
	  select: sinceQuery
	}, {
	  regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
	  select: function select(context, sign, popularity) {
	    popularity = parseFloat(popularity);
	    var usage = browserslist.usage.global;
	    return Object.keys(usage).reduce(function (result, version) {
	      if (sign === '>') {
	        if (usage[version] > popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<') {
	        if (usage[version] < popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<=') {
	        if (usage[version] <= popularity) {
	          result.push(version);
	        }
	      } else if (usage[version] >= popularity) {
	        result.push(version);
	      }

	      return result;
	    }, []);
	  }
	}, {
	  regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
	  select: function select(context, sign, popularity) {
	    popularity = parseFloat(popularity);

	    if (!context.customUsage) {
	      throw new error('Custom usage statistics was not provided');
	    }

	    var usage = context.customUsage;
	    return Object.keys(usage).reduce(function (result, version) {
	      if (sign === '>') {
	        if (usage[version] > popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<') {
	        if (usage[version] < popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<=') {
	        if (usage[version] <= popularity) {
	          result.push(version);
	        }
	      } else if (usage[version] >= popularity) {
	        result.push(version);
	      }

	      return result;
	    }, []);
	  }
	}, {
	  regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
	  select: function select(context, sign, popularity, name) {
	    popularity = parseFloat(popularity);
	    var stats = browser.loadStat(context, name, browserslist.data);

	    if (stats) {
	      context.customUsage = {};

	      for (var browser$1 in stats) {
	        fillUsage(context.customUsage, browser$1, stats[browser$1]);
	      }
	    }

	    if (!context.customUsage) {
	      throw new error('Custom usage statistics was not provided');
	    }

	    var usage = context.customUsage;
	    return Object.keys(usage).reduce(function (result, version) {
	      if (sign === '>') {
	        if (usage[version] > popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<') {
	        if (usage[version] < popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<=') {
	        if (usage[version] <= popularity) {
	          result.push(version);
	        }
	      } else if (usage[version] >= popularity) {
	        result.push(version);
	      }

	      return result;
	    }, []);
	  }
	}, {
	  regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
	  select: function select(context, sign, popularity, place) {
	    popularity = parseFloat(popularity);

	    if (place.length === 2) {
	      place = place.toUpperCase();
	    } else {
	      place = place.toLowerCase();
	    }

	    browser.loadCountry(browserslist.usage, place, browserslist.data);
	    var usage = browserslist.usage[place];
	    return Object.keys(usage).reduce(function (result, version) {
	      if (sign === '>') {
	        if (usage[version] > popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<') {
	        if (usage[version] < popularity) {
	          result.push(version);
	        }
	      } else if (sign === '<=') {
	        if (usage[version] <= popularity) {
	          result.push(version);
	        }
	      } else if (usage[version] >= popularity) {
	        result.push(version);
	      }

	      return result;
	    }, []);
	  }
	}, {
	  regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/,
	  select: coverQuery
	}, {
	  regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/,
	  select: coverQuery
	}, {
	  regexp: /^supports\s+([\w-]+)$/,
	  select: function select(context, feature) {
	    browser.loadFeature(browserslist.cache, feature);
	    var features = browserslist.cache[feature];
	    return Object.keys(features).reduce(function (result, version) {
	      var flags = features[version];

	      if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {
	        result.push(version);
	      }

	      return result;
	    }, []);
	  }
	}, {
	  regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	  select: function select(context, from, to) {
	    var fromToUse = normalizeElectron(from);
	    var toToUse = normalizeElectron(to);

	    if (!versions[fromToUse]) {
	      throw new error('Unknown version ' + from + ' of electron');
	    }

	    if (!versions[toToUse]) {
	      throw new error('Unknown version ' + to + ' of electron');
	    }

	    from = parseFloat(from);
	    to = parseFloat(to);
	    return Object.keys(versions).filter(function (i) {
	      var parsed = parseFloat(i);
	      return parsed >= from && parsed <= to;
	    }).map(function (i) {
	      return 'chrome ' + versions[i];
	    });
	  }
	}, {
	  regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	  select: function select(context, from, to) {
	    var nodeVersions = jsReleases.filter(function (i) {
	      return i.name === 'nodejs';
	    }).map(function (i) {
	      return i.version;
	    });
	    return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
	      return 'node ' + v;
	    });
	  }
	}, {
	  regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
	  select: function select(context, name, from, to) {
	    var data = checkName(name, context);
	    from = parseFloat(normalizeVersion(data, from) || from);
	    to = parseFloat(normalizeVersion(data, to) || to);

	    function filter(v) {
	      var parsed = parseFloat(v);
	      return parsed >= from && parsed <= to;
	    }

	    return data.released.filter(filter).map(nameMapper(data.name));
	  }
	}, {
	  regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
	  select: function select(context, sign, version) {
	    var versionToUse = normalizeElectron(version);
	    return Object.keys(versions).filter(generateFilter(sign, versionToUse)).map(function (i) {
	      return 'chrome ' + versions[i];
	    });
	  }
	}, {
	  regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
	  select: function select(context, sign, version) {
	    var nodeVersions = jsReleases.filter(function (i) {
	      return i.name === 'nodejs';
	    }).map(function (i) {
	      return i.version;
	    });
	    return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
	      return 'node ' + v;
	    });
	  }
	}, {
	  regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
	  select: function select(context, name, sign, version) {
	    var data = checkName(name, context);
	    var alias = browserslist.versionAliases[data.name][version];

	    if (alias) {
	      version = alias;
	    }

	    return data.released.filter(generateFilter(sign, version)).map(function (v) {
	      return data.name + ' ' + v;
	    });
	  }
	}, {
	  regexp: /^(firefox|ff|fx)\s+esr$/i,
	  select: function select() {
	    return ['firefox 78', 'firefox 91'];
	  }
	}, {
	  regexp: /(operamini|op_mini)\s+all/i,
	  select: function select() {
	    return ['op_mini all'];
	  }
	}, {
	  regexp: /^electron\s+([\d.]+)$/i,
	  select: function select(context, version) {
	    var versionToUse = normalizeElectron(version);
	    var chrome = versions[versionToUse];

	    if (!chrome) {
	      throw new error('Unknown version ' + version + ' of electron');
	    }

	    return ['chrome ' + chrome];
	  }
	}, {
	  regexp: /^node\s+(\d+)$/i,
	  select: nodeQuery
	}, {
	  regexp: /^node\s+(\d+\.\d+)$/i,
	  select: nodeQuery
	}, {
	  regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
	  select: nodeQuery
	}, {
	  regexp: /^current\s+node$/i,
	  select: function select(context) {
	    return [browser.currentNode(resolve$2, context)];
	  }
	}, {
	  regexp: /^maintained\s+node\s+versions$/i,
	  select: function select(context) {
	    var now = Date.now();
	    var queries = Object.keys(jsEOL).filter(function (key) {
	      return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
	    }).map(function (key) {
	      return 'node ' + key.slice(1);
	    });
	    return resolve$2(queries, context);
	  }
	}, {
	  regexp: /^phantomjs\s+1.9$/i,
	  select: function select() {
	    return ['safari 5'];
	  }
	}, {
	  regexp: /^phantomjs\s+2.1$/i,
	  select: function select() {
	    return ['safari 6'];
	  }
	}, {
	  regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
	  select: function select(context, name, version) {
	    if (/^tp$/i.test(version)) version = 'TP';
	    var data = checkName(name, context);
	    var alias = normalizeVersion(data, version);

	    if (alias) {
	      version = alias;
	    } else {
	      if (version.indexOf('.') === -1) {
	        alias = version + '.0';
	      } else {
	        alias = version.replace(/\.0$/, '');
	      }

	      alias = normalizeVersion(data, alias);

	      if (alias) {
	        version = alias;
	      } else if (context.ignoreUnknownVersions) {
	        return [];
	      } else {
	        throw new error('Unknown version ' + version + ' of ' + name);
	      }
	    }

	    return [data.name + ' ' + version];
	  }
	}, {
	  regexp: /^browserslist config$/i,
	  select: function select(context) {
	    return browserslist(undefined, context);
	  }
	}, {
	  regexp: /^extends (.+)$/i,
	  select: function select(context, name) {
	    return resolve$2(browser.loadQueries(context, name), context);
	  }
	}, {
	  regexp: /^defaults$/i,
	  select: function select(context) {
	    return resolve$2(browserslist.defaults, context);
	  }
	}, {
	  regexp: /^dead$/i,
	  select: function select(context) {
	    var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
	    return resolve$2(dead, context);
	  }
	}, {
	  regexp: /^(\w+)$/i,
	  select: function select(context, name) {
	    if (byName(name, context)) {
	      throw new error('Specify versions in Browserslist query for browser ' + name);
	    } else {
	      throw unknownQuery(name);
	    }
	  }
	}];

	(function () {
	  for (var name in agents) {
	    var browser = agents[name];
	    browserslist.data[name] = {
	      name: name,
	      versions: normalize(agents[name].versions),
	      released: normalize(agents[name].versions.slice(0, -3)),
	      releaseDate: agents[name].release_date
	    };
	    fillUsage(browserslist.usage.global, name, browser.usage_global);
	    browserslist.versionAliases[name] = {};

	    for (var i = 0; i < browser.versions.length; i++) {
	      var full = browser.versions[i];
	      if (!full) continue;

	      if (full.indexOf('-') !== -1) {
	        var interval = full.split('-');

	        for (var j = 0; j < interval.length; j++) {
	          browserslist.versionAliases[name][interval[j]] = full;
	        }
	      }
	    }
	  }

	  browserslist.versionAliases.op_mob['59'] = '58';
	})();

	var browserslist_1 = browserslist;

	var min = Math.min;

	function levenshtein(a, b) {
	  var t = [],
	      u = [],
	      i,
	      j;
	  var m = a.length,
	      n = b.length;

	  if (!m) {
	    return n;
	  }

	  if (!n) {
	    return m;
	  }

	  for (j = 0; j <= n; j++) {
	    t[j] = j;
	  }

	  for (i = 1; i <= m; i++) {
	    for (u = [i], j = 1; j <= n; j++) {
	      u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
	    }

	    t = u;
	  }

	  return u[n];
	}

	function findSuggestion(str, arr) {
	  var distances = arr.map(function (el) {
	    return levenshtein(el, str);
	  });
	  return arr[distances.indexOf(min.apply(void 0, _toConsumableArray(distances)))];
	}

	var OptionValidator = function () {
	  function OptionValidator(descriptor) {
	    this.descriptor = descriptor;
	  }

	  var _proto = OptionValidator.prototype;

	  _proto.validateTopLevelOptions = function validateTopLevelOptions(options, TopLevelOptionShape) {
	    var validOptionNames = Object.keys(TopLevelOptionShape);

	    for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
	      var option = _Object$keys[_i];

	      if (!validOptionNames.includes(option)) {
	        throw new Error(this.formatMessage("'" + option + "' is not a valid top-level option.\n- Did you mean '" + findSuggestion(option, validOptionNames) + "'?"));
	      }
	    }
	  };

	  _proto.validateBooleanOption = function validateBooleanOption(name, value, defaultValue) {
	    if (value === undefined) {
	      return defaultValue;
	    } else {
	      this.invariant(typeof value === "boolean", "'" + name + "' option must be a boolean.");
	    }

	    return value;
	  };

	  _proto.validateStringOption = function validateStringOption(name, value, defaultValue) {
	    if (value === undefined) {
	      return defaultValue;
	    } else {
	      this.invariant(typeof value === "string", "'" + name + "' option must be a string.");
	    }

	    return value;
	  };

	  _proto.invariant = function invariant(condition, message) {
	    if (!condition) {
	      throw new Error(this.formatMessage(message));
	    }
	  };

	  _proto.formatMessage = function formatMessage(message) {
	    return this.descriptor + ": " + message;
	  };

	  return OptionValidator;
	}();

	var require$$0$6 = {
		"es6.module": {
		chrome: "61",
		and_chr: "61",
		edge: "16",
		firefox: "60",
		and_ff: "60",
		node: "13.2.0",
		opera: "48",
		op_mob: "48",
		safari: "10.1",
		ios: "10.3",
		samsung: "8.2",
		android: "61",
		electron: "2.0",
		ios_saf: "10.3"
	}
	};

	var nativeModules = require$$0$6;

	var unreleasedLabels = {
	  safari: "tp"
	};
	var browserNameMap = {
	  and_chr: "chrome",
	  and_ff: "firefox",
	  android: "android",
	  chrome: "chrome",
	  edge: "edge",
	  firefox: "firefox",
	  ie: "ie",
	  ie_mob: "ie",
	  ios_saf: "ios",
	  node: "node",
	  op_mob: "opera",
	  opera: "opera",
	  safari: "safari",
	  samsung: "samsung"
	};

	var versionRegExp = /^(\d+|\d+.\d+)$/;
	var v$3 = new OptionValidator("@babel/helper-compilation-targets");
	function semverMin(first, second) {
	  return first && semver$4.lt(first, second) ? first : second;
	}
	function semverify(version) {
	  if (typeof version === "string" && semver$4.valid(version)) {
	    return version;
	  }

	  v$3.invariant(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'" + version + "' is not a valid version");
	  var split = version.toString().split(".");

	  while (split.length < 3) {
	    split.push("0");
	  }

	  return split.join(".");
	}
	function isUnreleasedVersion(version, env) {
	  var unreleasedLabel = unreleasedLabels[env];
	  return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
	}
	function getLowestUnreleased(a, b, env) {
	  var unreleasedLabel = unreleasedLabels[env];
	  var hasUnreleased = [a, b].some(function (item) {
	    return item === unreleasedLabel;
	  });

	  if (hasUnreleased) {
	    return a === hasUnreleased ? b : a || b;
	  }

	  return semverMin(a, b);
	}
	function getHighestUnreleased(a, b, env) {
	  return getLowestUnreleased(a, b, env) === a ? b : a;
	}
	function getLowestImplementedVersion(plugin, environment) {
	  var result = plugin[environment];

	  if (!result && environment === "android") {
	    return plugin.chrome;
	  }

	  return result;
	}

	var TargetNames = {
	  node: "node",
	  chrome: "chrome",
	  opera: "opera",
	  edge: "edge",
	  firefox: "firefox",
	  safari: "safari",
	  ie: "ie",
	  ios: "ios",
	  android: "android",
	  electron: "electron",
	  samsung: "samsung",
	  rhino: "rhino"
	};

	function prettifyVersion(version) {
	  if (typeof version !== "string") {
	    return version;
	  }

	  var parts = [semver$4.major(version)];
	  var minor = semver$4.minor(version);
	  var patch = semver$4.patch(version);

	  if (minor || patch) {
	    parts.push(minor);
	  }

	  if (patch) {
	    parts.push(patch);
	  }

	  return parts.join(".");
	}
	function prettifyTargets(targets) {
	  return Object.keys(targets).reduce(function (results, target) {
	    var value = targets[target];
	    var unreleasedLabel = unreleasedLabels[target];

	    if (typeof value === "string" && unreleasedLabel !== value) {
	      value = prettifyVersion(value);
	    }

	    results[target] = value;
	    return results;
	  }, {});
	}

	function getInclusionReasons(item, targetVersions, list) {
	  var minVersions = list[item] || {};
	  return Object.keys(targetVersions).reduce(function (result, env) {
	    var minVersion = getLowestImplementedVersion(minVersions, env);
	    var targetVersion = targetVersions[env];

	    if (!minVersion) {
	      result[env] = prettifyVersion(targetVersion);
	    } else {
	      var minIsUnreleased = isUnreleasedVersion(minVersion, env);
	      var targetIsUnreleased = isUnreleasedVersion(targetVersion, env);

	      if (!targetIsUnreleased && (minIsUnreleased || semver$4.lt(targetVersion.toString(), semverify(minVersion)))) {
	        result[env] = prettifyVersion(targetVersion);
	      }
	    }

	    return result;
	  }, {});
	}

	var require$$0$5 = {
		"proposal-class-static-block": {
		chrome: "94",
		opera: "80",
		edge: "94",
		firefox: "93",
		node: "16.11"
	},
		"proposal-private-property-in-object": {
		chrome: "91",
		opera: "77",
		edge: "91",
		firefox: "90",
		safari: "15",
		node: "16.9",
		ios: "15",
		electron: "13.0"
	},
		"proposal-class-properties": {
		chrome: "74",
		opera: "62",
		edge: "79",
		firefox: "90",
		safari: "14.1",
		node: "12",
		ios: "15",
		samsung: "11",
		electron: "6.0"
	},
		"proposal-private-methods": {
		chrome: "84",
		opera: "70",
		edge: "84",
		firefox: "90",
		safari: "15",
		node: "14.6",
		ios: "15",
		samsung: "14",
		electron: "10.0"
	},
		"proposal-numeric-separator": {
		chrome: "75",
		opera: "62",
		edge: "79",
		firefox: "70",
		safari: "13",
		node: "12.5",
		ios: "13",
		samsung: "11",
		electron: "6.0"
	},
		"proposal-logical-assignment-operators": {
		chrome: "85",
		opera: "71",
		edge: "85",
		firefox: "79",
		safari: "14",
		node: "15",
		ios: "14",
		samsung: "14",
		electron: "10.0"
	},
		"proposal-nullish-coalescing-operator": {
		chrome: "80",
		opera: "67",
		edge: "80",
		firefox: "72",
		safari: "13.1",
		node: "14",
		ios: "13.4",
		samsung: "13",
		electron: "8.0"
	},
		"proposal-optional-chaining": {
		chrome: "91",
		opera: "77",
		edge: "91",
		firefox: "74",
		safari: "13.1",
		node: "16.9",
		ios: "13.4",
		electron: "13.0"
	},
		"proposal-json-strings": {
		chrome: "66",
		opera: "53",
		edge: "79",
		firefox: "62",
		safari: "12",
		node: "10",
		ios: "12",
		samsung: "9",
		electron: "3.0"
	},
		"proposal-optional-catch-binding": {
		chrome: "66",
		opera: "53",
		edge: "79",
		firefox: "58",
		safari: "11.1",
		node: "10",
		ios: "11.3",
		samsung: "9",
		electron: "3.0"
	},
		"transform-parameters": {
		chrome: "49",
		opera: "36",
		edge: "18",
		firefox: "53",
		node: "6",
		samsung: "5",
		electron: "0.37"
	},
		"proposal-async-generator-functions": {
		chrome: "63",
		opera: "50",
		edge: "79",
		firefox: "57",
		safari: "12",
		node: "10",
		ios: "12",
		samsung: "8",
		electron: "3.0"
	},
		"proposal-object-rest-spread": {
		chrome: "60",
		opera: "47",
		edge: "79",
		firefox: "55",
		safari: "11.1",
		node: "8.3",
		ios: "11.3",
		samsung: "8",
		electron: "2.0"
	},
		"transform-dotall-regex": {
		chrome: "62",
		opera: "49",
		edge: "79",
		firefox: "78",
		safari: "11.1",
		node: "8.10",
		ios: "11.3",
		samsung: "8",
		electron: "3.0"
	},
		"proposal-unicode-property-regex": {
		chrome: "64",
		opera: "51",
		edge: "79",
		firefox: "78",
		safari: "11.1",
		node: "10",
		ios: "11.3",
		samsung: "9",
		electron: "3.0"
	},
		"transform-named-capturing-groups-regex": {
		chrome: "64",
		opera: "51",
		edge: "79",
		firefox: "78",
		safari: "11.1",
		node: "10",
		ios: "11.3",
		samsung: "9",
		electron: "3.0"
	},
		"transform-async-to-generator": {
		chrome: "55",
		opera: "42",
		edge: "15",
		firefox: "52",
		safari: "11",
		node: "7.6",
		ios: "11",
		samsung: "6",
		electron: "1.6"
	},
		"transform-exponentiation-operator": {
		chrome: "52",
		opera: "39",
		edge: "14",
		firefox: "52",
		safari: "10.1",
		node: "7",
		ios: "10.3",
		samsung: "6",
		electron: "1.3"
	},
		"transform-template-literals": {
		chrome: "41",
		opera: "28",
		edge: "13",
		firefox: "34",
		safari: "13",
		node: "4",
		ios: "13",
		samsung: "3.4",
		electron: "0.21"
	},
		"transform-literals": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "53",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		electron: "0.30"
	},
		"transform-function-name": {
		chrome: "51",
		opera: "38",
		edge: "79",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"transform-arrow-functions": {
		chrome: "47",
		opera: "34",
		edge: "13",
		firefox: "43",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.36"
	},
		"transform-block-scoped-functions": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "46",
		safari: "10",
		node: "4",
		ie: "11",
		ios: "10",
		samsung: "3.4",
		electron: "0.21"
	},
		"transform-classes": {
		chrome: "46",
		opera: "33",
		edge: "13",
		firefox: "45",
		safari: "10",
		node: "5",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"transform-object-super": {
		chrome: "46",
		opera: "33",
		edge: "13",
		firefox: "45",
		safari: "10",
		node: "5",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"transform-shorthand-properties": {
		chrome: "43",
		opera: "30",
		edge: "12",
		firefox: "33",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		electron: "0.27"
	},
		"transform-duplicate-keys": {
		chrome: "42",
		opera: "29",
		edge: "12",
		firefox: "34",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		electron: "0.25"
	},
		"transform-computed-properties": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "34",
		safari: "7.1",
		node: "4",
		ios: "8",
		samsung: "4",
		electron: "0.30"
	},
		"transform-for-of": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"transform-sticky-regex": {
		chrome: "49",
		opera: "36",
		edge: "13",
		firefox: "3",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"transform-unicode-escapes": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "53",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		electron: "0.30"
	},
		"transform-unicode-regex": {
		chrome: "50",
		opera: "37",
		edge: "13",
		firefox: "46",
		safari: "12",
		node: "6",
		ios: "12",
		samsung: "5",
		electron: "1.1"
	},
		"transform-spread": {
		chrome: "46",
		opera: "33",
		edge: "13",
		firefox: "45",
		safari: "10",
		node: "5",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"transform-destructuring": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"transform-block-scoping": {
		chrome: "49",
		opera: "36",
		edge: "14",
		firefox: "51",
		safari: "11",
		node: "6",
		ios: "11",
		samsung: "5",
		electron: "0.37"
	},
		"transform-typeof-symbol": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "36",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"transform-new-target": {
		chrome: "46",
		opera: "33",
		edge: "14",
		firefox: "41",
		safari: "10",
		node: "5",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"transform-regenerator": {
		chrome: "50",
		opera: "37",
		edge: "13",
		firefox: "53",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "1.1"
	},
		"transform-member-expression-literals": {
		chrome: "7",
		opera: "12",
		edge: "12",
		firefox: "2",
		safari: "5.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"transform-property-literals": {
		chrome: "7",
		opera: "12",
		edge: "12",
		firefox: "2",
		safari: "5.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"transform-reserved-words": {
		chrome: "13",
		opera: "10.50",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4.4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"proposal-export-namespace-from": {
		chrome: "72",
		and_chr: "72",
		edge: "79",
		firefox: "80",
		and_ff: "80",
		node: "13.2",
		opera: "60",
		op_mob: "51",
		samsung: "11.0",
		android: "72",
		electron: "5.0"
	}
	};

	var plugins = require$$0$5;

	function targetsSupported(target, support) {
	  var targetEnvironments = Object.keys(target);

	  if (targetEnvironments.length === 0) {
	    return false;
	  }

	  var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
	    var lowestImplementedVersion = getLowestImplementedVersion(support, environment);

	    if (!lowestImplementedVersion) {
	      return true;
	    }

	    var lowestTargetedVersion = target[environment];

	    if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
	      return false;
	    }

	    if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
	      return true;
	    }

	    if (!semver$4.valid(lowestTargetedVersion.toString())) {
	      throw new Error("Invalid version passed for target \"" + environment + "\": \"" + lowestTargetedVersion + "\". " + "Versions must be in semver format (major.minor.patch)");
	    }

	    return semver$4.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
	  });
	  return unsupportedEnvironments.length === 0;
	}
	function isRequired(name, targets, _temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      _ref$compatData = _ref.compatData,
	      compatData = _ref$compatData === void 0 ? plugins : _ref$compatData,
	      includes = _ref.includes,
	      excludes = _ref.excludes;

	  if (excludes != null && excludes.has(name)) return false;
	  if (includes != null && includes.has(name)) return true;
	  return !targetsSupported(targets, compatData[name]);
	}
	function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
	  var result = new Set();
	  var options = {
	    compatData: list,
	    includes: includes,
	    excludes: excludes
	  };

	  for (var item in list) {
	    if (isRequired(item, targets, options)) {
	      result.add(item);
	    } else if (pluginSyntaxMap) {
	      var shippedProposalsSyntax = pluginSyntaxMap.get(item);

	      if (shippedProposalsSyntax) {
	        result.add(shippedProposalsSyntax);
	      }
	    }
	  }

	  if (defaultIncludes) {
	    defaultIncludes.forEach(function (item) {
	      return !excludes.has(item) && result.add(item);
	    });
	  }

	  if (defaultExcludes) {
	    defaultExcludes.forEach(function (item) {
	      return !includes.has(item) && result["delete"](item);
	    });
	  }

	  return result;
	}

	var ESM_SUPPORT = nativeModules["es6.module"];
	var v$2 = new OptionValidator("@babel/helper-compilation-targets");

	function validateTargetNames(targets) {
	  var validTargets = Object.keys(TargetNames);

	  for (var _i = 0, _Object$keys = Object.keys(targets); _i < _Object$keys.length; _i++) {
	    var target = _Object$keys[_i];

	    if (!(target in TargetNames)) {
	      throw new Error(v$2.formatMessage("'" + target + "' is not a valid target\n- Did you mean '" + findSuggestion(target, validTargets) + "'?"));
	    }
	  }

	  return targets;
	}

	function isBrowsersQueryValid(browsers) {
	  return typeof browsers === "string" || Array.isArray(browsers) && browsers.every(function (b) {
	    return typeof b === "string";
	  });
	}

	function validateBrowsers(browsers) {
	  v$2.invariant(browsers === undefined || isBrowsersQueryValid(browsers), "'" + String(browsers) + "' is not a valid browserslist query");
	  return browsers;
	}

	function getLowestVersions(browsers) {
	  return browsers.reduce(function (all, browser) {
	    var _browser$split = browser.split(" "),
	        _browser$split2 = _slicedToArray$1(_browser$split, 2),
	        browserName = _browser$split2[0],
	        browserVersion = _browser$split2[1];

	    var normalizedBrowserName = browserNameMap[browserName];

	    if (!normalizedBrowserName) {
	      return all;
	    }

	    try {
	      var splitVersion = browserVersion.split("-")[0].toLowerCase();
	      var isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);

	      if (!all[normalizedBrowserName]) {
	        all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
	        return all;
	      }

	      var version = all[normalizedBrowserName];
	      var isUnreleased = isUnreleasedVersion(version, browserName);

	      if (isUnreleased && isSplitUnreleased) {
	        all[normalizedBrowserName] = getLowestUnreleased(version, splitVersion, browserName);
	      } else if (isUnreleased) {
	        all[normalizedBrowserName] = semverify(splitVersion);
	      } else if (!isUnreleased && !isSplitUnreleased) {
	        var parsedBrowserVersion = semverify(splitVersion);
	        all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
	      }
	    } catch (e) {}

	    return all;
	  }, {});
	}

	function outputDecimalWarning(decimalTargets) {
	  if (!decimalTargets.length) {
	    return;
	  }

	  console.warn("Warning, the following targets are using a decimal version:\n");
	  decimalTargets.forEach(function (_ref) {
	    var target = _ref.target,
	        value = _ref.value;
	    return console.warn("  " + target + ": " + value);
	  });
	  console.warn("\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n");
	}

	function semverifyTarget(target, value) {
	  try {
	    return semverify(value);
	  } catch (error) {
	    throw new Error(v$2.formatMessage("'" + value + "' is not a valid value for 'targets." + target + "'."));
	  }
	}

	var targetParserMap = {
	  __default: function __default(target, value) {
	    var version = isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
	    return [target, version];
	  },
	  node: function node(target, value) {
	    var parsed = value === true || value === "current" ? browser$4.versions.node : semverifyTarget(target, value);
	    return [target, parsed];
	  }
	};

	function generateTargets(inputTargets) {
	  var input = Object.assign({}, inputTargets);
	  delete input.esmodules;
	  delete input.browsers;
	  return input;
	}

	function resolveTargets$1(queries, env) {
	  var resolved = browserslist_1(queries, {
	    mobileToDesktop: true,
	    env: env
	  });
	  return getLowestVersions(resolved);
	}

	function getTargets$2(inputTargets, options) {
	  var _browsers;

	  if (inputTargets === void 0) {
	    inputTargets = {};
	  }

	  if (options === void 0) {
	    options = {};
	  }

	  var _inputTargets = inputTargets,
	      browsers = _inputTargets.browsers,
	      esmodules = _inputTargets.esmodules;
	  var _options = options,
	      _options$configPath = _options.configPath,
	      configPath = _options$configPath === void 0 ? "." : _options$configPath;
	  validateBrowsers(browsers);
	  var input = generateTargets(inputTargets);
	  var targets = validateTargetNames(input);
	  var shouldParseBrowsers = !!browsers;
	  var hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
	  var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

	  if (!browsers && shouldSearchForConfig) {
	    browsers = browserslist_1.loadConfig({
	      config: options.configFile,
	      path: configPath,
	      env: options.browserslistEnv
	    });

	    if (browsers == null) {
	      {
	        browsers = [];
	      }
	    }
	  }

	  if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
	    browsers = Object.keys(ESM_SUPPORT).map(function (browser) {
	      return browser + " >= " + ESM_SUPPORT[browser];
	    }).join(", ");
	    esmodules = false;
	  }

	  if (browsers) {
	    var queryBrowsers = resolveTargets$1(browsers, options.browserslistEnv);

	    if (esmodules === "intersect") {
	      for (var _i2 = 0, _Object$keys2 = Object.keys(queryBrowsers); _i2 < _Object$keys2.length; _i2++) {
	        var browser = _Object$keys2[_i2];
	        var version = queryBrowsers[browser];

	        if (ESM_SUPPORT[browser]) {
	          queryBrowsers[browser] = getHighestUnreleased(version, semverify(ESM_SUPPORT[browser]), browser);
	        } else {
	          delete queryBrowsers[browser];
	        }
	      }
	    }

	    targets = Object.assign(queryBrowsers, targets);
	  }

	  var result = {};
	  var decimalWarnings = [];

	  for (var _iterator = _createForOfIteratorHelperLoose(Object.keys(targets).sort()), _step; !(_step = _iterator()).done;) {
	    var _targetParserMap$targ;

	    var target = _step.value;
	    var value = targets[target];

	    if (typeof value === "number" && value % 1 !== 0) {
	      decimalWarnings.push({
	        target: target,
	        value: value
	      });
	    }

	    var parser = (_targetParserMap$targ = targetParserMap[target]) != null ? _targetParserMap$targ : targetParserMap.__default;

	    var _parser = parser(target, value),
	        _parser2 = _slicedToArray$1(_parser, 2),
	        parsedTarget = _parser2[0],
	        parsedValue = _parser2[1];

	    if (parsedValue) {
	      result[parsedTarget] = parsedValue;
	    }
	  }

	  outputDecimalWarning(decimalWarnings);
	  return result;
	}

	function resolveBrowserslistConfigFile(browserslistConfigFile, configFilePath) {
	  return undefined;
	}
	function resolveTargets(options, root) {
	  var targets = options.targets;

	  if (typeof targets === "string" || Array.isArray(targets)) {
	    targets = {
	      browsers: targets
	    };
	  }

	  if (targets && targets.esmodules) {
	    targets = Object.assign({}, targets, {
	      esmodules: "intersect"
	    });
	  }

	  return getTargets$2(targets, {
	    ignoreBrowserslistConfig: true,
	    browserslistEnv: options.browserslistEnv
	  });
	}

	var _marked$7 = regenerator.mark(handlerOf),
	    _marked2$3 = regenerator.mark(createPresetDescriptors),
	    _marked3$1 = regenerator.mark(createPluginDescriptors),
	    _marked4$1 = regenerator.mark(createDescriptors),
	    _marked5$1 = regenerator.mark(createDescriptor);

	function isEqualDescriptor(a, b) {
	  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
	}

	function handlerOf(value) {
	  return regenerator.wrap(function handlerOf$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.abrupt("return", value);

	        case 1:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$7);
	}

	function optionsWithResolvedBrowserslistConfigFile(options, dirname) {
	  if (typeof options.browserslistConfigFile === "string") {
	    options.browserslistConfigFile = resolveBrowserslistConfigFile(options.browserslistConfigFile);
	  }

	  return options;
	}

	function createCachedDescriptors(dirname, options, alias) {
	  var plugins = options.plugins,
	      presets = options.presets,
	      passPerPreset = options.passPerPreset;
	  return {
	    options: optionsWithResolvedBrowserslistConfigFile(options),
	    plugins: plugins ? function () {
	      return createCachedPluginDescriptors(plugins, dirname)(alias);
	    } : function () {
	      return handlerOf([]);
	    },
	    presets: presets ? function () {
	      return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
	    } : function () {
	      return handlerOf([]);
	    }
	  };
	}
	function createUncachedDescriptors(dirname, options, alias) {
	  var _plugins;

	  var _presets;

	  return {
	    options: optionsWithResolvedBrowserslistConfigFile(options),
	    plugins: regenerator.mark(function plugins() {
	      return regenerator.wrap(function plugins$(_context2) {
	        while (1) {
	          switch (_context2.prev = _context2.next) {
	            case 0:
	              if (_plugins) {
	                _context2.next = 3;
	                break;
	              }

	              return _context2.delegateYield(createPluginDescriptors(options.plugins || [], dirname, alias), "t0", 2);

	            case 2:
	              _plugins = _context2.t0;

	            case 3:
	              return _context2.abrupt("return", _plugins);

	            case 4:
	            case "end":
	              return _context2.stop();
	          }
	        }
	      }, plugins);
	    }),
	    presets: regenerator.mark(function presets() {
	      return regenerator.wrap(function presets$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              if (_presets) {
	                _context3.next = 3;
	                break;
	              }

	              return _context3.delegateYield(createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset), "t0", 2);

	            case 2:
	              _presets = _context3.t0;

	            case 3:
	              return _context3.abrupt("return", _presets);

	            case 4:
	            case "end":
	              return _context3.stop();
	          }
	        }
	      }, presets);
	    })
	  };
	}
	var PRESET_DESCRIPTOR_CACHE = new WeakMap();
	var createCachedPresetDescriptors = makeWeakCacheSync(function (items, cache) {
	  var dirname = cache.using(function (dir) {
	    return dir;
	  });
	  return makeStrongCacheSync(function (alias) {
	    return makeStrongCache(regenerator.mark(function _callee(passPerPreset) {
	      var descriptors;
	      return regenerator.wrap(function _callee$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.delegateYield(createPresetDescriptors(items, dirname, alias, passPerPreset), "t0", 1);

	            case 1:
	              descriptors = _context4.t0;
	              return _context4.abrupt("return", descriptors.map(function (desc) {
	                return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
	              }));

	            case 3:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, _callee);
	    }));
	  });
	});
	var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
	var createCachedPluginDescriptors = makeWeakCacheSync(function (items, cache) {
	  var dirname = cache.using(function (dir) {
	    return dir;
	  });
	  return makeStrongCache(regenerator.mark(function _callee2(alias) {
	    var descriptors;
	    return regenerator.wrap(function _callee2$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            return _context5.delegateYield(createPluginDescriptors(items, dirname, alias), "t0", 1);

	          case 1:
	            descriptors = _context5.t0;
	            return _context5.abrupt("return", descriptors.map(function (desc) {
	              return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
	            }));

	          case 3:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee2);
	  }));
	});
	var DEFAULT_OPTIONS = {};

	function loadCachedDescriptor(cache, desc) {
	  var value = desc.value,
	      _desc$options = desc.options,
	      options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
	  if (options === false) return desc;
	  var cacheByOptions = cache.get(value);

	  if (!cacheByOptions) {
	    cacheByOptions = new WeakMap();
	    cache.set(value, cacheByOptions);
	  }

	  var possibilities = cacheByOptions.get(options);

	  if (!possibilities) {
	    possibilities = [];
	    cacheByOptions.set(options, possibilities);
	  }

	  if (possibilities.indexOf(desc) === -1) {
	    var matches = possibilities.filter(function (possibility) {
	      return isEqualDescriptor(possibility, desc);
	    });

	    if (matches.length > 0) {
	      return matches[0];
	    }

	    possibilities.push(desc);
	  }

	  return desc;
	}

	function createPresetDescriptors(items, dirname, alias, passPerPreset) {
	  return regenerator.wrap(function createPresetDescriptors$(_context6) {
	    while (1) {
	      switch (_context6.prev = _context6.next) {
	        case 0:
	          return _context6.delegateYield(createDescriptors("preset", items, dirname, alias, passPerPreset), "t0", 1);

	        case 1:
	          return _context6.abrupt("return", _context6.t0);

	        case 2:
	        case "end":
	          return _context6.stop();
	      }
	    }
	  }, _marked2$3);
	}

	function createPluginDescriptors(items, dirname, alias) {
	  return regenerator.wrap(function createPluginDescriptors$(_context7) {
	    while (1) {
	      switch (_context7.prev = _context7.next) {
	        case 0:
	          return _context7.delegateYield(createDescriptors("plugin", items, dirname, alias), "t0", 1);

	        case 1:
	          return _context7.abrupt("return", _context7.t0);

	        case 2:
	        case "end":
	          return _context7.stop();
	      }
	    }
	  }, _marked3$1);
	}

	function createDescriptors(type, items, dirname, alias, ownPass) {
	  var descriptors;
	  return regenerator.wrap(function createDescriptors$(_context8) {
	    while (1) {
	      switch (_context8.prev = _context8.next) {
	        case 0:
	          return _context8.delegateYield(gensync.all(items.map(function (item, index) {
	            return createDescriptor(item, dirname, {
	              type: type,
	              alias: alias + "$" + index,
	              ownPass: !!ownPass
	            });
	          })), "t0", 1);

	        case 1:
	          descriptors = _context8.t0;
	          assertNoDuplicates(descriptors);
	          return _context8.abrupt("return", descriptors);

	        case 4:
	        case "end":
	          return _context8.stop();
	      }
	    }
	  }, _marked4$1);
	}

	function createDescriptor(pair, dirname, _ref) {
	  var type, alias, ownPass, desc, name, options, value, _value, _value2, _value3, _value4, file, filepath, resolver, request, _yield$resolver;

	  return regenerator.wrap(function createDescriptor$(_context9) {
	    while (1) {
	      switch (_context9.prev = _context9.next) {
	        case 0:
	          type = _ref.type, alias = _ref.alias, ownPass = _ref.ownPass;
	          desc = getItemDescriptor(pair);

	          if (!desc) {
	            _context9.next = 4;
	            break;
	          }

	          return _context9.abrupt("return", desc);

	        case 4:
	          value = pair;

	          if (Array.isArray(value)) {
	            if (value.length === 3) {
	              _value = value;
	              _value2 = _slicedToArray$1(_value, 3);
	              value = _value2[0];
	              options = _value2[1];
	              name = _value2[2];
	            } else {
	              _value3 = value;
	              _value4 = _slicedToArray$1(_value3, 2);
	              value = _value4[0];
	              options = _value4[1];
	            }
	          }

	          file = undefined;
	          filepath = null;

	          if (!(typeof value === "string")) {
	            _context9.next = 18;
	            break;
	          }

	          if (!(typeof type !== "string")) {
	            _context9.next = 11;
	            break;
	          }

	          throw new Error("To resolve a string-based item, the type of item must be given");

	        case 11:
	          resolver = type === "plugin" ? loadPlugin : loadPreset;
	          request = value;
	          return _context9.delegateYield(resolver(value, dirname), "t0", 14);

	        case 14:
	          _yield$resolver = _context9.t0;
	          filepath = _yield$resolver.filepath;
	          value = _yield$resolver.value;
	          file = {
	            request: request,
	            resolved: filepath
	          };

	        case 18:
	          if (value) {
	            _context9.next = 20;
	            break;
	          }

	          throw new Error("Unexpected falsy value: " + String(value));

	        case 20:
	          if (!(typeof value === "object" && value.__esModule)) {
	            _context9.next = 26;
	            break;
	          }

	          if (!value["default"]) {
	            _context9.next = 25;
	            break;
	          }

	          value = value["default"];
	          _context9.next = 26;
	          break;

	        case 25:
	          throw new Error("Must export a default export when using ES6 modules.");

	        case 26:
	          if (!(typeof value !== "object" && typeof value !== "function")) {
	            _context9.next = 28;
	            break;
	          }

	          throw new Error("Unsupported format: " + typeof value + ". Expected an object or a function.");

	        case 28:
	          if (!(filepath !== null && typeof value === "object" && value)) {
	            _context9.next = 30;
	            break;
	          }

	          throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);

	        case 30:
	          return _context9.abrupt("return", {
	            name: name,
	            alias: filepath || alias,
	            value: value,
	            options: options,
	            dirname: dirname,
	            ownPass: ownPass,
	            file: file
	          });

	        case 31:
	        case "end":
	          return _context9.stop();
	      }
	    }
	  }, _marked5$1);
	}

	function assertNoDuplicates(items) {
	  var map = new Map();

	  var _loop = function _loop() {
	    var item = _step.value;
	    if (typeof item.value !== "function") return "continue";
	    var nameMap = map.get(item.value);

	    if (!nameMap) {
	      nameMap = new Set();
	      map.set(item.value, nameMap);
	    }

	    if (nameMap.has(item.name)) {
	      var conflicts = items.filter(function (i) {
	        return i.value === item.value;
	      });
	      throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "" + JSON.stringify(conflicts, null, 2)].join("\n"));
	    }

	    nameMap.add(item.name);
	  };

	  for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
	    var _ret = _loop();

	    if (_ret === "continue") continue;
	  }
	}

	var _marked$6 = regenerator.mark(createConfigItem$1);
	function createItemFromDescriptor(desc) {
	  return new ConfigItem(desc);
	}
	function createConfigItem$1(value, _temp) {
	  var _ref, _ref$dirname, dirname, type, descriptor;

	  return regenerator.wrap(function createConfigItem$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          _ref = _temp === void 0 ? {} : _temp, _ref$dirname = _ref.dirname, dirname = _ref$dirname === void 0 ? "." : _ref$dirname, type = _ref.type;
	          return _context.delegateYield(createDescriptor(value, path$1.resolve(dirname), {
	            type: type,
	            alias: "programmatic item"
	          }), "t0", 2);

	        case 2:
	          descriptor = _context.t0;
	          return _context.abrupt("return", createItemFromDescriptor(descriptor));

	        case 4:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$6);
	}
	function getItemDescriptor(item) {
	  if (item != null && item[CONFIG_ITEM_BRAND]) {
	    return item._descriptor;
	  }

	  return undefined;
	}
	var CONFIG_ITEM_BRAND = Symbol["for"]("@babel/core@7 - ConfigItem");

	var ConfigItem = function ConfigItem(descriptor) {
	  this._descriptor = void 0;
	  this[CONFIG_ITEM_BRAND] = true;
	  this.value = void 0;
	  this.options = void 0;
	  this.dirname = void 0;
	  this.name = void 0;
	  this.file = void 0;
	  this._descriptor = descriptor;
	  Object.defineProperty(this, "_descriptor", {
	    enumerable: false
	  });
	  Object.defineProperty(this, CONFIG_ITEM_BRAND, {
	    enumerable: false
	  });
	  this.value = this._descriptor.value;
	  this.options = this._descriptor.options;
	  this.dirname = this._descriptor.dirname;
	  this.name = this._descriptor.name;
	  this.file = this._descriptor.file ? {
	    request: this._descriptor.file.request,
	    resolved: this._descriptor.file.resolved
	  } : undefined;
	  Object.freeze(this);
	};

	Object.freeze(ConfigItem.prototype);

	var removed = {
	  auxiliaryComment: {
	    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
	  },
	  blacklist: {
	    message: "Put the specific transforms you want in the `plugins` option"
	  },
	  breakConfig: {
	    message: "This is not a necessary option in Babel 6"
	  },
	  experimental: {
	    message: "Put the specific transforms you want in the `plugins` option"
	  },
	  externalHelpers: {
	    message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
	  },
	  extra: {
	    message: ""
	  },
	  jsxPragma: {
	    message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
	  },
	  loose: {
	    message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
	  },
	  metadataUsedHelpers: {
	    message: "Not required anymore as this is enabled by default"
	  },
	  modules: {
	    message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
	  },
	  nonStandard: {
	    message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
	  },
	  optional: {
	    message: "Put the specific transforms you want in the `plugins` option"
	  },
	  sourceMapName: {
	    message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
	  },
	  stage: {
	    message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
	  },
	  whitelist: {
	    message: "Put the specific transforms you want in the `plugins` option"
	  },
	  resolveModuleSource: {
	    version: 6,
	    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
	  },
	  metadata: {
	    version: 6,
	    message: "Generated plugin metadata is always included in the output result"
	  },
	  sourceMapTarget: {
	    version: 6,
	    message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
	  }
	};

	function msg(loc) {
	  switch (loc.type) {
	    case "root":
	      return "";

	    case "env":
	      return msg(loc.parent) + ".env[\"" + loc.name + "\"]";

	    case "overrides":
	      return msg(loc.parent) + ".overrides[" + loc.index + "]";

	    case "option":
	      return msg(loc.parent) + "." + loc.name;

	    case "access":
	      return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

	    default:
	      throw new Error("Assertion failure: Unknown type " + loc.type);
	  }
	}
	function access(loc, name) {
	  return {
	    type: "access",
	    name: name,
	    parent: loc
	  };
	}
	function assertRootMode(loc, value) {
	  if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
	    throw new Error(msg(loc) + " must be a \"root\", \"upward\", \"upward-optional\" or undefined");
	  }

	  return value;
	}
	function assertSourceMaps(loc, value) {
	  if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
	    throw new Error(msg(loc) + " must be a boolean, \"inline\", \"both\", or undefined");
	  }

	  return value;
	}
	function assertCompact(loc, value) {
	  if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
	    throw new Error(msg(loc) + " must be a boolean, \"auto\", or undefined");
	  }

	  return value;
	}
	function assertSourceType(loc, value) {
	  if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
	    throw new Error(msg(loc) + " must be \"module\", \"script\", \"unambiguous\", or undefined");
	  }

	  return value;
	}
	function assertCallerMetadata(loc, value) {
	  var obj = assertObject(loc, value);

	  if (obj) {
	    if (typeof obj.name !== "string") {
	      throw new Error(msg(loc) + " set but does not contain \"name\" property string");
	    }

	    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
	      var prop = _Object$keys[_i];
	      var propLoc = access(loc, prop);
	      var _value = obj[prop];

	      if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
	        throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
	      }
	    }
	  }

	  return value;
	}
	function assertInputSourceMap(loc, value) {
	  if (value !== undefined && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
	    throw new Error(msg(loc) + " must be a boolean, object, or undefined");
	  }

	  return value;
	}
	function assertString(loc, value) {
	  if (value !== undefined && typeof value !== "string") {
	    throw new Error(msg(loc) + " must be a string, or undefined");
	  }

	  return value;
	}
	function assertFunction(loc, value) {
	  if (value !== undefined && typeof value !== "function") {
	    throw new Error(msg(loc) + " must be a function, or undefined");
	  }

	  return value;
	}
	function assertBoolean(loc, value) {
	  if (value !== undefined && typeof value !== "boolean") {
	    throw new Error(msg(loc) + " must be a boolean, or undefined");
	  }

	  return value;
	}
	function assertObject(loc, value) {
	  if (value !== undefined && (typeof value !== "object" || Array.isArray(value) || !value)) {
	    throw new Error(msg(loc) + " must be an object, or undefined");
	  }

	  return value;
	}
	function assertArray(loc, value) {
	  if (value != null && !Array.isArray(value)) {
	    throw new Error(msg(loc) + " must be an array, or undefined");
	  }

	  return value;
	}
	function assertIgnoreList(loc, value) {
	  var arr = assertArray(loc, value);

	  if (arr) {
	    arr.forEach(function (item, i) {
	      return assertIgnoreItem(access(loc, i), item);
	    });
	  }

	  return arr;
	}

	function assertIgnoreItem(loc, value) {
	  if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
	    throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");
	  }

	  return value;
	}

	function assertConfigApplicableTest(loc, value) {
	  if (value === undefined) return value;

	  if (Array.isArray(value)) {
	    value.forEach(function (item, i) {
	      if (!checkValidTest(item)) {
	        throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
	      }
	    });
	  } else if (!checkValidTest(value)) {
	    throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");
	  }

	  return value;
	}

	function checkValidTest(value) {
	  return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
	}

	function assertConfigFileSearch(loc, value) {
	  if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
	    throw new Error(msg(loc) + " must be a undefined, a boolean, a string, " + ("got " + JSON.stringify(value)));
	  }

	  return value;
	}
	function assertBabelrcSearch(loc, value) {
	  if (value === undefined || typeof value === "boolean") return value;

	  if (Array.isArray(value)) {
	    value.forEach(function (item, i) {
	      if (!checkValidTest(item)) {
	        throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
	      }
	    });
	  } else if (!checkValidTest(value)) {
	    throw new Error(msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp " + ("or an array of those, got " + JSON.stringify(value)));
	  }

	  return value;
	}
	function assertPluginList(loc, value) {
	  var arr = assertArray(loc, value);

	  if (arr) {
	    arr.forEach(function (item, i) {
	      return assertPluginItem(access(loc, i), item);
	    });
	  }

	  return arr;
	}

	function assertPluginItem(loc, value) {
	  if (Array.isArray(value)) {
	    if (value.length === 0) {
	      throw new Error(msg(loc) + " must include an object");
	    }

	    if (value.length > 3) {
	      throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");
	    }

	    assertPluginTarget(access(loc, 0), value[0]);

	    if (value.length > 1) {
	      var opts = value[1];

	      if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
	        throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
	      }
	    }

	    if (value.length === 3) {
	      var _name = value[2];

	      if (_name !== undefined && typeof _name !== "string") {
	        throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
	      }
	    }
	  } else {
	    assertPluginTarget(loc, value);
	  }

	  return value;
	}

	function assertPluginTarget(loc, value) {
	  if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
	    throw new Error(msg(loc) + " must be a string, object, function");
	  }

	  return value;
	}

	function assertTargets(loc, value) {
	  if (isBrowsersQueryValid(value)) return value;

	  if (typeof value !== "object" || !value || Array.isArray(value)) {
	    throw new Error(msg(loc) + " must be a string, an array of strings or an object");
	  }

	  var browsersLoc = access(loc, "browsers");
	  var esmodulesLoc = access(loc, "esmodules");
	  assertBrowsersList(browsersLoc, value.browsers);
	  assertBoolean(esmodulesLoc, value.esmodules);

	  for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
	    var _key = _Object$keys2[_i2];
	    var val = value[_key];
	    var subLoc = access(loc, _key);
	    if (_key === "esmodules") assertBoolean(subLoc, val);else if (_key === "browsers") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(TargetNames, _key)) {
	      var validTargets = Object.keys(TargetNames).join(", ");
	      throw new Error(msg(subLoc) + " is not a valid target. Supported targets are " + validTargets);
	    } else assertBrowserVersion(subLoc, val);
	  }

	  return value;
	}

	function assertBrowsersList(loc, value) {
	  if (value !== undefined && !isBrowsersQueryValid(value)) {
	    throw new Error(msg(loc) + " must be undefined, a string or an array of strings");
	  }
	}

	function assertBrowserVersion(loc, value) {
	  if (typeof value === "number" && Math.round(value) === value) return;
	  if (typeof value === "string") return;
	  throw new Error(msg(loc) + " must be a string or an integer number");
	}

	function assertAssumptions(loc, value) {
	  if (value === undefined) return;

	  if (typeof value !== "object" || value === null) {
	    throw new Error(msg(loc) + " must be an object or undefined.");
	  }

	  var root = loc;

	  do {
	    root = root.parent;
	  } while (root.type !== "root");

	  var inPreset = root.source === "preset";

	  for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {
	    var _name2 = _Object$keys3[_i3];
	    var subLoc = access(loc, _name2);

	    if (!assumptionsNames.has(_name2)) {
	      throw new Error(msg(subLoc) + " is not a supported assumption.");
	    }

	    if (typeof value[_name2] !== "boolean") {
	      throw new Error(msg(subLoc) + " must be a boolean.");
	    }

	    if (inPreset && value[_name2] === false) {
	      throw new Error(msg(subLoc) + " cannot be set to 'false' inside presets.");
	    }
	  }

	  return value;
	}

	var ROOT_VALIDATORS = {
	  cwd: assertString,
	  root: assertString,
	  rootMode: assertRootMode,
	  configFile: assertConfigFileSearch,
	  caller: assertCallerMetadata,
	  filename: assertString,
	  filenameRelative: assertString,
	  code: assertBoolean,
	  ast: assertBoolean,
	  cloneInputAst: assertBoolean,
	  envName: assertString
	};
	var BABELRC_VALIDATORS = {
	  babelrc: assertBoolean,
	  babelrcRoots: assertBabelrcSearch
	};
	var NONPRESET_VALIDATORS = {
	  "extends": assertString,
	  ignore: assertIgnoreList,
	  only: assertIgnoreList,
	  targets: assertTargets,
	  browserslistConfigFile: assertConfigFileSearch,
	  browserslistEnv: assertString
	};
	var COMMON_VALIDATORS = {
	  inputSourceMap: assertInputSourceMap,
	  presets: assertPluginList,
	  plugins: assertPluginList,
	  passPerPreset: assertBoolean,
	  assumptions: assertAssumptions,
	  env: assertEnvSet,
	  overrides: assertOverridesList,
	  test: assertConfigApplicableTest,
	  include: assertConfigApplicableTest,
	  exclude: assertConfigApplicableTest,
	  retainLines: assertBoolean,
	  comments: assertBoolean,
	  shouldPrintComment: assertFunction,
	  compact: assertCompact,
	  minified: assertBoolean,
	  auxiliaryCommentBefore: assertString,
	  auxiliaryCommentAfter: assertString,
	  sourceType: assertSourceType,
	  wrapPluginVisitorMethod: assertFunction,
	  highlightCode: assertBoolean,
	  sourceMaps: assertSourceMaps,
	  sourceMap: assertSourceMaps,
	  sourceFileName: assertString,
	  sourceRoot: assertString,
	  parserOpts: assertObject,
	  generatorOpts: assertObject
	};
	{
	  Object.assign(COMMON_VALIDATORS, {
	    getModuleId: assertFunction,
	    moduleRoot: assertString,
	    moduleIds: assertBoolean,
	    moduleId: assertString
	  });
	}
	var assumptionsNames = new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);

	function getSource(loc) {
	  return loc.type === "root" ? loc.source : getSource(loc.parent);
	}

	function validate(type, opts) {
	  return validateNested({
	    type: "root",
	    source: type
	  }, opts);
	}

	function validateNested(loc, opts) {
	  var type = getSource(loc);
	  assertNoDuplicateSourcemap(opts);
	  Object.keys(opts).forEach(function (key) {
	    var optLoc = {
	      type: "option",
	      name: key,
	      parent: loc
	    };

	    if (type === "preset" && NONPRESET_VALIDATORS[key]) {
	      throw new Error(msg(optLoc) + " is not allowed in preset options");
	    }

	    if (type !== "arguments" && ROOT_VALIDATORS[key]) {
	      throw new Error(msg(optLoc) + " is only allowed in root programmatic options");
	    }

	    if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
	      if (type === "babelrcfile" || type === "extendsfile") {
	        throw new Error(msg(optLoc) + " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, " + "or babel.config.js/config file options");
	      }

	      throw new Error(msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options");
	    }

	    var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
	    validator(optLoc, opts[key]);
	  });
	  return opts;
	}

	function throwUnknownError(loc) {
	  var key = loc.name;

	  if (removed[key]) {
	    var _removed$key = removed[key],
	        message = _removed$key.message,
	        _removed$key$version = _removed$key.version,
	        version = _removed$key$version === void 0 ? 5 : _removed$key$version;
	    throw new Error("Using removed Babel " + version + " option: " + msg(loc) + " - " + message);
	  } else {
	    var unknownOptErr = new Error("Unknown option: " + msg(loc) + ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
	    unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
	    throw unknownOptErr;
	  }
	}

	function has$9(obj, key) {
	  return Object.prototype.hasOwnProperty.call(obj, key);
	}

	function assertNoDuplicateSourcemap(opts) {
	  if (has$9(opts, "sourceMap") && has$9(opts, "sourceMaps")) {
	    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
	  }
	}

	function assertEnvSet(loc, value) {
	  if (loc.parent.type === "env") {
	    throw new Error(msg(loc) + " is not allowed inside of another .env block");
	  }

	  var parent = loc.parent;
	  var obj = assertObject(loc, value);

	  if (obj) {
	    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
	      var envName = _Object$keys[_i];
	      var env = assertObject(access(loc, envName), obj[envName]);
	      if (!env) continue;
	      var envLoc = {
	        type: "env",
	        name: envName,
	        parent: parent
	      };
	      validateNested(envLoc, env);
	    }
	  }

	  return obj;
	}

	function assertOverridesList(loc, value) {
	  if (loc.parent.type === "env") {
	    throw new Error(msg(loc) + " is not allowed inside an .env block");
	  }

	  if (loc.parent.type === "overrides") {
	    throw new Error(msg(loc) + " is not allowed inside an .overrides block");
	  }

	  var parent = loc.parent;
	  var arr = assertArray(loc, value);

	  if (arr) {
	    for (var _iterator = _createForOfIteratorHelperLoose(arr.entries()), _step; !(_step = _iterator()).done;) {
	      var _step$value = _slicedToArray$1(_step.value, 2),
	          index = _step$value[0],
	          item = _step$value[1];

	      var objLoc = access(loc, index);
	      var env = assertObject(objLoc, item);
	      if (!env) throw new Error(msg(objLoc) + " must be an object");
	      var overridesLoc = {
	        type: "overrides",
	        index: index,
	        parent: parent
	      };
	      validateNested(overridesLoc, env);
	    }
	  }

	  return arr;
	}

	function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
	  if (index === 0) return;
	  var lastItem = items[index - 1];
	  var thisItem = items[index];

	  if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
	    e.message += "\n- Maybe you meant to use\n" + ("\"" + type + "s\": [\n  [\"" + lastItem.file.request + "\", " + JSON.stringify(thisItem.value, undefined, 2) + "]\n]\n") + ("To be a valid " + type + ", its name and options should be wrapped in a pair of brackets");
	  }
	}

	var sep = "\\" + path$1.sep;
	var endSep = "(?:" + sep + "|$)";
	var substitution = "[^" + sep + "]+";
	var starPat = "(?:" + substitution + sep + ")";
	var starPatLast = "(?:" + substitution + endSep + ")";
	var starStarPat = starPat + "*?";
	var starStarPatLast = starPat + "*?" + starPatLast + "?";

	function escapeRegExp(string) {
	  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
	}

	function pathToPattern(pattern, dirname) {
	  var parts = path$1.resolve(dirname, pattern).split(path$1.sep);
	  return new RegExp(["^"].concat(_toConsumableArray(parts.map(function (part, i) {
	    var last = i === parts.length - 1;
	    if (part === "**") return last ? starStarPatLast : starStarPat;
	    if (part === "*") return last ? starPatLast : starPat;

	    if (part.indexOf("*.") === 0) {
	      return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);
	    }

	    return escapeRegExp(part) + (last ? endSep : sep);
	  }))).join(""));
	}

	var ChainFormatter = {
	  Programmatic: 0,
	  Config: 1
	};
	var Formatter = {
	  title: function title(type, callerName, filepath) {
	    var title = "";

	    if (type === ChainFormatter.Programmatic) {
	      title = "programmatic options";

	      if (callerName) {
	        title += " from " + callerName;
	      }
	    } else {
	      title = "config " + filepath;
	    }

	    return title;
	  },
	  loc: function loc(index, envName) {
	    var loc = "";

	    if (index != null) {
	      loc += ".overrides[" + index + "]";
	    }

	    if (envName != null) {
	      loc += ".env[\"" + envName + "\"]";
	    }

	    return loc;
	  },
	  optionsAndDescriptors: regenerator.mark(function optionsAndDescriptors(opt) {
	    var content, pluginDescriptors, presetDescriptors;
	    return regenerator.wrap(function optionsAndDescriptors$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            content = Object.assign({}, opt.options);
	            delete content.overrides;
	            delete content.env;
	            _context.t0 = _toConsumableArray;
	            return _context.delegateYield(opt.plugins(), "t1", 5);

	          case 5:
	            _context.t2 = _context.t1;
	            pluginDescriptors = (0, _context.t0)(_context.t2);

	            if (pluginDescriptors.length) {
	              content.plugins = pluginDescriptors.map(function (d) {
	                return descriptorToConfig(d);
	              });
	            }

	            _context.t3 = _toConsumableArray;
	            return _context.delegateYield(opt.presets(), "t4", 10);

	          case 10:
	            _context.t5 = _context.t4;
	            presetDescriptors = (0, _context.t3)(_context.t5);

	            if (presetDescriptors.length) {
	              content.presets = _toConsumableArray(presetDescriptors).map(function (d) {
	                return descriptorToConfig(d);
	              });
	            }

	            return _context.abrupt("return", JSON.stringify(content, undefined, 2));

	          case 14:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, optionsAndDescriptors);
	  })
	};

	function descriptorToConfig(d) {
	  var _d$file;

	  var name = (_d$file = d.file) == null ? void 0 : _d$file.request;

	  if (name == null) {
	    if (typeof d.value === "object") {
	      name = d.value;
	    } else if (typeof d.value === "function") {
	      name = "[Function: " + d.value.toString().substr(0, 50) + " ... ]";
	    }
	  }

	  if (name == null) {
	    name = "[Unknown]";
	  }

	  if (d.options === undefined) {
	    return name;
	  } else if (d.name == null) {
	    return [name, d.options];
	  } else {
	    return [name, d.options, d.name];
	  }
	}

	var ConfigPrinter = function () {
	  function ConfigPrinter() {
	    this._stack = [];
	  }

	  var _proto = ConfigPrinter.prototype;

	  _proto.configure = function configure(enabled, type, _ref) {
	    var _this = this;

	    var callerName = _ref.callerName,
	        filepath = _ref.filepath;
	    if (!enabled) return function () {};
	    return function (content, index, envName) {
	      _this._stack.push({
	        type: type,
	        callerName: callerName,
	        filepath: filepath,
	        content: content,
	        index: index,
	        envName: envName
	      });
	    };
	  };

	  ConfigPrinter.format = regenerator.mark(function format(config) {
	    var title, loc, content;
	    return regenerator.wrap(function format$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            title = Formatter.title(config.type, config.callerName, config.filepath);
	            loc = Formatter.loc(config.index, config.envName);
	            if (loc) title += " " + loc;
	            return _context2.delegateYield(Formatter.optionsAndDescriptors(config.content), "t0", 4);

	          case 4:
	            content = _context2.t0;
	            return _context2.abrupt("return", title + "\n" + content);

	          case 6:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, format);
	  });
	  _proto.output = regenerator.mark(function output() {
	    var configs;
	    return regenerator.wrap(function output$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if (!(this._stack.length === 0)) {
	              _context3.next = 2;
	              break;
	            }

	            return _context3.abrupt("return", "");

	          case 2:
	            return _context3.delegateYield(gensync.all(this._stack.map(function (s) {
	              return ConfigPrinter.format(s);
	            })), "t0", 3);

	          case 3:
	            configs = _context3.t0;
	            return _context3.abrupt("return", configs.join("\n\n"));

	          case 5:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, output, this);
	  });
	  return ConfigPrinter;
	}();

	var _marked$5 = regenerator.mark(buildPresetChain),
	    _marked2$2 = regenerator.mark(buildRootChain),
	    _marked3 = regenerator.mark(loadFileChain),
	    _marked4 = regenerator.mark(mergeExtendsChain),
	    _marked5 = regenerator.mark(mergeChainOpts);
	var debug$2 = browser$3("babel:config:config-chain");
	function buildPresetChain(arg, context) {
	  var chain;
	  return regenerator.wrap(function buildPresetChain$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(buildPresetChainWalker(arg, context), "t0", 1);

	        case 1:
	          chain = _context.t0;

	          if (chain) {
	            _context.next = 4;
	            break;
	          }

	          return _context.abrupt("return", null);

	        case 4:
	          return _context.abrupt("return", {
	            plugins: dedupDescriptors(chain.plugins),
	            presets: dedupDescriptors(chain.presets),
	            options: chain.options.map(function (o) {
	              return normalizeOptions$5(o);
	            }),
	            files: new Set()
	          });

	        case 5:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$5);
	}
	var buildPresetChainWalker = makeChainWalker({
	  root: function root(preset) {
	    return loadPresetDescriptors(preset);
	  },
	  env: function env(preset, envName) {
	    return loadPresetEnvDescriptors(preset)(envName);
	  },
	  overrides: function overrides(preset, index) {
	    return loadPresetOverridesDescriptors(preset)(index);
	  },
	  overridesEnv: function overridesEnv(preset, index, envName) {
	    return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
	  },
	  createLogger: function createLogger() {
	    return function () {};
	  }
	});
	var loadPresetDescriptors = makeWeakCacheSync(function (preset) {
	  return buildRootDescriptors(preset, preset.alias, createUncachedDescriptors);
	});
	var loadPresetEnvDescriptors = makeWeakCacheSync(function (preset) {
	  return makeStrongCacheSync(function (envName) {
	    return buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName);
	  });
	});
	var loadPresetOverridesDescriptors = makeWeakCacheSync(function (preset) {
	  return makeStrongCacheSync(function (index) {
	    return buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index);
	  });
	});
	var loadPresetOverridesEnvDescriptors = makeWeakCacheSync(function (preset) {
	  return makeStrongCacheSync(function (index) {
	    return makeStrongCacheSync(function (envName) {
	      return buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName);
	    });
	  });
	});
	function buildRootChain(opts, context) {
	  var configReport, babelRcReport, programmaticLogger, programmaticChain, programmaticReport, configFile, babelrc, babelrcRoots, babelrcRootsDirectory, configFileChain, configFileLogger, validatedFile, result, ignoreFile, babelrcFile, isIgnored, fileChain, pkgData, _yield$findRelativeCo, _validatedFile, babelrcLogger, _result, chain;

	  return regenerator.wrap(function buildRootChain$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          programmaticLogger = new ConfigPrinter();
	          return _context2.delegateYield(loadProgrammaticChain({
	            options: opts,
	            dirname: context.cwd
	          }, context, undefined, programmaticLogger), "t0", 2);

	        case 2:
	          programmaticChain = _context2.t0;

	          if (programmaticChain) {
	            _context2.next = 5;
	            break;
	          }

	          return _context2.abrupt("return", null);

	        case 5:
	          return _context2.delegateYield(programmaticLogger.output(), "t1", 6);

	        case 6:
	          programmaticReport = _context2.t1;

	          if (!(typeof opts.configFile === "string")) {
	            _context2.next = 12;
	            break;
	          }

	          return _context2.delegateYield(loadConfig$1(opts.configFile, context.cwd, context.envName, context.caller), "t2", 9);

	        case 9:
	          configFile = _context2.t2;
	          _context2.next = 15;
	          break;

	        case 12:
	          if (!(opts.configFile !== false)) {
	            _context2.next = 15;
	            break;
	          }

	          return _context2.delegateYield(findRootConfig(context.root, context.envName, context.caller), "t3", 14);

	        case 14:
	          configFile = _context2.t3;

	        case 15:
	          babelrc = opts.babelrc, babelrcRoots = opts.babelrcRoots;
	          babelrcRootsDirectory = context.cwd;
	          configFileChain = emptyChain();
	          configFileLogger = new ConfigPrinter();

	          if (!configFile) {
	            _context2.next = 30;
	            break;
	          }

	          validatedFile = validateConfigFile(configFile);
	          return _context2.delegateYield(loadFileChain(validatedFile, context, undefined, configFileLogger), "t4", 22);

	        case 22:
	          result = _context2.t4;

	          if (result) {
	            _context2.next = 25;
	            break;
	          }

	          return _context2.abrupt("return", null);

	        case 25:
	          return _context2.delegateYield(configFileLogger.output(), "t5", 26);

	        case 26:
	          configReport = _context2.t5;

	          if (babelrc === undefined) {
	            babelrc = validatedFile.options.babelrc;
	          }

	          if (babelrcRoots === undefined) {
	            babelrcRootsDirectory = validatedFile.dirname;
	            babelrcRoots = validatedFile.options.babelrcRoots;
	          }

	          mergeChain(configFileChain, result);

	        case 30:
	          isIgnored = false;
	          fileChain = emptyChain();

	          if (!((babelrc === true || babelrc === undefined) && typeof context.filename === "string")) {
	            _context2.next = 55;
	            break;
	          }

	          return _context2.delegateYield(findPackageData(context.filename), "t6", 34);

	        case 34:
	          pkgData = _context2.t6;

	          if (!(pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory))) {
	            _context2.next = 55;
	            break;
	          }

	          return _context2.delegateYield(findRelativeConfig(pkgData, context.envName, context.caller), "t7", 37);

	        case 37:
	          _yield$findRelativeCo = _context2.t7;
	          ignoreFile = _yield$findRelativeCo.ignore;
	          babelrcFile = _yield$findRelativeCo.config;

	          if (ignoreFile) {
	            fileChain.files.add(ignoreFile.filepath);
	          }

	          if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
	            isIgnored = true;
	          }

	          if (!(babelrcFile && !isIgnored)) {
	            _context2.next = 54;
	            break;
	          }

	          _validatedFile = validateBabelrcFile(babelrcFile);
	          babelrcLogger = new ConfigPrinter();
	          return _context2.delegateYield(loadFileChain(_validatedFile, context, undefined, babelrcLogger), "t8", 46);

	        case 46:
	          _result = _context2.t8;

	          if (_result) {
	            _context2.next = 51;
	            break;
	          }

	          isIgnored = true;
	          _context2.next = 54;
	          break;

	        case 51:
	          return _context2.delegateYield(babelrcLogger.output(), "t9", 52);

	        case 52:
	          babelRcReport = _context2.t9;
	          mergeChain(fileChain, _result);

	        case 54:
	          if (babelrcFile && isIgnored) {
	            fileChain.files.add(babelrcFile.filepath);
	          }

	        case 55:
	          if (context.showConfig) {
	            console.log("Babel configs on \"" + context.filename + "\" (ascending priority):\n" + [configReport, babelRcReport, programmaticReport].filter(function (x) {
	              return !!x;
	            }).join("\n\n") + "\n-----End Babel configs-----");
	          }

	          chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
	          return _context2.abrupt("return", {
	            plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
	            presets: isIgnored ? [] : dedupDescriptors(chain.presets),
	            options: isIgnored ? [] : chain.options.map(function (o) {
	              return normalizeOptions$5(o);
	            }),
	            fileHandling: isIgnored ? "ignored" : "transpile",
	            ignore: ignoreFile || undefined,
	            babelrc: babelrcFile || undefined,
	            config: configFile || undefined,
	            files: chain.files
	          });

	        case 58:
	        case "end":
	          return _context2.stop();
	      }
	    }
	  }, _marked2$2);
	}

	function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
	  if (typeof babelrcRoots === "boolean") return babelrcRoots;
	  var absoluteRoot = context.root;

	  if (babelrcRoots === undefined) {
	    return pkgData.directories.indexOf(absoluteRoot) !== -1;
	  }

	  var babelrcPatterns = babelrcRoots;

	  if (!Array.isArray(babelrcPatterns)) {
	    babelrcPatterns = [babelrcPatterns];
	  }

	  babelrcPatterns = babelrcPatterns.map(function (pat) {
	    return typeof pat === "string" ? path$1.resolve(babelrcRootsDirectory, pat) : pat;
	  });

	  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
	    return pkgData.directories.indexOf(absoluteRoot) !== -1;
	  }

	  return babelrcPatterns.some(function (pat) {
	    if (typeof pat === "string") {
	      pat = pathToPattern(pat, babelrcRootsDirectory);
	    }

	    return pkgData.directories.some(function (directory) {
	      return matchPattern(pat, babelrcRootsDirectory, directory, context);
	    });
	  });
	}

	var validateConfigFile = makeWeakCacheSync(function (file) {
	  return {
	    filepath: file.filepath,
	    dirname: file.dirname,
	    options: validate("configfile", file.options)
	  };
	});
	var validateBabelrcFile = makeWeakCacheSync(function (file) {
	  return {
	    filepath: file.filepath,
	    dirname: file.dirname,
	    options: validate("babelrcfile", file.options)
	  };
	});
	var validateExtendFile = makeWeakCacheSync(function (file) {
	  return {
	    filepath: file.filepath,
	    dirname: file.dirname,
	    options: validate("extendsfile", file.options)
	  };
	});
	var loadProgrammaticChain = makeChainWalker({
	  root: function root(input) {
	    return buildRootDescriptors(input, "base", createCachedDescriptors);
	  },
	  env: function env(input, envName) {
	    return buildEnvDescriptors(input, "base", createCachedDescriptors, envName);
	  },
	  overrides: function overrides(input, index) {
	    return buildOverrideDescriptors(input, "base", createCachedDescriptors, index);
	  },
	  overridesEnv: function overridesEnv(input, index, envName) {
	    return buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName);
	  },
	  createLogger: function createLogger(input, context, baseLogger) {
	    return buildProgrammaticLogger(input, context, baseLogger);
	  }
	});
	var loadFileChainWalker = makeChainWalker({
	  root: function root(file) {
	    return loadFileDescriptors(file);
	  },
	  env: function env(file, envName) {
	    return loadFileEnvDescriptors(file)(envName);
	  },
	  overrides: function overrides(file, index) {
	    return loadFileOverridesDescriptors(file)(index);
	  },
	  overridesEnv: function overridesEnv(file, index, envName) {
	    return loadFileOverridesEnvDescriptors(file)(index)(envName);
	  },
	  createLogger: function createLogger(file, context, baseLogger) {
	    return buildFileLogger(file.filepath, context, baseLogger);
	  }
	});

	function loadFileChain(input, context, files, baseLogger) {
	  var chain;
	  return regenerator.wrap(function loadFileChain$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          return _context3.delegateYield(loadFileChainWalker(input, context, files, baseLogger), "t0", 1);

	        case 1:
	          chain = _context3.t0;

	          if (chain) {
	            chain.files.add(input.filepath);
	          }

	          return _context3.abrupt("return", chain);

	        case 4:
	        case "end":
	          return _context3.stop();
	      }
	    }
	  }, _marked3);
	}

	var loadFileDescriptors = makeWeakCacheSync(function (file) {
	  return buildRootDescriptors(file, file.filepath, createUncachedDescriptors);
	});
	var loadFileEnvDescriptors = makeWeakCacheSync(function (file) {
	  return makeStrongCacheSync(function (envName) {
	    return buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName);
	  });
	});
	var loadFileOverridesDescriptors = makeWeakCacheSync(function (file) {
	  return makeStrongCacheSync(function (index) {
	    return buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index);
	  });
	});
	var loadFileOverridesEnvDescriptors = makeWeakCacheSync(function (file) {
	  return makeStrongCacheSync(function (index) {
	    return makeStrongCacheSync(function (envName) {
	      return buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName);
	    });
	  });
	});

	function buildFileLogger(filepath, context, baseLogger) {
	  if (!baseLogger) {
	    return function () {};
	  }

	  return baseLogger.configure(context.showConfig, ChainFormatter.Config, {
	    filepath: filepath
	  });
	}

	function buildRootDescriptors(_ref, alias, descriptors) {
	  var dirname = _ref.dirname,
	      options = _ref.options;
	  return descriptors(dirname, options, alias);
	}

	function buildProgrammaticLogger(_, context, baseLogger) {
	  var _context$caller;

	  if (!baseLogger) {
	    return function () {};
	  }

	  return baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {
	    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
	  });
	}

	function buildEnvDescriptors(_ref2, alias, descriptors, envName) {
	  var dirname = _ref2.dirname,
	      options = _ref2.options;
	  var opts = options.env && options.env[envName];
	  return opts ? descriptors(dirname, opts, alias + ".env[\"" + envName + "\"]") : null;
	}

	function buildOverrideDescriptors(_ref3, alias, descriptors, index) {
	  var dirname = _ref3.dirname,
	      options = _ref3.options;
	  var opts = options.overrides && options.overrides[index];
	  if (!opts) throw new Error("Assertion failure - missing override");
	  return descriptors(dirname, opts, alias + ".overrides[" + index + "]");
	}

	function buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {
	  var dirname = _ref4.dirname,
	      options = _ref4.options;
	  var override = options.overrides && options.overrides[index];
	  if (!override) throw new Error("Assertion failure - missing override");
	  var opts = override.env && override.env[envName];
	  return opts ? descriptors(dirname, opts, alias + ".overrides[" + index + "].env[\"" + envName + "\"]") : null;
	}

	function makeChainWalker(_ref5) {
	  var root = _ref5.root,
	      env = _ref5.env,
	      overrides = _ref5.overrides,
	      overridesEnv = _ref5.overridesEnv,
	      createLogger = _ref5.createLogger;
	  return regenerator.mark(function _callee(input, context, files, baseLogger) {
	    var dirname, flattenedConfigs, rootOpts, envOpts, chain, logger, _i, _flattenedConfigs, _flattenedConfigs$_i, config, _index, envName;

	    return regenerator.wrap(function _callee$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            if (files === void 0) {
	              files = new Set();
	            }

	            dirname = input.dirname;
	            flattenedConfigs = [];
	            rootOpts = root(input);

	            if (configIsApplicable(rootOpts, dirname, context)) {
	              flattenedConfigs.push({
	                config: rootOpts,
	                envName: undefined,
	                index: undefined
	              });
	              envOpts = env(input, context.envName);

	              if (envOpts && configIsApplicable(envOpts, dirname, context)) {
	                flattenedConfigs.push({
	                  config: envOpts,
	                  envName: context.envName,
	                  index: undefined
	                });
	              }

	              (rootOpts.options.overrides || []).forEach(function (_, index) {
	                var overrideOps = overrides(input, index);

	                if (configIsApplicable(overrideOps, dirname, context)) {
	                  flattenedConfigs.push({
	                    config: overrideOps,
	                    index: index,
	                    envName: undefined
	                  });
	                  var overrideEnvOpts = overridesEnv(input, index, context.envName);

	                  if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
	                    flattenedConfigs.push({
	                      config: overrideEnvOpts,
	                      index: index,
	                      envName: context.envName
	                    });
	                  }
	                }
	              });
	            }

	            if (!flattenedConfigs.some(function (_ref6) {
	              var _ref6$config$options = _ref6.config.options,
	                  ignore = _ref6$config$options.ignore,
	                  only = _ref6$config$options.only;
	              return shouldIgnore(context, ignore, only, dirname);
	            })) {
	              _context4.next = 7;
	              break;
	            }

	            return _context4.abrupt("return", null);

	          case 7:
	            chain = emptyChain();
	            logger = createLogger(input, context, baseLogger);
	            _i = 0, _flattenedConfigs = flattenedConfigs;

	          case 10:
	            if (!(_i < _flattenedConfigs.length)) {
	              _context4.next = 20;
	              break;
	            }

	            _flattenedConfigs$_i = _flattenedConfigs[_i], config = _flattenedConfigs$_i.config, _index = _flattenedConfigs$_i.index, envName = _flattenedConfigs$_i.envName;
	            return _context4.delegateYield(mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger), "t0", 13);

	          case 13:
	            if (_context4.t0) {
	              _context4.next = 15;
	              break;
	            }

	            return _context4.abrupt("return", null);

	          case 15:
	            logger(config, _index, envName);
	            return _context4.delegateYield(mergeChainOpts(chain, config), "t1", 17);

	          case 17:
	            _i++;
	            _context4.next = 10;
	            break;

	          case 20:
	            return _context4.abrupt("return", chain);

	          case 21:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee);
	  });
	}

	function mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {
	  var file, fileChain;
	  return regenerator.wrap(function mergeExtendsChain$(_context5) {
	    while (1) {
	      switch (_context5.prev = _context5.next) {
	        case 0:
	          if (!(opts["extends"] === undefined)) {
	            _context5.next = 2;
	            break;
	          }

	          return _context5.abrupt("return", true);

	        case 2:
	          return _context5.delegateYield(loadConfig$1(opts["extends"], dirname, context.envName, context.caller), "t0", 3);

	        case 3:
	          file = _context5.t0;

	          if (!files.has(file)) {
	            _context5.next = 6;
	            break;
	          }

	          throw new Error("Configuration cycle detected loading " + file.filepath + ".\n" + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
	            return " - " + file.filepath;
	          }).join("\n"));

	        case 6:
	          files.add(file);
	          return _context5.delegateYield(loadFileChain(validateExtendFile(file), context, files, baseLogger), "t1", 8);

	        case 8:
	          fileChain = _context5.t1;
	          files["delete"](file);

	          if (fileChain) {
	            _context5.next = 12;
	            break;
	          }

	          return _context5.abrupt("return", false);

	        case 12:
	          mergeChain(chain, fileChain);
	          return _context5.abrupt("return", true);

	        case 14:
	        case "end":
	          return _context5.stop();
	      }
	    }
	  }, _marked4);
	}

	function mergeChain(target, source) {
	  var _target$options, _target$plugins, _target$presets;

	  (_target$options = target.options).push.apply(_target$options, _toConsumableArray(source.options));

	  (_target$plugins = target.plugins).push.apply(_target$plugins, _toConsumableArray(source.plugins));

	  (_target$presets = target.presets).push.apply(_target$presets, _toConsumableArray(source.presets));

	  for (var _iterator = _createForOfIteratorHelperLoose(source.files), _step; !(_step = _iterator()).done;) {
	    var file = _step.value;
	    target.files.add(file);
	  }

	  return target;
	}

	function mergeChainOpts(target, _ref7) {
	  var _target$plugins2, _target$presets2;

	  var options, plugins, presets;
	  return regenerator.wrap(function mergeChainOpts$(_context6) {
	    while (1) {
	      switch (_context6.prev = _context6.next) {
	        case 0:
	          options = _ref7.options, plugins = _ref7.plugins, presets = _ref7.presets;
	          target.options.push(options);
	          _context6.t0 = (_target$plugins2 = target.plugins).push;
	          _context6.t1 = _target$plugins2;
	          _context6.t2 = _toConsumableArray;
	          return _context6.delegateYield(plugins(), "t3", 6);

	        case 6:
	          _context6.t4 = _context6.t3;
	          _context6.t5 = (0, _context6.t2)(_context6.t4);

	          _context6.t0.apply.call(_context6.t0, _context6.t1, _context6.t5);

	          _context6.t6 = (_target$presets2 = target.presets).push;
	          _context6.t7 = _target$presets2;
	          _context6.t8 = _toConsumableArray;
	          return _context6.delegateYield(presets(), "t9", 13);

	        case 13:
	          _context6.t10 = _context6.t9;
	          _context6.t11 = (0, _context6.t8)(_context6.t10);

	          _context6.t6.apply.call(_context6.t6, _context6.t7, _context6.t11);

	          return _context6.abrupt("return", target);

	        case 17:
	        case "end":
	          return _context6.stop();
	      }
	    }
	  }, _marked5);
	}

	function emptyChain() {
	  return {
	    options: [],
	    presets: [],
	    plugins: [],
	    files: new Set()
	  };
	}

	function normalizeOptions$5(opts) {
	  var options = Object.assign({}, opts);
	  delete options["extends"];
	  delete options.env;
	  delete options.overrides;
	  delete options.plugins;
	  delete options.presets;
	  delete options.passPerPreset;
	  delete options.ignore;
	  delete options.only;
	  delete options.test;
	  delete options.include;
	  delete options.exclude;

	  if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
	    options.sourceMaps = options.sourceMap;
	    delete options.sourceMap;
	  }

	  return options;
	}

	function dedupDescriptors(items) {
	  var map = new Map();
	  var descriptors = [];

	  for (var _iterator2 = _createForOfIteratorHelperLoose(items), _step2; !(_step2 = _iterator2()).done;) {
	    var item = _step2.value;

	    if (typeof item.value === "function") {
	      var fnKey = item.value;
	      var nameMap = map.get(fnKey);

	      if (!nameMap) {
	        nameMap = new Map();
	        map.set(fnKey, nameMap);
	      }

	      var desc = nameMap.get(item.name);

	      if (!desc) {
	        desc = {
	          value: item
	        };
	        descriptors.push(desc);
	        if (!item.ownPass) nameMap.set(item.name, desc);
	      } else {
	        desc.value = item;
	      }
	    } else {
	      descriptors.push({
	        value: item
	      });
	    }
	  }

	  return descriptors.reduce(function (acc, desc) {
	    acc.push(desc.value);
	    return acc;
	  }, []);
	}

	function configIsApplicable(_ref8, dirname, context) {
	  var options = _ref8.options;
	  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
	}

	function configFieldIsApplicable(context, test, dirname) {
	  var patterns = Array.isArray(test) ? test : [test];
	  return matchesPatterns(context, patterns, dirname);
	}

	function ignoreListReplacer(_key, value) {
	  if (value instanceof RegExp) {
	    return String(value);
	  }

	  return value;
	}

	function shouldIgnore(context, ignore, only, dirname) {
	  if (ignore && matchesPatterns(context, ignore, dirname)) {
	    var _context$filename;

	    var message = "No config is applied to \"" + ((_context$filename = context.filename) != null ? _context$filename : "(unknown)") + "\" because it matches one of `ignore: " + JSON.stringify(ignore, ignoreListReplacer) + "` from \"" + dirname + "\"";
	    debug$2(message);

	    if (context.showConfig) {
	      console.log(message);
	    }

	    return true;
	  }

	  if (only && !matchesPatterns(context, only, dirname)) {
	    var _context$filename2;

	    var _message = "No config is applied to \"" + ((_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)") + "\" because it fails to match one of `only: " + JSON.stringify(only, ignoreListReplacer) + "` from \"" + dirname + "\"";

	    debug$2(_message);

	    if (context.showConfig) {
	      console.log(_message);
	    }

	    return true;
	  }

	  return false;
	}

	function matchesPatterns(context, patterns, dirname) {
	  return patterns.some(function (pattern) {
	    return matchPattern(pattern, dirname, context.filename, context);
	  });
	}

	function matchPattern(pattern, dirname, pathToTest, context) {
	  if (typeof pattern === "function") {
	    return !!pattern(pathToTest, {
	      dirname: dirname,
	      envName: context.envName,
	      caller: context.caller
	    });
	  }

	  if (typeof pathToTest !== "string") {
	    throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
	  }

	  if (typeof pattern === "string") {
	    pattern = pathToPattern(pattern, dirname);
	  }

	  return pattern.test(pathToTest);
	}

	var VALIDATORS = {
	  name: assertString,
	  manipulateOptions: assertFunction,
	  pre: assertFunction,
	  post: assertFunction,
	  inherits: assertFunction,
	  visitor: assertVisitorMap,
	  parserOverride: assertFunction,
	  generatorOverride: assertFunction
	};

	function assertVisitorMap(loc, value) {
	  var obj = assertObject(loc, value);

	  if (obj) {
	    Object.keys(obj).forEach(function (prop) {
	      return assertVisitorHandler(prop, obj[prop]);
	    });

	    if (obj.enter || obj.exit) {
	      throw new Error(msg(loc) + " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.");
	    }
	  }

	  return obj;
	}

	function assertVisitorHandler(key, value) {
	  if (value && typeof value === "object") {
	    Object.keys(value).forEach(function (handler) {
	      if (handler !== "enter" && handler !== "exit") {
	        throw new Error(".visitor[\"" + key + "\"] may only have .enter and/or .exit handlers.");
	      }
	    });
	  } else if (typeof value !== "function") {
	    throw new Error(".visitor[\"" + key + "\"] must be a function");
	  }

	  return value;
	}

	function validatePluginObject(obj) {
	  var rootPath = {
	    type: "root",
	    source: "plugin"
	  };
	  Object.keys(obj).forEach(function (key) {
	    var validator = VALIDATORS[key];

	    if (validator) {
	      var optLoc = {
	        type: "option",
	        name: key,
	        parent: rootPath
	      };
	      validator(optLoc, obj[key]);
	    } else {
	      var invalidPluginPropertyError = new Error("." + key + " is not a valid Plugin property");
	      invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
	      throw invalidPluginPropertyError;
	    }
	  });
	  return obj;
	}

	function makeConfigAPI(cache) {
	  var env = function env(value) {
	    return cache.using(function (data) {
	      if (typeof value === "undefined") return data.envName;

	      if (typeof value === "function") {
	        return assertSimpleType(value(data.envName));
	      }

	      if (!Array.isArray(value)) value = [value];
	      return value.some(function (entry) {
	        if (typeof entry !== "string") {
	          throw new Error("Unexpected non-string value");
	        }

	        return entry === data.envName;
	      });
	    });
	  };

	  var caller = function caller(cb) {
	    return cache.using(function (data) {
	      return assertSimpleType(cb(data.caller));
	    });
	  };

	  return {
	    version: version$3,
	    cache: cache.simple(),
	    env: env,
	    async: function async() {
	      return false;
	    },
	    caller: caller,
	    assertVersion: assertVersion
	  };
	}
	function makePresetAPI(cache) {
	  var targets = function targets() {
	    return JSON.parse(cache.using(function (data) {
	      return JSON.stringify(data.targets);
	    }));
	  };

	  return Object.assign({}, makeConfigAPI(cache), {
	    targets: targets
	  });
	}
	function makePluginAPI(cache) {
	  var assumption = function assumption(name) {
	    return cache.using(function (data) {
	      return data.assumptions[name];
	    });
	  };

	  return Object.assign({}, makePresetAPI(cache), {
	    assumption: assumption
	  });
	}

	function assertVersion(range) {
	  if (typeof range === "number") {
	    if (!Number.isInteger(range)) {
	      throw new Error("Expected string or integer value.");
	    }

	    range = "^" + range + ".0.0-0";
	  }

	  if (typeof range !== "string") {
	    throw new Error("Expected string or integer value.");
	  }

	  if (semver$4.satisfies(version$3, range)) return;
	  var limit = Error.stackTraceLimit;

	  if (typeof limit === "number" && limit < 25) {
	    Error.stackTraceLimit = 25;
	  }

	  var err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version$3 + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

	  if (typeof limit === "number") {
	    Error.stackTraceLimit = limit;
	  }

	  throw Object.assign(err, {
	    code: "BABEL_VERSION_UNSUPPORTED",
	    version: version$3,
	    range: range
	  });
	}

	var _excluded$2 = ["showIgnoredFiles"];

	var _marked$4 = regenerator.mark(loadPrivatePartialConfig);

	function resolveRootMode(rootDir, rootMode) {
	  switch (rootMode) {
	    case "root":
	      return rootDir;

	    case "upward-optional":
	      {
	        var upwardRootDir = findConfigUpwards();
	        return upwardRootDir === null ? rootDir : upwardRootDir;
	      }

	    case "upward":
	      {
	        var _upwardRootDir = findConfigUpwards();

	        if (_upwardRootDir !== null) return _upwardRootDir;
	        throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\".\n") + "One of the following config files must be in the directory tree: " + ("\"" + ROOT_CONFIG_FILENAMES.join(", ") + "\".")), {
	          code: "BABEL_ROOT_NOT_FOUND",
	          dirname: rootDir
	        });
	      }

	    default:
	      throw new Error("Assertion failure - unknown rootMode value.");
	  }
	}

	function loadPrivatePartialConfig(inputOpts) {
	  var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, _args$cloneInputAst, cloneInputAst, absoluteCwd, absoluteRootDir, filename, showConfigPath, context, configChain, merged, options;

	  return regenerator.wrap(function loadPrivatePartialConfig$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          if (!(inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts)))) {
	            _context.next = 2;
	            break;
	          }

	          throw new Error("Babel options must be an object, null, or undefined");

	        case 2:
	          args = inputOpts ? validate("arguments", inputOpts) : {};
	          _args$envName = args.envName, envName = _args$envName === void 0 ? getEnv() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller, _args$cloneInputAst = args.cloneInputAst, cloneInputAst = _args$cloneInputAst === void 0 ? true : _args$cloneInputAst;
	          absoluteCwd = path$1.resolve(cwd);
	          absoluteRootDir = resolveRootMode(path$1.resolve(absoluteCwd, rootDir), rootMode);
	          filename = typeof args.filename === "string" ? path$1.resolve(cwd, args.filename) : undefined;
	          return _context.delegateYield(resolveShowConfigPath(), "t0", 8);

	        case 8:
	          showConfigPath = _context.t0;
	          context = {
	            filename: filename,
	            cwd: absoluteCwd,
	            root: absoluteRootDir,
	            envName: envName,
	            caller: caller,
	            showConfig: showConfigPath === filename
	          };
	          return _context.delegateYield(buildRootChain(args, context), "t1", 11);

	        case 11:
	          configChain = _context.t1;

	          if (configChain) {
	            _context.next = 14;
	            break;
	          }

	          return _context.abrupt("return", null);

	        case 14:
	          merged = {
	            assumptions: {}
	          };
	          configChain.options.forEach(function (opts) {
	            mergeOptions(merged, opts);
	          });
	          options = Object.assign({}, merged, {
	            targets: resolveTargets(merged),
	            cloneInputAst: cloneInputAst,
	            babelrc: false,
	            configFile: false,
	            browserslistConfigFile: false,
	            passPerPreset: false,
	            envName: context.envName,
	            cwd: context.cwd,
	            root: context.root,
	            rootMode: "root",
	            filename: typeof context.filename === "string" ? context.filename : undefined,
	            plugins: configChain.plugins.map(function (descriptor) {
	              return createItemFromDescriptor(descriptor);
	            }),
	            presets: configChain.presets.map(function (descriptor) {
	              return createItemFromDescriptor(descriptor);
	            })
	          });
	          return _context.abrupt("return", {
	            options: options,
	            context: context,
	            fileHandling: configChain.fileHandling,
	            ignore: configChain.ignore,
	            babelrc: configChain.babelrc,
	            config: configChain.config,
	            files: configChain.files
	          });

	        case 18:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$4);
	}
	var loadPartialConfig$1 = gensync(regenerator.mark(function _callee(opts) {
	  var showIgnoredFiles, _opts, result, options, babelrc, ignore, config, fileHandling, files;

	  return regenerator.wrap(function _callee$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          showIgnoredFiles = false;

	          if (typeof opts === "object" && opts !== null && !Array.isArray(opts)) {
	            _opts = opts;
	            showIgnoredFiles = _opts.showIgnoredFiles;
	            opts = _objectWithoutPropertiesLoose(_opts, _excluded$2);
	          }

	          return _context2.delegateYield(loadPrivatePartialConfig(opts), "t0", 3);

	        case 3:
	          result = _context2.t0;

	          if (result) {
	            _context2.next = 6;
	            break;
	          }

	          return _context2.abrupt("return", null);

	        case 6:
	          options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config, fileHandling = result.fileHandling, files = result.files;

	          if (!(fileHandling === "ignored" && !showIgnoredFiles)) {
	            _context2.next = 9;
	            break;
	          }

	          return _context2.abrupt("return", null);

	        case 9:
	          (options.plugins || []).forEach(function (item) {
	            if (item.value instanceof Plugin$1) {
	              throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
	            }
	          });
	          return _context2.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files));

	        case 11:
	        case "end":
	          return _context2.stop();
	      }
	    }
	  }, _callee);
	}));

	var PartialConfig = function () {
	  function PartialConfig(options, babelrc, ignore, config, fileHandling, files) {
	    this.options = void 0;
	    this.babelrc = void 0;
	    this.babelignore = void 0;
	    this.config = void 0;
	    this.fileHandling = void 0;
	    this.files = void 0;
	    this.options = options;
	    this.babelignore = ignore;
	    this.babelrc = babelrc;
	    this.config = config;
	    this.fileHandling = fileHandling;
	    this.files = files;
	    Object.freeze(this);
	  }

	  var _proto = PartialConfig.prototype;

	  _proto.hasFilesystemConfig = function hasFilesystemConfig() {
	    return this.babelrc !== undefined || this.config !== undefined;
	  };

	  return PartialConfig;
	}();

	Object.freeze(PartialConfig.prototype);

	var _marked$3 = regenerator.mark(loadPluginDescriptor),
	    _marked2$1 = regenerator.mark(loadPresetDescriptor);
	var loadConfig = gensync(regenerator.mark(function loadFullConfig(inputOpts) {
	  var _opts$assumptions;

	  var result, options, context, fileHandling, optionDefaults, plugins, presets, presetContext, toDescriptor, presetsDescriptors, initialPluginsDescriptors, pluginDescriptorsByPass, passes, ignored, opts, pluginContext;
	  return regenerator.wrap(function loadFullConfig$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          return _context3.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

	        case 1:
	          result = _context3.t0;

	          if (result) {
	            _context3.next = 4;
	            break;
	          }

	          return _context3.abrupt("return", null);

	        case 4:
	          options = result.options, context = result.context, fileHandling = result.fileHandling;

	          if (!(fileHandling === "ignored")) {
	            _context3.next = 7;
	            break;
	          }

	          return _context3.abrupt("return", null);

	        case 7:
	          optionDefaults = {};
	          plugins = options.plugins, presets = options.presets;

	          if (!(!plugins || !presets)) {
	            _context3.next = 11;
	            break;
	          }

	          throw new Error("Assertion failure - plugins and presets exist");

	        case 11:
	          presetContext = Object.assign({}, context, {
	            targets: options.targets
	          });

	          toDescriptor = function toDescriptor(item) {
	            var desc = getItemDescriptor(item);

	            if (!desc) {
	              throw new Error("Assertion failure - must be config item");
	            }

	            return desc;
	          };

	          presetsDescriptors = presets.map(toDescriptor);
	          initialPluginsDescriptors = plugins.map(toDescriptor);
	          pluginDescriptorsByPass = [[]];
	          passes = [];
	          return _context3.delegateYield(enhanceError(context, regenerator.mark(function recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
	            var presets, i, descriptor, _iterator, _step, _step$value, preset, pass, _ignored;

	            return regenerator.wrap(function recursePresetDescriptors$(_context) {
	              while (1) {
	                switch (_context.prev = _context.next) {
	                  case 0:
	                    presets = [];
	                    i = 0;

	                  case 2:
	                    if (!(i < rawPresets.length)) {
	                      _context.next = 30;
	                      break;
	                    }

	                    descriptor = rawPresets[i];

	                    if (!(descriptor.options !== false)) {
	                      _context.next = 27;
	                      break;
	                    }

	                    _context.prev = 5;

	                    if (!descriptor.ownPass) {
	                      _context.next = 15;
	                      break;
	                    }

	                    _context.t0 = presets;
	                    return _context.delegateYield(loadPresetDescriptor(descriptor, presetContext), "t1", 9);

	                  case 9:
	                    _context.t2 = _context.t1;
	                    _context.t3 = [];
	                    _context.t4 = {
	                      preset: _context.t2,
	                      pass: _context.t3
	                    };

	                    _context.t0.push.call(_context.t0, _context.t4);

	                    _context.next = 21;
	                    break;

	                  case 15:
	                    _context.t5 = presets;
	                    return _context.delegateYield(loadPresetDescriptor(descriptor, presetContext), "t6", 17);

	                  case 17:
	                    _context.t7 = _context.t6;
	                    _context.t8 = pluginDescriptorsPass;
	                    _context.t9 = {
	                      preset: _context.t7,
	                      pass: _context.t8
	                    };

	                    _context.t5.unshift.call(_context.t5, _context.t9);

	                  case 21:
	                    _context.next = 27;
	                    break;

	                  case 23:
	                    _context.prev = 23;
	                    _context.t10 = _context["catch"](5);

	                    if (_context.t10.code === "BABEL_UNKNOWN_OPTION") {
	                      checkNoUnwrappedItemOptionPairs(rawPresets, i, "preset", _context.t10);
	                    }

	                    throw _context.t10;

	                  case 27:
	                    i++;
	                    _context.next = 2;
	                    break;

	                  case 30:
	                    if (!(presets.length > 0)) {
	                      _context.next = 45;
	                      break;
	                    }

	                    pluginDescriptorsByPass.splice.apply(pluginDescriptorsByPass, [1, 0].concat(_toConsumableArray(presets.map(function (o) {
	                      return o.pass;
	                    }).filter(function (p) {
	                      return p !== pluginDescriptorsPass;
	                    }))));
	                    _iterator = _createForOfIteratorHelperLoose(presets);

	                  case 33:
	                    if ((_step = _iterator()).done) {
	                      _context.next = 45;
	                      break;
	                    }

	                    _step$value = _step.value, preset = _step$value.preset, pass = _step$value.pass;

	                    if (preset) {
	                      _context.next = 37;
	                      break;
	                    }

	                    return _context.abrupt("return", true);

	                  case 37:
	                    pass.push.apply(pass, _toConsumableArray(preset.plugins));
	                    return _context.delegateYield(recursePresetDescriptors(preset.presets, pass), "t11", 39);

	                  case 39:
	                    _ignored = _context.t11;

	                    if (!_ignored) {
	                      _context.next = 42;
	                      break;
	                    }

	                    return _context.abrupt("return", true);

	                  case 42:
	                    preset.options.forEach(function (opts) {
	                      mergeOptions(optionDefaults, opts);
	                    });

	                  case 43:
	                    _context.next = 33;
	                    break;

	                  case 45:
	                  case "end":
	                    return _context.stop();
	                }
	              }
	            }, recursePresetDescriptors, null, [[5, 23]]);
	          }))(presetsDescriptors, pluginDescriptorsByPass[0]), "t1", 18);

	        case 18:
	          ignored = _context3.t1;

	          if (!ignored) {
	            _context3.next = 21;
	            break;
	          }

	          return _context3.abrupt("return", null);

	        case 21:
	          opts = optionDefaults;
	          mergeOptions(opts, options);
	          pluginContext = Object.assign({}, presetContext, {
	            assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
	          });
	          return _context3.delegateYield(enhanceError(context, regenerator.mark(function loadPluginDescriptors() {
	            var _pluginDescriptorsByP;

	            var _iterator2, _step2, descs, pass, i, descriptor;

	            return regenerator.wrap(function loadPluginDescriptors$(_context2) {
	              while (1) {
	                switch (_context2.prev = _context2.next) {
	                  case 0:
	                    (_pluginDescriptorsByP = pluginDescriptorsByPass[0]).unshift.apply(_pluginDescriptorsByP, _toConsumableArray(initialPluginsDescriptors));

	                    _iterator2 = _createForOfIteratorHelperLoose(pluginDescriptorsByPass);

	                  case 2:
	                    if ((_step2 = _iterator2()).done) {
	                      _context2.next = 26;
	                      break;
	                    }

	                    descs = _step2.value;
	                    pass = [];
	                    passes.push(pass);
	                    i = 0;

	                  case 7:
	                    if (!(i < descs.length)) {
	                      _context2.next = 24;
	                      break;
	                    }

	                    descriptor = descs[i];

	                    if (!(descriptor.options !== false)) {
	                      _context2.next = 21;
	                      break;
	                    }

	                    _context2.prev = 10;
	                    _context2.t0 = pass;
	                    return _context2.delegateYield(loadPluginDescriptor(descriptor, pluginContext), "t1", 13);

	                  case 13:
	                    _context2.t2 = _context2.t1;

	                    _context2.t0.push.call(_context2.t0, _context2.t2);

	                    _context2.next = 21;
	                    break;

	                  case 17:
	                    _context2.prev = 17;
	                    _context2.t3 = _context2["catch"](10);

	                    if (_context2.t3.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
	                      checkNoUnwrappedItemOptionPairs(descs, i, "plugin", _context2.t3);
	                    }

	                    throw _context2.t3;

	                  case 21:
	                    i++;
	                    _context2.next = 7;
	                    break;

	                  case 24:
	                    _context2.next = 2;
	                    break;

	                  case 26:
	                  case "end":
	                    return _context2.stop();
	                }
	              }
	            }, loadPluginDescriptors, null, [[10, 17]]);
	          }))(), "t2", 25);

	        case 25:
	          opts.plugins = passes[0];
	          opts.presets = passes.slice(1).filter(function (plugins) {
	            return plugins.length > 0;
	          }).map(function (plugins) {
	            return {
	              plugins: plugins
	            };
	          });
	          opts.passPerPreset = opts.presets.length > 0;
	          return _context3.abrupt("return", {
	            options: opts,
	            passes: passes
	          });

	        case 29:
	        case "end":
	          return _context3.stop();
	      }
	    }
	  }, loadFullConfig);
	}));

	function enhanceError(context, fn) {
	  return regenerator.mark(function _callee(arg1, arg2) {
	    return regenerator.wrap(function _callee$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.prev = 0;
	            return _context4.delegateYield(fn(arg1, arg2), "t0", 2);

	          case 2:
	            return _context4.abrupt("return", _context4.t0);

	          case 5:
	            _context4.prev = 5;
	            _context4.t1 = _context4["catch"](0);

	            if (!/^\[BABEL\]/.test(_context4.t1.message)) {
	              _context4.t1.message = "[BABEL] " + (context.filename || "unknown") + ": " + _context4.t1.message;
	            }

	            throw _context4.t1;

	          case 9:
	          case "end":
	            return _context4.stop();
	        }
	      }
	    }, _callee, null, [[0, 5]]);
	  });
	}

	var makeDescriptorLoader = function makeDescriptorLoader(apiFactory) {
	  return makeWeakCache(regenerator.mark(function _callee2(_ref, cache) {
	    var value, options, dirname, alias, item, factory, api;
	    return regenerator.wrap(function _callee2$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            value = _ref.value, options = _ref.options, dirname = _ref.dirname, alias = _ref.alias;

	            if (!(options === false)) {
	              _context5.next = 3;
	              break;
	            }

	            throw new Error("Assertion failure");

	          case 3:
	            options = options || {};
	            item = value;

	            if (!(typeof value === "function")) {
	              _context5.next = 17;
	              break;
	            }

	            factory = maybeAsync(value, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
	            api = Object.assign({}, babel, apiFactory(cache));
	            _context5.prev = 8;
	            return _context5.delegateYield(factory(api, options, dirname), "t0", 10);

	          case 10:
	            item = _context5.t0;
	            _context5.next = 17;
	            break;

	          case 13:
	            _context5.prev = 13;
	            _context5.t1 = _context5["catch"](8);

	            if (alias) {
	              _context5.t1.message += " (While processing: " + JSON.stringify(alias) + ")";
	            }

	            throw _context5.t1;

	          case 17:
	            if (!(!item || typeof item !== "object")) {
	              _context5.next = 19;
	              break;
	            }

	            throw new Error("Plugin/Preset did not return an object.");

	          case 19:
	            if (!isThenable$1(item)) {
	              _context5.next = 22;
	              break;
	            }

	            return _context5.delegateYield([], "t2", 21);

	          case 21:
	            throw new Error("You appear to be using a promise as a plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version. " + "As an alternative, you can prefix the promise with \"await\". " + ("(While processing: " + JSON.stringify(alias) + ")"));

	          case 22:
	            return _context5.abrupt("return", {
	              value: item,
	              options: options,
	              dirname: dirname,
	              alias: alias
	            });

	          case 23:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee2, null, [[8, 13]]);
	  }));
	};

	var pluginDescriptorLoader = makeDescriptorLoader(makePluginAPI);
	var presetDescriptorLoader = makeDescriptorLoader(makePresetAPI);

	function loadPluginDescriptor(descriptor, context) {
	  return regenerator.wrap(function loadPluginDescriptor$(_context6) {
	    while (1) {
	      switch (_context6.prev = _context6.next) {
	        case 0:
	          if (!(descriptor.value instanceof Plugin$1)) {
	            _context6.next = 4;
	            break;
	          }

	          if (!descriptor.options) {
	            _context6.next = 3;
	            break;
	          }

	          throw new Error("Passed options to an existing Plugin instance will not work.");

	        case 3:
	          return _context6.abrupt("return", descriptor.value);

	        case 4:
	          _context6.t0 = instantiatePlugin;
	          return _context6.delegateYield(pluginDescriptorLoader(descriptor, context), "t1", 6);

	        case 6:
	          _context6.t2 = _context6.t1;
	          _context6.t3 = context;
	          return _context6.delegateYield((0, _context6.t0)(_context6.t2, _context6.t3), "t4", 9);

	        case 9:
	          return _context6.abrupt("return", _context6.t4);

	        case 10:
	        case "end":
	          return _context6.stop();
	      }
	    }
	  }, _marked$3);
	}

	var instantiatePlugin = makeWeakCache(regenerator.mark(function _callee3(_ref2, cache) {
	  var value, options, dirname, alias, pluginObj, plugin, inheritsDescriptor, inherits;
	  return regenerator.wrap(function _callee3$(_context7) {
	    while (1) {
	      switch (_context7.prev = _context7.next) {
	        case 0:
	          value = _ref2.value, options = _ref2.options, dirname = _ref2.dirname, alias = _ref2.alias;
	          pluginObj = validatePluginObject(value);
	          plugin = Object.assign({}, pluginObj);

	          if (plugin.visitor) {
	            plugin.visitor = traverse.explode(Object.assign({}, plugin.visitor));
	          }

	          if (!plugin.inherits) {
	            _context7.next = 12;
	            break;
	          }

	          inheritsDescriptor = {
	            name: undefined,
	            alias: alias + "$inherits",
	            value: plugin.inherits,
	            options: options,
	            dirname: dirname
	          };
	          return _context7.delegateYield(forwardAsync(loadPluginDescriptor, function (run) {
	            return cache.invalidate(function (data) {
	              return run(inheritsDescriptor, data);
	            });
	          }), "t0", 7);

	        case 7:
	          inherits = _context7.t0;
	          plugin.pre = chain(inherits.pre, plugin.pre);
	          plugin.post = chain(inherits.post, plugin.post);
	          plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
	          plugin.visitor = traverse.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);

	        case 12:
	          return _context7.abrupt("return", new Plugin$1(plugin, options, alias));

	        case 13:
	        case "end":
	          return _context7.stop();
	      }
	    }
	  }, _callee3);
	}));

	var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
	  if (options.test || options.include || options.exclude) {
	    var formattedPresetName = descriptor.name ? "\"" + descriptor.name + "\"" : "/* your preset */";
	    throw new Error(["Preset " + formattedPresetName + " requires a filename to be set when babel is called directly,", "```", "babel.transform(code, { filename: 'file.ts', presets: [" + formattedPresetName + "] });", "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
	  }
	};

	var validatePreset = function validatePreset(preset, context, descriptor) {
	  if (!context.filename) {
	    var options = preset.options;
	    validateIfOptionNeedsFilename(options, descriptor);

	    if (options.overrides) {
	      options.overrides.forEach(function (overrideOptions) {
	        return validateIfOptionNeedsFilename(overrideOptions, descriptor);
	      });
	    }
	  }
	};

	function loadPresetDescriptor(descriptor, context) {
	  var preset;
	  return regenerator.wrap(function loadPresetDescriptor$(_context8) {
	    while (1) {
	      switch (_context8.prev = _context8.next) {
	        case 0:
	          _context8.t0 = instantiatePreset;
	          return _context8.delegateYield(presetDescriptorLoader(descriptor, context), "t1", 2);

	        case 2:
	          _context8.t2 = _context8.t1;
	          preset = (0, _context8.t0)(_context8.t2);
	          validatePreset(preset, context, descriptor);
	          return _context8.delegateYield(buildPresetChain(preset, context), "t3", 6);

	        case 6:
	          return _context8.abrupt("return", _context8.t3);

	        case 7:
	        case "end":
	          return _context8.stop();
	      }
	    }
	  }, _marked2$1);
	}

	var instantiatePreset = makeWeakCacheSync(function (_ref3) {
	  var value = _ref3.value,
	      dirname = _ref3.dirname,
	      alias = _ref3.alias;
	  return {
	    options: validate("preset", value),
	    alias: alias,
	    dirname: dirname
	  };
	});

	function chain(a, b) {
	  var fns = [a, b].filter(Boolean);
	  if (fns.length <= 1) return fns[0];
	  return function () {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
	      var fn = _step3.value;
	      fn.apply(this, args);
	    }
	  };
	}

	var loadOptionsRunner = gensync(regenerator.mark(function _callee(opts) {
	  var _config$options;

	  var config;
	  return regenerator.wrap(function _callee$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(loadConfig(opts), "t0", 1);

	        case 1:
	          config = _context.t0;
	          return _context.abrupt("return", (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null);

	        case 3:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _callee);
	}));
	var createConfigItemRunner = gensync(createConfigItem$1);

	var maybeErrback = function maybeErrback(runner) {
	  return function (opts, callback) {
	    if (callback === undefined && typeof opts === "function") {
	      callback = opts;
	      opts = undefined;
	    }

	    return callback ? runner.errback(opts, callback) : runner.sync(opts);
	  };
	};

	var loadPartialConfig = maybeErrback(loadPartialConfig$1);
	var loadPartialConfigSync = loadPartialConfig$1.sync;
	var loadPartialConfigAsync = loadPartialConfig$1.async;
	var loadOptions = maybeErrback(loadOptionsRunner);
	var loadOptionsSync = loadOptionsRunner.sync;
	var loadOptionsAsync = loadOptionsRunner.async;
	var createConfigItemSync = createConfigItemRunner.sync;
	var createConfigItemAsync = createConfigItemRunner.async;
	function createConfigItem(target, options, callback) {
	  if (callback !== undefined) {
	    return createConfigItemRunner.errback(target, options, callback);
	  } else if (typeof options === "function") {
	    return createConfigItemRunner.errback(target, undefined, callback);
	  } else {
	    return createConfigItemRunner.sync(target, options);
	  }
	}

	var PluginPass = function () {
	  function PluginPass(file, key, options) {
	    this._map = new Map();
	    this.key = void 0;
	    this.file = void 0;
	    this.opts = void 0;
	    this.cwd = void 0;
	    this.filename = void 0;
	    this.key = key;
	    this.file = file;
	    this.opts = options || {};
	    this.cwd = file.opts.cwd;
	    this.filename = file.opts.filename;
	  }

	  var _proto = PluginPass.prototype;

	  _proto.set = function set(key, val) {
	    this._map.set(key, val);
	  };

	  _proto.get = function get(key) {
	    return this._map.get(key);
	  };

	  _proto.availableHelper = function availableHelper(name, versionRange) {
	    return this.file.availableHelper(name, versionRange);
	  };

	  _proto.addHelper = function addHelper(name) {
	    return this.file.addHelper(name);
	  };

	  _proto.addImport = function addImport() {
	    return this.file.addImport();
	  };

	  _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, _Error) {
	    return this.file.buildCodeFrameError(node, msg, _Error);
	  };

	  return PluginPass;
	}();
	{
	  PluginPass.prototype.getModuleName = function getModuleName() {
	    return this.file.getModuleName();
	  };
	}

	var LOADED_PLUGIN;
	function loadBlockHoistPlugin() {
	  if (!LOADED_PLUGIN) {
	    LOADED_PLUGIN = new Plugin$1(Object.assign({}, blockHoistPlugin, {
	      visitor: traverse.explode(blockHoistPlugin.visitor)
	    }), {});
	  }

	  return LOADED_PLUGIN;
	}

	function priority(bodyNode) {
	  var priority = bodyNode == null ? void 0 : bodyNode._blockHoist;
	  if (priority == null) return 1;
	  if (priority === true) return 2;
	  return priority;
	}

	function stableSort(body) {
	  var buckets = Object.create(null);

	  for (var i = 0; i < body.length; i++) {
	    var n = body[i];
	    var p = priority(n);
	    var bucket = buckets[p] || (buckets[p] = []);
	    bucket.push(n);
	  }

	  var keys = Object.keys(buckets).map(function (k) {
	    return +k;
	  }).sort(function (a, b) {
	    return b - a;
	  });
	  var index = 0;

	  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
	    var key = _step.value;
	    var _bucket = buckets[key];

	    for (var _iterator2 = _createForOfIteratorHelperLoose(_bucket), _step2; !(_step2 = _iterator2()).done;) {
	      var _n = _step2.value;
	      body[index++] = _n;
	    }
	  }

	  return body;
	}

	var blockHoistPlugin = {
	  name: "internal.blockHoist",
	  visitor: {
	    Block: {
	      exit: function exit(_ref) {
	        var node = _ref.node;
	        var body = node.body;
	        var max = Math.pow(2, 30) - 1;
	        var hasChange = false;

	        for (var i = 0; i < body.length; i++) {
	          var n = body[i];
	          var p = priority(n);

	          if (p > max) {
	            hasChange = true;
	            break;
	          }

	          max = p;
	        }

	        if (!hasChange) return;
	        node.body = stableSort(body.slice());
	      }
	    }
	  }
	};

	function normalizeOptions$4(config) {
	  var _config$options = config.options,
	      filename = _config$options.filename,
	      cwd = _config$options.cwd,
	      _config$options$filen = _config$options.filenameRelative,
	      filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? path$1.relative(cwd, filename) : "unknown" : _config$options$filen,
	      _config$options$sourc = _config$options.sourceType,
	      sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
	      inputSourceMap = _config$options.inputSourceMap,
	      _config$options$sourc2 = _config$options.sourceMaps,
	      sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
	      _config$options$sourc3 = _config$options.sourceRoot,
	      sourceRoot = _config$options$sourc3 === void 0 ? config.options.moduleRoot : _config$options$sourc3,
	      _config$options$sourc4 = _config$options.sourceFileName,
	      sourceFileName = _config$options$sourc4 === void 0 ? path$1.basename(filenameRelative) : _config$options$sourc4,
	      _config$options$comme = _config$options.comments,
	      comments = _config$options$comme === void 0 ? true : _config$options$comme,
	      _config$options$compa = _config$options.compact,
	      compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
	  var opts = config.options;
	  var options = Object.assign({}, opts, {
	    parserOpts: Object.assign({
	      sourceType: path$1.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
	      sourceFileName: filename,
	      plugins: []
	    }, opts.parserOpts),
	    generatorOpts: Object.assign({
	      filename: filename,
	      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
	      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
	      retainLines: opts.retainLines,
	      comments: comments,
	      shouldPrintComment: opts.shouldPrintComment,
	      compact: compact,
	      minified: opts.minified,
	      sourceMaps: sourceMaps,
	      sourceRoot: sourceRoot,
	      sourceFileName: sourceFileName
	    }, opts.generatorOpts)
	  });

	  for (var _iterator = _createForOfIteratorHelperLoose(config.passes), _step; !(_step = _iterator()).done;) {
	    var plugins = _step.value;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
	      var plugin = _step2.value;

	      if (plugin.manipulateOptions) {
	        plugin.manipulateOptions(options, options.parserOpts);
	      }
	    }
	  }

	  return options;
	}

	var fs = {};

	var safeBuffer = createCommonjsModule(function (module, exports) {
	  var Buffer = buffer.Buffer;

	  function copyProps(src, dst) {
	    for (var key in src) {
	      dst[key] = src[key];
	    }
	  }

	  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	    module.exports = buffer;
	  } else {
	    copyProps(buffer, exports);
	    exports.Buffer = SafeBuffer;
	  }

	  function SafeBuffer(arg, encodingOrOffset, length) {
	    return Buffer(arg, encodingOrOffset, length);
	  }

	  copyProps(Buffer, SafeBuffer);

	  SafeBuffer.from = function (arg, encodingOrOffset, length) {
	    if (typeof arg === 'number') {
	      throw new TypeError('Argument must not be a number');
	    }

	    return Buffer(arg, encodingOrOffset, length);
	  };

	  SafeBuffer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('Argument must be a number');
	    }

	    var buf = Buffer(size);

	    if (fill !== undefined) {
	      if (typeof encoding === 'string') {
	        buf.fill(fill, encoding);
	      } else {
	        buf.fill(fill);
	      }
	    } else {
	      buf.fill(0);
	    }

	    return buf;
	  };

	  SafeBuffer.allocUnsafe = function (size) {
	    if (typeof size !== 'number') {
	      throw new TypeError('Argument must be a number');
	    }

	    return Buffer(size);
	  };

	  SafeBuffer.allocUnsafeSlow = function (size) {
	    if (typeof size !== 'number') {
	      throw new TypeError('Argument must be a number');
	    }

	    return buffer.SlowBuffer(size);
	  };
	}, "/$$rollup_base$$/node_modules/convert-source-map/node_modules/safe-buffer");

	var path = /*@__PURE__*/getAugmentedNamespace(path$2);

	var convertSourceMap = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, 'commentRegex', {
	    get: function getCommentRegex() {
	      return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
	    }
	  });
	  Object.defineProperty(exports, 'mapFileCommentRegex', {
	    get: function getMapFileCommentRegex() {
	      return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
	    }
	  });

	  function decodeBase64(base64) {
	    return safeBuffer.Buffer.from(base64, 'base64').toString();
	  }

	  function stripComment(sm) {
	    return sm.split(',').pop();
	  }

	  function readFromFileMap(sm, dir) {
	    var r = exports.mapFileCommentRegex.exec(sm);
	    var filename = r[1] || r[2];
	    var filepath = path.resolve(dir, filename);

	    try {
	      return fs$1.readFileSync(filepath, 'utf8');
	    } catch (e) {
	      throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
	    }
	  }

	  function Converter(sm, opts) {
	    opts = opts || {};
	    if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
	    if (opts.hasComment) sm = stripComment(sm);
	    if (opts.isEncoded) sm = decodeBase64(sm);
	    if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
	    this.sourcemap = sm;
	  }

	  Converter.prototype.toJSON = function (space) {
	    return JSON.stringify(this.sourcemap, null, space);
	  };

	  Converter.prototype.toBase64 = function () {
	    var json = this.toJSON();
	    return safeBuffer.Buffer.from(json, 'utf8').toString('base64');
	  };

	  Converter.prototype.toComment = function (options) {
	    var base64 = this.toBase64();
	    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
	    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
	  };

	  Converter.prototype.toObject = function () {
	    return JSON.parse(this.toJSON());
	  };

	  Converter.prototype.addProperty = function (key, value) {
	    if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
	    return this.setProperty(key, value);
	  };

	  Converter.prototype.setProperty = function (key, value) {
	    this.sourcemap[key] = value;
	    return this;
	  };

	  Converter.prototype.getProperty = function (key) {
	    return this.sourcemap[key];
	  };

	  exports.fromObject = function (obj) {
	    return new Converter(obj);
	  };

	  exports.fromJSON = function (json) {
	    return new Converter(json, {
	      isJSON: true
	    });
	  };

	  exports.fromBase64 = function (base64) {
	    return new Converter(base64, {
	      isEncoded: true
	    });
	  };

	  exports.fromComment = function (comment) {
	    comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
	    return new Converter(comment, {
	      isEncoded: true,
	      hasComment: true
	    });
	  };

	  exports.fromMapFileComment = function (comment, dir) {
	    return new Converter(comment, {
	      commentFileDir: dir,
	      isFileComment: true,
	      isJSON: true
	    });
	  };

	  exports.fromSource = function (content) {
	    var m = content.match(exports.commentRegex);
	    return m ? exports.fromComment(m.pop()) : null;
	  };

	  exports.fromMapFileSource = function (content, dir) {
	    var m = content.match(exports.mapFileCommentRegex);
	    return m ? exports.fromMapFileComment(m.pop(), dir) : null;
	  };

	  exports.removeComments = function (src) {
	    return src.replace(exports.commentRegex, '');
	  };

	  exports.removeMapFileComments = function (src) {
	    return src.replace(exports.mapFileCommentRegex, '');
	  };

	  exports.generateMapFileComment = function (file, options) {
	    var data = 'sourceMappingURL=' + file;
	    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
	  };
	}, "/$$rollup_base$$/node_modules/convert-source-map");

	var pluginNameMap = {
	  asyncDoExpressions: {
	    syntax: {
	      name: "@babel/plugin-syntax-async-do-expressions",
	      url: "https://git.io/JYer8"
	    }
	  },
	  classProperties: {
	    syntax: {
	      name: "@babel/plugin-syntax-class-properties",
	      url: "https://git.io/vb4yQ"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-class-properties",
	      url: "https://git.io/vb4SL"
	    }
	  },
	  classPrivateProperties: {
	    syntax: {
	      name: "@babel/plugin-syntax-class-properties",
	      url: "https://git.io/vb4yQ"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-class-properties",
	      url: "https://git.io/vb4SL"
	    }
	  },
	  classPrivateMethods: {
	    syntax: {
	      name: "@babel/plugin-syntax-class-properties",
	      url: "https://git.io/vb4yQ"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-private-methods",
	      url: "https://git.io/JvpRG"
	    }
	  },
	  classStaticBlock: {
	    syntax: {
	      name: "@babel/plugin-syntax-class-static-block",
	      url: "https://git.io/JTLB6"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-class-static-block",
	      url: "https://git.io/JTLBP"
	    }
	  },
	  decimal: {
	    syntax: {
	      name: "@babel/plugin-syntax-decimal",
	      url: "https://git.io/JfKOH"
	    }
	  },
	  decorators: {
	    syntax: {
	      name: "@babel/plugin-syntax-decorators",
	      url: "https://git.io/vb4y9"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-decorators",
	      url: "https://git.io/vb4ST"
	    }
	  },
	  doExpressions: {
	    syntax: {
	      name: "@babel/plugin-syntax-do-expressions",
	      url: "https://git.io/vb4yh"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-do-expressions",
	      url: "https://git.io/vb4S3"
	    }
	  },
	  dynamicImport: {
	    syntax: {
	      name: "@babel/plugin-syntax-dynamic-import",
	      url: "https://git.io/vb4Sv"
	    }
	  },
	  exportDefaultFrom: {
	    syntax: {
	      name: "@babel/plugin-syntax-export-default-from",
	      url: "https://git.io/vb4SO"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-export-default-from",
	      url: "https://git.io/vb4yH"
	    }
	  },
	  exportNamespaceFrom: {
	    syntax: {
	      name: "@babel/plugin-syntax-export-namespace-from",
	      url: "https://git.io/vb4Sf"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-export-namespace-from",
	      url: "https://git.io/vb4SG"
	    }
	  },
	  flow: {
	    syntax: {
	      name: "@babel/plugin-syntax-flow",
	      url: "https://git.io/vb4yb"
	    },
	    transform: {
	      name: "@babel/preset-flow",
	      url: "https://git.io/JfeDn"
	    }
	  },
	  functionBind: {
	    syntax: {
	      name: "@babel/plugin-syntax-function-bind",
	      url: "https://git.io/vb4y7"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-function-bind",
	      url: "https://git.io/vb4St"
	    }
	  },
	  functionSent: {
	    syntax: {
	      name: "@babel/plugin-syntax-function-sent",
	      url: "https://git.io/vb4yN"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-function-sent",
	      url: "https://git.io/vb4SZ"
	    }
	  },
	  importMeta: {
	    syntax: {
	      name: "@babel/plugin-syntax-import-meta",
	      url: "https://git.io/vbKK6"
	    }
	  },
	  jsx: {
	    syntax: {
	      name: "@babel/plugin-syntax-jsx",
	      url: "https://git.io/vb4yA"
	    },
	    transform: {
	      name: "@babel/preset-react",
	      url: "https://git.io/JfeDR"
	    }
	  },
	  importAssertions: {
	    syntax: {
	      name: "@babel/plugin-syntax-import-assertions",
	      url: "https://git.io/JUbkv"
	    }
	  },
	  moduleStringNames: {
	    syntax: {
	      name: "@babel/plugin-syntax-module-string-names",
	      url: "https://git.io/JTL8G"
	    }
	  },
	  numericSeparator: {
	    syntax: {
	      name: "@babel/plugin-syntax-numeric-separator",
	      url: "https://git.io/vb4Sq"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-numeric-separator",
	      url: "https://git.io/vb4yS"
	    }
	  },
	  optionalChaining: {
	    syntax: {
	      name: "@babel/plugin-syntax-optional-chaining",
	      url: "https://git.io/vb4Sc"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-optional-chaining",
	      url: "https://git.io/vb4Sk"
	    }
	  },
	  pipelineOperator: {
	    syntax: {
	      name: "@babel/plugin-syntax-pipeline-operator",
	      url: "https://git.io/vb4yj"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-pipeline-operator",
	      url: "https://git.io/vb4SU"
	    }
	  },
	  privateIn: {
	    syntax: {
	      name: "@babel/plugin-syntax-private-property-in-object",
	      url: "https://git.io/JfK3q"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-private-property-in-object",
	      url: "https://git.io/JfK3O"
	    }
	  },
	  recordAndTuple: {
	    syntax: {
	      name: "@babel/plugin-syntax-record-and-tuple",
	      url: "https://git.io/JvKp3"
	    }
	  },
	  throwExpressions: {
	    syntax: {
	      name: "@babel/plugin-syntax-throw-expressions",
	      url: "https://git.io/vb4SJ"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-throw-expressions",
	      url: "https://git.io/vb4yF"
	    }
	  },
	  typescript: {
	    syntax: {
	      name: "@babel/plugin-syntax-typescript",
	      url: "https://git.io/vb4SC"
	    },
	    transform: {
	      name: "@babel/preset-typescript",
	      url: "https://git.io/JfeDz"
	    }
	  },
	  asyncGenerators: {
	    syntax: {
	      name: "@babel/plugin-syntax-async-generators",
	      url: "https://git.io/vb4SY"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-async-generator-functions",
	      url: "https://git.io/vb4yp"
	    }
	  },
	  logicalAssignment: {
	    syntax: {
	      name: "@babel/plugin-syntax-logical-assignment-operators",
	      url: "https://git.io/vAlBp"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-logical-assignment-operators",
	      url: "https://git.io/vAlRe"
	    }
	  },
	  nullishCoalescingOperator: {
	    syntax: {
	      name: "@babel/plugin-syntax-nullish-coalescing-operator",
	      url: "https://git.io/vb4yx"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-nullish-coalescing-operator",
	      url: "https://git.io/vb4Se"
	    }
	  },
	  objectRestSpread: {
	    syntax: {
	      name: "@babel/plugin-syntax-object-rest-spread",
	      url: "https://git.io/vb4y5"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-object-rest-spread",
	      url: "https://git.io/vb4Ss"
	    }
	  },
	  optionalCatchBinding: {
	    syntax: {
	      name: "@babel/plugin-syntax-optional-catch-binding",
	      url: "https://git.io/vb4Sn"
	    },
	    transform: {
	      name: "@babel/plugin-proposal-optional-catch-binding",
	      url: "https://git.io/vb4SI"
	    }
	  }
	};
	pluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform;

	var getNameURLCombination = function getNameURLCombination(_ref) {
	  var name = _ref.name,
	      url = _ref.url;
	  return name + " (" + url + ")";
	};

	function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
	  var helpMessage = "Support for the experimental syntax '" + missingPluginName + "' isn't currently enabled " + ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") + codeFrame;
	  var pluginInfo = pluginNameMap[missingPluginName];

	  if (pluginInfo) {
	    var syntaxPlugin = pluginInfo.syntax,
	        transformPlugin = pluginInfo.transform;

	    if (syntaxPlugin) {
	      var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);

	      if (transformPlugin) {
	        var transformPluginInfo = getNameURLCombination(transformPlugin);
	        var sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
	        helpMessage += "\n\nAdd " + transformPluginInfo + " to the '" + sectionType + "' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add " + syntaxPluginInfo + " to the 'plugins' section to enable parsing.";
	      } else {
	        helpMessage += "\n\nAdd " + syntaxPluginInfo + " to the 'plugins' section of your Babel config " + "to enable parsing.";
	      }
	    }
	  }

	  return helpMessage;
	}

	var _marked$2 = regenerator.mark(parser$1);
	function parser$1(pluginPasses, _ref, code) {
	  var parserOpts, _ref$highlightCode, highlightCode, _ref$filename, filename, results, _iterator, _step, plugins, _iterator2, _step2, plugin, parserOverride, ast, loc, missingPlugin, codeFrame;

	  return regenerator.wrap(function parser$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          parserOpts = _ref.parserOpts, _ref$highlightCode = _ref.highlightCode, highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode, _ref$filename = _ref.filename, filename = _ref$filename === void 0 ? "unknown" : _ref$filename;
	          _context.prev = 1;
	          results = [];

	          for (_iterator = _createForOfIteratorHelperLoose(pluginPasses); !(_step = _iterator()).done;) {
	            plugins = _step.value;

	            for (_iterator2 = _createForOfIteratorHelperLoose(plugins); !(_step2 = _iterator2()).done;) {
	              plugin = _step2.value;
	              parserOverride = plugin.parserOverride;

	              if (parserOverride) {
	                ast = parserOverride(code, parserOpts, parse$5);
	                if (ast !== undefined) results.push(ast);
	              }
	            }
	          }

	          if (!(results.length === 0)) {
	            _context.next = 8;
	            break;
	          }

	          return _context.abrupt("return", parse$5(code, parserOpts));

	        case 8:
	          if (!(results.length === 1)) {
	            _context.next = 13;
	            break;
	          }

	          return _context.delegateYield([], "t0", 10);

	        case 10:
	          if (!(typeof results[0].then === "function")) {
	            _context.next = 12;
	            break;
	          }

	          throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

	        case 12:
	          return _context.abrupt("return", results[0]);

	        case 13:
	          throw new Error("More than one plugin attempted to override parsing.");

	        case 16:
	          _context.prev = 16;
	          _context.t1 = _context["catch"](1);

	          if (_context.t1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
	            _context.t1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
	          }

	          loc = _context.t1.loc, missingPlugin = _context.t1.missingPlugin;

	          if (loc) {
	            codeFrame = codeFrameColumns(code, {
	              start: {
	                line: loc.line,
	                column: loc.column + 1
	              }
	            }, {
	              highlightCode: highlightCode
	            });

	            if (missingPlugin) {
	              _context.t1.message = filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
	            } else {
	              _context.t1.message = filename + ": " + _context.t1.message + "\n\n" + codeFrame;
	            }

	            _context.t1.code = "BABEL_PARSE_ERROR";
	          }

	          throw _context.t1;

	        case 22:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$2, null, [[1, 16]]);
	}

	var serialized = "$$ babel internal serialized type" + Math.random();

	function serialize(key, value) {
	  var _ref;

	  if (typeof value !== "bigint") return value;
	  return _ref = {}, _ref[serialized] = "BigInt", _ref.value = value.toString(), _ref;
	}

	function revive(key, value) {
	  if (!value || typeof value !== "object") return value;
	  if (value[serialized] !== "BigInt") return value;
	  return BigInt(value.value);
	}

	function cloneDeep (value) {
	  return JSON.parse(JSON.stringify(value, serialize), revive);
	}

	var _marked$1 = regenerator.mark(normalizeFile);
	var file = file$1,
	    traverseFast = traverseFast$2;
	var debug$1 = browser$3("babel:transform:file");
	var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;
	function normalizeFile(pluginPasses, options, code, ast) {
	  var inputMap, lastComment, _lastComment, match, inputMapContent;

	  return regenerator.wrap(function normalizeFile$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          code = "" + (code || "");

	          if (!ast) {
	            _context.next = 11;
	            break;
	          }

	          if (!(ast.type === "Program")) {
	            _context.next = 6;
	            break;
	          }

	          ast = file(ast, [], []);
	          _context.next = 8;
	          break;

	        case 6:
	          if (!(ast.type !== "File")) {
	            _context.next = 8;
	            break;
	          }

	          throw new Error("AST root must be a Program or File node");

	        case 8:
	          if (options.cloneInputAst) {
	            ast = cloneDeep(ast);
	          }

	          _context.next = 13;
	          break;

	        case 11:
	          return _context.delegateYield(parser$1(pluginPasses, options, code), "t0", 12);

	        case 12:
	          ast = _context.t0;

	        case 13:
	          inputMap = null;

	          if (options.inputSourceMap !== false) {
	            if (typeof options.inputSourceMap === "object") {
	              inputMap = convertSourceMap.fromObject(options.inputSourceMap);
	            }

	            if (!inputMap) {
	              lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

	              if (lastComment) {
	                try {
	                  inputMap = convertSourceMap.fromComment(lastComment);
	                } catch (err) {
	                  debug$1("discarding unknown inline input sourcemap", err);
	                }
	              }
	            }

	            if (!inputMap) {
	              _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

	              if (typeof options.filename === "string" && _lastComment) {
	                try {
	                  match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
	                  inputMapContent = fs.readFileSync(path$1.resolve(path$1.dirname(options.filename), match[1]));

	                  if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
	                    debug$1("skip merging input map > 1 MB");
	                  } else {
	                    inputMap = convertSourceMap.fromJSON(inputMapContent);
	                  }
	                } catch (err) {
	                  debug$1("discarding unknown file input sourcemap", err);
	                }
	              } else if (_lastComment) {
	                debug$1("discarding un-loadable file input sourcemap");
	              }
	            }
	          }

	          return _context.abrupt("return", new File(options, {
	            code: code,
	            ast: ast,
	            inputMap: inputMap
	          }));

	        case 16:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked$1);
	}
	var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
	var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

	function extractCommentsFromList(regex, comments, lastComment) {
	  if (comments) {
	    comments = comments.filter(function (_ref) {
	      var value = _ref.value;

	      if (regex.test(value)) {
	        lastComment = value;
	        return false;
	      }

	      return true;
	    });
	  }

	  return [comments, lastComment];
	}

	function extractComments(regex, ast) {
	  var lastComment = null;
	  traverseFast(ast, function (node) {
	    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

	    var _extractCommentsFromL2 = _slicedToArray$1(_extractCommentsFromL, 2);

	    node.leadingComments = _extractCommentsFromL2[0];
	    lastComment = _extractCommentsFromL2[1];

	    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);

	    var _extractCommentsFromL4 = _slicedToArray$1(_extractCommentsFromL3, 2);

	    node.innerComments = _extractCommentsFromL4[0];
	    lastComment = _extractCommentsFromL4[1];

	    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);

	    var _extractCommentsFromL6 = _slicedToArray$1(_extractCommentsFromL5, 2);

	    node.trailingComments = _extractCommentsFromL6[0];
	    lastComment = _extractCommentsFromL6[1];
	  });
	  return lastComment;
	}

	function mergeSourceMap(inputMap, map) {
	  var input = buildMappingData(inputMap);
	  var output = buildMappingData(map);
	  var mergedGenerator = new sourceMap.SourceMapGenerator();

	  for (var _iterator = _createForOfIteratorHelperLoose(input.sources), _step; !(_step = _iterator()).done;) {
	    var source = _step.value.source;

	    if (typeof source.content === "string") {
	      mergedGenerator.setSourceContent(source.path, source.content);
	    }
	  }

	  if (output.sources.length === 1) {
	    var defaultSource = output.sources[0];
	    var insertedMappings = new Map();
	    eachInputGeneratedRange(input, function (generated, original, source) {
	      eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
	        var key = makeMappingKey(item);
	        if (insertedMappings.has(key)) return;
	        insertedMappings.set(key, item);
	        mergedGenerator.addMapping({
	          source: source.path,
	          original: {
	            line: original.line,
	            column: original.columnStart
	          },
	          generated: {
	            line: item.line,
	            column: item.columnStart
	          },
	          name: original.name
	        });
	      });
	    });

	    for (var _iterator2 = _createForOfIteratorHelperLoose(insertedMappings.values()), _step2; !(_step2 = _iterator2()).done;) {
	      var _item = _step2.value;

	      if (_item.columnEnd === Infinity) {
	        continue;
	      }

	      var clearItem = {
	        line: _item.line,
	        columnStart: _item.columnEnd
	      };
	      var key = makeMappingKey(clearItem);

	      if (insertedMappings.has(key)) {
	        continue;
	      }

	      mergedGenerator.addMapping({
	        generated: {
	          line: clearItem.line,
	          column: clearItem.columnStart
	        }
	      });
	    }
	  }

	  var result = mergedGenerator.toJSON();

	  if (typeof input.sourceRoot === "string") {
	    result.sourceRoot = input.sourceRoot;
	  }

	  return result;
	}

	function makeMappingKey(item) {
	  return item.line + "/" + item.columnStart;
	}

	function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
	  var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);

	  for (var _iterator3 = _createForOfIteratorHelperLoose(overlappingOriginal), _step3; !(_step3 = _iterator3()).done;) {
	    var generated = _step3.value.generated;

	    for (var _iterator4 = _createForOfIteratorHelperLoose(generated), _step4; !(_step4 = _iterator4()).done;) {
	      var _item2 = _step4.value;
	      callback(_item2);
	    }
	  }
	}

	function filterApplicableOriginalRanges(_ref, _ref2) {
	  var mappings = _ref.mappings;
	  var line = _ref2.line,
	      columnStart = _ref2.columnStart,
	      columnEnd = _ref2.columnEnd;
	  return filterSortedArray(mappings, function (_ref3) {
	    var outOriginal = _ref3.original;
	    if (line > outOriginal.line) return -1;
	    if (line < outOriginal.line) return 1;
	    if (columnStart >= outOriginal.columnEnd) return -1;
	    if (columnEnd <= outOriginal.columnStart) return 1;
	    return 0;
	  });
	}

	function eachInputGeneratedRange(map, callback) {
	  for (var _iterator5 = _createForOfIteratorHelperLoose(map.sources), _step5; !(_step5 = _iterator5()).done;) {
	    var _step5$value = _step5.value,
	        source = _step5$value.source,
	        mappings = _step5$value.mappings;

	    for (var _iterator6 = _createForOfIteratorHelperLoose(mappings), _step6; !(_step6 = _iterator6()).done;) {
	      var _step6$value = _step6.value,
	          original = _step6$value.original,
	          generated = _step6$value.generated;

	      for (var _iterator7 = _createForOfIteratorHelperLoose(generated), _step7; !(_step7 = _iterator7()).done;) {
	        var _item3 = _step7.value;
	        callback(_item3, original, source);
	      }
	    }
	  }
	}

	function buildMappingData(map) {
	  var consumer = new sourceMap.SourceMapConsumer(Object.assign({}, map, {
	    sourceRoot: null
	  }));
	  var sources = new Map();
	  var mappings = new Map();
	  var last = null;
	  consumer.computeColumnSpans();
	  consumer.eachMapping(function (m) {
	    if (m.originalLine === null) return;
	    var source = sources.get(m.source);

	    if (!source) {
	      source = {
	        path: m.source,
	        content: consumer.sourceContentFor(m.source, true)
	      };
	      sources.set(m.source, source);
	    }

	    var sourceData = mappings.get(source);

	    if (!sourceData) {
	      sourceData = {
	        source: source,
	        mappings: []
	      };
	      mappings.set(source, sourceData);
	    }

	    var obj = {
	      line: m.originalLine,
	      columnStart: m.originalColumn,
	      columnEnd: Infinity,
	      name: m.name
	    };

	    if (last && last.source === source && last.mapping.line === m.originalLine) {
	      last.mapping.columnEnd = m.originalColumn;
	    }

	    last = {
	      source: source,
	      mapping: obj
	    };
	    sourceData.mappings.push({
	      original: obj,
	      generated: consumer.allGeneratedPositionsFor({
	        source: m.source,
	        line: m.originalLine,
	        column: m.originalColumn
	      }).map(function (item) {
	        return {
	          line: item.line,
	          columnStart: item.column,
	          columnEnd: item.lastColumn + 1
	        };
	      })
	    });
	  }, null, sourceMap.SourceMapConsumer.ORIGINAL_ORDER);
	  return {
	    file: map.file,
	    sourceRoot: map.sourceRoot,
	    sources: Array.from(mappings.values())
	  };
	}

	function findInsertionLocation(array, callback) {
	  var left = 0;
	  var right = array.length;

	  while (left < right) {
	    var mid = Math.floor((left + right) / 2);
	    var _item4 = array[mid];
	    var result = callback(_item4);

	    if (result === 0) {
	      left = mid;
	      break;
	    }

	    if (result >= 0) {
	      right = mid;
	    } else {
	      left = mid + 1;
	    }
	  }

	  var i = left;

	  if (i < array.length) {
	    while (i >= 0 && callback(array[i]) >= 0) {
	      i--;
	    }

	    return i + 1;
	  }

	  return i;
	}

	function filterSortedArray(array, callback) {
	  var start = findInsertionLocation(array, callback);
	  var results = [];

	  for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
	    results.push(array[i]);
	  }

	  return results;
	}

	function generateCode(pluginPasses, file) {
	  var opts = file.opts,
	      ast = file.ast,
	      code = file.code,
	      inputMap = file.inputMap;
	  var results = [];

	  for (var _iterator = _createForOfIteratorHelperLoose(pluginPasses), _step; !(_step = _iterator()).done;) {
	    var plugins = _step.value;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
	      var plugin = _step2.value;
	      var generatorOverride = plugin.generatorOverride;

	      if (generatorOverride) {
	        var _result2 = generatorOverride(ast, opts.generatorOpts, code, generate$1);

	        if (_result2 !== undefined) results.push(_result2);
	      }
	    }
	  }

	  var result;

	  if (results.length === 0) {
	    result = generate$1(ast, opts.generatorOpts, code);
	  } else if (results.length === 1) {
	    result = results[0];

	    if (typeof result.then === "function") {
	      throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
	    }
	  } else {
	    throw new Error("More than one plugin attempted to override codegen.");
	  }

	  var _result = result,
	      outputCode = _result.code,
	      outputMap = _result.map;

	  if (outputMap && inputMap) {
	    outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
	  }

	  if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
	    outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
	  }

	  if (opts.sourceMaps === "inline") {
	    outputMap = null;
	  }

	  return {
	    outputCode: outputCode,
	    outputMap: outputMap
	  };
	}

	var _marked = regenerator.mark(run$1),
	    _marked2 = regenerator.mark(transformFile$1);
	function run$1(config, code, ast) {
	  var file, opts, _opts$filename, outputCode, outputMap, _generateCode, _opts$filename2;

	  return regenerator.wrap(function run$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(normalizeFile(config.passes, normalizeOptions$4(config), code, ast), "t0", 1);

	        case 1:
	          file = _context.t0;
	          opts = file.opts;
	          _context.prev = 3;
	          return _context.delegateYield(transformFile$1(file, config.passes), "t1", 5);

	        case 5:
	          _context.next = 12;
	          break;

	        case 7:
	          _context.prev = 7;
	          _context.t2 = _context["catch"](3);
	          _context.t2.message = ((_opts$filename = opts.filename) != null ? _opts$filename : "unknown") + ": " + _context.t2.message;

	          if (!_context.t2.code) {
	            _context.t2.code = "BABEL_TRANSFORM_ERROR";
	          }

	          throw _context.t2;

	        case 12:
	          _context.prev = 12;

	          if (opts.code !== false) {
	            _generateCode = generateCode(config.passes, file);
	            outputCode = _generateCode.outputCode;
	            outputMap = _generateCode.outputMap;
	          }

	          _context.next = 21;
	          break;

	        case 16:
	          _context.prev = 16;
	          _context.t3 = _context["catch"](12);
	          _context.t3.message = ((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown") + ": " + _context.t3.message;

	          if (!_context.t3.code) {
	            _context.t3.code = "BABEL_GENERATE_ERROR";
	          }

	          throw _context.t3;

	        case 21:
	          return _context.abrupt("return", {
	            metadata: file.metadata,
	            options: opts,
	            ast: opts.ast === true ? file.ast : null,
	            code: outputCode === undefined ? null : outputCode,
	            map: outputMap === undefined ? null : outputMap,
	            sourceType: file.ast.program.sourceType
	          });

	        case 22:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked, null, [[3, 7], [12, 16]]);
	}

	function transformFile$1(file, pluginPasses) {
	  var _iterator, _step, pluginPairs, passPairs, passes, visitors, _iterator2, _step2, _plugin2, _pass2, _i, _passPairs, _passPairs$_i, plugin, pass, fn, result, visitor, _i2, _passPairs2, _passPairs2$_i, _plugin, _pass, _fn, _result;

	  return regenerator.wrap(function transformFile$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _iterator = _createForOfIteratorHelperLoose(pluginPasses);

	        case 1:
	          if ((_step = _iterator()).done) {
	            _context2.next = 35;
	            break;
	          }

	          pluginPairs = _step.value;
	          passPairs = [];
	          passes = [];
	          visitors = [];

	          for (_iterator2 = _createForOfIteratorHelperLoose(pluginPairs.concat([loadBlockHoistPlugin()])); !(_step2 = _iterator2()).done;) {
	            _plugin2 = _step2.value;
	            _pass2 = new PluginPass(file, _plugin2.key, _plugin2.options);
	            passPairs.push([_plugin2, _pass2]);
	            passes.push(_pass2);
	            visitors.push(_plugin2.visitor);
	          }

	          _i = 0, _passPairs = passPairs;

	        case 8:
	          if (!(_i < _passPairs.length)) {
	            _context2.next = 19;
	            break;
	          }

	          _passPairs$_i = _slicedToArray$1(_passPairs[_i], 2), plugin = _passPairs$_i[0], pass = _passPairs$_i[1];
	          fn = plugin.pre;

	          if (!fn) {
	            _context2.next = 16;
	            break;
	          }

	          result = fn.call(pass, file);
	          return _context2.delegateYield([], "t0", 14);

	        case 14:
	          if (!isThenable(result)) {
	            _context2.next = 16;
	            break;
	          }

	          throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

	        case 16:
	          _i++;
	          _context2.next = 8;
	          break;

	        case 19:
	          visitor = traverse.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
	          traverse(file.ast, visitor, file.scope);
	          _i2 = 0, _passPairs2 = passPairs;

	        case 22:
	          if (!(_i2 < _passPairs2.length)) {
	            _context2.next = 33;
	            break;
	          }

	          _passPairs2$_i = _slicedToArray$1(_passPairs2[_i2], 2), _plugin = _passPairs2$_i[0], _pass = _passPairs2$_i[1];
	          _fn = _plugin.post;

	          if (!_fn) {
	            _context2.next = 30;
	            break;
	          }

	          _result = _fn.call(_pass, file);
	          return _context2.delegateYield([], "t1", 28);

	        case 28:
	          if (!isThenable(_result)) {
	            _context2.next = 30;
	            break;
	          }

	          throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

	        case 30:
	          _i2++;
	          _context2.next = 22;
	          break;

	        case 33:
	          _context2.next = 1;
	          break;

	        case 35:
	        case "end":
	          return _context2.stop();
	      }
	    }
	  }, _marked2);
	}

	function isThenable(val) {
	  return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
	}

	var transformRunner = gensync(regenerator.mark(function transform(code, opts) {
	  var config;
	  return regenerator.wrap(function transform$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(loadConfig(opts), "t0", 1);

	        case 1:
	          config = _context.t0;

	          if (!(config === null)) {
	            _context.next = 4;
	            break;
	          }

	          return _context.abrupt("return", null);

	        case 4:
	          return _context.delegateYield(run$1(config, code), "t1", 5);

	        case 5:
	          return _context.abrupt("return", _context.t1);

	        case 6:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, transform);
	}));
	var transform$2 = function transform(code, opts, callback) {
	  if (typeof opts === "function") {
	    callback = opts;
	    opts = undefined;
	  }

	  if (callback === undefined) return transformRunner.sync(code, opts);
	  transformRunner.errback(code, opts, callback);
	};
	var transformSync = transformRunner.sync;
	var transformAsync = transformRunner.async;

	var transformFile = function transformFile(filename, opts, callback) {
	  if (typeof opts === "function") {
	    callback = opts;
	  }

	  callback(new Error("Transforming files is not supported in browsers"), null);
	};
	function transformFileSync() {
	  throw new Error("Transforming files is not supported in browsers");
	}
	function transformFileAsync() {
	  return Promise.reject(new Error("Transforming files is not supported in browsers"));
	}

	var transformFromAstRunner = gensync(regenerator.mark(function _callee(ast, code, opts) {
	  var config;
	  return regenerator.wrap(function _callee$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(loadConfig(opts), "t0", 1);

	        case 1:
	          config = _context.t0;

	          if (!(config === null)) {
	            _context.next = 4;
	            break;
	          }

	          return _context.abrupt("return", null);

	        case 4:
	          if (ast) {
	            _context.next = 6;
	            break;
	          }

	          throw new Error("No AST given");

	        case 6:
	          return _context.delegateYield(run$1(config, code, ast), "t1", 7);

	        case 7:
	          return _context.abrupt("return", _context.t1);

	        case 8:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _callee);
	}));
	var transformFromAst$1 = function transformFromAst(ast, code, opts, callback) {
	  if (typeof opts === "function") {
	    callback = opts;
	    opts = undefined;
	  }

	  if (callback === undefined) {
	    return transformFromAstRunner.sync(ast, code, opts);
	  }

	  transformFromAstRunner.errback(ast, code, opts, callback);
	};
	var transformFromAstSync = transformFromAstRunner.sync;
	var transformFromAstAsync = transformFromAstRunner.async;

	var parseRunner = gensync(regenerator.mark(function parse(code, opts) {
	  var config;
	  return regenerator.wrap(function parse$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          return _context.delegateYield(loadConfig(opts), "t0", 1);

	        case 1:
	          config = _context.t0;

	          if (!(config === null)) {
	            _context.next = 4;
	            break;
	          }

	          return _context.abrupt("return", null);

	        case 4:
	          return _context.delegateYield(parser$1(config.passes, normalizeOptions$4(config), code), "t1", 5);

	        case 5:
	          return _context.abrupt("return", _context.t1);

	        case 6:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, parse);
	}));
	var parse$2 = function parse(code, opts, callback) {
	  if (typeof opts === "function") {
	    callback = opts;
	    opts = undefined;
	  }

	  if (callback === undefined) return parseRunner.sync(code, opts);
	  parseRunner.errback(code, opts, callback);
	};
	var parseSync = parseRunner.sync;
	var parseAsync = parseRunner.async;

	var version$3 = "7.16.5";
	var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
	var OptionManager = function () {
	  function OptionManager() {}

	  var _proto = OptionManager.prototype;

	  _proto.init = function init(opts) {
	    return loadOptions(opts);
	  };

	  return OptionManager;
	}();
	function Plugin(alias) {
	  throw new Error("The (" + alias + ") Babel 5 plugin is being run with an unsupported Babel version.");
	}

	function declare(builder) {
	  return function (api, options, dirname) {
	    var _clonedApi2;

	    var clonedApi;

	    for (var _i = 0, _Object$keys = Object.keys(apiPolyfills); _i < _Object$keys.length; _i++) {
	      var _clonedApi;

	      var name = _Object$keys[_i];
	      if (api[name]) continue;
	      clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api);
	      clonedApi[name] = apiPolyfills[name](clonedApi);
	    }

	    return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
	  };
	}
	var apiPolyfills = {
	  assertVersion: function assertVersion(api) {
	    return function (range) {
	      throwVersionError(range, api.version);
	    };
	  },
	  targets: function targets() {
	    return function () {
	      return {};
	    };
	  },
	  assumption: function assumption() {
	    return function () {};
	  }
	};

	function copyApiObject(api) {
	  var proto = null;

	  if (typeof api.version === "string" && /^7\./.test(api.version)) {
	    proto = Object.getPrototypeOf(api);

	    if (proto && (!has$8(proto, "version") || !has$8(proto, "transform") || !has$8(proto, "template") || !has$8(proto, "types"))) {
	      proto = null;
	    }
	  }

	  return Object.assign({}, proto, api);
	}

	function has$8(obj, key) {
	  return Object.prototype.hasOwnProperty.call(obj, key);
	}

	function throwVersionError(range, version) {
	  if (typeof range === "number") {
	    if (!Number.isInteger(range)) {
	      throw new Error("Expected string or integer value.");
	    }

	    range = "^" + range + ".0.0-0";
	  }

	  if (typeof range !== "string") {
	    throw new Error("Expected string or integer value.");
	  }

	  var limit = Error.stackTraceLimit;

	  if (typeof limit === "number" && limit < 25) {
	    Error.stackTraceLimit = 25;
	  }

	  var err;

	  if (version.slice(0, 2) === "7.") {
	    err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"" + version + "\". " + "You'll need to update your @babel/core version.");
	  } else {
	    err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
	  }

	  if (typeof limit === "number") {
	    Error.stackTraceLimit = limit;
	  }

	  throw Object.assign(err, {
	    code: "BABEL_VERSION_UNSUPPORTED",
	    version: version,
	    range: range
	  });
	}

	var src = /*#__PURE__*/Object.freeze({
		__proto__: null,
		declare: declare
	});

	var externalHelpers = declare(function (api, options) {
	  api.assertVersion(7);
	  var _options$helperVersio = options.helperVersion,
	      helperVersion = _options$helperVersio === void 0 ? "7.0.0-beta.0" : _options$helperVersio,
	      _options$whitelist = options.whitelist,
	      whitelist = _options$whitelist === void 0 ? false : _options$whitelist;

	  if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(function (w) {
	    return typeof w !== "string";
	  }))) {
	    throw new Error(".whitelist must be undefined, false, or an array of strings");
	  }

	  var helperWhitelist = whitelist ? new Set(whitelist) : null;
	  return {
	    name: "external-helpers",
	    pre: function pre(file) {
	      file.set("helperGenerator", function (name) {
	        if (file.availableHelper && !file.availableHelper(name, helperVersion)) {
	          return;
	        }

	        if (helperWhitelist && !helperWhitelist.has(name)) return;
	        return memberExpression$b(identifier$j("babelHelpers"), identifier$j(name));
	      });
	    }
	  };
	});

	var _helperPluginUtils = /*@__PURE__*/getAugmentedNamespace(src);

	var lib$x = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-async-generators",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("asyncGenerators");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-async-generators/lib");

	var lib$w = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-class-properties",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-class-properties/lib");

	var lib$v = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-class-static-block",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("classStaticBlock");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-class-static-block/lib");

	var syntaxDecimal = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-decimal",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("decimal");
	    }
	  };
	});

	var syntaxDecorators = declare(function (api, options) {
	  api.assertVersion(7);
	  var _options$legacy = options.legacy,
	      legacy = _options$legacy === void 0 ? false : _options$legacy;

	  if (typeof legacy !== "boolean") {
	    throw new Error("'legacy' must be a boolean.");
	  }

	  var decoratorsBeforeExport = options.decoratorsBeforeExport;

	  if (decoratorsBeforeExport === undefined) {
	    if (!legacy) {
	      throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a" + " 'decoratorsBeforeExport' option, whose value must be a boolean." + " If you want to use the legacy decorators semantics, you can set" + " the 'legacy: true' option.");
	    }
	  } else {
	    if (legacy) {
	      throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
	    }

	    if (typeof decoratorsBeforeExport !== "boolean") {
	      throw new Error("'decoratorsBeforeExport' must be a boolean.");
	    }
	  }

	  return {
	    name: "syntax-decorators",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", {
	        decoratorsBeforeExport: decoratorsBeforeExport
	      }]);
	    }
	  };
	});

	var syntaxDoExpressions = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-do-expressions",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("doExpressions");
	    }
	  };
	});

	var syntaxExportDefaultFrom = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-export-default-from",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("exportDefaultFrom");
	    }
	  };
	});

	var syntaxFlow = declare(function (api, options) {
	  api.assertVersion(7);
	  var all = options.all,
	      enums = options.enums;

	  if (typeof all !== "boolean" && typeof all !== "undefined") {
	    throw new Error(".all must be a boolean, or undefined");
	  }

	  if (typeof enums !== "boolean" && typeof enums !== "undefined") {
	    throw new Error(".enums must be a boolean, or undefined");
	  }

	  return {
	    name: "syntax-flow",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      if (parserOpts.plugins.some(function (p) {
	        return (Array.isArray(p) ? p[0] : p) === "typescript";
	      })) {
	        return;
	      }

	      parserOpts.plugins.push(["flow", {
	        all: all,
	        enums: enums
	      }]);
	    }
	  };
	});

	var syntaxFunctionBind = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-function-bind",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("functionBind");
	    }
	  };
	});

	var syntaxFunctionSent = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-function-sent",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("functionSent");
	    }
	  };
	});

	var syntaxModuleBlocks = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-module-blocks",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("moduleBlocks");
	    }
	  };
	});

	var lib$u = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-import-meta",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("importMeta");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-import-meta/lib");

	var syntaxJsx = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-jsx",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      if (parserOpts.plugins.some(function (p) {
	        return (Array.isArray(p) ? p[0] : p) === "typescript";
	      })) {
	        return;
	      }

	      parserOpts.plugins.push("jsx");
	    }
	  };
	});

	var syntaxImportAssertions = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-import-assertions",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push(["importAssertions"]);
	    }
	  };
	});

	var lib$t = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-object-rest-spread",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("objectRestSpread");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

	var lib$s = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-optional-catch-binding",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("optionalCatchBinding");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

	var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
	var TOPIC_TOKENS = ["^", "%", "#"];
	var documentationURL = "https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator";
	var syntaxPipelineOperator = declare(function (api, _ref) {
	  var proposal = _ref.proposal,
	      topicToken = _ref.topicToken;
	  api.assertVersion(7);

	  if (typeof proposal !== "string" || !PIPELINE_PROPOSALS.includes(proposal)) {
	    var proposalList = PIPELINE_PROPOSALS.map(function (p) {
	      return "\"" + p + "\"";
	    }).join(", ");
	    throw new Error("The pipeline plugin requires a \"proposal\" option. \"proposal\" must be one of: " + proposalList + ". See <" + documentationURL + ">.");
	  }

	  if (proposal === "hack" && !TOPIC_TOKENS.includes(topicToken)) {
	    var topicTokenList = TOPIC_TOKENS.map(function (t) {
	      return "\"" + t + "\"";
	    }).join(", ");
	    throw new Error("The pipeline plugin in \"proposal\": \"hack\" mode also requires a \"topicToken\" option. \"topicToken\" must be one of: " + topicTokenList + ". See <" + documentationURL + ">.");
	  }

	  return {
	    name: "syntax-pipeline-operator",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push(["pipelineOperator", {
	        proposal: proposal,
	        topicToken: topicToken
	      }]);
	      opts.generatorOpts.topicToken = topicToken;
	    }
	  };
	});

	var syntaxRecordAndTuple = declare(function (api, options) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-record-and-tuple",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      opts.generatorOpts.recordAndTupleSyntaxType = options.syntaxType;
	      parserOpts.plugins.push(["recordAndTuple", {
	        syntaxType: options.syntaxType
	      }]);
	    }
	  };
	});

	var lib$r = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-top-level-await",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("topLevelAwait");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-top-level-await/lib");

	function removePlugin(plugins, name) {
	  var indices = [];
	  plugins.forEach(function (plugin, i) {
	    var n = Array.isArray(plugin) ? plugin[0] : plugin;

	    if (n === name) {
	      indices.unshift(i);
	    }
	  });

	  for (var _i = 0, _indices = indices; _i < _indices.length; _i++) {
	    var i = _indices[_i];
	    plugins.splice(i, 1);
	  }
	}

	var syntaxTypescript = declare(function (api, _ref) {
	  var isTSX = _ref.isTSX,
	      disallowAmbiguousJSXLike = _ref.disallowAmbiguousJSXLike;
	  api.assertVersion(7);
	  return {
	    name: "syntax-typescript",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      var plugins = parserOpts.plugins;
	      removePlugin(plugins, "flow");
	      removePlugin(plugins, "jsx");
	      parserOpts.plugins.push(["typescript", {
	        disallowAmbiguousJSXLike: disallowAmbiguousJSXLike
	      }], "classProperties");
	      {
	        parserOpts.plugins.push("objectRestSpread");
	      }

	      if (isTSX) {
	        parserOpts.plugins.push("jsx");
	      }
	    }
	  };
	});

	var blockStatement = blockStatement$6,
	    callExpression$5 = callExpression$e,
	    functionExpression$1 = functionExpression$3,
	    isAssignmentPattern$1 = isAssignmentPattern$4,
	    isRestElement = isRestElement$2,
	    returnStatement = returnStatement$3;
	var buildAnonymousExpressionWrapper = template$2.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");
	var buildNamedExpressionWrapper = template$2.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");
	var buildDeclarationWrapper = template$2("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

	function classOrObjectMethod(path, callId) {
	  var node = path.node;
	  var body = node.body;
	  var container = functionExpression$1(null, [], blockStatement(body.body), true);
	  body.body = [returnStatement(callExpression$5(callExpression$5(callId, [container]), []))];
	  node.async = false;
	  node.generator = false;
	  path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
	}

	function plainFunction(path, callId, noNewArrows) {
	  var node = path.node;
	  var isDeclaration = path.isFunctionDeclaration();
	  var functionId = node.id;
	  var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

	  if (path.isArrowFunctionExpression()) {
	    path.arrowFunctionToExpression({
	      noNewArrows: noNewArrows
	    });
	  }

	  node.id = null;

	  if (isDeclaration) {
	    node.type = "FunctionExpression";
	  }

	  var built = callExpression$5(callId, [node]);
	  var container = wrapper({
	    NAME: functionId || null,
	    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
	    FUNCTION: built,
	    PARAMS: node.params.reduce(function (acc, param) {
	      acc.done = acc.done || isAssignmentPattern$1(param) || isRestElement(param);

	      if (!acc.done) {
	        acc.params.push(path.scope.generateUidIdentifier("x"));
	      }

	      return acc;
	    }, {
	      params: [],
	      done: false
	    }).params
	  });

	  if (isDeclaration) {
	    path.replaceWith(container[0]);
	    path.insertAfter(container[1]);
	  } else {
	    var retFunction = container.callee.body.body[1].argument;

	    if (!functionId) {
	      nameFunction({
	        node: retFunction,
	        parent: path.parent,
	        scope: path.scope
	      });
	    }

	    if (!retFunction || retFunction.id || node.params.length) {
	      path.replaceWith(container);
	    } else {
	      path.replaceWith(built);
	    }
	  }
	}

	function wrapFunction(path, callId, noNewArrows) {
	  if (noNewArrows === void 0) {
	    noNewArrows = true;
	  }

	  if (path.isMethod()) {
	    classOrObjectMethod(path, callId);
	  } else {
	    plainFunction(path, callId, noNewArrows);
	  }
	}

	var addComment = addComment$2;
	var PURE_ANNOTATION = "#__PURE__";

	var isPureAnnotated = function isPureAnnotated(_ref) {
	  var leadingComments = _ref.leadingComments;
	  return !!leadingComments && leadingComments.some(function (comment) {
	    return /[@#]__PURE__/.test(comment.value);
	  });
	};

	function annotateAsPure(pathOrNode) {
	  var node = pathOrNode["node"] || pathOrNode;

	  if (isPureAnnotated(node)) {
	    return;
	  }

	  addComment(node, "leading", PURE_ANNOTATION);
	}

	var callExpression$4 = callExpression$e,
	    cloneNode$3 = cloneNode$i,
	    isIdentifier$4 = isIdentifier$g,
	    isThisExpression = isThisExpression$2,
	    yieldExpression = yieldExpression$2;
	var awaitVisitor$1 = {
	  Function: function Function(path) {
	    path.skip();
	  },
	  AwaitExpression: function AwaitExpression(path, _ref) {
	    var wrapAwait = _ref.wrapAwait;
	    var argument = path.get("argument");
	    path.replaceWith(yieldExpression(wrapAwait ? callExpression$4(cloneNode$3(wrapAwait), [argument.node]) : argument.node));
	  }
	};
	function remapAsyncToGenerator (path, helpers, noNewArrows) {
	  path.traverse(awaitVisitor$1, {
	    wrapAwait: helpers.wrapAwait
	  });
	  var isIIFE = checkIsIIFE(path);
	  path.node.async = false;
	  path.node.generator = true;
	  wrapFunction(path, cloneNode$3(helpers.wrapAsync), noNewArrows);
	  var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

	  if (!isProperty && !isIIFE && path.isExpression()) {
	    annotateAsPure(path);
	  }

	  function checkIsIIFE(path) {
	    if (path.parentPath.isCallExpression({
	      callee: path.node
	    })) {
	      return true;
	    }

	    var parentPath = path.parentPath;

	    if (parentPath.isMemberExpression() && isIdentifier$4(parentPath.node.property, {
	      name: "bind"
	    })) {
	      var bindCall = parentPath.parentPath;
	      return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
	        callee: bindCall.node
	      });
	    }

	    return false;
	  }
	}

	var lib$q = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-async-generators",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("asyncGenerators");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-async-generator-functions/node_modules/@babel/plugin-syntax-async-generators/lib");

	var buildForAwait = template$2("\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
	function rewriteForAwait (path, _ref) {
	  var getAsyncIterator = _ref.getAsyncIterator;
	  var node = path.node,
	      scope = path.scope,
	      parent = path.parent;
	  var stepKey = scope.generateUidIdentifier("step");
	  var stepValue = memberExpression$b(stepKey, identifier$j("value"));
	  var left = node.left;
	  var declar;

	  if (isIdentifier$g(left) || isPattern(left) || isMemberExpression$8(left)) {
	    declar = expressionStatement$a(assignmentExpression$c("=", left, stepValue));
	  } else if (isVariableDeclaration$3(left)) {
	    declar = variableDeclaration$8(left.kind, [variableDeclarator$8(left.declarations[0].id, stepValue)]);
	  }

	  var template = buildForAwait({
	    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
	    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
	    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
	    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
	    GET_ITERATOR: getAsyncIterator,
	    OBJECT: node.right,
	    STEP_KEY: cloneNode$i(stepKey)
	  });
	  template = template.body.body;
	  var isLabeledParent = isLabeledStatement(parent);
	  var tryBody = template[3].block.body;
	  var loop = tryBody[0];

	  if (isLabeledParent) {
	    tryBody[0] = labeledStatement(parent.label, loop);
	  }

	  return {
	    replaceParent: isLabeledParent,
	    node: template,
	    declar: declar,
	    loop: loop
	  };
	}

	var _proposalAsyncGeneratorFunctions = declare(function (api) {
	  api.assertVersion(7);
	  var yieldStarVisitor = {
	    Function: function Function(path) {
	      path.skip();
	    },
	    YieldExpression: function YieldExpression(_ref, state) {
	      var node = _ref.node;
	      if (!node.delegate) return;
	      var callee = state.addHelper("asyncGeneratorDelegate");
	      node.argument = callExpression$e(callee, [callExpression$e(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
	    }
	  };
	  var forAwaitVisitor = {
	    Function: function Function(path) {
	      path.skip();
	    },
	    ForOfStatement: function ForOfStatement(path, _ref2) {
	      var _block$body;

	      var file = _ref2.file;
	      var node = path.node;
	      if (!node["await"]) return;
	      var build = rewriteForAwait(path, {
	        getAsyncIterator: file.addHelper("asyncIterator")
	      });
	      var declar = build.declar,
	          loop = build.loop;
	      var block = loop.body;
	      path.ensureBlock();

	      if (declar) {
	        block.body.push(declar);
	      }

	      (_block$body = block.body).push.apply(_block$body, _toConsumableArray(node.body.body));

	      inherits$1(loop, node);
	      inherits$1(loop.body, node.body);

	      if (build.replaceParent) {
	        path.parentPath.replaceWithMultiple(build.node);
	      } else {
	        path.replaceWithMultiple(build.node);
	      }
	    }
	  };
	  var visitor = {
	    Function: function Function(path, state) {
	      if (!path.node.async) return;
	      path.traverse(forAwaitVisitor, state);
	      if (!path.node.generator) return;
	      path.traverse(yieldStarVisitor, state);
	      remapAsyncToGenerator(path, {
	        wrapAsync: state.addHelper("wrapAsyncGenerator"),
	        wrapAwait: state.addHelper("awaitAsyncGenerator")
	      });
	    }
	  };
	  return {
	    name: "proposal-async-generator-functions",
	    inherits: lib$q["default"],
	    visitor: {
	      Program: function Program(path, state) {
	        path.traverse(visitor, state);
	      }
	    }
	  };
	});

	function willPathCastToBoolean$1(path) {
	  var maybeWrapped = path;
	  var node = maybeWrapped.node,
	      parentPath = maybeWrapped.parentPath;

	  if (parentPath.isLogicalExpression()) {
	    var _parentPath$node = parentPath.node,
	        operator = _parentPath$node.operator,
	        right = _parentPath$node.right;

	    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
	      return willPathCastToBoolean$1(parentPath);
	    }
	  }

	  if (parentPath.isSequenceExpression()) {
	    var expressions = parentPath.node.expressions;

	    if (expressions[expressions.length - 1] === node) {
	      return willPathCastToBoolean$1(parentPath);
	    } else {
	      return true;
	    }
	  }

	  return parentPath.isConditional({
	    test: node
	  }) || parentPath.isUnaryExpression({
	    operator: "!"
	  }) || parentPath.isLoop({
	    test: node
	  });
	}

	var LOGICAL_OPERATORS = LOGICAL_OPERATORS$2,
	    arrowFunctionExpression = arrowFunctionExpression$4,
	    assignmentExpression$3 = assignmentExpression$c,
	    binaryExpression = binaryExpression$4,
	    booleanLiteral$3 = booleanLiteral$5,
	    callExpression$3 = callExpression$e,
	    cloneNode$2 = cloneNode$i,
	    conditionalExpression = conditionalExpression$3,
	    identifier$4 = identifier$j,
	    isMemberExpression$1 = isMemberExpression$8,
	    isOptionalCallExpression = isOptionalCallExpression$3,
	    isOptionalMemberExpression = isOptionalMemberExpression$3,
	    isUpdateExpression = isUpdateExpression$1,
	    logicalExpression = logicalExpression$2,
	    memberExpression$4 = memberExpression$b,
	    nullLiteral$1 = nullLiteral$2,
	    numericLiteral = numericLiteral$8,
	    optionalCallExpression$1 = optionalCallExpression$2,
	    optionalMemberExpression$1 = optionalMemberExpression$2,
	    sequenceExpression$2 = sequenceExpression$7,
	    unaryExpression = unaryExpression$7;

	var AssignmentMemoiser = function () {
	  function AssignmentMemoiser() {
	    this._map = void 0;
	    this._map = new WeakMap();
	  }

	  var _proto = AssignmentMemoiser.prototype;

	  _proto.has = function has(key) {
	    return this._map.has(key);
	  };

	  _proto.get = function get(key) {
	    if (!this.has(key)) return;

	    var record = this._map.get(key);

	    var value = record.value;
	    record.count--;

	    if (record.count === 0) {
	      return assignmentExpression$3("=", value, key);
	    }

	    return value;
	  };

	  _proto.set = function set(key, value, count) {
	    return this._map.set(key, {
	      count: count,
	      value: value
	    });
	  };

	  return AssignmentMemoiser;
	}();

	function toNonOptional(path, base) {
	  var node = path.node;

	  if (isOptionalMemberExpression(node)) {
	    return memberExpression$4(base, node.property, node.computed);
	  }

	  if (path.isOptionalCallExpression()) {
	    var callee = path.get("callee");

	    if (path.node.optional && callee.isOptionalMemberExpression()) {
	      var object = callee.node.object;
	      var context = path.scope.maybeGenerateMemoised(object) || object;
	      callee.get("object").replaceWith(assignmentExpression$3("=", context, object));
	      return callExpression$3(memberExpression$4(base, identifier$4("call")), [context].concat(_toConsumableArray(path.node.arguments)));
	    }

	    return callExpression$3(base, path.node.arguments);
	  }

	  return path.node;
	}

	function isInDetachedTree(path) {
	  while (path) {
	    if (path.isProgram()) break;
	    var _path = path,
	        parentPath = _path.parentPath,
	        container = _path.container,
	        listKey = _path.listKey;
	    var parentNode = parentPath.node;

	    if (listKey) {
	      if (container !== parentNode[listKey]) return true;
	    } else {
	      if (container !== parentNode) return true;
	    }

	    path = parentPath;
	  }

	  return false;
	}

	var handle = {
	  memoise: function memoise() {},
	  handle: function handle(member, noDocumentAll) {
	    var node = member.node,
	        parent = member.parent,
	        parentPath = member.parentPath,
	        scope = member.scope;

	    if (member.isOptionalMemberExpression()) {
	      if (isInDetachedTree(member)) return;
	      var endPath = member.find(function (_ref) {
	        var node = _ref.node,
	            parent = _ref.parent;

	        if (isOptionalMemberExpression(parent)) {
	          return parent.optional || parent.object !== node;
	        }

	        if (isOptionalCallExpression(parent)) {
	          return node !== member.node && parent.optional || parent.callee !== node;
	        }

	        return true;
	      });

	      if (scope.path.isPattern()) {
	        endPath.replaceWith(callExpression$3(arrowFunctionExpression([], endPath.node), []));
	        return;
	      }

	      var willEndPathCastToBoolean = willPathCastToBoolean$1(endPath);
	      var rootParentPath = endPath.parentPath;

	      if (rootParentPath.isUpdateExpression({
	        argument: node
	      }) || rootParentPath.isAssignmentExpression({
	        left: node
	      })) {
	        throw member.buildCodeFrameError("can't handle assignment");
	      }

	      var isDeleteOperation = rootParentPath.isUnaryExpression({
	        operator: "delete"
	      });

	      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
	        throw member.buildCodeFrameError("can't delete a private class element");
	      }

	      var startingOptional = member;

	      for (;;) {
	        if (startingOptional.isOptionalMemberExpression()) {
	          if (startingOptional.node.optional) break;
	          startingOptional = startingOptional.get("object");
	          continue;
	        } else if (startingOptional.isOptionalCallExpression()) {
	          if (startingOptional.node.optional) break;
	          startingOptional = startingOptional.get("callee");
	          continue;
	        }

	        throw new Error("Internal error: unexpected " + startingOptional.node.type);
	      }

	      var startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee";
	      var startingNode = startingOptional.node[startingProp];
	      var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
	      var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
	      var parentIsOptionalCall = parentPath.isOptionalCallExpression({
	        callee: node
	      });

	      var isOptionalCall = function isOptionalCall(parent) {
	        return parentIsOptionalCall;
	      };

	      var parentIsCall = parentPath.isCallExpression({
	        callee: node
	      });
	      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));

	      if (isOptionalCall(parent)) {
	        if (parent.optional) {
	          parentPath.replaceWith(this.optionalCall(member, parent.arguments));
	        } else {
	          parentPath.replaceWith(this.call(member, parent.arguments));
	        }
	      } else if (parentIsCall) {
	        member.replaceWith(this.boundGet(member));
	      } else {
	        member.replaceWith(this.get(member));
	      }

	      var regular = member.node;

	      for (var current = member; current !== endPath;) {
	        var _parentPath = current.parentPath;

	        if (_parentPath === endPath && isOptionalCall(parent) && parent.optional) {
	          regular = _parentPath.node;
	          break;
	        }

	        regular = toNonOptional(_parentPath, regular);
	        current = _parentPath;
	      }

	      var context;
	      var endParentPath = endPath.parentPath;

	      if (isMemberExpression$1(regular) && endParentPath.isOptionalCallExpression({
	        callee: endPath.node,
	        optional: true
	      })) {
	        var _regular = regular,
	            object = _regular.object;
	        context = member.scope.maybeGenerateMemoised(object);

	        if (context) {
	          regular.object = assignmentExpression$3("=", context, object);
	        }
	      }

	      var replacementPath = endPath;

	      if (isDeleteOperation) {
	        replacementPath = endParentPath;
	        regular = endParentPath.node;
	      }

	      var baseMemoised = baseNeedsMemoised ? assignmentExpression$3("=", cloneNode$2(baseRef), cloneNode$2(startingNode)) : cloneNode$2(baseRef);

	      if (willEndPathCastToBoolean) {
	        var nonNullishCheck;

	        if (noDocumentAll) {
	          nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral$1());
	        } else {
	          nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral$1()), binaryExpression("!==", cloneNode$2(baseRef), scope.buildUndefinedNode()));
	        }

	        replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
	      } else {
	        var nullishCheck;

	        if (noDocumentAll) {
	          nullishCheck = binaryExpression("==", baseMemoised, nullLiteral$1());
	        } else {
	          nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral$1()), binaryExpression("===", cloneNode$2(baseRef), scope.buildUndefinedNode()));
	        }

	        replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral$3(true) : scope.buildUndefinedNode(), regular));
	      }

	      if (context) {
	        var endParent = endParentPath.node;
	        endParentPath.replaceWith(optionalCallExpression$1(optionalMemberExpression$1(endParent.callee, identifier$4("call"), false, true), [cloneNode$2(context)].concat(_toConsumableArray(endParent.arguments)), false));
	      }

	      return;
	    }

	    if (isUpdateExpression(parent, {
	      argument: node
	    })) {
	      if (this.simpleSet) {
	        member.replaceWith(this.simpleSet(member));
	        return;
	      }

	      var operator = parent.operator,
	          prefix = parent.prefix;
	      this.memoise(member, 2);

	      var _value = binaryExpression(operator[0], unaryExpression("+", this.get(member)), numericLiteral(1));

	      if (prefix) {
	        parentPath.replaceWith(this.set(member, _value));
	      } else {
	        var _scope = member.scope;

	        var ref = _scope.generateUidIdentifierBasedOnNode(node);

	        _scope.push({
	          id: ref
	        });

	        _value.left = assignmentExpression$3("=", cloneNode$2(ref), _value.left);
	        parentPath.replaceWith(sequenceExpression$2([this.set(member, _value), cloneNode$2(ref)]));
	      }

	      return;
	    }

	    if (parentPath.isAssignmentExpression({
	      left: node
	    })) {
	      if (this.simpleSet) {
	        member.replaceWith(this.simpleSet(member));
	        return;
	      }

	      var _parentPath$node = parentPath.node,
	          _operator = _parentPath$node.operator,
	          _value2 = _parentPath$node.right;

	      if (_operator === "=") {
	        parentPath.replaceWith(this.set(member, _value2));
	      } else {
	        var operatorTrunc = _operator.slice(0, -1);

	        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
	          this.memoise(member, 1);
	          parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, _value2)));
	        } else {
	          this.memoise(member, 2);
	          parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), _value2)));
	        }
	      }

	      return;
	    }

	    if (parentPath.isCallExpression({
	      callee: node
	    })) {
	      parentPath.replaceWith(this.call(member, parentPath.node.arguments));
	      return;
	    }

	    if (parentPath.isOptionalCallExpression({
	      callee: node
	    })) {
	      if (scope.path.isPattern()) {
	        parentPath.replaceWith(callExpression$3(arrowFunctionExpression([], parentPath.node), []));
	        return;
	      }

	      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
	      return;
	    }

	    if (parentPath.isForXStatement({
	      left: node
	    }) || parentPath.isObjectProperty({
	      value: node
	    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
	      left: node
	    }) && parentPath.parentPath.isObjectProperty({
	      value: parent
	    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
	      left: node
	    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
	      member.replaceWith(this.destructureSet(member));
	      return;
	    }

	    if (parentPath.isTaggedTemplateExpression()) {
	      member.replaceWith(this.boundGet(member));
	    } else {
	      member.replaceWith(this.get(member));
	    }
	  }
	};
	function memberExpressionToFunctions(path, visitor, state) {
	  path.traverse(visitor, Object.assign({}, handle, state, {
	    memoiser: new AssignmentMemoiser()
	  }));
	}

	var callExpression$2 = callExpression$e,
	    identifier$3 = identifier$j,
	    isIdentifier$3 = isIdentifier$g,
	    isSpreadElement = isSpreadElement$1,
	    memberExpression$3 = memberExpression$b,
	    optionalCallExpression = optionalCallExpression$2,
	    optionalMemberExpression = optionalMemberExpression$2;
	function optimiseCallExpression(callee, thisNode, args, optional) {
	  if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier$3(args[0].argument, {
	    name: "arguments"
	  })) {
	    if (optional) {
	      return optionalCallExpression(optionalMemberExpression(callee, identifier$3("apply"), false, true), [thisNode, args[0].argument], false);
	    }

	    return callExpression$2(memberExpression$3(callee, identifier$3("apply")), [thisNode, args[0].argument]);
	  } else {
	    if (optional) {
	      return optionalCallExpression(optionalMemberExpression(callee, identifier$3("call"), false, true), [thisNode].concat(_toConsumableArray(args)), false);
	    }

	    return callExpression$2(memberExpression$3(callee, identifier$3("call")), [thisNode].concat(_toConsumableArray(args)));
	  }
	}

	var assignmentExpression$2 = assignmentExpression$c,
	    booleanLiteral$2 = booleanLiteral$5,
	    callExpression$1 = callExpression$e,
	    cloneNode$1 = cloneNode$i,
	    identifier$2 = identifier$j,
	    memberExpression$2 = memberExpression$b,
	    sequenceExpression$1 = sequenceExpression$7,
	    stringLiteral$1 = stringLiteral$8,
	    thisExpression$1 = thisExpression$3;

	function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
	  objectRef = cloneNode$1(objectRef);
	  var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression$2(objectRef, identifier$2("prototype"));
	  return callExpression$1(file.addHelper("getPrototypeOf"), [targetRef]);
	}

	var visitor$1 = traverse.visitors.merge([environmentVisitor, {
	  Super: function Super(path, state) {
	    var node = path.node,
	        parentPath = path.parentPath;
	    if (!parentPath.isMemberExpression({
	      object: node
	    })) return;
	    state.handle(parentPath);
	  }
	}]);
	var unshadowSuperBindingVisitor = traverse.visitors.merge([environmentVisitor, {
	  Scopable: function Scopable(path, _ref) {
	    var refName = _ref.refName;
	    var binding = path.scope.getOwnBinding(refName);

	    if (binding && binding.identifier.name === refName) {
	      path.scope.rename(refName);
	    }
	  }
	}]);
	var specHandlers = {
	  memoise: function memoise(superMember, count) {
	    var scope = superMember.scope,
	        node = superMember.node;
	    var computed = node.computed,
	        property = node.property;

	    if (!computed) {
	      return;
	    }

	    var memo = scope.maybeGenerateMemoised(property);

	    if (!memo) {
	      return;
	    }

	    this.memoiser.set(property, memo, count);
	  },
	  prop: function prop(superMember) {
	    var _superMember$node = superMember.node,
	        computed = _superMember$node.computed,
	        property = _superMember$node.property;

	    if (this.memoiser.has(property)) {
	      return cloneNode$1(this.memoiser.get(property));
	    }

	    if (computed) {
	      return cloneNode$1(property);
	    }

	    return stringLiteral$1(property.name);
	  },
	  get: function get(superMember) {
	    return this._get(superMember, this._getThisRefs());
	  },
	  _get: function _get(superMember, thisRefs) {
	    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
	    return callExpression$1(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression$1([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
	  },
	  _getThisRefs: function _getThisRefs() {
	    if (!this.isDerivedConstructor) {
	      return {
	        "this": thisExpression$1()
	      };
	    }

	    var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
	    return {
	      memo: assignmentExpression$2("=", thisRef, thisExpression$1()),
	      "this": cloneNode$1(thisRef)
	    };
	  },
	  set: function set(superMember, value) {
	    var thisRefs = this._getThisRefs();

	    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
	    return callExpression$1(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression$1([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], booleanLiteral$2(superMember.isInStrictMode())]);
	  },
	  destructureSet: function destructureSet(superMember) {
	    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
	  },
	  call: function call(superMember, args) {
	    var thisRefs = this._getThisRefs();

	    return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode$1(thisRefs["this"]), args, false);
	  },
	  optionalCall: function optionalCall(superMember, args) {
	    var thisRefs = this._getThisRefs();

	    return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode$1(thisRefs["this"]), args, true);
	  }
	};
	var looseHandlers = Object.assign({}, specHandlers, {
	  prop: function prop(superMember) {
	    var property = superMember.node.property;

	    if (this.memoiser.has(property)) {
	      return cloneNode$1(this.memoiser.get(property));
	    }

	    return cloneNode$1(property);
	  },
	  get: function get(superMember) {
	    var isStatic = this.isStatic,
	        getSuperRef = this.getSuperRef;
	    var computed = superMember.node.computed;
	    var prop = this.prop(superMember);
	    var object;

	    if (isStatic) {
	      var _getSuperRef;

	      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression$2(identifier$2("Function"), identifier$2("prototype"));
	    } else {
	      var _getSuperRef2;

	      object = memberExpression$2((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier$2("Object"), identifier$2("prototype"));
	    }

	    return memberExpression$2(object, prop, computed);
	  },
	  set: function set(superMember, value) {
	    var computed = superMember.node.computed;
	    var prop = this.prop(superMember);
	    return assignmentExpression$2("=", memberExpression$2(thisExpression$1(), prop, computed), value);
	  },
	  destructureSet: function destructureSet(superMember) {
	    var computed = superMember.node.computed;
	    var prop = this.prop(superMember);
	    return memberExpression$2(thisExpression$1(), prop, computed);
	  },
	  call: function call(superMember, args) {
	    return optimiseCallExpression(this.get(superMember), thisExpression$1(), args, false);
	  },
	  optionalCall: function optionalCall(superMember, args) {
	    return optimiseCallExpression(this.get(superMember), thisExpression$1(), args, true);
	  }
	});

	var ReplaceSupers = function () {
	  function ReplaceSupers(opts) {
	    var _opts$constantSuper;

	    var path = opts.methodPath;
	    this.methodPath = path;
	    this.isDerivedConstructor = path.isClassMethod({
	      kind: "constructor"
	    }) && !!opts.superRef;
	    this.isStatic = path.isObjectMethod() || path.node["static"] || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
	    this.isPrivateMethod = path.isPrivate() && path.isMethod();
	    this.file = opts.file;
	    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
	    this.opts = opts;
	  }

	  var _proto = ReplaceSupers.prototype;

	  _proto.getObjectRef = function getObjectRef() {
	    return cloneNode$1(this.opts.objectRef || this.opts.getObjectRef());
	  };

	  _proto.getSuperRef = function getSuperRef() {
	    if (this.opts.superRef) return cloneNode$1(this.opts.superRef);
	    if (this.opts.getSuperRef) return cloneNode$1(this.opts.getSuperRef());
	  };

	  _proto.replace = function replace() {
	    if (this.opts.refToPreserve) {
	      this.methodPath.traverse(unshadowSuperBindingVisitor, {
	        refName: this.opts.refToPreserve.name
	      });
	    }

	    var handler = this.constantSuper ? looseHandlers : specHandlers;
	    memberExpressionToFunctions(this.methodPath, visitor$1, Object.assign({
	      file: this.file,
	      scope: this.methodPath.scope,
	      isDerivedConstructor: this.isDerivedConstructor,
	      isStatic: this.isStatic,
	      isPrivateMethod: this.isPrivateMethod,
	      getObjectRef: this.getObjectRef.bind(this),
	      getSuperRef: this.getSuperRef.bind(this),
	      boundGet: handler.get
	    }, handler));
	  };

	  return ReplaceSupers;
	}();

	function assertFieldTransformed(path) {
	  if (path.node.declare) {
	    throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-proposal-class-properties\n" + " - @babel/plugin-proposal-private-methods\n" + " - @babel/plugin-proposal-decorators");
	  }
	}

	var _templateObject$j, _templateObject2$9, _templateObject3$8, _templateObject4$4, _templateObject5$2, _templateObject6$2, _templateObject7$1, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19;
	function buildPrivateNamesMap(props) {
	  var privateNamesMap = new Map();

	  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
	    var prop = _step.value;

	    if (prop.isPrivate()) {
	      var name = prop.node.key.id.name;
	      var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
	        id: prop.scope.generateUidIdentifier(name),
	        "static": prop.node["static"],
	        method: !prop.isProperty()
	      };

	      if (prop.isClassPrivateMethod()) {
	        if (prop.node.kind === "get") {
	          update.getId = prop.scope.generateUidIdentifier("get_" + name);
	        } else if (prop.node.kind === "set") {
	          update.setId = prop.scope.generateUidIdentifier("set_" + name);
	        } else if (prop.node.kind === "method") {
	          update.methodId = prop.scope.generateUidIdentifier(name);
	        }
	      }

	      privateNamesMap.set(name, update);
	    }
	  }

	  return privateNamesMap;
	}
	function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, state) {
	  var initNodes = [];

	  for (var _iterator2 = _createForOfIteratorHelperLoose(privateNamesMap), _step2; !(_step2 = _iterator2()).done;) {
	    var _step2$value = _slicedToArray$1(_step2.value, 2),
	        name = _step2$value[0],
	        value = _step2$value[1];

	    var isStatic = value["static"],
	        isMethod = value.method,
	        getId = value.getId,
	        setId = value.setId;
	    var isAccessor = getId || setId;
	    var id = cloneNode$i(value.id);
	    var init = void 0;

	    if (privateFieldsAsProperties) {
	      init = callExpression$e(state.addHelper("classPrivateFieldLooseKey"), [stringLiteral$8(name)]);
	    } else if (!isStatic) {
	      init = newExpression(identifier$j(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), []);
	    }

	    if (init) {
	      annotateAsPure(init);
	      initNodes.push(template$2.statement.ast(_templateObject$j || (_templateObject$j = _taggedTemplateLiteralLoose(["var ", " = ", ""])), id, init));
	    }
	  }

	  return initNodes;
	}

	function privateNameVisitorFactory(visitor) {
	  var privateNameVisitor = Object.assign({}, visitor, {
	    Class: function Class(path) {
	      var privateNamesMap = this.privateNamesMap;
	      var body = path.get("body.body");
	      var visiblePrivateNames = new Map(privateNamesMap);
	      var redeclared = [];

	      for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
	        var prop = _step3.value;
	        if (!prop.isPrivate()) continue;
	        var name = prop.node.key.id.name;
	        visiblePrivateNames["delete"](name);
	        redeclared.push(name);
	      }

	      if (!redeclared.length) {
	        return;
	      }

	      path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
	        redeclared: redeclared
	      }));
	      path.traverse(privateNameVisitor, Object.assign({}, this, {
	        privateNamesMap: visiblePrivateNames
	      }));
	      path.skipKey("body");
	    }
	  });
	  var nestedVisitor = traverse.visitors.merge([Object.assign({}, visitor), environmentVisitor]);
	  return privateNameVisitor;
	}

	var privateNameVisitor = privateNameVisitorFactory({
	  PrivateName: function PrivateName(path, _ref) {
	    var noDocumentAll = _ref.noDocumentAll;
	    var privateNamesMap = this.privateNamesMap,
	        redeclared = this.redeclared;
	    var node = path.node,
	        parentPath = path.parentPath;

	    if (!parentPath.isMemberExpression({
	      property: node
	    }) && !parentPath.isOptionalMemberExpression({
	      property: node
	    })) {
	      return;
	    }

	    var name = node.id.name;
	    if (!privateNamesMap.has(name)) return;
	    if (redeclared && redeclared.includes(name)) return;
	    this.handle(parentPath, noDocumentAll);
	  }
	});

	function unshadow(name, scope, innerBinding) {
	  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
	    var _scope;

	    scope.rename(name);
	    scope = scope.parent;
	  }
	}

	var privateInVisitor = privateNameVisitorFactory({
	  BinaryExpression: function BinaryExpression(path) {
	    var _path$node = path.node,
	        operator = _path$node.operator,
	        left = _path$node.left,
	        right = _path$node.right;
	    if (operator !== "in") return;
	    if (!isPrivateName$1(left)) return;
	    var privateFieldsAsProperties = this.privateFieldsAsProperties,
	        privateNamesMap = this.privateNamesMap,
	        redeclared = this.redeclared;
	    var name = left.id.name;
	    if (!privateNamesMap.has(name)) return;
	    if (redeclared && redeclared.includes(name)) return;
	    unshadow(this.classRef.name, path.scope, this.innerBinding);

	    if (privateFieldsAsProperties) {
	      var _privateNamesMap$get = privateNamesMap.get(name),
	          _id = _privateNamesMap$get.id;

	      path.replaceWith(template$2.expression.ast(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteralLoose(["\n        Object.prototype.hasOwnProperty.call(", ", ", ")\n      "])), right, cloneNode$i(_id)));
	      return;
	    }

	    var _privateNamesMap$get2 = privateNamesMap.get(name),
	        id = _privateNamesMap$get2.id,
	        isStatic = _privateNamesMap$get2["static"];

	    if (isStatic) {
	      path.replaceWith(template$2.expression.ast(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteralLoose(["", " === ", ""])), right, this.classRef));
	      return;
	    }

	    path.replaceWith(template$2.expression.ast(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), cloneNode$i(id), right));
	  }
	});
	var privateNameHandlerSpec = {
	  memoise: function memoise(member, count) {
	    var scope = member.scope;
	    var object = member.node.object;
	    var memo = scope.maybeGenerateMemoised(object);

	    if (!memo) {
	      return;
	    }

	    this.memoiser.set(object, memo, count);
	  },
	  receiver: function receiver(member) {
	    var object = member.node.object;

	    if (this.memoiser.has(object)) {
	      return cloneNode$i(this.memoiser.get(object));
	    }

	    return cloneNode$i(object);
	  },
	  get: function get(member) {
	    var classRef = this.classRef,
	        privateNamesMap = this.privateNamesMap,
	        file = this.file,
	        innerBinding = this.innerBinding;
	    var name = member.node.property.id.name;

	    var _privateNamesMap$get3 = privateNamesMap.get(name),
	        id = _privateNamesMap$get3.id,
	        isStatic = _privateNamesMap$get3["static"],
	        isMethod = _privateNamesMap$get3.method,
	        methodId = _privateNamesMap$get3.methodId,
	        getId = _privateNamesMap$get3.getId,
	        setId = _privateNamesMap$get3.setId;

	    var isAccessor = getId || setId;

	    if (isStatic) {
	      var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
	      unshadow(classRef.name, member.scope, innerBinding);
	      return callExpression$e(file.addHelper(helperName), [this.receiver(member), cloneNode$i(classRef), cloneNode$i(id)]);
	    }

	    if (isMethod) {
	      if (isAccessor) {
	        if (!getId && setId) {
	          if (file.availableHelper("writeOnlyError")) {
	            return sequenceExpression$7([this.receiver(member), callExpression$e(file.addHelper("writeOnlyError"), [stringLiteral$8("#" + name)])]);
	          }

	          console.warn("@babel/helpers is outdated, update it to silence this warning.");
	        }

	        return callExpression$e(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode$i(id)]);
	      }

	      return callExpression$e(file.addHelper("classPrivateMethodGet"), [this.receiver(member), cloneNode$i(id), cloneNode$i(methodId)]);
	    }

	    return callExpression$e(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode$i(id)]);
	  },
	  boundGet: function boundGet(member) {
	    this.memoise(member, 1);
	    return callExpression$e(memberExpression$b(this.get(member), identifier$j("bind")), [this.receiver(member)]);
	  },
	  set: function set(member, value) {
	    var classRef = this.classRef,
	        privateNamesMap = this.privateNamesMap,
	        file = this.file;
	    var name = member.node.property.id.name;

	    var _privateNamesMap$get4 = privateNamesMap.get(name),
	        id = _privateNamesMap$get4.id,
	        isStatic = _privateNamesMap$get4["static"],
	        isMethod = _privateNamesMap$get4.method,
	        setId = _privateNamesMap$get4.setId,
	        getId = _privateNamesMap$get4.getId;

	    var isAccessor = getId || setId;

	    if (isStatic) {
	      var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
	      return callExpression$e(file.addHelper(helperName), [this.receiver(member), cloneNode$i(classRef), cloneNode$i(id), value]);
	    }

	    if (isMethod) {
	      if (setId) {
	        return callExpression$e(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode$i(id), value]);
	      }

	      return sequenceExpression$7([this.receiver(member), value, callExpression$e(file.addHelper("readOnlyError"), [stringLiteral$8("#" + name)])]);
	    }

	    return callExpression$e(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode$i(id), value]);
	  },
	  destructureSet: function destructureSet(member) {
	    var classRef = this.classRef,
	        privateNamesMap = this.privateNamesMap,
	        file = this.file;
	    var name = member.node.property.id.name;

	    var _privateNamesMap$get5 = privateNamesMap.get(name),
	        id = _privateNamesMap$get5.id,
	        isStatic = _privateNamesMap$get5["static"];

	    if (isStatic) {
	      try {
	        var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
	      } catch (_unused) {
	        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
	      }

	      return memberExpression$b(callExpression$e(helper, [this.receiver(member), cloneNode$i(classRef), cloneNode$i(id)]), identifier$j("value"));
	    }

	    return memberExpression$b(callExpression$e(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneNode$i(id)]), identifier$j("value"));
	  },
	  call: function call(member, args) {
	    this.memoise(member, 1);
	    return optimiseCallExpression(this.get(member), this.receiver(member), args, false);
	  },
	  optionalCall: function optionalCall(member, args) {
	    this.memoise(member, 1);
	    return optimiseCallExpression(this.get(member), this.receiver(member), args, true);
	  }
	};
	var privateNameHandlerLoose = {
	  get: function get(member) {
	    var privateNamesMap = this.privateNamesMap,
	        file = this.file;
	    var object = member.node.object;
	    var name = member.node.property.id.name;
	    return template$2.expression(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteralLoose(["BASE(REF, PROP)[PROP]"])))({
	      BASE: file.addHelper("classPrivateFieldLooseBase"),
	      REF: cloneNode$i(object),
	      PROP: cloneNode$i(privateNamesMap.get(name).id)
	    });
	  },
	  set: function set() {
	    throw new Error("private name handler with loose = true don't need set()");
	  },
	  boundGet: function boundGet(member) {
	    return callExpression$e(memberExpression$b(this.get(member), identifier$j("bind")), [cloneNode$i(member.node.object)]);
	  },
	  simpleSet: function simpleSet(member) {
	    return this.get(member);
	  },
	  destructureSet: function destructureSet(member) {
	    return this.get(member);
	  },
	  call: function call(member, args) {
	    return callExpression$e(this.get(member), args);
	  },
	  optionalCall: function optionalCall(member, args) {
	    return optionalCallExpression$2(this.get(member), args, true);
	  }
	};
	function transformPrivateNamesUsage(ref, path, privateNamesMap, _ref2, state) {
	  var privateFieldsAsProperties = _ref2.privateFieldsAsProperties,
	      noDocumentAll = _ref2.noDocumentAll,
	      innerBinding = _ref2.innerBinding;
	  if (!privateNamesMap.size) return;
	  var body = path.get("body");
	  var handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
	  memberExpressionToFunctions(body, privateNameVisitor, Object.assign({
	    privateNamesMap: privateNamesMap,
	    classRef: ref,
	    file: state
	  }, handler, {
	    noDocumentAll: noDocumentAll,
	    innerBinding: innerBinding
	  }));
	  body.traverse(privateInVisitor, {
	    privateNamesMap: privateNamesMap,
	    classRef: ref,
	    file: state,
	    privateFieldsAsProperties: privateFieldsAsProperties,
	    innerBinding: innerBinding
	  });
	}

	function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
	  var _privateNamesMap$get6 = privateNamesMap.get(prop.node.key.id.name),
	      id = _privateNamesMap$get6.id;

	  var value = prop.node.value || prop.scope.buildUndefinedNode();
	  return template$2.statement.ast(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "])), ref, cloneNode$i(id), value);
	}

	function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
	  var _privateNamesMap$get7 = privateNamesMap.get(prop.node.key.id.name),
	      id = _privateNamesMap$get7.id;

	  var value = prop.node.value || prop.scope.buildUndefinedNode();
	  {
	    if (!state.availableHelper("classPrivateFieldInitSpec")) {
	      return template$2.statement.ast(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteralLoose(["", ".set(", ", {\n        // configurable is always false for private elements\n        // enumerable is always false for private elements\n        writable: true,\n        value: ", ",\n      })"])), cloneNode$i(id), ref, value);
	    }
	  }
	  var helper = state.addHelper("classPrivateFieldInitSpec");
	  return template$2.statement.ast(_templateObject8 || (_templateObject8 = _taggedTemplateLiteralLoose(["", "(\n    ", ",\n    ", ",\n    {\n      writable: true,\n      value: ", "\n    },\n  )"])), helper, thisExpression$3(), cloneNode$i(id), value);
	}

	function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var id = privateName.id,
	      getId = privateName.getId,
	      setId = privateName.setId,
	      initAdded = privateName.initAdded;
	  var isAccessor = getId || setId;
	  if (!prop.isProperty() && (initAdded || !isAccessor)) return;

	  if (isAccessor) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return template$2.statement.ast(_templateObject9 || (_templateObject9 = _taggedTemplateLiteralLoose(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "])), cloneNode$i(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
	  }

	  var value = prop.node.value || prop.scope.buildUndefinedNode();
	  return template$2.statement.ast(_templateObject10 || (_templateObject10 = _taggedTemplateLiteralLoose(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "])), cloneNode$i(id), value);
	}

	function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var methodId = privateName.methodId,
	      id = privateName.id,
	      getId = privateName.getId,
	      setId = privateName.setId,
	      initAdded = privateName.initAdded;
	  if (initAdded) return;

	  if (methodId) {
	    return template$2.statement.ast(_templateObject11 || (_templateObject11 = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "])), ref, id, methodId.name);
	  }

	  var isAccessor = getId || setId;

	  if (isAccessor) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return template$2.statement.ast(_templateObject12 || (_templateObject12 = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
	  }
	}

	function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var getId = privateName.getId,
	      setId = privateName.setId,
	      initAdded = privateName.initAdded;
	  if (initAdded) return;
	  var isAccessor = getId || setId;

	  if (isAccessor) {
	    return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);
	  }

	  return buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state);
	}

	function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var id = privateName.id,
	      getId = privateName.getId,
	      setId = privateName.setId;
	  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	    initAdded: true
	  }));
	  {
	    if (!state.availableHelper("classPrivateFieldInitSpec")) {
	      return template$2.statement.ast(_templateObject13 || (_templateObject13 = _taggedTemplateLiteralLoose(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "])), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
	    }
	  }
	  var helper = state.addHelper("classPrivateFieldInitSpec");
	  return template$2.statement.ast(_templateObject14 || (_templateObject14 = _taggedTemplateLiteralLoose(["", "(\n    ", ",\n    ", ",\n    {\n      get: ", ",\n      set: ", "\n    },\n  )"])), helper, thisExpression$3(), cloneNode$i(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
	}

	function buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var id = privateName.id;
	  {
	    if (!state.availableHelper("classPrivateMethodInitSpec")) {
	      return template$2.statement.ast(_templateObject15 || (_templateObject15 = _taggedTemplateLiteralLoose(["", ".add(", ")"])), id, ref);
	    }
	  }
	  var helper = state.addHelper("classPrivateMethodInitSpec");
	  return template$2.statement.ast(_templateObject16 || (_templateObject16 = _taggedTemplateLiteralLoose(["", "(\n    ", ",\n    ", "\n  )"])), helper, thisExpression$3(), cloneNode$i(id));
	}

	function buildPublicFieldInitLoose(ref, prop) {
	  var _prop$node = prop.node,
	      key = _prop$node.key,
	      computed = _prop$node.computed;
	  var value = prop.node.value || prop.scope.buildUndefinedNode();
	  return expressionStatement$a(assignmentExpression$c("=", memberExpression$b(ref, key, computed || isLiteral$7(key)), value));
	}

	function buildPublicFieldInitSpec(ref, prop, state) {
	  var _prop$node2 = prop.node,
	      key = _prop$node2.key,
	      computed = _prop$node2.computed;
	  var value = prop.node.value || prop.scope.buildUndefinedNode();
	  return expressionStatement$a(callExpression$e(state.addHelper("defineProperty"), [ref, computed || isLiteral$7(key) ? key : stringLiteral$8(key.name), value]));
	}

	function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var id = privateName.id,
	      methodId = privateName.methodId,
	      getId = privateName.getId,
	      setId = privateName.setId,
	      initAdded = privateName.initAdded;
	  if (initAdded) return;
	  var isAccessor = getId || setId;

	  if (isAccessor) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      initAdded: true
	    }));
	    return template$2.statement.ast(_templateObject17 || (_templateObject17 = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
	  }

	  return template$2.statement.ast(_templateObject18 || (_templateObject18 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "])), ref, id, methodId.name);
	}

	function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties) {
	  if (privateFieldsAsProperties === void 0) {
	    privateFieldsAsProperties = false;
	  }

	  var privateName = privateNamesMap.get(prop.node.key.id.name);
	  var id = privateName.id,
	      methodId = privateName.methodId,
	      getId = privateName.getId,
	      setId = privateName.setId,
	      getterDeclared = privateName.getterDeclared,
	      setterDeclared = privateName.setterDeclared,
	      isStatic = privateName["static"];
	  var _prop$node3 = prop.node,
	      params = _prop$node3.params,
	      body = _prop$node3.body,
	      generator = _prop$node3.generator,
	      async = _prop$node3.async;
	  var isGetter = getId && !getterDeclared && params.length === 0;
	  var isSetter = setId && !setterDeclared && params.length > 0;
	  var declId = methodId;

	  if (isGetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      getterDeclared: true
	    }));
	    declId = getId;
	  } else if (isSetter) {
	    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
	      setterDeclared: true
	    }));
	    declId = setId;
	  } else if (isStatic && !privateFieldsAsProperties) {
	    declId = id;
	  }

	  return functionDeclaration(cloneNode$i(declId), params, body, generator, async);
	}

	var thisContextVisitor = traverse.visitors.merge([{
	  ThisExpression: function ThisExpression(path, state) {
	    state.needsClassRef = true;
	    path.replaceWith(cloneNode$i(state.classRef));
	  },
	  MetaProperty: function (_MetaProperty) {
	    function MetaProperty(_x) {
	      return _MetaProperty.apply(this, arguments);
	    }

	    MetaProperty.toString = function () {
	      return _MetaProperty.toString();
	    };

	    return MetaProperty;
	  }(function (path) {
	    var meta = path.get("meta");
	    var property = path.get("property");
	    var scope = path.scope;

	    if (meta.isIdentifier({
	      name: "new"
	    }) && property.isIdentifier({
	      name: "target"
	    })) {
	      path.replaceWith(scope.buildUndefinedNode());
	    }
	  })
	}, environmentVisitor]);
	var innerReferencesVisitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
	      state.needsClassRef = true;
	      path.node.name = state.classRef.name;
	    }
	  }
	};

	function replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
	  var _state$classRef;

	  var state = {
	    classRef: ref,
	    needsClassRef: false,
	    innerBinding: innerBindingRef
	  };
	  var replacer = new ReplaceSupers({
	    methodPath: path,
	    constantSuper: constantSuper,
	    file: file,
	    refToPreserve: ref,
	    getSuperRef: getSuperRef,
	    getObjectRef: function getObjectRef() {
	      state.needsClassRef = true;
	      return isStaticBlock || path.node["static"] ? ref : memberExpression$b(ref, identifier$j("prototype"));
	    }
	  });
	  replacer.replace();

	  if (isStaticBlock || path.isProperty()) {
	    path.traverse(thisContextVisitor, state);
	  }

	  if ((_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {
	    path.traverse(innerReferencesVisitor, state);
	  }

	  return state.needsClassRef;
	}

	function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
	  var needsClassRef = false;
	  var injectSuperRef;
	  var staticNodes = [];
	  var instanceNodes = [];
	  var pureStaticNodes = [];
	  var getSuperRef = isIdentifier$g(superRef) ? function () {
	    return superRef;
	  } : function () {
	    var _injectSuperRef;

	    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);
	    return injectSuperRef;
	  };

	  for (var _iterator4 = _createForOfIteratorHelperLoose(props), _step4; !(_step4 = _iterator4()).done;) {
	    var prop = _step4.value;
	    prop.isClassProperty() && assertFieldTransformed(prop);
	    var isStatic = prop.node["static"];
	    var isInstance = !isStatic;
	    var isPrivate = prop.isPrivate();
	    var isPublic = !isPrivate;
	    var isField = prop.isProperty();
	    var isMethod = !isField;
	    var isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();

	    if (isStatic || isMethod && isPrivate || isStaticBlock) {
	      var replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
	      needsClassRef = needsClassRef || replaced;
	    }

	    switch (true) {
	      case isStaticBlock:
	        staticNodes.push(template$2.statement.ast(_templateObject19 || (_templateObject19 = _taggedTemplateLiteralLoose(["(() => ", ")()"])), blockStatement$6(prop.node.body)));
	        break;

	      case isStatic && isPrivate && isField && privateFieldsAsProperties:
	        needsClassRef = true;
	        staticNodes.push(buildPrivateFieldInitLoose(cloneNode$i(ref), prop, privateNamesMap));
	        break;

	      case isStatic && isPrivate && isField && !privateFieldsAsProperties:
	        needsClassRef = true;
	        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
	        break;

	      case isStatic && isPublic && isField && setPublicClassFields:
	        needsClassRef = true;
	        staticNodes.push(buildPublicFieldInitLoose(cloneNode$i(ref), prop));
	        break;

	      case isStatic && isPublic && isField && !setPublicClassFields:
	        needsClassRef = true;
	        staticNodes.push(buildPublicFieldInitSpec(cloneNode$i(ref), prop, state));
	        break;

	      case isInstance && isPrivate && isField && privateFieldsAsProperties:
	        instanceNodes.push(buildPrivateFieldInitLoose(thisExpression$3(), prop, privateNamesMap));
	        break;

	      case isInstance && isPrivate && isField && !privateFieldsAsProperties:
	        instanceNodes.push(buildPrivateInstanceFieldInitSpec(thisExpression$3(), prop, privateNamesMap, state));
	        break;

	      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:
	        instanceNodes.unshift(buildPrivateMethodInitLoose(thisExpression$3(), prop, privateNamesMap));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
	        break;

	      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:
	        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(thisExpression$3(), prop, privateNamesMap, state));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
	        break;

	      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:
	        needsClassRef = true;
	        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
	        break;

	      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:
	        needsClassRef = true;
	        staticNodes.unshift(buildPrivateStaticMethodInitLoose(cloneNode$i(ref), prop, state, privateNamesMap));
	        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
	        break;

	      case isInstance && isPublic && isField && setPublicClassFields:
	        instanceNodes.push(buildPublicFieldInitLoose(thisExpression$3(), prop));
	        break;

	      case isInstance && isPublic && isField && !setPublicClassFields:
	        instanceNodes.push(buildPublicFieldInitSpec(thisExpression$3(), prop, state));
	        break;

	      default:
	        throw new Error("Unreachable.");
	    }
	  }

	  return {
	    staticNodes: staticNodes.filter(Boolean),
	    instanceNodes: instanceNodes.filter(Boolean),
	    pureStaticNodes: pureStaticNodes.filter(Boolean),
	    wrapClass: function wrapClass(path) {
	      for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {
	        var prop = _step5.value;
	        prop.remove();
	      }

	      if (injectSuperRef) {
	        path.scope.push({
	          id: cloneNode$i(injectSuperRef)
	        });
	        path.set("superClass", assignmentExpression$c("=", injectSuperRef, path.node.superClass));
	      }

	      if (!needsClassRef) return path;

	      if (path.isClassExpression()) {
	        path.scope.push({
	          id: ref
	        });
	        path.replaceWith(assignmentExpression$c("=", cloneNode$i(ref), path.node));
	      } else if (!path.node.id) {
	        path.node.id = ref;
	      }

	      return path;
	    }
	  };
	}

	var _templateObject$i, _templateObject2$8, _templateObject3$7, _templateObject4$3;
	function hasOwnDecorators(node) {
	  return !!(node.decorators && node.decorators.length);
	}
	function hasDecorators(node) {
	  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
	}

	function prop(key, value) {
	  if (!value) return null;
	  return objectProperty$2(identifier$j(key), value);
	}

	function method(key, body) {
	  return objectMethod("method", identifier$j(key), [], blockStatement$6(body));
	}

	function takeDecorators(node) {
	  var result;

	  if (node.decorators && node.decorators.length > 0) {
	    result = arrayExpression$2(node.decorators.map(function (decorator) {
	      return decorator.expression;
	    }));
	  }

	  node.decorators = undefined;
	  return result;
	}

	function getKey(node) {
	  if (node.computed) {
	    return node.key;
	  } else if (isIdentifier$g(node.key)) {
	    return stringLiteral$8(node.key.name);
	  } else {
	    return stringLiteral$8(String(node.key.value));
	  }
	}

	function extractElementDescriptor(classRef, superRef, path) {
	  var node = path.node,
	      scope = path.scope;
	  var isMethod = path.isClassMethod();

	  if (path.isPrivate()) {
	    throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
	  }

	  new ReplaceSupers({
	    methodPath: path,
	    objectRef: classRef,
	    superRef: superRef,
	    file: this,
	    refToPreserve: classRef
	  }).replace();
	  var properties = [prop("kind", stringLiteral$8(isClassMethod$1(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node["static"] && booleanLiteral$5(true)), prop("key", getKey(node))].filter(Boolean);

	  if (isClassMethod$1(node)) {
	    var id = node.computed ? null : node.key;
	    toExpression$1(node);
	    properties.push(prop("value", nameFunction({
	      node: node,
	      id: id,
	      scope: scope
	    }) || node));
	  } else if (isClassProperty(node) && node.value) {
	    properties.push(method("value", template$2.statements.ast(_templateObject$i || (_templateObject$i = _taggedTemplateLiteralLoose(["return ", ""])), node.value)));
	  } else {
	    properties.push(prop("value", scope.buildUndefinedNode()));
	  }

	  path.remove();
	  return objectExpression$4(properties);
	}

	function addDecorateHelper(file) {
	  try {
	    return file.addHelper("decorate");
	  } catch (err) {
	    if (err.code === "BABEL_HELPER_UNKNOWN") {
	      err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
	    }

	    throw err;
	  }
	}

	function buildDecoratedClass(ref, path, elements, file) {
	  var node = path.node,
	      scope = path.scope;
	  var initializeId = scope.generateUidIdentifier("initialize");
	  var isDeclaration = node.id && path.isDeclaration();
	  var isStrict = path.isInStrictMode();
	  var superClass = node.superClass;
	  node.type = "ClassDeclaration";
	  if (!node.id) node.id = cloneNode$i(ref);
	  var superId;

	  if (superClass) {
	    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
	    node.superClass = superId;
	  }

	  var classDecorators = takeDecorators(node);
	  var definitions = arrayExpression$2(elements.filter(function (element) {
	    return !element.node["abstract"];
	  }).map(extractElementDescriptor.bind(file, node.id, superId)));
	  var wrapperCall = template$2.expression.ast(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteralLoose(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "])), addDecorateHelper(file), classDecorators || nullLiteral$2(), initializeId, superClass ? cloneNode$i(superId) : null, node, cloneNode$i(node.id), definitions, superClass);

	  if (!isStrict) {
	    wrapperCall.arguments[1].body.directives.push(directive$1(directiveLiteral$1("use strict")));
	  }

	  var replacement = wrapperCall;
	  var classPathDesc = "arguments.1.body.body.0";

	  if (isDeclaration) {
	    replacement = template$2.statement.ast(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteralLoose(["let ", " = ", ""])), ref, wrapperCall);
	    classPathDesc = "declarations.0.init." + classPathDesc;
	  }

	  return {
	    instanceNodes: [template$2.statement.ast(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteralLoose(["", "(this)"])), cloneNode$i(initializeId))],
	    wrapClass: function wrapClass(path) {
	      path.replaceWith(replacement);
	      return path.get(classPathDesc);
	    }
	  };
	}

	var _templateObject$h;
	var findBareSupers = traverse.visitors.merge([{
	  Super: function (_Super) {
	    function Super(_x) {
	      return _Super.apply(this, arguments);
	    }

	    Super.toString = function () {
	      return _Super.toString();
	    };

	    return Super;
	  }(function (path) {
	    var node = path.node,
	        parentPath = path.parentPath;

	    if (parentPath.isCallExpression({
	      callee: node
	    })) {
	      this.push(parentPath);
	    }
	  })
	}, environmentVisitor]);
	var referenceVisitor = {
	  "TSTypeAnnotation|TypeAnnotation": function TSTypeAnnotationTypeAnnotation(path) {
	    path.skip();
	  },
	  ReferencedIdentifier: function ReferencedIdentifier(path) {
	    if (this.scope.hasOwnBinding(path.node.name)) {
	      this.scope.rename(path.node.name);
	      path.skip();
	    }
	  }
	};

	function handleClassTDZ(path, state) {
	  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
	    var classNameTDZError = state.file.addHelper("classNameTDZError");
	    var throwNode = callExpression$e(classNameTDZError, [stringLiteral$8(path.node.name)]);
	    path.replaceWith(sequenceExpression$7([throwNode, path.node]));
	    path.skip();
	  }
	}

	var classFieldDefinitionEvaluationTDZVisitor = {
	  ReferencedIdentifier: handleClassTDZ
	};
	function injectInitialization(path, constructor, nodes, renamer) {
	  if (!nodes.length) return;
	  var isDerived = !!path.node.superClass;

	  if (!constructor) {
	    var newConstructor = classMethod("constructor", identifier$j("constructor"), [], blockStatement$6([]));

	    if (isDerived) {
	      newConstructor.params = [restElement$1(identifier$j("args"))];
	      newConstructor.body.body.push(template$2.statement.ast(_templateObject$h || (_templateObject$h = _taggedTemplateLiteralLoose(["super(...args)"]))));
	    }

	    var _ref = path.get("body").unshiftContainer("body", newConstructor);

	    var _ref2 = _slicedToArray$1(_ref, 1);

	    constructor = _ref2[0];
	  }

	  if (renamer) {
	    renamer(referenceVisitor, {
	      scope: constructor.scope
	    });
	  }

	  if (isDerived) {
	    var bareSupers = [];
	    constructor.traverse(findBareSupers, bareSupers);
	    var isFirst = true;

	    for (var _i = 0, _bareSupers = bareSupers; _i < _bareSupers.length; _i++) {
	      var bareSuper = _bareSupers[_i];

	      if (isFirst) {
	        bareSuper.insertAfter(nodes);
	        isFirst = false;
	      } else {
	        bareSuper.insertAfter(nodes.map(function (n) {
	          return cloneNode$i(n);
	        }));
	      }
	    }
	  } else {
	    constructor.get("body").unshiftContainer("body", nodes);
	  }
	}
	function extractComputedKeys(ref, path, computedPaths, file) {
	  var declarations = [];
	  var state = {
	    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
	    file: file
	  };

	  for (var _iterator = _createForOfIteratorHelperLoose(computedPaths), _step; !(_step = _iterator()).done;) {
	    var computedPath = _step.value;
	    var computedKey = computedPath.get("key");

	    if (computedKey.isReferencedIdentifier()) {
	      handleClassTDZ(computedKey, state);
	    } else {
	      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
	    }

	    var computedNode = computedPath.node;

	    if (!computedKey.isConstantExpression()) {
	      var ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
	      path.scope.push({
	        id: ident,
	        kind: "let"
	      });
	      declarations.push(expressionStatement$a(assignmentExpression$c("=", cloneNode$i(ident), computedNode.key)));
	      computedNode.key = cloneNode$i(ident);
	    }
	  }

	  return declarations;
	}

	var FEATURES$1 = Object.freeze({
	  fields: 1 << 1,
	  privateMethods: 1 << 2,
	  decorators: 1 << 3,
	  privateIn: 1 << 4,
	  staticBlocks: 1 << 5
	});
	var featuresSameLoose = new Map([[FEATURES$1.fields, "@babel/plugin-proposal-class-properties"], [FEATURES$1.privateMethods, "@babel/plugin-proposal-private-methods"], [FEATURES$1.privateIn, "@babel/plugin-proposal-private-property-in-object"]]);
	var featuresKey$1 = "@babel/plugin-class-features/featuresKey";
	var looseKey = "@babel/plugin-class-features/looseKey";
	var looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
	function enableFeature$1(file, feature, loose) {
	  if (!hasFeature$1(file, feature) || canIgnoreLoose(file, feature)) {
	    file.set(featuresKey$1, file.get(featuresKey$1) | feature);

	    if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
	      setLoose(file, feature, true);
	      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
	    } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
	      setLoose(file, feature, false);
	      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
	    } else {
	      setLoose(file, feature, loose);
	    }
	  }

	  var resolvedLoose;
	  var higherPriorityPluginName;

	  for (var _iterator = _createForOfIteratorHelperLoose(featuresSameLoose), _step; !(_step = _iterator()).done;) {
	    var _step$value = _slicedToArray$1(_step.value, 2),
	        _mask = _step$value[0],
	        _name = _step$value[1];

	    if (!hasFeature$1(file, _mask)) continue;

	    var _loose = isLoose(file, _mask);

	    if (canIgnoreLoose(file, _mask)) {
	      continue;
	    } else if (resolvedLoose === !_loose) {
	      throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, " + "@babel/plugin-proposal-private-methods and " + "@babel/plugin-proposal-private-property-in-object (when they are enabled).");
	    } else {
	      resolvedLoose = _loose;
	      higherPriorityPluginName = _name;
	    }
	  }

	  if (resolvedLoose !== undefined) {
	    for (var _iterator2 = _createForOfIteratorHelperLoose(featuresSameLoose), _step2; !(_step2 = _iterator2()).done;) {
	      var _step2$value = _slicedToArray$1(_step2.value, 2),
	          mask = _step2$value[0],
	          name = _step2$value[1];

	      if (hasFeature$1(file, mask) && isLoose(file, mask) !== resolvedLoose) {
	        setLoose(file, mask, resolvedLoose);
	        console.warn("Though the \"loose\" option was set to \"" + !resolvedLoose + "\" in your @babel/preset-env " + ("config, it will not be used for " + name + " since the \"loose\" mode option was set to ") + ("\"" + resolvedLoose + "\" for " + higherPriorityPluginName + ".\nThe \"loose\" option must be the ") + "same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods " + "and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can " + "silence this warning by explicitly adding\n" + ("\t[\"" + name + "\", { \"loose\": " + resolvedLoose + " }]\n") + "to the \"plugins\" section of your Babel config.");
	      }
	    }
	  }
	}

	function hasFeature$1(file, feature) {
	  return !!(file.get(featuresKey$1) & feature);
	}

	function isLoose(file, feature) {
	  return !!(file.get(looseKey) & feature);
	}

	function setLoose(file, feature, loose) {
	  if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);
	  file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
	}

	function canIgnoreLoose(file, feature) {
	  return !!(file.get(looseLowPriorityKey) & feature);
	}

	function verifyUsedFeatures(path, file) {
	  if (hasOwnDecorators(path.node)) {
	    if (!hasFeature$1(file, FEATURES$1.decorators)) {
	      throw path.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "legacy": true }], ' + 'make sure it comes *before* "@babel/plugin-proposal-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n' + '\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
	    }

	    if (path.isPrivate()) {
	      throw path.buildCodeFrameError("Private " + (path.isClassMethod() ? "methods" : "fields") + " in decorated classes are not supported yet.");
	    }
	  }

	  if (path.isClassPrivateMethod != null && path.isClassPrivateMethod()) {
	    if (!hasFeature$1(file, FEATURES$1.privateMethods)) {
	      throw path.buildCodeFrameError("Class private methods are not enabled.");
	    }
	  }

	  if (path.isPrivateName() && path.parentPath.isBinaryExpression({
	    operator: "in",
	    left: path.node
	  })) {
	    if (!hasFeature$1(file, FEATURES$1.privateIn)) {
	      throw path.buildCodeFrameError("Private property in checks are not enabled.");
	    }
	  }

	  if (path.isProperty()) {
	    if (!hasFeature$1(file, FEATURES$1.fields)) {
	      throw path.buildCodeFrameError("Class fields are not enabled.");
	    }
	  }

	  if (path.isStaticBlock != null && path.isStaticBlock()) {
	    if (!hasFeature$1(file, FEATURES$1.staticBlocks)) {
	      throw path.buildCodeFrameError("Static class blocks are not enabled. " + "Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
	    }
	  }
	}

	var version$2 = "7.16.5".split(".").reduce(function (v, x) {
	  return v * 1e5 + +x;
	}, 0);
	var versionKey$1 = "@babel/plugin-class-features/version";
	function createClassFeaturePlugin(_ref) {
	  var name = _ref.name,
	      feature = _ref.feature,
	      loose = _ref.loose,
	      manipulateOptions = _ref.manipulateOptions,
	      _ref$api = _ref.api,
	      api = _ref$api === void 0 ? {
	    assumption: function assumption() {
	      return void 0;
	    }
	  } : _ref$api;
	  var setPublicClassFields = api.assumption("setPublicClassFields");
	  var privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
	  var constantSuper = api.assumption("constantSuper");
	  var noDocumentAll = api.assumption("noDocumentAll");

	  if (loose === true) {
	    var explicit = [];

	    if (setPublicClassFields !== undefined) {
	      explicit.push("\"setPublicClassFields\"");
	    }

	    if (privateFieldsAsProperties !== undefined) {
	      explicit.push("\"privateFieldsAsProperties\"");
	    }

	    if (explicit.length !== 0) {
	      console.warn("[" + name + "]: You are using the \"loose: true\" option and you are" + (" explicitly setting a value for the " + explicit.join(" and ")) + (" assumption" + (explicit.length > 1 ? "s" : "") + ". The \"loose\" option") + " can cause incompatibilities with the other class features" + " plugins, so it's recommended that you replace it with the" + " following top-level option:\n" + "\t\"assumptions\": {\n" + "\t\t\"setPublicClassFields\": true,\n" + "\t\t\"privateFieldsAsProperties\": true\n" + "\t}");
	    }
	  }

	  return {
	    name: name,
	    manipulateOptions: manipulateOptions,
	    pre: function pre() {
	      enableFeature$1(this.file, feature, loose);

	      if (!this.file.get(versionKey$1) || this.file.get(versionKey$1) < version$2) {
	        this.file.set(versionKey$1, version$2);
	      }
	    },
	    visitor: {
	      Class: function (_Class) {
	        function Class(_x, _x2) {
	          return _Class.apply(this, arguments);
	        }

	        Class.toString = function () {
	          return _Class.toString();
	        };

	        return Class;
	      }(function (path, state) {
	        if (this.file.get(versionKey$1) !== version$2) return;
	        verifyUsedFeatures(path, this.file);
	        if (path.isClassDeclaration()) assertFieldTransformed(path);
	        var loose = isLoose(this.file, feature);
	        var constructor;
	        var isDecorated = hasDecorators(path.node);
	        var props = [];
	        var elements = [];
	        var computedPaths = [];
	        var privateNames = new Set();
	        var body = path.get("body");

	        for (var _iterator = _createForOfIteratorHelperLoose(body.get("body")), _step; !(_step = _iterator()).done;) {
	          var _path = _step.value;
	          verifyUsedFeatures(_path, this.file);

	          if ((_path.isClassProperty() || _path.isClassMethod()) && _path.node.computed) {
	            computedPaths.push(_path);
	          }

	          if (_path.isPrivate()) {
	            var _name = _path.node.key.id.name;
	            var getName = "get " + _name;
	            var setName = "set " + _name;

	            if (_path.isClassPrivateMethod()) {
	              if (_path.node.kind === "get") {
	                if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
	                  throw _path.buildCodeFrameError("Duplicate private field");
	                }

	                privateNames.add(getName).add(_name);
	              } else if (_path.node.kind === "set") {
	                if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
	                  throw _path.buildCodeFrameError("Duplicate private field");
	                }

	                privateNames.add(setName).add(_name);
	              }
	            } else {
	              if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
	                throw _path.buildCodeFrameError("Duplicate private field");
	              }

	              privateNames.add(_name);
	            }
	          }

	          if (_path.isClassMethod({
	            kind: "constructor"
	          })) {
	            constructor = _path;
	          } else {
	            elements.push(_path);

	            if (_path.isProperty() || _path.isPrivate() || _path.isStaticBlock != null && _path.isStaticBlock()) {
	              props.push(_path);
	            }
	          }
	        }

	        if (!props.length && !isDecorated) return;
	        var innerBinding = path.node.id;
	        var ref;

	        if (!innerBinding || path.isClassExpression()) {
	          nameFunction(path);
	          ref = path.scope.generateUidIdentifier("class");
	        } else {
	          ref = cloneNode$i(path.node.id);
	        }

	        var privateNamesMap = buildPrivateNamesMap(props);
	        var privateNamesNodes = buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, state);
	        transformPrivateNamesUsage(ref, path, privateNamesMap, {
	          privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,
	          noDocumentAll: noDocumentAll,
	          innerBinding: innerBinding
	        }, state);
	        var keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;

	        if (isDecorated) {
	          staticNodes = pureStaticNodes = keysNodes = [];

	          var _buildDecoratedClass = buildDecoratedClass(ref, path, elements, this.file);

	          instanceNodes = _buildDecoratedClass.instanceNodes;
	          wrapClass = _buildDecoratedClass.wrapClass;
	        } else {
	          keysNodes = extractComputedKeys(ref, path, computedPaths, this.file);

	          var _buildFieldsInitNodes = buildFieldsInitNodes(ref, path.node.superClass, props, privateNamesMap, state, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding);

	          staticNodes = _buildFieldsInitNodes.staticNodes;
	          pureStaticNodes = _buildFieldsInitNodes.pureStaticNodes;
	          instanceNodes = _buildFieldsInitNodes.instanceNodes;
	          wrapClass = _buildFieldsInitNodes.wrapClass;
	        }

	        if (instanceNodes.length > 0) {
	          injectInitialization(path, constructor, instanceNodes, function (referenceVisitor, state) {
	            if (isDecorated) return;

	            for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
	              var prop = _step2.value;
	              if (prop.node["static"]) continue;
	              prop.traverse(referenceVisitor, state);
	            }
	          });
	        }

	        var wrappedPath = wrapClass(path);
	        wrappedPath.insertBefore([].concat(_toConsumableArray(privateNamesNodes), _toConsumableArray(keysNodes)));

	        if (staticNodes.length > 0) {
	          wrappedPath.insertAfter(staticNodes);
	        }

	        if (pureStaticNodes.length > 0) {
	          wrappedPath.find(function (parent) {
	            return parent.isStatement() || parent.isDeclaration();
	          }).insertAfter(pureStaticNodes);
	        }
	      }),
	      PrivateName: function (_PrivateName) {
	        function PrivateName(_x3) {
	          return _PrivateName.apply(this, arguments);
	        }

	        PrivateName.toString = function () {
	          return _PrivateName.toString();
	        };

	        return PrivateName;
	      }(function (path) {
	        if (this.file.get(versionKey$1) !== version$2 || path.parentPath.isPrivate({
	          key: path.node
	        })) {
	          return;
	        }

	        throw path.buildCodeFrameError("Unknown PrivateName \"" + path + "\"");
	      }),
	      ExportDefaultDeclaration: function (_ExportDefaultDeclaration) {
	        function ExportDefaultDeclaration(_x4) {
	          return _ExportDefaultDeclaration.apply(this, arguments);
	        }

	        ExportDefaultDeclaration.toString = function () {
	          return _ExportDefaultDeclaration.toString();
	        };

	        return ExportDefaultDeclaration;
	      }(function (path) {
	        if (this.file.get(versionKey$1) !== version$2) return;
	        var decl = path.get("declaration");

	        if (decl.isClassDeclaration() && hasDecorators(decl.node)) {
	          if (decl.node.id) {
	            splitExportDeclaration(path);
	          } else {
	            decl.node.type = "ClassExpression";
	          }
	        }
	      })
	    }
	  };
	}

	var _proposalClassProperties = declare(function (api, options) {
	  api.assertVersion(7);
	  return createClassFeaturePlugin({
	    name: "proposal-class-properties",
	    api: api,
	    feature: FEATURES$1.fields,
	    loose: options.loose,
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("classProperties", "classPrivateProperties");
	    }
	  });
	});

	var lib$p = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-class-static-block",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("classStaticBlock");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-class-static-block/node_modules/@babel/plugin-syntax-class-static-block/lib");

	var _templateObject$g;

	function generateUid(scope, denyList) {
	  var name = "";
	  var uid;
	  var i = 1;

	  do {
	    uid = scope._generateUid(name, i);
	    i++;
	  } while (denyList.has(uid));

	  return uid;
	}

	var _proposalClassStaticBlock = declare(function (_ref) {
	  var t = _ref.types,
	      template = _ref.template,
	      assertVersion = _ref.assertVersion;
	  assertVersion("^7.12.0");
	  return {
	    name: "proposal-class-static-block",
	    inherits: lib$p["default"],
	    pre: function pre() {
	      enableFeature$1(this.file, FEATURES$1.staticBlocks, false);
	    },
	    visitor: {
	      ClassBody: function (_ClassBody) {
	        function ClassBody(_x) {
	          return _ClassBody.apply(this, arguments);
	        }

	        ClassBody.toString = function () {
	          return _ClassBody.toString();
	        };

	        return ClassBody;
	      }(function (classBody) {
	        var scope = classBody.scope;
	        var privateNames = new Set();
	        var body = classBody.get("body");

	        for (var _iterator = _createForOfIteratorHelperLoose(body), _step; !(_step = _iterator()).done;) {
	          var path = _step.value;

	          if (path.isPrivate()) {
	            privateNames.add(path.get("key.id").node.name);
	          }
	        }

	        for (var _iterator2 = _createForOfIteratorHelperLoose(body), _step2; !(_step2 = _iterator2()).done;) {
	          var _path = _step2.value;
	          if (!_path.isStaticBlock()) continue;
	          var staticBlockPrivateId = generateUid(scope, privateNames);
	          privateNames.add(staticBlockPrivateId);
	          var staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));

	          _path.replaceWith(t.classPrivateProperty(staticBlockRef, template.expression.ast(_templateObject$g || (_templateObject$g = _taggedTemplateLiteralLoose(["(() => { ", " })()"])), _path.node.body), [], true));
	        }
	      })
	    }
	  };
	});

	var buildClassDecorator = template$2("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n");
	var buildClassPrototype = template$2("\n  CLASS_REF.prototype;\n");
	var buildGetDescriptor = template$2("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n");
	var buildGetObjectInitializer = template$2("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n");
	var WARNING_CALLS = new WeakSet();

	function applyEnsureOrdering(path) {
	  var decorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce(function (acc, prop) {
	    return acc.concat(prop.node.decorators || []);
	  }, []);
	  var identDecorators = decorators.filter(function (decorator) {
	    return !isIdentifier$g(decorator.expression);
	  });
	  if (identDecorators.length === 0) return;
	  return sequenceExpression$7(identDecorators.map(function (decorator) {
	    var expression = decorator.expression;
	    var id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
	    return assignmentExpression$c("=", id, expression);
	  }).concat([path.node]));
	}

	function applyClassDecorators(classPath) {
	  if (!hasClassDecorators(classPath.node)) return;
	  var decorators = classPath.node.decorators || [];
	  classPath.node.decorators = null;
	  var name = classPath.scope.generateDeclaredUidIdentifier("class");
	  return decorators.map(function (dec) {
	    return dec.expression;
	  }).reverse().reduce(function (acc, decorator) {
	    return buildClassDecorator({
	      CLASS_REF: cloneNode$i(name),
	      DECORATOR: cloneNode$i(decorator),
	      INNER: acc
	    }).expression;
	  }, classPath.node);
	}

	function hasClassDecorators(classNode) {
	  return !!(classNode.decorators && classNode.decorators.length);
	}

	function applyMethodDecorators(path, state) {
	  if (!hasMethodDecorators(path.node.body.body)) return;
	  return applyTargetDecorators(path, state, path.node.body.body);
	}

	function hasMethodDecorators(body) {
	  return body.some(function (node) {
	    var _node$decorators;

	    return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;
	  });
	}

	function applyObjectDecorators(path, state) {
	  if (!hasMethodDecorators(path.node.properties)) return;
	  return applyTargetDecorators(path, state, path.node.properties);
	}

	function applyTargetDecorators(path, state, decoratedProps) {
	  var name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
	  var exprs = decoratedProps.reduce(function (acc, node) {
	    var decorators = node.decorators || [];
	    node.decorators = null;
	    if (decorators.length === 0) return acc;

	    if (node.computed) {
	      throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
	    }

	    var property = isLiteral$7(node.key) ? node.key : stringLiteral$8(node.key.name);
	    var target = path.isClass() && !node["static"] ? buildClassPrototype({
	      CLASS_REF: name
	    }).expression : name;

	    if (isClassProperty(node, {
	      "static": false
	    })) {
	      var descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
	      var initializer = node.value ? functionExpression$3(null, [], blockStatement$6([returnStatement$3(node.value)])) : nullLiteral$2();
	      node.value = callExpression$e(state.addHelper("initializerWarningHelper"), [descriptor, thisExpression$3()]);
	      WARNING_CALLS.add(node.value);
	      acc.push(assignmentExpression$c("=", cloneNode$i(descriptor), callExpression$e(state.addHelper("applyDecoratedDescriptor"), [cloneNode$i(target), cloneNode$i(property), arrayExpression$2(decorators.map(function (dec) {
	        return cloneNode$i(dec.expression);
	      })), objectExpression$4([objectProperty$2(identifier$j("configurable"), booleanLiteral$5(true)), objectProperty$2(identifier$j("enumerable"), booleanLiteral$5(true)), objectProperty$2(identifier$j("writable"), booleanLiteral$5(true)), objectProperty$2(identifier$j("initializer"), initializer)])])));
	    } else {
	      acc.push(callExpression$e(state.addHelper("applyDecoratedDescriptor"), [cloneNode$i(target), cloneNode$i(property), arrayExpression$2(decorators.map(function (dec) {
	        return cloneNode$i(dec.expression);
	      })), isObjectProperty$4(node) || isClassProperty(node, {
	        "static": true
	      }) ? buildGetObjectInitializer({
	        TEMP: path.scope.generateDeclaredUidIdentifier("init"),
	        TARGET: cloneNode$i(target),
	        PROPERTY: cloneNode$i(property)
	      }).expression : buildGetDescriptor({
	        TARGET: cloneNode$i(target),
	        PROPERTY: cloneNode$i(property)
	      }).expression, cloneNode$i(target)]));
	    }

	    return acc;
	  }, []);
	  return sequenceExpression$7([assignmentExpression$c("=", cloneNode$i(name), path.node), sequenceExpression$7(exprs), cloneNode$i(name)]);
	}

	function decoratedClassToExpression(_ref) {
	  var node = _ref.node,
	      scope = _ref.scope;

	  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
	    return;
	  }

	  var ref = node.id ? cloneNode$i(node.id) : scope.generateUidIdentifier("class");
	  return variableDeclaration$8("let", [variableDeclarator$8(ref, toExpression$1(node))]);
	}

	var legacyVisitor = {
	  ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
	    var decl = path.get("declaration");
	    if (!decl.isClassDeclaration()) return;
	    var replacement = decoratedClassToExpression(decl);

	    if (replacement) {
	      var _path$replaceWithMult = path.replaceWithMultiple([replacement, exportNamedDeclaration$2(null, [exportSpecifier$2(cloneNode$i(replacement.declarations[0].id), identifier$j("default"))])]),
	          _path$replaceWithMult2 = _slicedToArray$1(_path$replaceWithMult, 1),
	          varDeclPath = _path$replaceWithMult2[0];

	      if (!decl.node.id) {
	        path.scope.registerDeclaration(varDeclPath);
	      }
	    }
	  },
	  ClassDeclaration: function ClassDeclaration(path) {
	    var replacement = decoratedClassToExpression(path);

	    if (replacement) {
	      path.replaceWith(replacement);
	    }
	  },
	  ClassExpression: function ClassExpression(path, state) {
	    var decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
	    if (decoratedClass) path.replaceWith(decoratedClass);
	  },
	  ObjectExpression: function ObjectExpression(path, state) {
	    var decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
	    if (decoratedObject) path.replaceWith(decoratedObject);
	  },
	  AssignmentExpression: function AssignmentExpression(path, state) {
	    if (!WARNING_CALLS.has(path.node.right)) return;
	    path.replaceWith(callExpression$e(state.addHelper("initializerDefineProperty"), [cloneNode$i(path.get("left.object").node), stringLiteral$8(path.get("left.property").node.name || path.get("left.property").node.value), cloneNode$i(path.get("right.arguments")[0].node), cloneNode$i(path.get("right.arguments")[1].node)]));
	  },
	  CallExpression: function CallExpression(path, state) {
	    if (path.node.arguments.length !== 3) return;
	    if (!WARNING_CALLS.has(path.node.arguments[2])) return;

	    if (path.node.callee.name !== state.addHelper("defineProperty").name) {
	      return;
	    }

	    path.replaceWith(callExpression$e(state.addHelper("initializerDefineProperty"), [cloneNode$i(path.get("arguments")[0].node), cloneNode$i(path.get("arguments")[1].node), cloneNode$i(path.get("arguments.2.arguments")[0].node), cloneNode$i(path.get("arguments.2.arguments")[1].node)]));
	  }
	};

	var proposalDecorators = declare(function (api, options) {
	  api.assertVersion(7);
	  var _options$legacy = options.legacy,
	      legacy = _options$legacy === void 0 ? false : _options$legacy;

	  if (typeof legacy !== "boolean") {
	    throw new Error("'legacy' must be a boolean.");
	  }

	  var decoratorsBeforeExport = options.decoratorsBeforeExport;

	  if (decoratorsBeforeExport === undefined) {
	    if (!legacy) {
	      throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you want to use the legacy" + " decorators semantics, you can set the 'legacy: true' option.");
	    }
	  } else {
	    if (legacy) {
	      throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
	    }

	    if (typeof decoratorsBeforeExport !== "boolean") {
	      throw new Error("'decoratorsBeforeExport' must be a boolean.");
	    }
	  }

	  if (legacy) {
	    return {
	      name: "proposal-decorators",
	      inherits: syntaxDecorators,
	      manipulateOptions: function manipulateOptions(_ref) {
	        var generatorOpts = _ref.generatorOpts;
	        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
	      },
	      visitor: legacyVisitor
	    };
	  }

	  return createClassFeaturePlugin({
	    name: "proposal-decorators",
	    api: api,
	    feature: FEATURES$1.decorators,
	    manipulateOptions: function manipulateOptions(_ref2) {
	      var generatorOpts = _ref2.generatorOpts,
	          parserOpts = _ref2.parserOpts;
	      parserOpts.plugins.push(["decorators", {
	        decoratorsBeforeExport: decoratorsBeforeExport
	      }]);
	      generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
	    }
	  });
	});

	var proposalDoExpressions = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-do-expressions",
	    inherits: syntaxDoExpressions,
	    visitor: {
	      DoExpression: {
	        exit: function exit(path) {
	          var node = path.node;

	          if (node.async) {
	            return;
	          }

	          var body = node.body.body;

	          if (body.length) {
	            path.replaceExpressionWithStatements(body);
	          } else {
	            path.replaceWith(path.scope.buildUndefinedNode());
	          }
	        }
	      }
	    }
	  };
	});

	var lib$o = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-dynamic-import",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("dynamicImport");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-dynamic-import/node_modules/@babel/plugin-syntax-dynamic-import/lib");

	var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
	var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";
	var _proposalDynamicImport = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-dynamic-import",
	    inherits: lib$o["default"],
	    pre: function pre() {
	      this.file.set("@babel/plugin-proposal-dynamic-import", "7.16.5");
	    },
	    visitor: {
	      Program: function Program() {
	        var modules = this.file.get("@babel/plugin-transform-modules-*");

	        if (!SUPPORTED_MODULES.includes(modules)) {
	          throw new Error(MODULES_NOT_FOUND);
	        }
	      }
	    }
	  };
	});

	var proposalExportDefaultFrom = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-export-default-from",
	    inherits: syntaxExportDefaultFrom,
	    visitor: {
	      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
	        var node = path.node,
	            scope = path.scope;
	        var specifiers = node.specifiers;
	        if (!isExportDefaultSpecifier$1(specifiers[0])) return;
	        var specifier = specifiers.shift();
	        var exported = specifier.exported;
	        var uid = scope.generateUidIdentifier(exported.name);
	        var nodes = [importDeclaration$1([importDefaultSpecifier$1(uid)], cloneNode$i(node.source)), exportNamedDeclaration$2(null, [exportSpecifier$2(cloneNode$i(uid), exported)])];

	        if (specifiers.length >= 1) {
	          nodes.push(node);
	        }

	        var _path$replaceWithMult = path.replaceWithMultiple(nodes),
	            _path$replaceWithMult2 = _slicedToArray$1(_path$replaceWithMult, 1),
	            importDeclaration = _path$replaceWithMult2[0];

	        path.scope.registerDeclaration(importDeclaration);
	      }
	    }
	  };
	});

	var lib$n = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-export-namespace-from",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("exportNamespaceFrom");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-export-namespace-from/node_modules/@babel/plugin-syntax-export-namespace-from/lib");

	var _proposalExportNamespaceFrom = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-export-namespace-from",
	    inherits: lib$n["default"],
	    visitor: {
	      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
	        var _exported$name;

	        var node = path.node,
	            scope = path.scope;
	        var specifiers = node.specifiers;
	        var index = isExportDefaultSpecifier$1(specifiers[0]) ? 1 : 0;
	        if (!isExportNamespaceSpecifier$1(specifiers[index])) return;
	        var nodes = [];

	        if (index === 1) {
	          nodes.push(exportNamedDeclaration$2(null, [specifiers.shift()], node.source));
	        }

	        var specifier = specifiers.shift();
	        var exported = specifier.exported;
	        var uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
	        nodes.push(importDeclaration$1([importNamespaceSpecifier$1(uid)], cloneNode$i(node.source)), exportNamedDeclaration$2(null, [exportSpecifier$2(cloneNode$i(uid), exported)]));

	        if (node.specifiers.length >= 1) {
	          nodes.push(node);
	        }

	        var _path$replaceWithMult = path.replaceWithMultiple(nodes),
	            _path$replaceWithMult2 = _slicedToArray$1(_path$replaceWithMult, 1),
	            importDeclaration = _path$replaceWithMult2[0];

	        path.scope.registerDeclaration(importDeclaration);
	      }
	    }
	  };
	});

	var proposalFunctionBind = declare(function (api) {
	  api.assertVersion(7);

	  function getTempId(scope) {
	    var id = scope.path.getData("functionBind");
	    if (id) return cloneNode$i(id);
	    id = scope.generateDeclaredUidIdentifier("context");
	    return scope.path.setData("functionBind", id);
	  }

	  function getStaticContext(bind, scope) {
	    var object = bind.object || bind.callee.object;
	    return scope.isStatic(object) && (isSuper$2(object) ? thisExpression$3() : object);
	  }

	  function inferBindContext(bind, scope) {
	    var staticContext = getStaticContext(bind, scope);
	    if (staticContext) return cloneNode$i(staticContext);
	    var tempId = getTempId(scope);

	    if (bind.object) {
	      bind.callee = sequenceExpression$7([assignmentExpression$c("=", tempId, bind.object), bind.callee]);
	    } else {
	      bind.callee.object = assignmentExpression$c("=", tempId, bind.callee.object);
	    }

	    return cloneNode$i(tempId);
	  }

	  return {
	    name: "proposal-function-bind",
	    inherits: syntaxFunctionBind,
	    visitor: {
	      CallExpression: function CallExpression(_ref) {
	        var node = _ref.node,
	            scope = _ref.scope;
	        var bind = node.callee;
	        if (!isBindExpression(bind)) return;
	        var context = inferBindContext(bind, scope);
	        node.callee = memberExpression$b(bind.callee, identifier$j("call"));
	        node.arguments.unshift(context);
	      },
	      BindExpression: function BindExpression(path) {
	        var node = path.node,
	            scope = path.scope;
	        var context = inferBindContext(node, scope);
	        path.replaceWith(callExpression$e(memberExpression$b(node.callee, identifier$j("bind")), [context]));
	      }
	    }
	  };
	});

	var proposalFunctionSent = declare(function (api) {
	  api.assertVersion(7);

	  var isFunctionSent = function isFunctionSent(node) {
	    return isIdentifier$g(node.meta, {
	      name: "function"
	    }) && isIdentifier$g(node.property, {
	      name: "sent"
	    });
	  };

	  var hasBeenReplaced = function hasBeenReplaced(node, sentId) {
	    return isAssignmentExpression$3(node) && isIdentifier$g(node.left, {
	      name: sentId
	    });
	  };

	  var yieldVisitor = {
	    Function: function Function(path) {
	      path.skip();
	    },
	    YieldExpression: function YieldExpression(path) {
	      if (!hasBeenReplaced(path.parent, this.sentId)) {
	        path.replaceWith(assignmentExpression$c("=", identifier$j(this.sentId), path.node));
	      }
	    },
	    MetaProperty: function MetaProperty(path) {
	      if (isFunctionSent(path.node)) {
	        path.replaceWith(identifier$j(this.sentId));
	      }
	    }
	  };
	  return {
	    name: "proposal-function-sent",
	    inherits: syntaxFunctionSent,
	    visitor: {
	      MetaProperty: function MetaProperty(path, state) {
	        if (!isFunctionSent(path.node)) return;
	        var fnPath = path.getFunctionParent();

	        if (!fnPath.node.generator) {
	          throw new Error("Parent generator function not found");
	        }

	        var sentId = path.scope.generateUid("function.sent");
	        fnPath.traverse(yieldVisitor, {
	          sentId: sentId
	        });
	        fnPath.node.body.body.unshift(variableDeclaration$8("let", [variableDeclarator$8(identifier$j(sentId), yieldExpression$2())]));
	        wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
	      }
	    }
	  };
	});

	var lib$m = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-json-strings",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("jsonStrings");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-json-strings/node_modules/@babel/plugin-syntax-json-strings/lib");

	var _proposalJsonStrings = declare(function (api) {
	  api.assertVersion(7);
	  var regex = /(\\*)([\u2028\u2029])/g;

	  function replace(match, escapes, separator) {
	    var isEscaped = escapes.length % 2 === 1;
	    if (isEscaped) return match;
	    return escapes + "\\u" + separator.charCodeAt(0).toString(16);
	  }

	  return {
	    name: "proposal-json-strings",
	    inherits: lib$m["default"],
	    visitor: {
	      "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
	        var node = _ref.node;
	        var extra = node.extra;
	        if (!(extra != null && extra.raw)) return;
	        extra.raw = extra.raw.replace(regex, replace);
	      }
	    }
	  };
	});

	var lib$l = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-logical-assignment-operators",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("logicalAssignment");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-logical-assignment-operators/node_modules/@babel/plugin-syntax-logical-assignment-operators/lib");

	var _proposalLogicalAssignmentOperators = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-logical-assignment-operators",
	    inherits: lib$l["default"],
	    visitor: {
	      AssignmentExpression: function AssignmentExpression(path) {
	        var node = path.node,
	            scope = path.scope;
	        var operator = node.operator,
	            left = node.left,
	            right = node.right;
	        var operatorTrunc = operator.slice(0, -1);

	        if (!LOGICAL_OPERATORS$2.includes(operatorTrunc)) {
	          return;
	        }

	        var lhs = cloneNode$i(left);

	        if (isMemberExpression$8(left)) {
	          var object = left.object,
	              property = left.property,
	              computed = left.computed;
	          var memo = scope.maybeGenerateMemoised(object);

	          if (memo) {
	            left.object = memo;
	            lhs.object = assignmentExpression$c("=", cloneNode$i(memo), object);
	          }

	          if (computed) {
	            var _memo = scope.maybeGenerateMemoised(property);

	            if (_memo) {
	              left.property = _memo;
	              lhs.property = assignmentExpression$c("=", cloneNode$i(_memo), property);
	            }
	          }
	        }

	        path.replaceWith(logicalExpression$2(operatorTrunc, lhs, assignmentExpression$c("=", left, right)));
	      }
	    }
	  };
	});

	var lib$k = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-nullish-coalescing-operator",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("nullishCoalescingOperator");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-nullish-coalescing-operator/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib");

	var _templateObject$f;
	var _proposalNullishCoalescingOperator = declare(function (api, _ref) {
	  var _api$assumption;

	  var _ref$loose = _ref.loose,
	      loose = _ref$loose === void 0 ? false : _ref$loose;
	  api.assertVersion(7);
	  var noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
	  return {
	    name: "proposal-nullish-coalescing-operator",
	    inherits: lib$k["default"],
	    visitor: {
	      LogicalExpression: function LogicalExpression(path) {
	        var node = path.node,
	            scope = path.scope;

	        if (node.operator !== "??") {
	          return;
	        }

	        var ref;
	        var assignment;

	        if (scope.isStatic(node.left)) {
	          ref = node.left;
	          assignment = cloneNode$i(node.left);
	        } else if (scope.path.isPattern()) {
	          path.replaceWith(template$2.ast(_templateObject$f || (_templateObject$f = _taggedTemplateLiteralLoose(["(() => ", ")()"])), path.node));
	          return;
	        } else {
	          ref = scope.generateUidIdentifierBasedOnNode(node.left);
	          scope.push({
	            id: cloneNode$i(ref)
	          });
	          assignment = assignmentExpression$c("=", ref, node.left);
	        }

	        path.replaceWith(conditionalExpression$3(noDocumentAll ? binaryExpression$4("!=", assignment, nullLiteral$2()) : logicalExpression$2("&&", binaryExpression$4("!==", assignment, nullLiteral$2()), binaryExpression$4("!==", cloneNode$i(ref), scope.buildUndefinedNode())), cloneNode$i(ref), node.right));
	      }
	    }
	  };
	});

	var lib$j = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-numeric-separator",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("numericSeparator");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-numeric-separator/node_modules/@babel/plugin-syntax-numeric-separator/lib");

	function remover(_ref) {
	  var _extra$raw;

	  var node = _ref.node;
	  var extra = node.extra;

	  if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_")) {
	    extra.raw = extra.raw.replace(/_/g, "");
	  }
	}

	var _proposalNumericSeparator = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-numeric-separator",
	    inherits: lib$j["default"],
	    visitor: {
	      NumericLiteral: remover,
	      BigIntLiteral: remover
	    }
	  };
	});

	var lib$i = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-object-rest-spread",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("objectRestSpread");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-object-rest-spread/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

	var buildDefaultParam = template$2("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
	var buildLooseDefaultParam = template$2("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
	var buildLooseDestructuredDefaultParam = template$2("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
	var buildSafeArgumentsAccess = template$2("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
	var iifeVisitor = {
	  "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
	    var scope = path.scope,
	        node = path.node;
	    var name = node.name;

	    if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
	      state.needsOuterBinding = true;
	      path.stop();
	    }
	  },
	  "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": function TypeAnnotationTSTypeAnnotationTypeParameterDeclarationTSTypeParameterDeclaration(path) {
	    return path.skip();
	  }
	};
	function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
	  var params = path.get("params");
	  var isSimpleParameterList = params.every(function (param) {
	    return param.isIdentifier();
	  });
	  if (isSimpleParameterList) return false;
	  var node = path.node,
	      scope = path.scope;
	  var state = {
	    stop: false,
	    needsOuterBinding: false,
	    scope: scope
	  };
	  var body = [];
	  var shadowedParams = new Set();

	  for (var _iterator = _createForOfIteratorHelperLoose(params), _step; !(_step = _iterator()).done;) {
	    var _param2 = _step.value;

	    for (var _i = 0, _Object$keys = Object.keys(_param2.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
	      var _scope$bindings$name;

	      var name = _Object$keys[_i];
	      var constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;

	      if (constantViolations) {
	        for (var _iterator4 = _createForOfIteratorHelperLoose(constantViolations), _step4; !(_step4 = _iterator4()).done;) {
	          var redeclarator = _step4.value;
	          var _node = redeclarator.node;

	          switch (_node.type) {
	            case "VariableDeclarator":
	              {
	                if (_node.init === null) {
	                  var declaration = redeclarator.parentPath;

	                  if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
	                    redeclarator.remove();
	                    break;
	                  }
	                }

	                shadowedParams.add(name);
	                break;
	              }

	            case "FunctionDeclaration":
	              shadowedParams.add(name);
	              break;
	          }
	        }
	      }
	    }
	  }

	  if (shadowedParams.size === 0) {
	    for (var _iterator2 = _createForOfIteratorHelperLoose(params), _step2; !(_step2 = _iterator2()).done;) {
	      var param = _step2.value;
	      if (!param.isIdentifier()) param.traverse(iifeVisitor, state);
	      if (state.needsOuterBinding) break;
	    }
	  }

	  var firstOptionalIndex = null;

	  for (var i = 0; i < params.length; i++) {
	    var _param = params[i];

	    if (shouldTransformParam && !shouldTransformParam(i)) {
	      continue;
	    }

	    var transformedRestNodes = [];

	    if (replaceRestElement) {
	      replaceRestElement(_param.parentPath, _param, transformedRestNodes);
	    }

	    var paramIsAssignmentPattern = _param.isAssignmentPattern();

	    if (paramIsAssignmentPattern && (ignoreFunctionLength || node.kind === "set")) {
	      var left = _param.get("left");

	      var right = _param.get("right");

	      var undefinedNode = scope.buildUndefinedNode();

	      if (left.isIdentifier()) {
	        body.push(buildLooseDefaultParam({
	          ASSIGNMENT_IDENTIFIER: cloneNode$i(left.node),
	          DEFAULT_VALUE: right.node,
	          UNDEFINED: undefinedNode
	        }));

	        _param.replaceWith(left.node);
	      } else if (left.isObjectPattern() || left.isArrayPattern()) {
	        var paramName = scope.generateUidIdentifier();
	        body.push(buildLooseDestructuredDefaultParam({
	          ASSIGNMENT_IDENTIFIER: left.node,
	          DEFAULT_VALUE: right.node,
	          PARAMETER_NAME: cloneNode$i(paramName),
	          UNDEFINED: undefinedNode
	        }));

	        _param.replaceWith(paramName);
	      }
	    } else if (paramIsAssignmentPattern) {
	      if (firstOptionalIndex === null) firstOptionalIndex = i;

	      var _left = _param.get("left");

	      var _right = _param.get("right");

	      var defNode = buildDefaultParam({
	        VARIABLE_NAME: _left.node,
	        DEFAULT_VALUE: _right.node,
	        ARGUMENT_KEY: numericLiteral$8(i)
	      });
	      body.push(defNode);
	    } else if (firstOptionalIndex !== null) {
	      var _defNode = buildSafeArgumentsAccess([_param.node, numericLiteral$8(i)]);

	      body.push(_defNode);
	    } else if (_param.isObjectPattern() || _param.isArrayPattern()) {
	      var uid = path.scope.generateUidIdentifier("ref");

	      var _defNode2 = variableDeclaration$8("let", [variableDeclarator$8(_param.node, uid)]);

	      body.push(_defNode2);

	      _param.replaceWith(cloneNode$i(uid));
	    }

	    if (transformedRestNodes) {
	      for (var _iterator3 = _createForOfIteratorHelperLoose(transformedRestNodes), _step3; !(_step3 = _iterator3()).done;) {
	        var transformedNode = _step3.value;
	        body.push(transformedNode);
	      }
	    }
	  }

	  if (firstOptionalIndex !== null) {
	    node.params = node.params.slice(0, firstOptionalIndex);
	  }

	  path.ensureBlock();

	  if (state.needsOuterBinding || shadowedParams.size > 0) {
	    body.push(buildScopeIIFE(shadowedParams, path.get("body").node));
	    path.set("body", blockStatement$6(body));
	    var bodyPath = path.get("body.body");
	    var arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
	    arrowPath.arrowFunctionToExpression();
	    arrowPath.node.generator = path.node.generator;
	    arrowPath.node.async = path.node.async;
	    path.node.generator = false;
	  } else {
	    path.get("body").unshiftContainer("body", body);
	  }

	  return true;
	}

	function buildScopeIIFE(shadowedParams, body) {
	  var args = [];
	  var params = [];

	  for (var _iterator5 = _createForOfIteratorHelperLoose(shadowedParams), _step5; !(_step5 = _iterator5()).done;) {
	    var name = _step5.value;
	    args.push(identifier$j(name));
	    params.push(identifier$j(name));
	  }

	  return returnStatement$3(callExpression$e(arrowFunctionExpression$4(params, body), args));
	}

	var buildRest = template$2("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
	var restIndex = template$2("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
	var restIndexImpure = template$2("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
	var restLength = template$2("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

	function referencesRest(path, state) {
	  if (path.node.name === state.name) {
	    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
	  }

	  return false;
	}

	var memberExpressionOptimisationVisitor = {
	  Scope: function Scope(path, state) {
	    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
	      path.skip();
	    }
	  },
	  Flow: function Flow(path) {
	    if (path.isTypeCastExpression()) return;
	    path.skip();
	  },
	  Function: function Function(path, state) {
	    var oldNoOptimise = state.noOptimise;
	    state.noOptimise = true;
	    path.traverse(memberExpressionOptimisationVisitor, state);
	    state.noOptimise = oldNoOptimise;
	    path.skip();
	  },
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    var node = path.node;

	    if (node.name === "arguments") {
	      state.deopted = true;
	    }

	    if (!referencesRest(path, state)) return;

	    if (state.noOptimise) {
	      state.deopted = true;
	    } else {
	      var parentPath = path.parentPath;

	      if (parentPath.listKey === "params" && parentPath.key < state.offset) {
	        return;
	      }

	      if (parentPath.isMemberExpression({
	        object: node
	      })) {
	        var grandparentPath = parentPath.parentPath;
	        var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
	          operator: "delete"
	        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

	        if (argsOptEligible) {
	          if (parentPath.node.computed) {
	            if (parentPath.get("property").isBaseType("number")) {
	              state.candidates.push({
	                cause: "indexGetter",
	                path: path
	              });
	              return;
	            }
	          } else if (parentPath.node.property.name === "length") {
	            state.candidates.push({
	              cause: "lengthGetter",
	              path: path
	            });
	            return;
	          }
	        }
	      }

	      if (state.offset === 0 && parentPath.isSpreadElement()) {
	        var call = parentPath.parentPath;

	        if (call.isCallExpression() && call.node.arguments.length === 1) {
	          state.candidates.push({
	            cause: "argSpread",
	            path: path
	          });
	          return;
	        }
	      }

	      state.references.push(path);
	    }
	  },
	  BindingIdentifier: function BindingIdentifier(path, state) {
	    if (referencesRest(path, state)) {
	      state.deopted = true;
	    }
	  }
	};

	function getParamsCount(node) {
	  var count = node.params.length;

	  if (count > 0 && isIdentifier$g(node.params[0], {
	    name: "this"
	  })) {
	    count -= 1;
	  }

	  return count;
	}

	function hasRest(node) {
	  var length = node.params.length;
	  return length > 0 && isRestElement$2(node.params[length - 1]);
	}

	function optimiseIndexGetter(path, argsId, offset) {
	  var offsetLiteral = numericLiteral$8(offset);
	  var index;

	  if (isNumericLiteral(path.parent.property)) {
	    index = numericLiteral$8(path.parent.property.value + offset);
	  } else if (offset === 0) {
	    index = path.parent.property;
	  } else {
	    index = binaryExpression$4("+", path.parent.property, cloneNode$i(offsetLiteral));
	  }

	  var scope = path.scope;

	  if (!scope.isPure(index)) {
	    var temp = scope.generateUidIdentifierBasedOnNode(index);
	    scope.push({
	      id: temp,
	      kind: "var"
	    });
	    path.parentPath.replaceWith(restIndexImpure({
	      ARGUMENTS: argsId,
	      OFFSET: offsetLiteral,
	      INDEX: index,
	      REF: cloneNode$i(temp)
	    }));
	  } else {
	    var parentPath = path.parentPath;
	    parentPath.replaceWith(restIndex({
	      ARGUMENTS: argsId,
	      OFFSET: offsetLiteral,
	      INDEX: index
	    }));
	    var offsetTestPath = parentPath.get("test").get("left");
	    var valRes = offsetTestPath.evaluate();

	    if (valRes.confident) {
	      if (valRes.value === true) {
	        parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
	      } else {
	        parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
	      }
	    }
	  }
	}

	function optimiseLengthGetter(path, argsId, offset) {
	  if (offset) {
	    path.parentPath.replaceWith(restLength({
	      ARGUMENTS: argsId,
	      OFFSET: numericLiteral$8(offset)
	    }));
	  } else {
	    path.replaceWith(argsId);
	  }
	}

	function convertFunctionRest(path) {
	  var _state$references;

	  var node = path.node,
	      scope = path.scope;
	  if (!hasRest(node)) return false;
	  var rest = node.params.pop().argument;
	  if (rest.name === "arguments") scope.rename(rest.name);
	  var argsId = identifier$j("arguments");

	  if (isPattern(rest)) {
	    var pattern = rest;
	    rest = scope.generateUidIdentifier("ref");
	    var declar = variableDeclaration$8("let", [variableDeclarator$8(pattern, rest)]);
	    node.body.body.unshift(declar);
	  }

	  var paramsCount = getParamsCount(node);
	  var state = {
	    references: [],
	    offset: paramsCount,
	    argumentsNode: argsId,
	    outerBinding: scope.getBindingIdentifier(rest.name),
	    candidates: [],
	    name: rest.name,
	    deopted: false
	  };
	  path.traverse(memberExpressionOptimisationVisitor, state);

	  if (!state.deopted && !state.references.length) {
	    for (var _iterator = _createForOfIteratorHelperLoose(state.candidates), _step; !(_step = _iterator()).done;) {
	      var _step$value = _step.value,
	          _path = _step$value.path,
	          cause = _step$value.cause;
	      var clonedArgsId = cloneNode$i(argsId);

	      switch (cause) {
	        case "indexGetter":
	          optimiseIndexGetter(_path, clonedArgsId, state.offset);
	          break;

	        case "lengthGetter":
	          optimiseLengthGetter(_path, clonedArgsId, state.offset);
	          break;

	        default:
	          _path.replaceWith(clonedArgsId);

	      }
	    }

	    return true;
	  }

	  (_state$references = state.references).push.apply(_state$references, _toConsumableArray(state.candidates.map(function (_ref) {
	    var path = _ref.path;
	    return path;
	  })));

	  var start = numericLiteral$8(paramsCount);
	  var key = scope.generateUidIdentifier("key");
	  var len = scope.generateUidIdentifier("len");
	  var arrKey, arrLen;

	  if (paramsCount) {
	    arrKey = binaryExpression$4("-", cloneNode$i(key), cloneNode$i(start));
	    arrLen = conditionalExpression$3(binaryExpression$4(">", cloneNode$i(len), cloneNode$i(start)), binaryExpression$4("-", cloneNode$i(len), cloneNode$i(start)), numericLiteral$8(0));
	  } else {
	    arrKey = identifier$j(key.name);
	    arrLen = identifier$j(len.name);
	  }

	  var loop = buildRest({
	    ARGUMENTS: argsId,
	    ARRAY_KEY: arrKey,
	    ARRAY_LEN: arrLen,
	    START: start,
	    ARRAY: rest,
	    KEY: key,
	    LEN: len
	  });

	  if (state.deopted) {
	    node.body.body.unshift(loop);
	  } else {
	    var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
	    target.findParent(function (path) {
	      if (path.isLoop()) {
	        target = path;
	      } else {
	        return path.isFunction();
	      }
	    });
	    target.insertBefore(loop);
	  }

	  return true;
	}

	var _transformParameters = declare(function (api, options) {
	  var _api$assumption;

	  api.assertVersion(7);
	  var ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose;
	  var noNewArrows = api.assumption("noNewArrows");
	  return {
	    name: "transform-parameters",
	    visitor: {
	      Function: function Function(path) {
	        if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
	          return param.isRestElement() || param.isAssignmentPattern();
	        })) {
	          path.arrowFunctionToExpression({
	            noNewArrows: noNewArrows
	          });
	          if (!path.isFunctionExpression()) return;
	        }

	        var convertedRest = convertFunctionRest(path);
	        var convertedParams = convertFunctionParams(path, ignoreFunctionLength);

	        if (convertedRest || convertedParams) {
	          path.scope.crawl();
	        }
	      }
	    }
	  };
	});

	var require$$0$4 = {
		"es6.array.copy-within": {
		chrome: "45",
		opera: "32",
		edge: "12",
		firefox: "32",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.31"
	},
		"es6.array.every": {
		chrome: "5",
		opera: "10.10",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.fill": {
		chrome: "45",
		opera: "32",
		edge: "12",
		firefox: "31",
		safari: "7.1",
		node: "4",
		ios: "8",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.31"
	},
		"es6.array.filter": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.array.find": {
		chrome: "45",
		opera: "32",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "4",
		ios: "8",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.31"
	},
		"es6.array.find-index": {
		chrome: "45",
		opera: "32",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "4",
		ios: "8",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.31"
	},
		"es7.array.flat-map": {
		chrome: "69",
		opera: "56",
		edge: "79",
		firefox: "62",
		safari: "12",
		node: "11",
		ios: "12",
		samsung: "10",
		electron: "4.0"
	},
		"es6.array.for-each": {
		chrome: "5",
		opera: "10.10",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.from": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "36",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es7.array.includes": {
		chrome: "47",
		opera: "34",
		edge: "14",
		firefox: "43",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"es6.array.index-of": {
		chrome: "5",
		opera: "10.10",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.is-array": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "4",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.iterator": {
		chrome: "66",
		opera: "53",
		edge: "12",
		firefox: "60",
		safari: "9",
		node: "10",
		ios: "9",
		samsung: "9",
		rhino: "1.7.13",
		electron: "3.0"
	},
		"es6.array.last-index-of": {
		chrome: "5",
		opera: "10.10",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.map": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.array.of": {
		chrome: "45",
		opera: "32",
		edge: "12",
		firefox: "25",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.31"
	},
		"es6.array.reduce": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "3",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.reduce-right": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "3",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.slice": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.array.some": {
		chrome: "5",
		opera: "10.10",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.array.sort": {
		chrome: "63",
		opera: "50",
		edge: "12",
		firefox: "5",
		safari: "12",
		node: "10",
		ie: "9",
		ios: "12",
		samsung: "8",
		rhino: "1.7.13",
		electron: "3.0"
	},
		"es6.array.species": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.date.now": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "2",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.date.to-iso-string": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "3.5",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.date.to-json": {
		chrome: "5",
		opera: "12.10",
		edge: "12",
		firefox: "4",
		safari: "10",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "10",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.date.to-primitive": {
		chrome: "47",
		opera: "34",
		edge: "15",
		firefox: "44",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.36"
	},
		"es6.date.to-string": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "2",
		safari: "3.1",
		node: "0.10",
		ie: "10",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.function.bind": {
		chrome: "7",
		opera: "12",
		edge: "12",
		firefox: "4",
		safari: "5.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.function.has-instance": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "50",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.function.name": {
		chrome: "5",
		opera: "10.50",
		edge: "14",
		firefox: "2",
		safari: "4",
		node: "0.10",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.map": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.math.acosh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.asinh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.atanh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.cbrt": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.clz32": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "31",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.cosh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.expm1": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.fround": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "26",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.hypot": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "27",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.imul": {
		chrome: "30",
		opera: "17",
		edge: "12",
		firefox: "23",
		safari: "7",
		node: "0.12",
		android: "4.4",
		ios: "7",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.log1p": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.log10": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.log2": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.sign": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.sinh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.tanh": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.math.trunc": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "25",
		safari: "7.1",
		node: "0.12",
		ios: "8",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.constructor": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "36",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.number.epsilon": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "25",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		electron: "0.20"
	},
		"es6.number.is-finite": {
		chrome: "19",
		opera: "15",
		edge: "12",
		firefox: "16",
		safari: "9",
		node: "0.12",
		android: "4.1",
		ios: "9",
		samsung: "1.5",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.is-integer": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "16",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.is-nan": {
		chrome: "19",
		opera: "15",
		edge: "12",
		firefox: "15",
		safari: "9",
		node: "0.12",
		android: "4.1",
		ios: "9",
		samsung: "1.5",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.is-safe-integer": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "32",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.max-safe-integer": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "31",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.min-safe-integer": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "31",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.number.parse-float": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "25",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		electron: "0.20"
	},
		"es6.number.parse-int": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "25",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "2",
		electron: "0.20"
	},
		"es6.object.assign": {
		chrome: "49",
		opera: "36",
		edge: "13",
		firefox: "36",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.object.create": {
		chrome: "5",
		opera: "12",
		edge: "12",
		firefox: "4",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es7.object.define-getter": {
		chrome: "62",
		opera: "49",
		edge: "16",
		firefox: "48",
		safari: "9",
		node: "8.10",
		ios: "9",
		samsung: "8",
		electron: "3.0"
	},
		"es7.object.define-setter": {
		chrome: "62",
		opera: "49",
		edge: "16",
		firefox: "48",
		safari: "9",
		node: "8.10",
		ios: "9",
		samsung: "8",
		electron: "3.0"
	},
		"es6.object.define-property": {
		chrome: "5",
		opera: "12",
		edge: "12",
		firefox: "4",
		safari: "5.1",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.object.define-properties": {
		chrome: "5",
		opera: "12",
		edge: "12",
		firefox: "4",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es7.object.entries": {
		chrome: "54",
		opera: "41",
		edge: "14",
		firefox: "47",
		safari: "10.1",
		node: "7",
		ios: "10.3",
		samsung: "6",
		electron: "1.4"
	},
		"es6.object.freeze": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.get-own-property-descriptor": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es7.object.get-own-property-descriptors": {
		chrome: "54",
		opera: "41",
		edge: "15",
		firefox: "50",
		safari: "10.1",
		node: "7",
		ios: "10.3",
		samsung: "6",
		electron: "1.4"
	},
		"es6.object.get-own-property-names": {
		chrome: "40",
		opera: "27",
		edge: "12",
		firefox: "33",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.object.get-prototype-of": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es7.object.lookup-getter": {
		chrome: "62",
		opera: "49",
		edge: "79",
		firefox: "36",
		safari: "9",
		node: "8.10",
		ios: "9",
		samsung: "8",
		electron: "3.0"
	},
		"es7.object.lookup-setter": {
		chrome: "62",
		opera: "49",
		edge: "79",
		firefox: "36",
		safari: "9",
		node: "8.10",
		ios: "9",
		samsung: "8",
		electron: "3.0"
	},
		"es6.object.prevent-extensions": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.to-string": {
		chrome: "57",
		opera: "44",
		edge: "15",
		firefox: "51",
		safari: "10",
		node: "8",
		ios: "10",
		samsung: "7",
		electron: "1.7"
	},
		"es6.object.is": {
		chrome: "19",
		opera: "15",
		edge: "12",
		firefox: "22",
		safari: "9",
		node: "0.12",
		android: "4.1",
		ios: "9",
		samsung: "1.5",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.object.is-frozen": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.is-sealed": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.is-extensible": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.keys": {
		chrome: "40",
		opera: "27",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.object.seal": {
		chrome: "44",
		opera: "31",
		edge: "12",
		firefox: "35",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "4",
		rhino: "1.7.13",
		electron: "0.30"
	},
		"es6.object.set-prototype-of": {
		chrome: "34",
		opera: "21",
		edge: "12",
		firefox: "31",
		safari: "9",
		node: "0.12",
		ie: "11",
		ios: "9",
		samsung: "2",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es7.object.values": {
		chrome: "54",
		opera: "41",
		edge: "14",
		firefox: "47",
		safari: "10.1",
		node: "7",
		ios: "10.3",
		samsung: "6",
		electron: "1.4"
	},
		"es6.promise": {
		chrome: "51",
		opera: "38",
		edge: "14",
		firefox: "45",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es7.promise.finally": {
		chrome: "63",
		opera: "50",
		edge: "18",
		firefox: "58",
		safari: "11.1",
		node: "10",
		ios: "11.3",
		samsung: "8",
		electron: "3.0"
	},
		"es6.reflect.apply": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.construct": {
		chrome: "49",
		opera: "36",
		edge: "13",
		firefox: "49",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.define-property": {
		chrome: "49",
		opera: "36",
		edge: "13",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.delete-property": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.get": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.get-own-property-descriptor": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.get-prototype-of": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.has": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.is-extensible": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.own-keys": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.prevent-extensions": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.set": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.reflect.set-prototype-of": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "42",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"es6.regexp.constructor": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "40",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "1.1"
	},
		"es6.regexp.flags": {
		chrome: "49",
		opera: "36",
		edge: "79",
		firefox: "37",
		safari: "9",
		node: "6",
		ios: "9",
		samsung: "5",
		electron: "0.37"
	},
		"es6.regexp.match": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "49",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		rhino: "1.7.13",
		electron: "1.1"
	},
		"es6.regexp.replace": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "49",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "1.1"
	},
		"es6.regexp.split": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "49",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "1.1"
	},
		"es6.regexp.search": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "49",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		rhino: "1.7.13",
		electron: "1.1"
	},
		"es6.regexp.to-string": {
		chrome: "50",
		opera: "37",
		edge: "79",
		firefox: "39",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "1.1"
	},
		"es6.set": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.symbol": {
		chrome: "51",
		opera: "38",
		edge: "79",
		firefox: "51",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es7.symbol.async-iterator": {
		chrome: "63",
		opera: "50",
		edge: "79",
		firefox: "57",
		safari: "12",
		node: "10",
		ios: "12",
		samsung: "8",
		electron: "3.0"
	},
		"es6.string.anchor": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.big": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.blink": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.bold": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.code-point-at": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "29",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.ends-with": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "29",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.fixed": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.fontcolor": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.fontsize": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.from-code-point": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "29",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.includes": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "40",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.italics": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.iterator": {
		chrome: "38",
		opera: "25",
		edge: "12",
		firefox: "36",
		safari: "9",
		node: "0.12",
		ios: "9",
		samsung: "3",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.string.link": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es7.string.pad-start": {
		chrome: "57",
		opera: "44",
		edge: "15",
		firefox: "48",
		safari: "10",
		node: "8",
		ios: "10",
		samsung: "7",
		rhino: "1.7.13",
		electron: "1.7"
	},
		"es7.string.pad-end": {
		chrome: "57",
		opera: "44",
		edge: "15",
		firefox: "48",
		safari: "10",
		node: "8",
		ios: "10",
		samsung: "7",
		rhino: "1.7.13",
		electron: "1.7"
	},
		"es6.string.raw": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "34",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		electron: "0.21"
	},
		"es6.string.repeat": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "24",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.small": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.starts-with": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "29",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		rhino: "1.7.13",
		electron: "0.21"
	},
		"es6.string.strike": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.sub": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.sup": {
		chrome: "5",
		opera: "15",
		edge: "12",
		firefox: "17",
		safari: "6",
		node: "0.10",
		android: "4",
		ios: "7",
		phantom: "2",
		samsung: "1",
		electron: "0.20"
	},
		"es6.string.trim": {
		chrome: "5",
		opera: "10.50",
		edge: "12",
		firefox: "3.5",
		safari: "4",
		node: "0.10",
		ie: "9",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es7.string.trim-left": {
		chrome: "66",
		opera: "53",
		edge: "79",
		firefox: "61",
		safari: "12",
		node: "10",
		ios: "12",
		samsung: "9",
		rhino: "1.7.13",
		electron: "3.0"
	},
		"es7.string.trim-right": {
		chrome: "66",
		opera: "53",
		edge: "79",
		firefox: "61",
		safari: "12",
		node: "10",
		ios: "12",
		samsung: "9",
		rhino: "1.7.13",
		electron: "3.0"
	},
		"es6.typed.array-buffer": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.data-view": {
		chrome: "5",
		opera: "12",
		edge: "12",
		firefox: "15",
		safari: "5.1",
		node: "0.10",
		ie: "10",
		android: "4",
		ios: "6",
		phantom: "2",
		samsung: "1",
		rhino: "1.7.13",
		electron: "0.20"
	},
		"es6.typed.int8-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.uint8-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.uint8-clamped-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.int16-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.uint16-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.int32-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.uint32-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.float32-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.typed.float64-array": {
		chrome: "51",
		opera: "38",
		edge: "13",
		firefox: "48",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"es6.weak-map": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "9",
		node: "6.5",
		ios: "9",
		samsung: "5",
		electron: "1.2"
	},
		"es6.weak-set": {
		chrome: "51",
		opera: "38",
		edge: "15",
		firefox: "53",
		safari: "9",
		node: "6.5",
		ios: "9",
		samsung: "5",
		electron: "1.2"
	}
	};

	var corejs2BuiltIns = require$$0$4;

	var isObjectProperty$2 = isObjectProperty$4;
	function shouldStoreRHSInTemporaryVariable(node) {
	  if (isArrayPattern(node)) {
	    var nonNullElements = node.elements.filter(function (element) {
	      return element !== null;
	    });
	    if (nonNullElements.length > 1) return true;else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
	  } else if (isObjectPattern$1(node)) {
	    var properties = node.properties;
	    if (properties.length > 1) return true;else if (properties.length === 0) return false;else {
	      var firstProperty = properties[0];

	      if (isObjectProperty$2(firstProperty)) {
	        return shouldStoreRHSInTemporaryVariable(firstProperty.value);
	      } else {
	        return shouldStoreRHSInTemporaryVariable(firstProperty);
	      }
	    }
	  } else if (isAssignmentPattern$4(node)) {
	    return shouldStoreRHSInTemporaryVariable(node.left);
	  } else if (isRestElement$2(node)) {
	    if (isIdentifier$g(node.argument)) return true;
	    return shouldStoreRHSInTemporaryVariable(node.argument);
	  } else {
	    return false;
	  }
	}

	var isAssignmentPattern = isAssignmentPattern$4,
	    isObjectProperty$1 = isObjectProperty$4;
	{
	  var node = identifier$j("a");
	  var property = objectProperty$2(identifier$j("key"), node);
	  var pattern = objectPattern([property]);
	  var ZERO_REFS = isReferenced$2(node, property, pattern) ? 1 : 0;
	}
	var _proposalObjectRestSpread = declare(function (api, opts) {
	  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;

	  api.assertVersion(7);
	  var targets = api.targets();
	  var supportsObjectAssign = !isRequired("es6.object.assign", targets, {
	    compatData: corejs2BuiltIns
	  });
	  var _opts$useBuiltIns = opts.useBuiltIns,
	      useBuiltIns = _opts$useBuiltIns === void 0 ? supportsObjectAssign : _opts$useBuiltIns,
	      _opts$loose = opts.loose,
	      loose = _opts$loose === void 0 ? false : _opts$loose;

	  if (typeof loose !== "boolean") {
	    throw new Error(".loose must be a boolean, or undefined");
	  }

	  var ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose;
	  var objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose;
	  var pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose;
	  var setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;

	  function getExtendsHelper(file) {
	    return useBuiltIns ? memberExpression$b(identifier$j("Object"), identifier$j("assign")) : file.addHelper("extends");
	  }

	  function hasRestElement(path) {
	    var foundRestElement = false;
	    visitRestElements(path, function (restElement) {
	      foundRestElement = true;
	      restElement.stop();
	    });
	    return foundRestElement;
	  }

	  function hasObjectPatternRestElement(path) {
	    var foundRestElement = false;
	    visitRestElements(path, function (restElement) {
	      if (restElement.parentPath.isObjectPattern()) {
	        foundRestElement = true;
	        restElement.stop();
	      }
	    });
	    return foundRestElement;
	  }

	  function visitRestElements(path, visitor) {
	    path.traverse({
	      Expression: function Expression(path) {
	        var parent = path.parent,
	            key = path.key;

	        if (isAssignmentPattern(parent) && key === "right" || isObjectProperty$1(parent) && parent.computed && key === "key") {
	          path.skip();
	        }
	      },
	      RestElement: visitor
	    });
	  }

	  function hasSpread(node) {
	    for (var _iterator = _createForOfIteratorHelperLoose(node.properties), _step; !(_step = _iterator()).done;) {
	      var prop = _step.value;

	      if (isSpreadElement$1(prop)) {
	        return true;
	      }
	    }

	    return false;
	  }

	  function extractNormalizedKeys(node) {
	    var props = node.properties;
	    var keys = [];
	    var allLiteral = true;
	    var hasTemplateLiteral = false;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
	      var prop = _step2.value;

	      if (isIdentifier$g(prop.key) && !prop.computed) {
	        keys.push(stringLiteral$8(prop.key.name));
	      } else if (isTemplateLiteral$2(prop.key)) {
	        keys.push(cloneNode$i(prop.key));
	        hasTemplateLiteral = true;
	      } else if (isLiteral$7(prop.key)) {
	        keys.push(stringLiteral$8(String(prop.key.value)));
	      } else {
	        keys.push(cloneNode$i(prop.key));
	        allLiteral = false;
	      }
	    }

	    return {
	      keys: keys,
	      allLiteral: allLiteral,
	      hasTemplateLiteral: hasTemplateLiteral
	    };
	  }

	  function replaceImpureComputedKeys(properties, scope) {
	    var impureComputedPropertyDeclarators = [];

	    for (var _iterator3 = _createForOfIteratorHelperLoose(properties), _step3; !(_step3 = _iterator3()).done;) {
	      var propPath = _step3.value;
	      var key = propPath.get("key");

	      if (propPath.node.computed && !key.isPure()) {
	        var name = scope.generateUidBasedOnNode(key.node);
	        var declarator = variableDeclarator$8(identifier$j(name), key.node);
	        impureComputedPropertyDeclarators.push(declarator);
	        key.replaceWith(identifier$j(name));
	      }
	    }

	    return impureComputedPropertyDeclarators;
	  }

	  function removeUnusedExcludedKeys(path) {
	    var bindings = path.getOuterBindingIdentifierPaths();
	    Object.keys(bindings).forEach(function (bindingName) {
	      var bindingParentPath = bindings[bindingName].parentPath;

	      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
	        return;
	      }

	      bindingParentPath.remove();
	    });
	  }

	  function createObjectRest(path, file, objRef) {
	    var props = path.get("properties");
	    var last = props[props.length - 1];
	    assertRestElement(last.node);
	    var restElement = cloneNode$i(last.node);
	    last.remove();
	    var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

	    var _extractNormalizedKey = extractNormalizedKeys(path.node),
	        keys = _extractNormalizedKey.keys,
	        allLiteral = _extractNormalizedKey.allLiteral,
	        hasTemplateLiteral = _extractNormalizedKey.hasTemplateLiteral;

	    if (keys.length === 0) {
	      return [impureComputedPropertyDeclarators, restElement.argument, callExpression$e(getExtendsHelper(file), [objectExpression$4([]), cloneNode$i(objRef)])];
	    }

	    var keyExpression;

	    if (!allLiteral) {
	      keyExpression = callExpression$e(memberExpression$b(arrayExpression$2(keys), identifier$j("map")), [file.addHelper("toPropertyKey")]);
	    } else {
	      keyExpression = arrayExpression$2(keys);

	      if (!hasTemplateLiteral && !isProgram$2(path.scope.block)) {
	        var program = path.findParent(function (path) {
	          return path.isProgram();
	        });
	        var id = path.scope.generateUidIdentifier("excluded");
	        program.scope.push({
	          id: id,
	          init: keyExpression,
	          kind: "const"
	        });
	        keyExpression = cloneNode$i(id);
	      }
	    }

	    return [impureComputedPropertyDeclarators, restElement.argument, callExpression$e(file.addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [cloneNode$i(objRef), keyExpression])];
	  }

	  function replaceRestElement(parentPath, paramPath, container) {
	    if (paramPath.isAssignmentPattern()) {
	      replaceRestElement(parentPath, paramPath.get("left"), container);
	      return;
	    }

	    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
	      var elements = paramPath.get("elements");

	      for (var i = 0; i < elements.length; i++) {
	        replaceRestElement(parentPath, elements[i], container);
	      }
	    }

	    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
	      var uid = parentPath.scope.generateUidIdentifier("ref");
	      var declar = variableDeclaration$8("let", [variableDeclarator$8(paramPath.node, uid)]);

	      if (container) {
	        container.push(declar);
	      } else {
	        parentPath.ensureBlock();
	        parentPath.get("body").unshiftContainer("body", declar);
	      }

	      paramPath.replaceWith(cloneNode$i(uid));
	    }
	  }

	  return {
	    name: "proposal-object-rest-spread",
	    inherits: lib$i["default"],
	    visitor: {
	      Function: function Function(path) {
	        var params = path.get("params");
	        var paramsWithRestElement = new Set();
	        var idsInRestParams = new Set();

	        for (var _i = 0; _i < params.length; ++_i) {
	          var param = params[_i];

	          if (hasRestElement(param)) {
	            paramsWithRestElement.add(_i);

	            for (var _i2 = 0, _Object$keys = Object.keys(param.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
	              var name = _Object$keys[_i2];
	              idsInRestParams.add(name);
	            }
	          }
	        }

	        var idInRest = false;

	        var IdentifierHandler = function IdentifierHandler(path, functionScope) {
	          var name = path.node.name;

	          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
	            idInRest = true;
	            path.stop();
	          }
	        };

	        var i;

	        for (i = 0; i < params.length && !idInRest; ++i) {
	          var _param = params[i];

	          if (!paramsWithRestElement.has(i)) {
	            if (_param.isReferencedIdentifier() || _param.isBindingIdentifier()) {
	              IdentifierHandler(path, path.scope);
	            } else {
	              _param.traverse({
	                "Scope|TypeAnnotation|TSTypeAnnotation": function ScopeTypeAnnotationTSTypeAnnotation(path) {
	                  return path.skip();
	                },
	                "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
	              }, path.scope);
	            }
	          }
	        }

	        if (!idInRest) {
	          for (var _i3 = 0; _i3 < params.length; ++_i3) {
	            var _param2 = params[_i3];

	            if (paramsWithRestElement.has(_i3)) {
	              replaceRestElement(path, _param2);
	            }
	          }
	        } else {
	          var shouldTransformParam = function shouldTransformParam(idx) {
	            return idx >= i - 1 || paramsWithRestElement.has(idx);
	          };

	          convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
	        }
	      },
	      VariableDeclarator: function (_VariableDeclarator) {
	        function VariableDeclarator(_x, _x2) {
	          return _VariableDeclarator.apply(this, arguments);
	        }

	        VariableDeclarator.toString = function () {
	          return _VariableDeclarator.toString();
	        };

	        return VariableDeclarator;
	      }(function (path, file) {
	        if (!path.get("id").isObjectPattern()) {
	          return;
	        }

	        var insertionPath = path;
	        var originalPath = path;
	        visitRestElements(path.get("id"), function (path) {
	          if (!path.parentPath.isObjectPattern()) {
	            return;
	          }

	          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !isIdentifier$g(originalPath.node.init)) {
	            var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
	            originalPath.insertBefore(variableDeclarator$8(initRef, originalPath.node.init));
	            originalPath.replaceWith(variableDeclarator$8(originalPath.node.id, cloneNode$i(initRef)));
	            return;
	          }

	          var ref = originalPath.node.init;
	          var refPropertyPath = [];
	          var kind;
	          path.findParent(function (path) {
	            if (path.isObjectProperty()) {
	              refPropertyPath.unshift(path);
	            } else if (path.isVariableDeclarator()) {
	              kind = path.parentPath.node.kind;
	              return true;
	            }
	          });
	          var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
	          refPropertyPath.forEach(function (prop) {
	            var node = prop.node;
	            ref = memberExpression$b(ref, cloneNode$i(node.key), node.computed || isLiteral$7(node.key));
	          });
	          var objectPatternPath = path.findParent(function (path) {
	            return path.isObjectPattern();
	          });

	          var _createObjectRest = createObjectRest(objectPatternPath, file, ref),
	              _createObjectRest2 = _slicedToArray$1(_createObjectRest, 3),
	              impureComputedPropertyDeclarators = _createObjectRest2[0],
	              argument = _createObjectRest2[1],
	              callExpression = _createObjectRest2[2];

	          if (pureGetters) {
	            removeUnusedExcludedKeys(objectPatternPath);
	          }

	          assertIdentifier(argument);
	          insertionPath.insertBefore(impureComputedPropertyDeclarators);
	          insertionPath.insertBefore(impureObjRefComputedDeclarators);
	          insertionPath = insertionPath.insertAfter(variableDeclarator$8(argument, callExpression))[0];
	          path.scope.registerBinding(kind, insertionPath);

	          if (objectPatternPath.node.properties.length === 0) {
	            objectPatternPath.findParent(function (path) {
	              return path.isObjectProperty() || path.isVariableDeclarator();
	            }).remove();
	          }
	        });
	      }),
	      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
	        var declaration = path.get("declaration");
	        if (!declaration.isVariableDeclaration()) return;
	        var hasRest = declaration.get("declarations").some(function (path) {
	          return hasObjectPatternRestElement(path.get("id"));
	        });
	        if (!hasRest) return;
	        var specifiers = [];

	        for (var _i4 = 0, _Object$keys2 = Object.keys(path.getOuterBindingIdentifiers(true)); _i4 < _Object$keys2.length; _i4++) {
	          var name = _Object$keys2[_i4];
	          specifiers.push(exportSpecifier$2(identifier$j(name), identifier$j(name)));
	        }

	        path.replaceWith(declaration.node);
	        path.insertAfter(exportNamedDeclaration$2(null, specifiers));
	      },
	      CatchClause: function CatchClause(path) {
	        var paramPath = path.get("param");
	        replaceRestElement(path, paramPath);
	      },
	      AssignmentExpression: function AssignmentExpression(path, file) {
	        var leftPath = path.get("left");

	        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
	          var nodes = [];
	          var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
	          nodes.push(variableDeclaration$8("var", [variableDeclarator$8(identifier$j(refName), path.node.right)]));

	          var _createObjectRest3 = createObjectRest(leftPath, file, identifier$j(refName)),
	              _createObjectRest4 = _slicedToArray$1(_createObjectRest3, 3),
	              impureComputedPropertyDeclarators = _createObjectRest4[0],
	              argument = _createObjectRest4[1],
	              callExpression = _createObjectRest4[2];

	          if (impureComputedPropertyDeclarators.length > 0) {
	            nodes.push(variableDeclaration$8("var", impureComputedPropertyDeclarators));
	          }

	          var nodeWithoutSpread = cloneNode$i(path.node);
	          nodeWithoutSpread.right = identifier$j(refName);
	          nodes.push(expressionStatement$a(nodeWithoutSpread));
	          nodes.push(toStatement(assignmentExpression$c("=", argument, callExpression)));
	          nodes.push(expressionStatement$a(identifier$j(refName)));
	          path.replaceWithMultiple(nodes);
	        }
	      },
	      ForXStatement: function ForXStatement(path) {
	        var node = path.node,
	            scope = path.scope;
	        var leftPath = path.get("left");
	        var left = node.left;

	        if (!hasObjectPatternRestElement(leftPath)) {
	          return;
	        }

	        if (!isVariableDeclaration$3(left)) {
	          var temp = scope.generateUidIdentifier("ref");
	          node.left = variableDeclaration$8("var", [variableDeclarator$8(temp)]);
	          path.ensureBlock();
	          var body = node.body;

	          if (body.body.length === 0 && path.isCompletionRecord()) {
	            body.body.unshift(expressionStatement$a(scope.buildUndefinedNode()));
	          }

	          body.body.unshift(expressionStatement$a(assignmentExpression$c("=", left, cloneNode$i(temp))));
	        } else {
	          var _pattern = left.declarations[0].id;
	          var key = scope.generateUidIdentifier("ref");
	          node.left = variableDeclaration$8(left.kind, [variableDeclarator$8(key, null)]);
	          path.ensureBlock();
	          var _body = node.body;

	          _body.body.unshift(variableDeclaration$8(node.left.kind, [variableDeclarator$8(_pattern, cloneNode$i(key))]));
	        }
	      },
	      ArrayPattern: function ArrayPattern(path) {
	        var objectPatterns = [];
	        visitRestElements(path, function (path) {
	          if (!path.parentPath.isObjectPattern()) {
	            return;
	          }

	          var objectPattern = path.parentPath;
	          var uid = path.scope.generateUidIdentifier("ref");
	          objectPatterns.push(variableDeclarator$8(objectPattern.node, uid));
	          objectPattern.replaceWith(cloneNode$i(uid));
	          path.skip();
	        });

	        if (objectPatterns.length > 0) {
	          var statementPath = path.getStatementParent();
	          var statementNode = statementPath.node;
	          var kind = statementNode.type === "VariableDeclaration" ? statementNode.kind : "var";
	          statementPath.insertAfter(variableDeclaration$8(kind, objectPatterns));
	        }
	      },
	      ObjectExpression: function ObjectExpression(path, file) {
	        if (!hasSpread(path.node)) return;
	        var helper;

	        if (setSpreadProperties) {
	          helper = getExtendsHelper(file);
	        } else {
	          try {
	            helper = file.addHelper("objectSpread2");
	          } catch (_unused) {
	            this.file.declarations["objectSpread2"] = null;
	            helper = file.addHelper("objectSpread");
	          }
	        }

	        var exp = null;
	        var props = [];

	        function make() {
	          var hadProps = props.length > 0;
	          var obj = objectExpression$4(props);
	          props = [];

	          if (!exp) {
	            exp = callExpression$e(helper, [obj]);
	            return;
	          }

	          if (pureGetters) {
	            if (hadProps) {
	              exp.arguments.push(obj);
	            }

	            return;
	          }

	          exp = callExpression$e(cloneNode$i(helper), [exp].concat(_toConsumableArray(hadProps ? [objectExpression$4([]), obj] : [])));
	        }

	        for (var _iterator4 = _createForOfIteratorHelperLoose(path.node.properties), _step4; !(_step4 = _iterator4()).done;) {
	          var prop = _step4.value;

	          if (isSpreadElement$1(prop)) {
	            make();
	            exp.arguments.push(prop.argument);
	          } else {
	            props.push(prop);
	          }
	        }

	        if (props.length) make();
	        path.replaceWith(exp);
	      }
	    }
	  };
	});

	var lib$h = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-optional-catch-binding",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("optionalCatchBinding");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-optional-catch-binding/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

	var _proposalOptionalCatchBinding = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-optional-catch-binding",
	    inherits: lib$h["default"],
	    visitor: {
	      CatchClause: function CatchClause(path) {
	        if (!path.node.param) {
	          var uid = path.scope.generateUidIdentifier("unused");
	          var paramPath = path.get("param");
	          paramPath.replaceWith(uid);
	        }
	      }
	    }
	  };
	});

	var lib$g = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-optional-chaining",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("optionalChaining");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-optional-chaining/node_modules/@babel/plugin-syntax-optional-chaining/lib");

	var isParenthesizedExpression = isParenthesizedExpression$1,
	    isTSAsExpression = isTSAsExpression$2,
	    isTSNonNullExpression = isTSNonNullExpression$2,
	    isTSTypeAssertion = isTSTypeAssertion$2,
	    isTypeCastExpression = isTypeCastExpression$1;
	function isTransparentExprWrapper(node) {
	  return isTSAsExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
	}
	function skipTransparentExprWrappers(path) {
	  while (isTransparentExprWrapper(path.node)) {
	    path = path.get("expression");
	  }

	  return path;
	}
	function skipTransparentExprWrapperNodes(node) {
	  while (isTransparentExprWrapper(node)) {
	    node = node.expression;
	  }

	  return node;
	}

	function willPathCastToBoolean(path) {
	  var maybeWrapped = findOutermostTransparentParent(path);
	  var node = maybeWrapped.node,
	      parentPath = maybeWrapped.parentPath;

	  if (parentPath.isLogicalExpression()) {
	    var _parentPath$node = parentPath.node,
	        operator = _parentPath$node.operator,
	        right = _parentPath$node.right;

	    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
	      return willPathCastToBoolean(parentPath);
	    }
	  }

	  if (parentPath.isSequenceExpression()) {
	    var expressions = parentPath.node.expressions;

	    if (expressions[expressions.length - 1] === node) {
	      return willPathCastToBoolean(parentPath);
	    } else {
	      return true;
	    }
	  }

	  return parentPath.isConditional({
	    test: node
	  }) || parentPath.isUnaryExpression({
	    operator: "!"
	  }) || parentPath.isLoop({
	    test: node
	  });
	}
	function findOutermostTransparentParent(path) {
	  var maybeWrapped = path;
	  path.findParent(function (p) {
	    if (!isTransparentExprWrapper(p.node)) return true;
	    maybeWrapped = p;
	  });
	  return maybeWrapped;
	}

	var _templateObject$e, _templateObject2$7, _templateObject3$6, _templateObject4$2, _templateObject5$1, _templateObject6$1, _templateObject7;
	var ast = template$2.expression.ast;

	function isSimpleMemberExpression(expression) {
	  expression = skipTransparentExprWrapperNodes(expression);
	  return isIdentifier$g(expression) || isSuper$2(expression) || isMemberExpression$8(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
	}

	function needsMemoize(path) {
	  var optionalPath = path;
	  var scope = path.scope;

	  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
	    var _optionalPath = optionalPath,
	        node = _optionalPath.node;
	    var childKey = optionalPath.isOptionalMemberExpression() ? "object" : "callee";
	    var childPath = skipTransparentExprWrappers(optionalPath.get(childKey));

	    if (node.optional) {
	      return !scope.isStatic(childPath.node);
	    }

	    optionalPath = childPath;
	  }
	}

	function transform$1(path, _ref) {
	  var pureGetters = _ref.pureGetters,
	      noDocumentAll = _ref.noDocumentAll;
	  var scope = path.scope;
	  var maybeWrapped = findOutermostTransparentParent(path);
	  var parentPath = maybeWrapped.parentPath;
	  var willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);
	  var isDeleteOperation = false;
	  var parentIsCall = parentPath.isCallExpression({
	    callee: maybeWrapped.node
	  }) && path.isOptionalMemberExpression();
	  var optionals = [];
	  var optionalPath = path;

	  if (scope.path.isPattern() && needsMemoize(optionalPath)) {
	    path.replaceWith(template$2.ast(_templateObject$e || (_templateObject$e = _taggedTemplateLiteralLoose(["(() => ", ")()"])), path.node));
	    return;
	  }

	  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
	    var _optionalPath2 = optionalPath,
	        node = _optionalPath2.node;

	    if (node.optional) {
	      optionals.push(node);
	    }

	    if (optionalPath.isOptionalMemberExpression()) {
	      optionalPath.node.type = "MemberExpression";
	      optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
	    } else if (optionalPath.isOptionalCallExpression()) {
	      optionalPath.node.type = "CallExpression";
	      optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
	    }
	  }

	  var replacementPath = path;

	  if (parentPath.isUnaryExpression({
	    operator: "delete"
	  })) {
	    replacementPath = parentPath;
	    isDeleteOperation = true;
	  }

	  for (var i = optionals.length - 1; i >= 0; i--) {
	    var _node = optionals[i];
	    var isCall = isCallExpression$6(_node);
	    var replaceKey = isCall ? "callee" : "object";
	    var chainWithTypes = _node[replaceKey];
	    var chain = skipTransparentExprWrapperNodes(chainWithTypes);
	    var ref = void 0;
	    var check = void 0;

	    if (isCall && isIdentifier$g(chain, {
	      name: "eval"
	    })) {
	      check = ref = chain;
	      _node[replaceKey] = sequenceExpression$7([numericLiteral$8(0), ref]);
	    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
	      check = ref = chainWithTypes;
	    } else {
	      ref = scope.maybeGenerateMemoised(chain);

	      if (ref) {
	        check = assignmentExpression$c("=", cloneNode$i(ref), chainWithTypes);
	        _node[replaceKey] = ref;
	      } else {
	        check = ref = chainWithTypes;
	      }
	    }

	    if (isCall && isMemberExpression$8(chain)) {
	      if (pureGetters && isSimpleMemberExpression(chain)) {
	        _node.callee = chainWithTypes;
	      } else {
	        var object = chain.object;
	        var context = scope.maybeGenerateMemoised(object);

	        if (context) {
	          chain.object = assignmentExpression$c("=", context, object);
	        } else if (isSuper$2(object)) {
	          context = thisExpression$3();
	        } else {
	          context = object;
	        }

	        _node.arguments.unshift(cloneNode$i(context));

	        _node.callee = memberExpression$b(_node.callee, identifier$j("call"));
	      }
	    }

	    var replacement = replacementPath.node;

	    if (i === 0 && parentIsCall) {
	      var _baseRef;

	      var _object = skipTransparentExprWrapperNodes(replacement.object);

	      var baseRef = void 0;

	      if (!pureGetters || !isSimpleMemberExpression(_object)) {
	        baseRef = scope.maybeGenerateMemoised(_object);

	        if (baseRef) {
	          replacement.object = assignmentExpression$c("=", baseRef, _object);
	        }
	      }

	      replacement = callExpression$e(memberExpression$b(replacement, identifier$j("bind")), [cloneNode$i((_baseRef = baseRef) != null ? _baseRef : _object)]);
	    }

	    if (willReplacementCastToBoolean) {
	      var nonNullishCheck = noDocumentAll ? ast(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteralLoose(["", " != null"])), cloneNode$i(check)) : ast(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteralLoose(["\n            ", " !== null && ", " !== void 0"])), cloneNode$i(check), cloneNode$i(ref));
	      replacementPath.replaceWith(logicalExpression$2("&&", nonNullishCheck, replacement));
	      replacementPath = skipTransparentExprWrappers(replacementPath.get("right"));
	    } else {
	      var nullishCheck = noDocumentAll ? ast(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteralLoose(["", " == null"])), cloneNode$i(check)) : ast(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteralLoose(["\n            ", " === null || ", " === void 0"])), cloneNode$i(check), cloneNode$i(ref));
	      var returnValue = isDeleteOperation ? ast(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteralLoose(["true"]))) : ast(_templateObject7 || (_templateObject7 = _taggedTemplateLiteralLoose(["void 0"])));
	      replacementPath.replaceWith(conditionalExpression$3(nullishCheck, returnValue, replacement));
	      replacementPath = skipTransparentExprWrappers(replacementPath.get("alternate"));
	    }
	  }
	}

	var _proposalOptionalChaining = declare(function (api, options) {
	  var _api$assumption, _api$assumption2;

	  api.assertVersion(7);
	  var _options$loose = options.loose,
	      loose = _options$loose === void 0 ? false : _options$loose;
	  var noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
	  var pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
	  return {
	    name: "proposal-optional-chaining",
	    inherits: lib$g["default"],
	    visitor: {
	      "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
	        transform$1(path, {
	          noDocumentAll: noDocumentAll,
	          pureGetters: pureGetters
	        });
	      }
	    }
	  };
	});

	var buildOptimizedSequenceExpression = function buildOptimizedSequenceExpression(_ref) {
	  var call = _ref.call,
	      path = _ref.path,
	      placeholder = _ref.placeholder;
	  var calledExpression = call.callee;
	  var pipelineLeft = path.node.left;
	  var assign = assignmentExpression$c("=", cloneNode$i(placeholder), pipelineLeft);
	  var optimizeArrow = isArrowFunctionExpression$1(calledExpression) && isExpression$4(calledExpression.body) && !calledExpression.async && !calledExpression.generator;
	  var param;

	  if (optimizeArrow) {
	    var params = calledExpression.params;

	    if (params.length === 1 && isIdentifier$g(params[0])) {
	      param = params[0];
	    } else if (params.length > 0) {
	      optimizeArrow = false;
	    }
	  } else if (isIdentifier$g(calledExpression, {
	    name: "eval"
	  })) {
	    var evalSequence = sequenceExpression$7([numericLiteral$8(0), calledExpression]);
	    call.callee = evalSequence;
	    path.scope.push({
	      id: cloneNode$i(placeholder)
	    });
	    return sequenceExpression$7([assign, call]);
	  }

	  if (optimizeArrow && !param) {
	    return sequenceExpression$7([pipelineLeft, calledExpression.body]);
	  }

	  path.scope.push({
	    id: cloneNode$i(placeholder)
	  });

	  if (param) {
	    path.get("right").scope.rename(param.name, placeholder.name);
	    return sequenceExpression$7([assign, calledExpression.body]);
	  }

	  return sequenceExpression$7([assign, call]);
	};

	var minimalVisitor = {
	  BinaryExpression: function BinaryExpression(path) {
	    var scope = path.scope,
	        node = path.node;
	    var operator = node.operator,
	        left = node.left,
	        right = node.right;
	    if (operator !== "|>") return;
	    var placeholder = scope.generateUidIdentifierBasedOnNode(left);
	    var call = callExpression$e(right, [cloneNode$i(placeholder)]);
	    path.replaceWith(buildOptimizedSequenceExpression({
	      placeholder: placeholder,
	      call: call,
	      path: path
	    }));
	  }
	};

	var topicReferenceReplacementVisitor = {
	  TopicReference: function TopicReference(path) {
	    path.replaceWith(cloneNode$i(this.topicVariable));
	  }
	};
	var hackVisitor = {
	  BinaryExpression: {
	    exit: function exit(path) {
	      var scope = path.scope,
	          node = path.node;

	      if (node.operator !== "|>") {
	        return;
	      }

	      var topicVariable = scope.generateUidIdentifierBasedOnNode(node);
	      var pipeBodyPath = path.get("right");
	      scope.push({
	        id: topicVariable
	      });

	      if (pipeBodyPath.node.type === "TopicReference") {
	        pipeBodyPath.replaceWith(cloneNode$i(topicVariable));
	      } else {
	        pipeBodyPath.traverse(topicReferenceReplacementVisitor, {
	          topicVariable: topicVariable
	        });
	      }

	      path.replaceWith(sequenceExpression$7([assignmentExpression$c("=", cloneNode$i(topicVariable), node.left), node.right]));
	    }
	  }
	};

	var fsharpVisitor = {
	  BinaryExpression: function BinaryExpression(path) {
	    var scope = path.scope,
	        node = path.node;
	    var operator = node.operator,
	        left = node.left,
	        right = node.right;
	    if (operator !== "|>") return;
	    var placeholder = scope.generateUidIdentifierBasedOnNode(left);
	    var call = right.type === "AwaitExpression" ? awaitExpression$1(cloneNode$i(placeholder)) : callExpression$e(right, [cloneNode$i(placeholder)]);
	    var sequence = buildOptimizedSequenceExpression({
	      placeholder: placeholder,
	      call: call,
	      path: path
	    });
	    path.replaceWith(sequence);
	  }
	};

	var updateTopicReferenceVisitor = {
	  PipelinePrimaryTopicReference: function PipelinePrimaryTopicReference(path) {
	    path.replaceWith(cloneNode$i(this.topicId));
	  },
	  PipelineTopicExpression: function PipelineTopicExpression(path) {
	    path.skip();
	  }
	};
	var smartVisitor = {
	  BinaryExpression: function BinaryExpression(path) {
	    var scope = path.scope;
	    var node = path.node;
	    var operator = node.operator,
	        left = node.left,
	        right = node.right;
	    if (operator !== "|>") return;
	    var placeholder = scope.generateUidIdentifierBasedOnNode(left);
	    scope.push({
	      id: placeholder
	    });
	    var call;

	    if (isPipelineTopicExpression(right)) {
	      path.get("right").traverse(updateTopicReferenceVisitor, {
	        topicId: placeholder
	      });
	      call = right.expression;
	    } else {
	      var callee = right.callee;

	      if (isIdentifier$g(callee, {
	        name: "eval"
	      })) {
	        callee = sequenceExpression$7([numericLiteral$8(0), callee]);
	      }

	      call = callExpression$e(callee, [cloneNode$i(placeholder)]);
	    }

	    path.replaceWith(sequenceExpression$7([assignmentExpression$c("=", cloneNode$i(placeholder), left), call]));
	  }
	};

	var visitorsPerProposal = {
	  minimal: minimalVisitor,
	  hack: hackVisitor,
	  fsharp: fsharpVisitor,
	  smart: smartVisitor
	};
	var proposalPipelineOperator = declare(function (api, options) {
	  api.assertVersion(7);
	  var proposal = options.proposal;

	  if (proposal === "smart") {
	    console.warn("The smart-mix pipe operator is deprecated. Use \"proposal\": \"hack\" instead.");
	  }

	  return {
	    name: "proposal-pipeline-operator",
	    inherits: syntaxPipelineOperator,
	    visitor: visitorsPerProposal[options.proposal]
	  };
	});

	var _proposalPrivateMethods = declare(function (api, options) {
	  api.assertVersion(7);
	  return createClassFeaturePlugin({
	    name: "proposal-private-methods",
	    api: api,
	    feature: FEATURES$1.privateMethods,
	    loose: options.loose,
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("classPrivateMethods");
	    }
	  });
	});

	var lib$f = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-private-property-in-object",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("privateIn");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-plugin-proposal-private-property-in-object/node_modules/@babel/plugin-syntax-private-property-in-object/lib");

	var _templateObject$d, _templateObject2$6, _templateObject3$5, _templateObject4$1, _templateObject5, _templateObject6;
	var _proposalPrivatePropertyInObject = declare(function (_ref, _ref2) {
	  var assertVersion = _ref.assertVersion,
	      t = _ref.types,
	      template = _ref.template;
	  var loose = _ref2.loose;
	  assertVersion(7);
	  var classWeakSets = new WeakMap();
	  var fieldsWeakSets = new WeakMap();

	  function unshadow(name, targetScope, scope) {
	    while (scope !== targetScope) {
	      if (scope.hasOwnBinding(name)) scope.rename(name);
	      scope = scope.parent;
	    }
	  }

	  function injectToFieldInit(fieldPath, expr, before) {
	    if (before === void 0) {
	      before = false;
	    }

	    if (fieldPath.node.value) {
	      if (before) {
	        fieldPath.get("value").insertBefore(expr);
	      } else {
	        fieldPath.get("value").insertAfter(expr);
	      }
	    } else {
	      fieldPath.set("value", t.unaryExpression("void", expr));
	    }
	  }

	  function injectInitialization$1(classPath, init) {
	    var firstFieldPath;
	    var consturctorPath;

	    for (var _iterator = _createForOfIteratorHelperLoose(classPath.get("body.body")), _step; !(_step = _iterator()).done;) {
	      var el = _step.value;

	      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node["static"]) {
	        firstFieldPath = el;
	        break;
	      }

	      if (!consturctorPath && el.isClassMethod({
	        kind: "constructor"
	      })) {
	        consturctorPath = el;
	      }
	    }

	    if (firstFieldPath) {
	      injectToFieldInit(firstFieldPath, init, true);
	    } else {
	      injectInitialization(classPath, consturctorPath, [t.expressionStatement(init)]);
	    }
	  }

	  function getWeakSetId(weakSets, outerClass, reference, name, inject) {
	    if (name === void 0) {
	      name = "";
	    }

	    var id = classWeakSets.get(reference.node);

	    if (!id) {
	      id = outerClass.scope.generateUidIdentifier((name || "") + " brandCheck");
	      classWeakSets.set(reference.node, id);
	      inject(reference, template.expression.ast(_templateObject$d || (_templateObject$d = _taggedTemplateLiteralLoose(["", ".add(this)"])), t.cloneNode(id)));
	      var newExpr = t.newExpression(t.identifier("WeakSet"), []);
	      annotateAsPure(newExpr);
	      outerClass.insertBefore(template.ast(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteralLoose(["var ", " = ", ""])), id, newExpr));
	    }

	    return t.cloneNode(id);
	  }

	  return {
	    name: "proposal-private-property-in-object",
	    inherits: lib$f["default"],
	    pre: function pre() {
	      enableFeature$1(this.file, FEATURES$1.privateIn, loose);
	    },
	    visitor: {
	      BinaryExpression: function BinaryExpression(path) {
	        var node = path.node;
	        if (node.operator !== "in") return;
	        if (!t.isPrivateName(node.left)) return;
	        var name = node.left.id.name;
	        var privateElement;
	        var outerClass = path.findParent(function (path) {
	          if (!path.isClass()) return false;
	          privateElement = path.get("body.body").find(function (_ref3) {
	            var node = _ref3.node;
	            return t.isPrivate(node) && node.key.id.name === name;
	          });
	          return !!privateElement;
	        });

	        if (outerClass.parentPath.scope.path.isPattern()) {
	          outerClass.replaceWith(template.ast(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteralLoose(["(() => ", ")()"])), outerClass.node));
	          return;
	        }

	        if (privateElement.isMethod()) {
	          if (privateElement.node["static"]) {
	            if (outerClass.node.id) {
	              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);
	            } else {
	              outerClass.set("id", path.scope.generateUidIdentifier("class"));
	            }

	            path.replaceWith(template.expression.ast(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteralLoose(["\n                ", " === ", "\n              "])), t.cloneNode(outerClass.node.id), path.node.right));
	          } else {
	            var _outerClass$node$id;

	            var id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization$1);
	            path.replaceWith(template.expression.ast(_templateObject5 || (_templateObject5 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), id, path.node.right));
	          }
	        } else {
	          var _id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);

	          path.replaceWith(template.expression.ast(_templateObject6 || (_templateObject6 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), _id, path.node.right));
	        }
	      }
	    }
	  };
	});

	var syntaxThrowExpressions = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "syntax-throw-expressions",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("throwExpressions");
	    }
	  };
	});

	var proposalThrowExpressions = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "proposal-throw-expressions",
	    inherits: syntaxThrowExpressions,
	    visitor: {
	      UnaryExpression: function UnaryExpression(path) {
	        var _path$node = path.node,
	            operator = _path$node.operator,
	            argument = _path$node.argument;
	        if (operator !== "throw") return;
	        var arrow = functionExpression$3(null, [identifier$j("e")], blockStatement$6([throwStatement(identifier$j("e"))]));
	        path.replaceWith(callExpression$e(arrow, [argument]));
	      }
	    }
	  };
	});

	var regjsgen = createCommonjsModule(function (module, exports) {
	  (function () {

	    var objectTypes = {
	      'function': true,
	      'object': true
	    };
	    var root = objectTypes[typeof window] && window || this;
	    var freeExports = exports && !exports.nodeType && exports;
	    var hasFreeModule = module && !module.nodeType;
	    var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;

	    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
	      root = freeGlobal;
	    }

	    var hasOwnProperty = Object.prototype.hasOwnProperty;

	    function fromCodePoint() {
	      var codePoint = Number(arguments[0]);

	      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) != codePoint) {
	        throw RangeError('Invalid code point: ' + codePoint);
	      }

	      if (codePoint <= 0xFFFF) {
	        return String.fromCharCode(codePoint);
	      } else {
	        codePoint -= 0x10000;
	        var highSurrogate = (codePoint >> 10) + 0xD800;
	        var lowSurrogate = codePoint % 0x400 + 0xDC00;
	        return String.fromCharCode(highSurrogate, lowSurrogate);
	      }
	    }

	    var assertTypeRegexMap = {};

	    function assertType(type, expected) {
	      if (expected.indexOf('|') == -1) {
	        if (type == expected) {
	          return;
	        }

	        throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
	      }

	      expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

	      if (expected.test(type)) {
	        return;
	      }

	      throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
	    }

	    function generate(node) {
	      var type = node.type;

	      if (hasOwnProperty.call(generators, type)) {
	        return generators[type](node);
	      }

	      throw Error('Invalid node type: ' + type);
	    }

	    function generateSequence(generator, terms) {
	      var i = -1,
	          length = terms.length,
	          result = '',
	          term;

	      while (++i < length) {
	        term = terms[i];

	        if (i + 1 < length && terms[i].type == 'value' && terms[i].kind == 'null' && terms[i + 1].type == 'value' && terms[i + 1].kind == 'symbol' && terms[i + 1].codePoint >= 48 && terms[i + 1].codePoint <= 57) {
	          result += '\\000';
	          continue;
	        }

	        result += generator(term);
	      }

	      return result;
	    }

	    function generateAlternative(node) {
	      assertType(node.type, 'alternative');
	      return generateSequence(generateTerm, node.body);
	    }

	    function generateAnchor(node) {
	      assertType(node.type, 'anchor');

	      switch (node.kind) {
	        case 'start':
	          return '^';

	        case 'end':
	          return '$';

	        case 'boundary':
	          return '\\b';

	        case 'not-boundary':
	          return '\\B';

	        default:
	          throw Error('Invalid assertion');
	      }
	    }

	    function generateAtom(node) {
	      assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
	      return generate(node);
	    }

	    function generateCharacterClass(node) {
	      assertType(node.type, 'characterClass');
	      return '[' + (node.negative ? '^' : '') + generateSequence(generateClassAtom, node.body) + ']';
	    }

	    function generateCharacterClassEscape(node) {
	      assertType(node.type, 'characterClassEscape');
	      return '\\' + node.value;
	    }

	    function generateCharacterClassRange(node) {
	      assertType(node.type, 'characterClassRange');
	      var min = node.min,
	          max = node.max;

	      if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
	        throw Error('Invalid character class range');
	      }

	      return generateClassAtom(min) + '-' + generateClassAtom(max);
	    }

	    function generateClassAtom(node) {
	      assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
	      return generate(node);
	    }

	    function generateDisjunction(node) {
	      assertType(node.type, 'disjunction');
	      var body = node.body,
	          i = -1,
	          length = body.length,
	          result = '';

	      while (++i < length) {
	        if (i != 0) {
	          result += '|';
	        }

	        result += generate(body[i]);
	      }

	      return result;
	    }

	    function generateDot(node) {
	      assertType(node.type, 'dot');
	      return '.';
	    }

	    function generateGroup(node) {
	      assertType(node.type, 'group');
	      var result = '';

	      switch (node.behavior) {
	        case 'normal':
	          if (node.name) {
	            result += '?<' + generateIdentifier(node.name) + '>';
	          }

	          break;

	        case 'ignore':
	          result += '?:';
	          break;

	        case 'lookahead':
	          result += '?=';
	          break;

	        case 'negativeLookahead':
	          result += '?!';
	          break;

	        case 'lookbehind':
	          result += '?<=';
	          break;

	        case 'negativeLookbehind':
	          result += '?<!';
	          break;

	        default:
	          throw Error('Invalid behaviour: ' + node.behaviour);
	      }

	      result += generateSequence(generate, node.body);
	      return '(' + result + ')';
	    }

	    function generateIdentifier(node) {
	      assertType(node.type, 'identifier');
	      return node.value;
	    }

	    function generateQuantifier(node) {
	      assertType(node.type, 'quantifier');
	      var quantifier = '',
	          min = node.min,
	          max = node.max;

	      if (max == null) {
	        if (min == 0) {
	          quantifier = '*';
	        } else if (min == 1) {
	          quantifier = '+';
	        } else {
	          quantifier = '{' + min + ',}';
	        }
	      } else if (min == max) {
	        quantifier = '{' + min + '}';
	      } else if (min == 0 && max == 1) {
	        quantifier = '?';
	      } else {
	        quantifier = '{' + min + ',' + max + '}';
	      }

	      if (!node.greedy) {
	        quantifier += '?';
	      }

	      return generateAtom(node.body[0]) + quantifier;
	    }

	    function generateReference(node) {
	      assertType(node.type, 'reference');

	      if (node.matchIndex) {
	        return '\\' + node.matchIndex;
	      }

	      if (node.name) {
	        return '\\k<' + generateIdentifier(node.name) + '>';
	      }

	      throw new Error('Unknown reference type');
	    }

	    function generateTerm(node) {
	      assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
	      return generate(node);
	    }

	    function generateUnicodePropertyEscape(node) {
	      assertType(node.type, 'unicodePropertyEscape');
	      return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
	    }

	    function generateValue(node) {
	      assertType(node.type, 'value');
	      var kind = node.kind,
	          codePoint = node.codePoint;

	      if (typeof codePoint != 'number') {
	        throw new Error('Invalid code point: ' + codePoint);
	      }

	      switch (kind) {
	        case 'controlLetter':
	          return '\\c' + fromCodePoint(codePoint + 64);

	        case 'hexadecimalEscape':
	          return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

	        case 'identifier':
	          return '\\' + fromCodePoint(codePoint);

	        case 'null':
	          return '\\' + codePoint;

	        case 'octal':
	          return '\\' + ('000' + codePoint.toString(8)).slice(-3);

	        case 'singleEscape':
	          switch (codePoint) {
	            case 0x0008:
	              return '\\b';

	            case 0x0009:
	              return '\\t';

	            case 0x000A:
	              return '\\n';

	            case 0x000B:
	              return '\\v';

	            case 0x000C:
	              return '\\f';

	            case 0x000D:
	              return '\\r';

	            case 0x002D:
	              return '\\-';

	            default:
	              throw Error('Invalid code point: ' + codePoint);
	          }

	        case 'symbol':
	          return fromCodePoint(codePoint);

	        case 'unicodeEscape':
	          return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

	        case 'unicodeCodePointEscape':
	          return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

	        default:
	          throw Error('Unsupported node kind: ' + kind);
	      }
	    }

	    var generators = {
	      'alternative': generateAlternative,
	      'anchor': generateAnchor,
	      'characterClass': generateCharacterClass,
	      'characterClassEscape': generateCharacterClassEscape,
	      'characterClassRange': generateCharacterClassRange,
	      'disjunction': generateDisjunction,
	      'dot': generateDot,
	      'group': generateGroup,
	      'quantifier': generateQuantifier,
	      'reference': generateReference,
	      'unicodePropertyEscape': generateUnicodePropertyEscape,
	      'value': generateValue
	    };
	    var regjsgen = {
	      'generate': generate
	    };

	    if (freeExports && hasFreeModule) {
	      freeExports.generate = generate;
	    } else {
	      root.regjsgen = regjsgen;
	    }
	  }).call(commonjsGlobal);
	}, "/$$rollup_base$$/node_modules/regjsgen");

	var parser = createCommonjsModule(function (module) {
	  (function () {
	    var fromCodePoint = String.fromCodePoint || function () {
	      var stringFromCharCode = String.fromCharCode;
	      var floor = Math.floor;
	      return function fromCodePoint() {
	        var MAX_SIZE = 0x4000;
	        var codeUnits = [];
	        var highSurrogate;
	        var lowSurrogate;
	        var index = -1;
	        var length = arguments.length;

	        if (!length) {
	          return '';
	        }

	        var result = '';

	        while (++index < length) {
	          var codePoint = Number(arguments[index]);

	          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
	            throw RangeError('Invalid code point: ' + codePoint);
	          }

	          if (codePoint <= 0xFFFF) {
	            codeUnits.push(codePoint);
	          } else {
	            codePoint -= 0x10000;
	            highSurrogate = (codePoint >> 10) + 0xD800;
	            lowSurrogate = codePoint % 0x400 + 0xDC00;
	            codeUnits.push(highSurrogate, lowSurrogate);
	          }

	          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
	            result += stringFromCharCode.apply(null, codeUnits);
	            codeUnits.length = 0;
	          }
	        }

	        return result;
	      };
	    }();

	    function parse(str, flags, features) {
	      if (!features) {
	        features = {};
	      }

	      function addRaw(node) {
	        node.raw = str.substring(node.range[0], node.range[1]);
	        return node;
	      }

	      function updateRawStart(node, start) {
	        node.range[0] = start;
	        return addRaw(node);
	      }

	      function createAnchor(kind, rawLength) {
	        return addRaw({
	          type: 'anchor',
	          kind: kind,
	          range: [pos - rawLength, pos]
	        });
	      }

	      function createValue(kind, codePoint, from, to) {
	        return addRaw({
	          type: 'value',
	          kind: kind,
	          codePoint: codePoint,
	          range: [from, to]
	        });
	      }

	      function createEscaped(kind, codePoint, value, fromOffset) {
	        fromOffset = fromOffset || 0;
	        return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
	      }

	      function createCharacter(matches) {
	        var _char = matches[0];

	        var first = _char.charCodeAt(0);

	        if (hasUnicodeFlag) {
	          var second;

	          if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
	            second = lookahead().charCodeAt(0);

	            if (second >= 0xDC00 && second <= 0xDFFF) {
	              pos++;
	              return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
	            }
	          }
	        }

	        return createValue('symbol', first, pos - 1, pos);
	      }

	      function createDisjunction(alternatives, from, to) {
	        return addRaw({
	          type: 'disjunction',
	          body: alternatives,
	          range: [from, to]
	        });
	      }

	      function createDot() {
	        return addRaw({
	          type: 'dot',
	          range: [pos - 1, pos]
	        });
	      }

	      function createCharacterClassEscape(value) {
	        return addRaw({
	          type: 'characterClassEscape',
	          value: value,
	          range: [pos - 2, pos]
	        });
	      }

	      function createReference(matchIndex) {
	        return addRaw({
	          type: 'reference',
	          matchIndex: parseInt(matchIndex, 10),
	          range: [pos - 1 - matchIndex.length, pos]
	        });
	      }

	      function createNamedReference(name) {
	        return addRaw({
	          type: 'reference',
	          name: name,
	          range: [name.range[0] - 3, pos]
	        });
	      }

	      function createGroup(behavior, disjunction, from, to) {
	        return addRaw({
	          type: 'group',
	          behavior: behavior,
	          body: disjunction,
	          range: [from, to]
	        });
	      }

	      function createQuantifier(min, max, from, to) {
	        if (to == null) {
	          from = pos - 1;
	          to = pos;
	        }

	        return addRaw({
	          type: 'quantifier',
	          min: min,
	          max: max,
	          greedy: true,
	          body: null,
	          range: [from, to]
	        });
	      }

	      function createAlternative(terms, from, to) {
	        return addRaw({
	          type: 'alternative',
	          body: terms,
	          range: [from, to]
	        });
	      }

	      function createCharacterClass(contents, negative, from, to) {
	        return addRaw({
	          type: 'characterClass',
	          kind: contents.kind,
	          body: contents.body,
	          negative: negative,
	          range: [from, to]
	        });
	      }

	      function createClassRange(min, max, from, to) {
	        if (min.codePoint > max.codePoint) {
	          bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
	        }

	        return addRaw({
	          type: 'characterClassRange',
	          min: min,
	          max: max,
	          range: [from, to]
	        });
	      }

	      function createClassStrings(strings, from, to) {
	        return addRaw({
	          type: 'classStrings',
	          strings: strings,
	          range: [from, to]
	        });
	      }

	      function createClassString(characters, from, to) {
	        return addRaw({
	          type: 'classString',
	          characters: characters,
	          range: [from, to]
	        });
	      }

	      function flattenBody(body) {
	        if (body.type === 'alternative') {
	          return body.body;
	        } else {
	          return [body];
	        }
	      }

	      function incr(amount) {
	        amount = amount || 1;
	        var res = str.substring(pos, pos + amount);
	        pos += amount || 1;
	        return res;
	      }

	      function skip(value) {
	        if (!match(value)) {
	          bail('character', value);
	        }
	      }

	      function match(value) {
	        if (str.indexOf(value, pos) === pos) {
	          return incr(value.length);
	        }
	      }

	      function lookahead() {
	        return str[pos];
	      }

	      function current(value) {
	        return str.indexOf(value, pos) === pos;
	      }

	      function next(value) {
	        return str[pos + 1] === value;
	      }

	      function matchReg(regExp) {
	        var subStr = str.substring(pos);
	        var res = subStr.match(regExp);

	        if (res) {
	          res.range = [];
	          res.range[0] = pos;
	          incr(res[0].length);
	          res.range[1] = pos;
	        }

	        return res;
	      }

	      function parseDisjunction() {
	        var res = [],
	            from = pos;
	        res.push(parseAlternative());

	        while (match('|')) {
	          res.push(parseAlternative());
	        }

	        if (res.length === 1) {
	          return res[0];
	        }

	        return createDisjunction(res, from, pos);
	      }

	      function parseAlternative() {
	        var res = [],
	            from = pos;
	        var term;

	        while (term = parseTerm()) {
	          res.push(term);
	        }

	        if (res.length === 1) {
	          return res[0];
	        }

	        return createAlternative(res, from, pos);
	      }

	      function parseTerm() {
	        if (pos >= str.length || current('|') || current(')')) {
	          return null;
	        }

	        var anchor = parseAnchor();

	        if (anchor) {
	          return anchor;
	        }

	        var atom = parseAtomAndExtendedAtom();

	        if (!atom) {
	          pos_backup = pos;
	          var quantifier = parseQuantifier() || false;

	          if (quantifier) {
	            pos = pos_backup;
	            bail('Expected atom');
	          }

	          if (!hasUnicodeFlag && (res = matchReg(/^{/))) {
	            atom = createCharacter(res);
	          } else {
	            bail('Expected atom');
	          }
	        }

	        var quantifier = parseQuantifier() || false;

	        if (quantifier) {
	          quantifier.body = flattenBody(atom);
	          updateRawStart(quantifier, atom.range[0]);
	          return quantifier;
	        }

	        return atom;
	      }

	      function parseGroup(matchA, typeA, matchB, typeB) {
	        var type = null,
	            from = pos;

	        if (match(matchA)) {
	          type = typeA;
	        } else if (match(matchB)) {
	          type = typeB;
	        } else {
	          return false;
	        }

	        return finishGroup(type, from);
	      }

	      function finishGroup(type, from) {
	        var body = parseDisjunction();

	        if (!body) {
	          bail('Expected disjunction');
	        }

	        skip(')');
	        var group = createGroup(type, flattenBody(body), from, pos);

	        if (type == 'normal') {
	          if (firstIteration) {
	            closedCaptureCounter++;
	          }
	        }

	        return group;
	      }

	      function parseAnchor() {

	        if (match('^')) {
	          return createAnchor('start', 1);
	        } else if (match('$')) {
	          return createAnchor('end', 1);
	        } else if (match('\\b')) {
	          return createAnchor('boundary', 2);
	        } else if (match('\\B')) {
	          return createAnchor('not-boundary', 2);
	        } else {
	          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
	        }
	      }

	      function parseQuantifier() {
	        var res,
	            from = pos;
	        var quantifier;
	        var min, max;

	        if (match('*')) {
	          quantifier = createQuantifier(0);
	        } else if (match('+')) {
	          quantifier = createQuantifier(1);
	        } else if (match('?')) {
	          quantifier = createQuantifier(0, 1);
	        } else if (res = matchReg(/^\{([0-9]+)\}/)) {
	          min = parseInt(res[1], 10);
	          quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
	        } else if (res = matchReg(/^\{([0-9]+),\}/)) {
	          min = parseInt(res[1], 10);
	          quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
	        } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
	          min = parseInt(res[1], 10);
	          max = parseInt(res[2], 10);

	          if (min > max) {
	            bail('numbers out of order in {} quantifier', '', from, pos);
	          }

	          quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
	        }

	        if (quantifier) {
	          if (match('?')) {
	            quantifier.greedy = false;
	            quantifier.range[1] += 1;
	          }
	        }

	        return quantifier;
	      }

	      function parseAtomAndExtendedAtom() {
	        var res;

	        if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
	          return createCharacter(res);
	        } else if (!hasUnicodeFlag && (res = matchReg(/^(?:]|})/))) {
	          return createCharacter(res);
	        } else if (match('.')) {
	          return createDot();
	        } else if (match('\\')) {
	          res = parseAtomEscape();

	          if (!res) {
	            if (!hasUnicodeFlag && lookahead() == 'c') {
	              return createValue('symbol', 92, pos - 1, pos);
	            }

	            bail('atomEscape');
	          }

	          return res;
	        } else if (res = parseCharacterClass()) {
	          return res;
	        } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
	          return res;
	        } else if (features.namedGroups && match("(?<")) {
	          var name = parseIdentifier();
	          skip(">");
	          var group = finishGroup("normal", name.range[0] - 3);
	          group.name = name;
	          return group;
	        } else {
	          return parseGroup('(?:', 'ignore', '(', 'normal');
	        }
	      }

	      function parseUnicodeSurrogatePairEscape(firstEscape) {
	        if (hasUnicodeFlag) {
	          var first, second;

	          if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
	            var prevPos = pos;
	            pos++;
	            var secondEscape = parseClassEscape();

	            if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
	              firstEscape.range[1] = secondEscape.range[1];
	              firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	              firstEscape.type = 'value';
	              firstEscape.kind = 'unicodeCodePointEscape';
	              addRaw(firstEscape);
	            } else {
	              pos = prevPos;
	            }
	          }
	        }

	        return firstEscape;
	      }

	      function parseClassEscape() {
	        return parseAtomEscape(true);
	      }

	      function parseAtomEscape(insideCharacterClass) {
	        var res,
	            from = pos;
	        res = parseDecimalEscape() || parseNamedReference();

	        if (res) {
	          return res;
	        }

	        if (insideCharacterClass) {
	          if (match('b')) {
	            return createEscaped('singleEscape', 0x0008, '\\b');
	          } else if (match('B')) {
	            bail('\\B not possible inside of CharacterClass', '', from);
	          } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
	            return createEscaped('controlLetter', res[1] + 16, res[1], 2);
	          } else if (!hasUnicodeFlag && (res = matchReg(/^c_/))) {
	            return createEscaped('controlLetter', 31, '_', 2);
	          }

	          if (hasUnicodeFlag && match('-')) {
	            return createEscaped('singleEscape', 0x002d, '\\-');
	          }
	        }

	        res = parseCharacterClassEscape() || parseCharacterEscape();
	        return res;
	      }

	      function parseDecimalEscape() {
	        var res, match;

	        if (res = matchReg(/^(?!0)\d+/)) {
	          match = res[0];
	          var refIdx = parseInt(res[0], 10);

	          if (refIdx <= closedCaptureCounter) {
	            return createReference(res[0]);
	          } else {
	            backrefDenied.push(refIdx);
	            incr(-res[0].length);

	            if (res = matchReg(/^[0-7]{1,3}/)) {
	              return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
	            } else {
	              res = createCharacter(matchReg(/^[89]/));
	              return updateRawStart(res, res.range[0] - 1);
	            }
	          }
	        } else if (res = matchReg(/^[0-7]{1,3}/)) {
	          match = res[0];

	          if (/^0{1,3}$/.test(match)) {
	            return createEscaped('null', 0x0000, '0', match.length);
	          } else {
	            return createEscaped('octal', parseInt(match, 8), match, 1);
	          }
	        }

	        return false;
	      }

	      function parseCharacterClassEscape() {
	        var res;

	        if (res = matchReg(/^[dDsSwW]/)) {
	          return createCharacterClassEscape(res[0]);
	        } else if (features.unicodePropertyEscape && (hasUnicodeFlag || hasUnicodeSetFlag) && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
	          return addRaw({
	            type: 'unicodePropertyEscape',
	            negative: res[1] === 'P',
	            value: res[2],
	            range: [res.range[0] - 1, res.range[1]],
	            raw: res[0]
	          });
	        }

	        return false;
	      }

	      function parseNamedReference() {
	        if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
	          var name = parseIdentifier();
	          skip('>');
	          return createNamedReference(name);
	        }
	      }

	      function parseRegExpUnicodeEscapeSequence() {
	        var res;

	        if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
	          return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
	        } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
	          return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
	        }
	      }

	      function parseCharacterEscape() {
	        var res;
	        var from = pos;

	        if (res = matchReg(/^[fnrtv]/)) {
	          var codePoint = 0;

	          switch (res[0]) {
	            case 't':
	              codePoint = 0x009;
	              break;

	            case 'n':
	              codePoint = 0x00A;
	              break;

	            case 'v':
	              codePoint = 0x00B;
	              break;

	            case 'f':
	              codePoint = 0x00C;
	              break;

	            case 'r':
	              codePoint = 0x00D;
	              break;
	          }

	          return createEscaped('singleEscape', codePoint, '\\' + res[0]);
	        } else if (res = matchReg(/^c([a-zA-Z])/)) {
	          return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
	        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
	          return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
	        } else if (res = parseRegExpUnicodeEscapeSequence()) {
	          if (!res || res.codePoint > 0x10FFFF) {
	            bail('Invalid escape sequence', null, from, pos);
	          }

	          return res;
	        } else {
	          return parseIdentityEscape();
	        }
	      }

	      function parseIdentifierAtom(check) {
	        var ch = lookahead();
	        var from = pos;

	        if (ch === '\\') {
	          incr();
	          var esc = parseRegExpUnicodeEscapeSequence();

	          if (!esc || !check(esc.codePoint)) {
	            bail('Invalid escape sequence', null, from, pos);
	          }

	          return fromCodePoint(esc.codePoint);
	        }

	        var code = ch.charCodeAt(0);

	        if (code >= 0xD800 && code <= 0xDBFF) {
	          ch += str[pos + 1];
	          var second = ch.charCodeAt(1);

	          if (second >= 0xDC00 && second <= 0xDFFF) {
	            code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	          }
	        }

	        if (!check(code)) return;
	        incr();
	        if (code > 0xFFFF) incr();
	        return ch;
	      }

	      function parseIdentifier() {
	        var start = pos;
	        var res = parseIdentifierAtom(isIdentifierStart);

	        if (!res) {
	          bail('Invalid identifier');
	        }

	        var ch;

	        while (ch = parseIdentifierAtom(isIdentifierPart)) {
	          res += ch;
	        }

	        return addRaw({
	          type: 'identifier',
	          value: res,
	          range: [start, pos]
	        });
	      }

	      function isIdentifierStart(ch) {
	        var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
	        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
	      }

	      function isIdentifierPart(ch) {
	        var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
	        return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
	      }

	      function parseIdentityEscape() {
	        var tmp;
	        var l = lookahead();

	        if (hasUnicodeFlag && /[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/.test(l) || !hasUnicodeFlag && l !== "c") {
	          if (l === "k" && features.lookbehind) {
	            return null;
	          }

	          tmp = incr();
	          return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
	        }

	        return null;
	      }

	      function parseCharacterClass() {
	        var res,
	            from = pos;

	        if (res = matchReg(/^\[\^/)) {
	          res = parseClassRanges();
	          skip(']');
	          return createCharacterClass(res, true, from, pos);
	        } else if (match('[')) {
	          res = parseClassRanges();
	          skip(']');
	          return createCharacterClass(res, false, from, pos);
	        }

	        return null;
	      }

	      function parseClassRanges() {
	        var res;

	        if (current(']')) {
	          return {
	            kind: 'union',
	            body: []
	          };
	        } else if (hasUnicodeSetFlag) {
	          return parseClassContents();
	        } else {
	          res = parseNonemptyClassRanges();

	          if (!res) {
	            bail('nonEmptyClassRanges');
	          }

	          return {
	            kind: 'union',
	            body: res
	          };
	        }
	      }

	      function parseHelperClassRanges(atom) {
	        var from, to, res, atomTo, dash;

	        if (current('-') && !next(']')) {
	          from = atom.range[0];
	          dash = createCharacter(match('-'));
	          atomTo = parseClassAtom();

	          if (!atomTo) {
	            bail('classAtom');
	          }

	          to = pos;
	          var classRanges = parseClassRanges();

	          if (!classRanges) {
	            bail('classRanges');
	          }

	          if (!('codePoint' in atom) || !('codePoint' in atomTo)) {
	            if (!hasUnicodeFlag) {
	              res = [atom, dash, atomTo];
	            } else {
	              bail('invalid character class');
	            }
	          } else {
	            res = [createClassRange(atom, atomTo, from, to)];
	          }

	          if (classRanges.type === 'empty') {
	            return res;
	          }

	          return res.concat(classRanges.body);
	        }

	        res = parseNonemptyClassRangesNoDash();

	        if (!res) {
	          bail('nonEmptyClassRangesNoDash');
	        }

	        return [atom].concat(res);
	      }

	      function parseNonemptyClassRanges() {
	        var atom = parseClassAtom();

	        if (!atom) {
	          bail('classAtom');
	        }

	        if (current(']')) {
	          return [atom];
	        }

	        return parseHelperClassRanges(atom);
	      }

	      function parseNonemptyClassRangesNoDash() {
	        var res = parseClassAtom();

	        if (!res) {
	          bail('classAtom');
	        }

	        if (current(']')) {
	          return res;
	        }

	        return parseHelperClassRanges(res);
	      }

	      function parseClassAtom() {
	        if (match('-')) {
	          return createCharacter('-');
	        } else {
	          return parseClassAtomNoDash();
	        }
	      }

	      function parseClassAtomNoDash() {
	        var res;

	        if (res = matchReg(/^[^\\\]-]/)) {
	          return createCharacter(res[0]);
	        } else if (match('\\')) {
	          res = parseClassEscape();

	          if (!res) {
	            bail('classEscape');
	          }

	          return parseUnicodeSurrogatePairEscape(res);
	        }
	      }

	      function parseClassContents() {
	        var body = [];
	        var kind;
	        var operand = parseClassOperand(true);
	        body.push(operand);

	        if (operand.type === 'classRange') {
	          kind = 'union';
	        } else if (current('&')) {
	          kind = 'intersection';
	        } else if (current('-')) {
	          kind = 'subtraction';
	        } else {
	          kind = 'union';
	        }

	        while (!current(']')) {
	          if (kind === 'intersection') {
	            skip('&');
	            skip('&');

	            if (current('&')) {
	              bail('&& cannot be followed by &. Wrap it in parentheses: &&(&).');
	            }
	          } else if (kind === 'subtraction') {
	            skip('-');
	            skip('-');
	          }

	          operand = parseClassOperand(kind === 'union');
	          body.push(operand);
	        }

	        return {
	          kind: kind,
	          body: body
	        };
	      }

	      function parseClassOperand(allowRanges) {
	        var from = pos;
	        var start, res;

	        if (match('\\')) {
	          if (res = parseCharacterClassEscape()) {
	            start = res;
	          } else if (res = parseClassCharacterEscapedHelper()) {
	            return res;
	          } else {
	            bail('Invalid escape', '\\' + lookahead(), from);
	          }
	        } else if (res = parseClassCharacterUnescapedHelper()) {
	          start = res;
	        } else if (res = parseClassStrings() || parseCharacterClass()) {
	          return res;
	        } else {
	          bail('Invalid character', lookahead());
	        }

	        if (allowRanges && current('-') && !next('-')) {
	          skip('-');

	          if (res = parseClassCharacter()) {
	            return createClassRange(start, res, from, pos);
	          }

	          bail('Invalid range end', lookahead());
	        }

	        return start;
	      }

	      function parseClassCharacter() {
	        if (match('\\')) {
	          if (res = parseClassCharacterEscapedHelper()) {
	            return res;
	          } else {
	            bail('Invalid escape', '\\' + lookahead(), from);
	          }
	        }

	        return parseClassCharacterUnescapedHelper();
	      }

	      function parseClassCharacterUnescapedHelper() {
	        var res;

	        if (res = matchReg(/^[^()[\]{}/\-\\|]/)) {
	          return createCharacter(res);
	        }
	      }

	      function parseClassCharacterEscapedHelper() {
	        if (match('b')) {
	          return createEscaped('singleEscape', 0x0008, '\\b');
	        } else if (match('B')) {
	          bail('\\B not possible inside of ClassContents', '', pos - 2);
	        } else if (res = matchReg(/^[&\-!#%,:;<=>@_`~]/)) {
	          return createEscaped('identifier', res[0].codePointAt(0), res[0]);
	        } else if (res = parseCharacterEscape()) {
	          return res;
	        } else {
	          return null;
	        }
	      }

	      function parseClassStrings() {
	        var res = [];
	        var from = pos;

	        if (!match('(')) {
	          return null;
	        }

	        do {
	          res.push(parseClassString());
	        } while (match('|'));

	        skip(')');
	        return createClassStrings(res, from, pos);
	      }

	      function parseClassString() {
	        var res = [],
	            from = pos;

	        var _char2;

	        while (_char2 = parseClassCharacter()) {
	          res.push(_char2);
	        }

	        return createClassString(res, from, pos);
	      }

	      function bail(message, details, from, to) {
	        from = from == null ? pos : from;
	        to = to == null ? from : to;
	        var contextStart = Math.max(0, from - 10);
	        var contextEnd = Math.min(to + 10, str.length);
	        var context = '    ' + str.substring(contextStart, contextEnd);
	        var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
	        throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
	      }

	      var backrefDenied = [];
	      var closedCaptureCounter = 0;
	      var firstIteration = true;
	      var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
	      var hasUnicodeSetFlag = (flags || "").indexOf("v") !== -1;
	      var pos = 0;

	      if (hasUnicodeSetFlag && !features.unicodeSet) {
	        throw new Error('The "v" flag is only supported when the .unicodeSet option is enabled.');
	      }

	      if (hasUnicodeFlag && hasUnicodeSetFlag) {
	        throw new Error('The "u" and "v" flags are mutually exclusive.');
	      }

	      str = String(str);

	      if (str === '') {
	        str = '(?:)';
	      }

	      var result = parseDisjunction();

	      if (result.range[1] !== str.length) {
	        bail('Could not parse entire input - got stuck', '', result.range[1]);
	      }

	      for (var i = 0; i < backrefDenied.length; i++) {
	        if (backrefDenied[i] <= closedCaptureCounter) {
	          pos = 0;
	          firstIteration = false;
	          return parseDisjunction();
	        }
	      }

	      return result;
	    }

	    var regjsparser = {
	      parse: parse
	    };

	    if (module.exports) {
	      module.exports = regjsparser;
	    } else {
	      window.regjsparser = regjsparser;
	    }
	  })();
	}, "/$$rollup_base$$/node_modules/regjsparser");

	var unicodeCanonicalPropertyNamesEcmascript = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

	var unicodePropertyAliasesEcmascript = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['EBase', 'Emoji_Modifier_Base'], ['EComp', 'Emoji_Component'], ['EMod', 'Emoji_Modifier'], ['Emoji', 'Emoji'], ['EPres', 'Emoji_Presentation'], ['Ext', 'Extender'], ['ExtPict', 'Extended_Pictographic'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

	var matchProperty = function matchProperty(property) {
	  if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
	    return property;
	  }

	  if (unicodePropertyAliasesEcmascript.has(property)) {
	    return unicodePropertyAliasesEcmascript.get(property);
	  }

	  throw new Error("Unknown property: " + property);
	};

	var unicodeMatchPropertyEcmascript = matchProperty;

	var mappings = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cpmn', 'Cypro_Minoan'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Ougr', 'Old_Uyghur'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Tnsa', 'Tangsa'], ['Toto', 'Toto'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Vith', 'Vithkuqi'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypro_Minoan', 'Cypro_Minoan'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Old_Uyghur', 'Old_Uyghur'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Tangsa', 'Tangsa'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Vithkuqi', 'Vithkuqi'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cpmn', 'Cypro_Minoan'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Ougr', 'Old_Uyghur'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Tnsa', 'Tangsa'], ['Toto', 'Toto'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Vith', 'Vithkuqi'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypro_Minoan', 'Cypro_Minoan'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Old_Uyghur', 'Old_Uyghur'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Tangsa', 'Tangsa'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Vithkuqi', 'Vithkuqi'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

	var matchPropertyValue = function matchPropertyValue(property, value) {
	  var aliasToValue = mappings.get(property);

	  if (!aliasToValue) {
	    throw new Error("Unknown property `" + property + "`.");
	  }

	  var canonicalValue = aliasToValue.get(value);

	  if (canonicalValue) {
	    return canonicalValue;
	  }

	  throw new Error("Unknown value `" + value + "` for property `" + property + "`.");
	};

	var unicodeMatchPropertyValueEcmascript = matchPropertyValue;

	var iuMappings = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x462, 0x1C87], [0x1C80, 0x412], [0x1C81, 0x414], [0x1C82, 0x41E], [0x1C83, 0x421], [0x1C84, 0x1C85], [0x1C85, [0x422, 0x1C84]], [0x1C86, 0x42A], [0x1C87, 0x462], [0x1C88, 0xA64A], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0x2C2F, 0x2C5F], [0x2C5F, 0x2C2F], [0xA64A, 0x1C88], [0xA7C0, 0xA7C1], [0xA7C1, 0xA7C0], [0xA7D0, 0xA7D1], [0xA7D1, 0xA7D0], [0xA7D6, 0xA7D7], [0xA7D7, 0xA7D6], [0xA7D8, 0xA7D9], [0xA7D9, 0xA7D8], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10570, 0x10597], [0x10571, 0x10598], [0x10572, 0x10599], [0x10573, 0x1059A], [0x10574, 0x1059B], [0x10575, 0x1059C], [0x10576, 0x1059D], [0x10577, 0x1059E], [0x10578, 0x1059F], [0x10579, 0x105A0], [0x1057A, 0x105A1], [0x1057C, 0x105A3], [0x1057D, 0x105A4], [0x1057E, 0x105A5], [0x1057F, 0x105A6], [0x10580, 0x105A7], [0x10581, 0x105A8], [0x10582, 0x105A9], [0x10583, 0x105AA], [0x10584, 0x105AB], [0x10585, 0x105AC], [0x10586, 0x105AD], [0x10587, 0x105AE], [0x10588, 0x105AF], [0x10589, 0x105B0], [0x1058A, 0x105B1], [0x1058C, 0x105B3], [0x1058D, 0x105B4], [0x1058E, 0x105B5], [0x1058F, 0x105B6], [0x10590, 0x105B7], [0x10591, 0x105B8], [0x10592, 0x105B9], [0x10594, 0x105BB], [0x10595, 0x105BC], [0x10597, 0x10570], [0x10598, 0x10571], [0x10599, 0x10572], [0x1059A, 0x10573], [0x1059B, 0x10574], [0x1059C, 0x10575], [0x1059D, 0x10576], [0x1059E, 0x10577], [0x1059F, 0x10578], [0x105A0, 0x10579], [0x105A1, 0x1057A], [0x105A3, 0x1057C], [0x105A4, 0x1057D], [0x105A5, 0x1057E], [0x105A6, 0x1057F], [0x105A7, 0x10580], [0x105A8, 0x10581], [0x105A9, 0x10582], [0x105AA, 0x10583], [0x105AB, 0x10584], [0x105AC, 0x10585], [0x105AD, 0x10586], [0x105AE, 0x10587], [0x105AF, 0x10588], [0x105B0, 0x10589], [0x105B1, 0x1058A], [0x105B3, 0x1058C], [0x105B4, 0x1058D], [0x105B5, 0x1058E], [0x105B6, 0x1058F], [0x105B7, 0x10590], [0x105B8, 0x10591], [0x105B9, 0x10592], [0x105BB, 0x10594], [0x105BC, 0x10595], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

	var REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
	var UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
	var UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);
	var characterClassEscapeSets = {
	  REGULAR: REGULAR,
	  UNICODE: UNICODE,
	  UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
	};

	var generate = regjsgen.generate;
	var parse$1 = parser.parse;
	var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
	regenerate().addRange(0x0, 0xFFFF);
	var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);

	var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
	  if (unicode) {
	    if (ignoreCase) {
	      return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
	    }

	    return characterClassEscapeSets.UNICODE.get(character);
	  }

	  return characterClassEscapeSets.REGULAR.get(character);
	};

	var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
	  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
	};

	var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
	  var path = value ? property + "/" + value : "Binary_Property/" + property;

	  try {
	    return commonjsRequire("regenerate-unicode-properties/" + path + ".js", "/$$rollup_base$$/node_modules/regexpu-core");
	  } catch (exception) {
	    throw new Error("Failed to recognize value `" + value + "` for property " + ("`" + property + "`."));
	  }
	};

	var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
	  try {
	    var _property = 'General_Category';
	    var category = unicodeMatchPropertyValueEcmascript(_property, value);
	    return getUnicodePropertyValueSet(_property, category);
	  } catch (exception) {}

	  var property = unicodeMatchPropertyEcmascript(value);
	  return getUnicodePropertyValueSet(property);
	};

	var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
	  var parts = value.split('=');
	  var firstPart = parts[0];
	  var set;

	  if (parts.length == 1) {
	    set = handleLoneUnicodePropertyNameOrValue(firstPart);
	  } else {
	    var property = unicodeMatchPropertyEcmascript(firstPart);

	    var _value = unicodeMatchPropertyValueEcmascript(property, parts[1]);

	    set = getUnicodePropertyValueSet(property, _value);
	  }

	  if (isNegative) {
	    return UNICODE_SET.clone().remove(set);
	  }

	  return set.clone();
	};

	regenerate.prototype.iuAddRange = function (min, max) {
	  var $this = this;

	  do {
	    var folded = caseFold(min);

	    if (folded) {
	      $this.add(folded);
	    }
	  } while (++min <= max);

	  return $this;
	};

	var update = function update(item, pattern) {
	  var tree = parse$1(pattern, config.useUnicodeFlag ? 'u' : '');

	  switch (tree.type) {
	    case 'characterClass':
	    case 'group':
	    case 'value':
	      break;

	    default:
	      tree = wrap(tree, pattern);
	  }

	  Object.assign(item, tree);
	};

	var wrap = function wrap(tree, pattern) {
	  return {
	    'type': 'group',
	    'behavior': 'ignore',
	    'body': [tree],
	    'raw': "(?:" + pattern + ")"
	  };
	};

	var caseFold = function caseFold(codePoint) {
	  return iuMappings.get(codePoint) || false;
	};

	var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
	  var set = regenerate();

	  for (var _iterator = _createForOfIteratorHelperLoose(characterClassItem.body), _step; !(_step = _iterator()).done;) {
	    var item = _step.value;

	    switch (item.type) {
	      case 'value':
	        set.add(item.codePoint);

	        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
	          var folded = caseFold(item.codePoint);

	          if (folded) {
	            set.add(folded);
	          }
	        }

	        break;

	      case 'characterClassRange':
	        var min = item.min.codePoint;
	        var max = item.max.codePoint;
	        set.addRange(min, max);

	        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
	          set.iuAddRange(min, max);
	        }

	        break;

	      case 'characterClassEscape':
	        set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));
	        break;

	      case 'unicodePropertyEscape':
	        set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
	        break;

	      default:
	        throw new Error("Unknown term type: " + item.type);
	    }
	  }

	  if (characterClassItem.negative) {
	    update(characterClassItem, "(?!" + set.toString(regenerateOptions) + ")[\\s\\S]");
	  } else {
	    update(characterClassItem, set.toString(regenerateOptions));
	  }

	  return characterClassItem;
	};

	var updateNamedReference = function updateNamedReference(item, index) {
	  delete item.name;
	  item.matchIndex = index;
	};

	var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
	  var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

	  if (unmatchedReferencesNames.length > 0) {
	    throw new Error("Unknown group names: " + unmatchedReferencesNames);
	  }
	};

	var processTerm = function processTerm(item, regenerateOptions, groups) {
	  switch (item.type) {
	    case 'dot':
	      if (config.useDotAllFlag) {
	        break;
	      } else if (config.unicode) {
	        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));
	      } else if (config.dotAll) {
	        update(item, '[\\s\\S]');
	      }

	      break;

	    case 'characterClass':
	      item = processCharacterClass(item, regenerateOptions);
	      break;

	    case 'unicodePropertyEscape':
	      if (config.unicodePropertyEscape) {
	        update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
	      }

	      break;

	    case 'characterClassEscape':
	      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));
	      break;

	    case 'group':
	      if (item.behavior == 'normal') {
	        groups.lastIndex++;
	      }

	      if (item.name && config.namedGroup) {
	        var name = item.name.value;

	        if (groups.names[name]) {
	          throw new Error("Multiple groups with the same name (" + name + ") are not allowed.");
	        }

	        var index = groups.lastIndex;
	        delete item.name;
	        groups.names[name] = index;

	        if (groups.onNamedGroup) {
	          groups.onNamedGroup.call(null, name, index);
	        }

	        if (groups.unmatchedReferences[name]) {
	          groups.unmatchedReferences[name].forEach(function (reference) {
	            updateNamedReference(reference, index);
	          });
	          delete groups.unmatchedReferences[name];
	        }
	      }

	    case 'alternative':
	    case 'disjunction':
	    case 'quantifier':
	      item.body = item.body.map(function (term) {
	        return processTerm(term, regenerateOptions, groups);
	      });
	      break;

	    case 'value':
	      var codePoint = item.codePoint;
	      var set = regenerate(codePoint);

	      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
	        var folded = caseFold(codePoint);

	        if (folded) {
	          set.add(folded);
	        }
	      }

	      update(item, set.toString(regenerateOptions));
	      break;

	    case 'reference':
	      if (item.name) {
	        var _name = item.name.value;
	        var _index = groups.names[_name];

	        if (_index) {
	          updateNamedReference(item, _index);
	          break;
	        }

	        if (!groups.unmatchedReferences[_name]) {
	          groups.unmatchedReferences[_name] = [];
	        }

	        groups.unmatchedReferences[_name].push(item);
	      }

	      break;

	    case 'anchor':
	    case 'empty':
	    case 'group':
	      break;

	    default:
	      throw new Error("Unknown term type: " + item.type);
	  }

	  return item;
	};

	var config = {
	  'ignoreCase': false,
	  'unicode': false,
	  'dotAll': false,
	  'useDotAllFlag': false,
	  'useUnicodeFlag': false,
	  'unicodePropertyEscape': false,
	  'namedGroup': false
	};

	var rewritePattern = function rewritePattern(pattern, flags, options) {
	  config.unicode = flags && flags.includes('u');
	  var regjsparserFeatures = {
	    'unicodePropertyEscape': config.unicode,
	    'namedGroups': true,
	    'lookbehind': options && options.lookbehind
	  };
	  config.ignoreCase = flags && flags.includes('i');
	  var supportDotAllFlag = options && options.dotAllFlag;
	  config.dotAll = supportDotAllFlag && flags && flags.includes('s');
	  config.namedGroup = options && options.namedGroup;
	  config.useDotAllFlag = options && options.useDotAllFlag;
	  config.useUnicodeFlag = options && options.useUnicodeFlag;
	  config.unicodePropertyEscape = options && options.unicodePropertyEscape;

	  if (supportDotAllFlag && config.useDotAllFlag) {
	    throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');
	  }

	  var regenerateOptions = {
	    'hasUnicodeFlag': config.useUnicodeFlag,
	    'bmpOnly': !config.unicode
	  };
	  var groups = {
	    'onNamedGroup': options && options.onNamedGroup,
	    'lastIndex': 0,
	    'names': Object.create(null),
	    'unmatchedReferences': Object.create(null)
	  };
	  var tree = parse$1(pattern, flags, regjsparserFeatures);
	  processTerm(tree, regenerateOptions, groups);
	  assertNoUnmatchedReferences(groups);
	  return generate(tree);
	};

	var rewritePattern_1 = rewritePattern;

	var FEATURES = Object.freeze({
	  unicodeFlag: 1 << 0,
	  dotAllFlag: 1 << 1,
	  unicodePropertyEscape: 1 << 2,
	  namedCaptureGroups: 1 << 3
	});
	var featuresKey = "@babel/plugin-regexp-features/featuresKey";
	var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
	function enableFeature(features, feature) {
	  return features | feature;
	}
	function hasFeature(features, feature) {
	  return !!(features & feature);
	}

	function generateRegexpuOptions(node, features) {
	  var useUnicodeFlag = false,
	      dotAllFlag = false,
	      unicodePropertyEscape = false,
	      namedGroup = false;
	  var flags = node.flags,
	      pattern = node.pattern;
	  var flagsIncludesU = flags.includes("u");

	  if (flagsIncludesU) {
	    if (!hasFeature(features, FEATURES.unicodeFlag)) {
	      useUnicodeFlag = true;
	    }

	    if (hasFeature(features, FEATURES.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
	      unicodePropertyEscape = true;
	    }
	  }

	  if (hasFeature(features, FEATURES.dotAllFlag) && flags.indexOf("s") >= 0) {
	    dotAllFlag = true;
	  }

	  if (hasFeature(features, FEATURES.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
	    namedGroup = true;
	  }

	  if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
	    return null;
	  }

	  if (flagsIncludesU && flags.indexOf("s") >= 0) {
	    dotAllFlag = true;
	  }

	  return {
	    useUnicodeFlag: useUnicodeFlag,
	    onNamedGroup: function onNamedGroup() {},
	    namedGroup: namedGroup,
	    unicodePropertyEscape: unicodePropertyEscape,
	    dotAllFlag: dotAllFlag,
	    lookbehind: true
	  };
	}

	function pullFlag(node, flag) {
	  node.flags = node.flags.replace(flag, "");
	}

	var version$1 = "7.16.0".split(".").reduce(function (v, x) {
	  return v * 1e5 + +x;
	}, 0);
	var versionKey = "@babel/plugin-regexp-features/version";
	function createRegExpFeaturePlugin(_ref) {
	  var name = _ref.name,
	      feature = _ref.feature,
	      _ref$options = _ref.options,
	      options = _ref$options === void 0 ? {} : _ref$options;
	  return {
	    name: name,
	    pre: function pre() {
	      var _file$get;

	      var file = this.file;
	      var features = (_file$get = file.get(featuresKey)) != null ? _file$get : 0;
	      var newFeatures = enableFeature(features, FEATURES[feature]);
	      var useUnicodeFlag = options.useUnicodeFlag,
	          _options$runtime = options.runtime,
	          runtime = _options$runtime === void 0 ? true : _options$runtime;

	      if (useUnicodeFlag === false) {
	        newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);
	      }

	      if (newFeatures !== features) {
	        file.set(featuresKey, newFeatures);
	      }

	      if (!runtime) {
	        file.set(runtimeKey, false);
	      }

	      if (!file.has(versionKey) || file.get(versionKey) < version$1) {
	        file.set(versionKey, version$1);
	      }
	    },
	    visitor: {
	      RegExpLiteral: function RegExpLiteral(path) {
	        var _file$get2;

	        var node = path.node;
	        var file = this.file;
	        var features = file.get(featuresKey);
	        var runtime = (_file$get2 = file.get(runtimeKey)) != null ? _file$get2 : true;
	        var regexpuOptions = generateRegexpuOptions(node, features);

	        if (regexpuOptions === null) {
	          return;
	        }

	        var namedCaptureGroups = {};

	        if (regexpuOptions.namedGroup) {
	          regexpuOptions.onNamedGroup = function (name, index) {
	            namedCaptureGroups[name] = index;
	          };
	        }

	        node.pattern = rewritePattern_1(node.pattern, node.flags, regexpuOptions);

	        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
	          var call = callExpression$e(this.addHelper("wrapRegExp"), [node, valueToNode$1(namedCaptureGroups)]);
	          annotateAsPure(call);
	          path.replaceWith(call);
	        }

	        if (hasFeature(features, FEATURES.unicodeFlag)) {
	          pullFlag(node, "u");
	        }

	        if (hasFeature(features, FEATURES.dotAllFlag)) {
	          pullFlag(node, "s");
	        }
	      }
	    }
	  };
	}

	function isRegExpTest(path) {
	  return path.parentPath.isMemberExpression({
	    object: path.node,
	    computed: false
	  }) && path.parentPath.get("property").isIdentifier({
	    name: "test"
	  });
	}

	var _proposalUnicodePropertyRegex = declare(function (api, options) {
	  api.assertVersion(7);
	  var _options$useUnicodeFl = options.useUnicodeFlag,
	      useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

	  if (typeof useUnicodeFlag !== "boolean") {
	    throw new Error(".useUnicodeFlag must be a boolean, or undefined");
	  }

	  return createRegExpFeaturePlugin({
	    name: "proposal-unicode-property-regex",
	    feature: "unicodePropertyEscape",
	    options: {
	      useUnicodeFlag: useUnicodeFlag
	    }
	  });
	});

	var _transformAsyncToGenerator = declare(function (api, options) {
	  api.assertVersion(7);
	  var method = options.method,
	      module = options.module;
	  var noNewArrows = api.assumption("noNewArrows");

	  if (method && module) {
	    return {
	      name: "transform-async-to-generator",
	      visitor: {
	        Function: function Function(path, state) {
	          if (!path.node.async || path.node.generator) return;
	          var wrapAsync = state.methodWrapper;

	          if (wrapAsync) {
	            wrapAsync = cloneNode$i(wrapAsync);
	          } else {
	            wrapAsync = state.methodWrapper = addNamed(path, method, module);
	          }

	          remapAsyncToGenerator(path, {
	            wrapAsync: wrapAsync
	          }, noNewArrows);
	        }
	      }
	    };
	  }

	  return {
	    name: "transform-async-to-generator",
	    visitor: {
	      Function: function Function(path, state) {
	        if (!path.node.async || path.node.generator) return;
	        remapAsyncToGenerator(path, {
	          wrapAsync: state.addHelper("asyncToGenerator")
	        }, noNewArrows);
	      }
	    }
	  };
	});

	var _transformArrowFunctions = declare(function (api, options) {
	  var _api$assumption;

	  api.assertVersion(7);
	  var noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
	  return {
	    name: "transform-arrow-functions",
	    visitor: {
	      ArrowFunctionExpression: function (_ArrowFunctionExpression) {
	        function ArrowFunctionExpression(_x) {
	          return _ArrowFunctionExpression.apply(this, arguments);
	        }

	        ArrowFunctionExpression.toString = function () {
	          return _ArrowFunctionExpression.toString();
	        };

	        return ArrowFunctionExpression;
	      }(function (path) {
	        if (!path.isArrowFunctionExpression()) return;
	        path.arrowFunctionToExpression({
	          allowInsertArrow: false,
	          noNewArrows: noNewArrows,
	          specCompliant: !noNewArrows
	        });
	      })
	    }
	  };
	});

	var _transformBlockScopedFunctions = declare(function (api) {
	  api.assertVersion(7);

	  function statementList(key, path) {
	    var paths = path.get(key);

	    for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
	      var _path = _step.value;
	      var func = _path.node;
	      if (!_path.isFunctionDeclaration()) continue;
	      var declar = variableDeclaration$8("let", [variableDeclarator$8(func.id, toExpression$1(func))]);
	      declar._blockHoist = 2;
	      func.id = null;

	      _path.replaceWith(declar);
	    }
	  }

	  return {
	    name: "transform-block-scoped-functions",
	    visitor: {
	      BlockStatement: function BlockStatement(path) {
	        var node = path.node,
	            parent = path.parent;

	        if (isFunction$4(parent, {
	          body: node
	        }) || isExportDeclaration$2(parent)) {
	          return;
	        }

	        statementList("body", path);
	      },
	      SwitchCase: function SwitchCase(path) {
	        statementList("consequent", path);
	      }
	    }
	  };
	});

	var _templateObject$c;

	function getTDZStatus(refPath, bindingPath) {
	  var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

	  if (executionStatus === "before") {
	    return "outside";
	  } else if (executionStatus === "after") {
	    return "inside";
	  } else {
	    return "maybe";
	  }
	}

	function buildTDZAssert(node, state) {
	  return callExpression$e(state.addHelper("temporalRef"), [node, stringLiteral$8(node.name)]);
	}

	function isReference$1(node, scope, state) {
	  var declared = state.letReferences.get(node.name);
	  if (!declared) return false;
	  return scope.getBindingIdentifier(node.name) === declared;
	}

	var visitedMaybeTDZNodes = new WeakSet();
	var visitor = {
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    if (!state.tdzEnabled) return;
	    var node = path.node,
	        parent = path.parent,
	        scope = path.scope;
	    if (path.parentPath.isFor({
	      left: node
	    })) return;
	    if (!isReference$1(node, scope, state)) return;
	    var bindingPath = scope.getBinding(node.name).path;
	    if (bindingPath.isFunctionDeclaration()) return;
	    var status = getTDZStatus(path, bindingPath);
	    if (status === "outside") return;

	    if (status === "maybe") {
	      if (visitedMaybeTDZNodes.has(node)) {
	        return;
	      }

	      visitedMaybeTDZNodes.add(node);
	      var assert = buildTDZAssert(node, state);
	      bindingPath.parent._tdzThis = true;

	      if (path.parentPath.isUpdateExpression()) {
	        if (parent._ignoreBlockScopingTDZ) return;
	        path.parentPath.replaceWith(sequenceExpression$7([assert, parent]));
	      } else {
	        path.replaceWith(assert);
	      }
	    } else if (status === "inside") {
	      path.replaceWith(template$2.ast(_templateObject$c || (_templateObject$c = _taggedTemplateLiteralLoose(["", "(\"", "\")"])), state.addHelper("tdz"), node.name));
	    }
	  },
	  AssignmentExpression: {
	    exit: function exit(path, state) {
	      if (!state.tdzEnabled) return;
	      var node = path.node;
	      if (node._ignoreBlockScopingTDZ) return;
	      var nodes = [];
	      var ids = path.getBindingIdentifiers();

	      for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
	        var _name = _Object$keys[_i];
	        var id = ids[_name];

	        if (isReference$1(id, path.scope, state)) {
	          nodes.push(id);
	        }
	      }

	      if (nodes.length) {
	        node._ignoreBlockScopingTDZ = true;
	        nodes.push(node);
	        path.replaceWithMultiple(nodes.map(function (n) {
	          return expressionStatement$a(n);
	        }));
	      }
	    }
	  }
	};

	var DONE = new WeakSet();
	var _transformBlockScoping = declare(function (api, opts) {
	  api.assertVersion(7);
	  var _opts$throwIfClosureR = opts.throwIfClosureRequired,
	      throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
	      _opts$tdz = opts.tdz,
	      tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

	  if (typeof throwIfClosureRequired !== "boolean") {
	    throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
	  }

	  if (typeof tdzEnabled !== "boolean") {
	    throw new Error(".tdz must be a boolean, or undefined");
	  }

	  return {
	    name: "transform-block-scoping",
	    visitor: {
	      VariableDeclaration: function VariableDeclaration(path) {
	        var node = path.node,
	            parent = path.parent,
	            scope = path.scope;
	        if (!isBlockScoped(node)) return;
	        convertBlockScopedToVar(path, null, parent, scope, true);

	        if (node._tdzThis) {
	          var nodes = [node];

	          for (var i = 0; i < node.declarations.length; i++) {
	            var decl = node.declarations[i];
	            var assign = assignmentExpression$c("=", cloneNode$i(decl.id), decl.init || scope.buildUndefinedNode());
	            assign._ignoreBlockScopingTDZ = true;
	            nodes.push(expressionStatement$a(assign));
	            decl.init = this.addHelper("temporalUndefined");
	          }

	          node._blockHoist = 2;

	          if (path.isCompletionRecord()) {
	            nodes.push(expressionStatement$a(scope.buildUndefinedNode()));
	          }

	          path.replaceWithMultiple(nodes);
	        }
	      },
	      Loop: function Loop(path, state) {
	        var parent = path.parent,
	            scope = path.scope;
	        path.ensureBlock();
	        var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
	        var replace = blockScoping.run();
	        if (replace) path.replaceWith(replace);
	      },
	      CatchClause: function CatchClause(path, state) {
	        var parent = path.parent,
	            scope = path.scope;
	        var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
	        blockScoping.run();
	      },
	      "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
	        if (!ignoreBlock(path)) {
	          var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
	          blockScoping.run();
	        }
	      }
	    }
	  };
	});

	function ignoreBlock(path) {
	  return isLoop$1(path.parent) || isCatchClause(path.parent);
	}

	var buildRetCheck = template$2("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

	function isBlockScoped(node) {
	  if (!isVariableDeclaration$3(node)) return false;
	  if (node[BLOCK_SCOPED_SYMBOL]) return true;
	  if (node.kind !== "let" && node.kind !== "const") return false;
	  return true;
	}

	function isInLoop(path) {
	  var loopOrFunctionParent = path.find(function (path) {
	    return path.isLoop() || path.isFunction();
	  });
	  return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();
	}

	function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent) {
	  if (moveBindingsToParent === void 0) {
	    moveBindingsToParent = false;
	  }

	  if (!node) {
	    node = path.node;
	  }

	  if (isInLoop(path) && !isFor$2(parent)) {
	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      declar.init = declar.init || scope.buildUndefinedNode();
	    }
	  }

	  node[BLOCK_SCOPED_SYMBOL] = true;
	  node.kind = "var";

	  if (moveBindingsToParent) {
	    var parentScope = scope.getFunctionParent() || scope.getProgramParent();

	    for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
	      var _name = _Object$keys[_i];
	      var binding = scope.getOwnBinding(_name);
	      if (binding) binding.kind = "var";
	      scope.moveBindingTo(_name, parentScope);
	    }
	  }
	}

	function isVar(node) {
	  return isVariableDeclaration$3(node, {
	    kind: "var"
	  }) && !isBlockScoped(node);
	}

	var letReferenceBlockVisitor = traverse.visitors.merge([{
	  Loop: {
	    enter: function enter(path, state) {
	      state.loopDepth++;
	    },
	    exit: function exit(path, state) {
	      state.loopDepth--;
	    }
	  },
	  FunctionParent: function FunctionParent(path, state) {
	    if (state.loopDepth > 0) {
	      path.traverse(letReferenceFunctionVisitor, state);
	    } else {
	      path.traverse(visitor, state);
	    }

	    return path.skip();
	  }
	}, visitor]);
	var letReferenceFunctionVisitor = traverse.visitors.merge([{
	  ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	    var ref = state.letReferences.get(path.node.name);
	    if (!ref) return;
	    var localBinding = path.scope.getBindingIdentifier(path.node.name);
	    if (localBinding && localBinding !== ref) return;
	    state.closurify = true;
	  }
	}, visitor]);
	var hoistVarDeclarationsVisitor = {
	  enter: function enter(path, self) {
	    if (path.isForStatement()) {
	      var node = path.node;

	      if (isVar(node.init)) {
	        var nodes = self.pushDeclar(node.init);

	        if (nodes.length === 1) {
	          node.init = nodes[0];
	        } else {
	          node.init = sequenceExpression$7(nodes);
	        }
	      }
	    } else if (path.isForInStatement() || path.isForOfStatement()) {
	      var _node = path.node;

	      if (isVar(_node.left)) {
	        self.pushDeclar(_node.left);
	        _node.left = _node.left.declarations[0].id;
	      }
	    } else if (isVar(path.node)) {
	      path.replaceWithMultiple(self.pushDeclar(path.node).map(function (expr) {
	        return expressionStatement$a(expr);
	      }));
	    } else if (path.isFunction()) {
	      return path.skip();
	    }
	  }
	};
	var loopLabelVisitor = {
	  LabeledStatement: function LabeledStatement(_ref, state) {
	    var node = _ref.node;
	    state.innerLabels.push(node.label.name);
	  }
	};
	var continuationVisitor = {
	  enter: function enter(path, state) {
	    if (path.isAssignmentExpression() || path.isUpdateExpression()) {
	      for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
	        var _name2 = _Object$keys2[_i2];

	        if (state.outsideReferences.get(_name2) !== path.scope.getBindingIdentifier(_name2)) {
	          continue;
	        }

	        state.reassignments[_name2] = true;
	      }
	    } else if (path.isReturnStatement()) {
	      state.returnStatements.push(path);
	    }
	  }
	};

	function loopNodeTo(node) {
	  if (isBreakStatement(node)) {
	    return "break";
	  } else if (isContinueStatement(node)) {
	    return "continue";
	  }
	}

	var loopVisitor = {
	  Loop: function Loop(path, state) {
	    var oldIgnoreLabeless = state.ignoreLabeless;
	    state.ignoreLabeless = true;
	    path.traverse(loopVisitor, state);
	    state.ignoreLabeless = oldIgnoreLabeless;
	    path.skip();
	  },
	  Function: function Function(path) {
	    path.skip();
	  },
	  SwitchCase: function SwitchCase(path, state) {
	    var oldInSwitchCase = state.inSwitchCase;
	    state.inSwitchCase = true;
	    path.traverse(loopVisitor, state);
	    state.inSwitchCase = oldInSwitchCase;
	    path.skip();
	  },
	  "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
	    var node = path.node,
	        scope = path.scope;
	    if (node[this.LOOP_IGNORE]) return;
	    var replace;
	    var loopText = loopNodeTo(node);

	    if (loopText) {
	      if (isReturnStatement$1(node)) {
	        throw new Error("Internal error: unexpected return statement with `loopText`");
	      }

	      if (node.label) {
	        if (state.innerLabels.indexOf(node.label.name) >= 0) {
	          return;
	        }

	        loopText = loopText + "|" + node.label.name;
	      } else {
	        if (state.ignoreLabeless) return;
	        if (isBreakStatement(node) && state.inSwitchCase) return;
	      }

	      state.hasBreakContinue = true;
	      state.map[loopText] = node;
	      replace = stringLiteral$8(loopText);
	    }

	    if (isReturnStatement$1(node)) {
	      state.hasReturn = true;
	      replace = objectExpression$4([objectProperty$2(identifier$j("v"), node.argument || scope.buildUndefinedNode())]);
	    }

	    if (replace) {
	      replace = returnStatement$3(replace);
	      replace[this.LOOP_IGNORE] = true;
	      path.skip();
	      path.replaceWith(inherits$1(replace, node));
	    }
	  }
	};

	function isStrict(path) {
	  return !!path.find(function (_ref2) {
	    var node = _ref2.node;

	    if (isProgram$2(node)) {
	      if (node.sourceType === "module") return true;
	    } else if (!isBlockStatement$2(node)) return false;

	    return node.directives.some(function (directive) {
	      return directive.value.value === "use strict";
	    });
	  });
	}

	var BlockScoping = function () {
	  function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
	    this.parent = void 0;
	    this.state = void 0;
	    this.scope = void 0;
	    this.throwIfClosureRequired = void 0;
	    this.tdzEnabled = void 0;
	    this.blockPath = void 0;
	    this.block = void 0;
	    this.outsideLetReferences = void 0;
	    this.hasLetReferences = void 0;
	    this.letReferences = void 0;
	    this.body = void 0;
	    this.loopParent = void 0;
	    this.loopLabel = void 0;
	    this.loopPath = void 0;
	    this.loop = void 0;
	    this.has = void 0;
	    this.parent = parent;
	    this.scope = scope;
	    this.state = state;
	    this.throwIfClosureRequired = throwIfClosureRequired;
	    this.tdzEnabled = tdzEnabled;
	    this.blockPath = blockPath;
	    this.block = blockPath.node;
	    this.outsideLetReferences = new Map();
	    this.hasLetReferences = false;
	    this.letReferences = new Map();
	    this.body = [];

	    if (loopPath) {
	      this.loopParent = loopPath.parent;
	      this.loopLabel = isLabeledStatement(this.loopParent) && this.loopParent.label;
	      this.loopPath = loopPath;
	      this.loop = loopPath.node;
	    }
	  }

	  var _proto = BlockScoping.prototype;

	  _proto.run = function run() {
	    var block = this.block;
	    if (DONE.has(block)) return;
	    DONE.add(block);
	    var needsClosure = this.getLetReferences();
	    this.checkConstants();

	    if (isFunction$4(this.parent) || isProgram$2(this.block)) {
	      this.updateScopeInfo();
	      return;
	    }

	    if (!this.hasLetReferences) return;

	    if (needsClosure) {
	      this.wrapClosure();
	    } else {
	      this.remap();
	    }

	    this.updateScopeInfo(needsClosure);

	    if (this.loopLabel && !isLabeledStatement(this.loopParent)) {
	      return labeledStatement(this.loopLabel, this.loop);
	    }
	  };

	  _proto.checkConstants = function checkConstants() {
	    var scope = this.scope;
	    var state = this.state;

	    for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
	      var _name3 = _Object$keys3[_i3];
	      var binding = scope.bindings[_name3];
	      if (binding.kind !== "const") continue;

	      for (var _iterator = _createForOfIteratorHelperLoose(binding.constantViolations), _step; !(_step = _iterator()).done;) {
	        var violation = _step.value;
	        var readOnlyError = state.addHelper("readOnlyError");
	        var throwNode = callExpression$e(readOnlyError, [stringLiteral$8(_name3)]);

	        if (violation.isAssignmentExpression()) {
	          var operator = violation.node.operator;

	          if (operator === "=") {
	            violation.replaceWith(sequenceExpression$7([violation.get("right").node, throwNode]));
	          } else if (["&&=", "||=", "??="].includes(operator)) {
	            violation.replaceWith(logicalExpression$2(operator.slice(0, -1), violation.get("left").node, sequenceExpression$7([violation.get("right").node, throwNode])));
	          } else {
	            violation.replaceWith(sequenceExpression$7([binaryExpression$4(operator.slice(0, -1), violation.get("left").node, violation.get("right").node), throwNode]));
	          }
	        } else if (violation.isUpdateExpression()) {
	          violation.replaceWith(sequenceExpression$7([unaryExpression$7("+", violation.get("argument").node), throwNode]));
	        } else if (violation.isForXStatement()) {
	          violation.ensureBlock();
	          violation.get("left").replaceWith(variableDeclaration$8("var", [variableDeclarator$8(violation.scope.generateUidIdentifier(_name3))]));
	          violation.node.body.body.unshift(expressionStatement$a(throwNode));
	        }
	      }
	    }
	  };

	  _proto.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {
	    var blockScope = this.blockPath.scope;
	    var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
	    var letRefs = this.letReferences;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(letRefs.keys()), _step2; !(_step2 = _iterator2()).done;) {
	      var key = _step2.value;
	      var ref = letRefs.get(key);
	      var binding = blockScope.getBinding(ref.name);
	      if (!binding) continue;

	      if (binding.kind === "let" || binding.kind === "const") {
	        binding.kind = "var";

	        if (wrappedInClosure) {
	          if (blockScope.hasOwnBinding(ref.name)) {
	            blockScope.removeBinding(ref.name);
	          }
	        } else {
	          blockScope.moveBindingTo(ref.name, parentScope);
	        }
	      }
	    }
	  };

	  _proto.remap = function remap() {
	    var letRefs = this.letReferences;
	    var outsideLetRefs = this.outsideLetReferences;
	    var scope = this.scope;
	    var blockPathScope = this.blockPath.scope;

	    for (var _iterator3 = _createForOfIteratorHelperLoose(letRefs.keys()), _step3; !(_step3 = _iterator3()).done;) {
	      var key = _step3.value;
	      var ref = letRefs.get(key);

	      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
	        var binding = scope.getOwnBinding(key);

	        if (binding) {
	          var parentBinding = scope.parent.getOwnBinding(key);

	          if (binding.kind === "hoisted" && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar(parentBinding.path.parent)) && !isStrict(binding.path.parentPath)) {
	            continue;
	          }

	          scope.rename(ref.name);
	        }

	        if (blockPathScope.hasOwnBinding(key)) {
	          blockPathScope.rename(ref.name);
	        }
	      }
	    }

	    for (var _iterator4 = _createForOfIteratorHelperLoose(outsideLetRefs.keys()), _step4; !(_step4 = _iterator4()).done;) {
	      var _key = _step4.value;

	      var _ref3 = letRefs.get(_key);

	      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
	        blockPathScope.rename(_ref3.name);
	      }
	    }
	  };

	  _proto.wrapClosure = function wrapClosure() {
	    if (this.throwIfClosureRequired) {
	      throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
	    }

	    var block = this.block;
	    var outsideRefs = this.outsideLetReferences;

	    if (this.loop) {
	      for (var _i4 = 0, _Array$from = Array.from(outsideRefs.keys()); _i4 < _Array$from.length; _i4++) {
	        var _name4 = _Array$from[_i4];
	        var id = outsideRefs.get(_name4);

	        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
	          outsideRefs["delete"](id.name);
	          this.letReferences["delete"](id.name);
	          this.scope.rename(id.name);
	          this.letReferences.set(id.name, id);
	          outsideRefs.set(id.name, id);
	        }
	      }
	    }

	    this.has = this.checkLoop();
	    this.hoistVarDeclarations();
	    var args = Array.from(outsideRefs.values(), function (node) {
	      return cloneNode$i(node);
	    });
	    var params = args.map(function (id) {
	      return cloneNode$i(id);
	    });
	    var isSwitch = this.blockPath.isSwitchStatement();
	    var fn = functionExpression$3(null, params, blockStatement$6(isSwitch ? [block] : block.body));
	    this.addContinuations(fn);
	    var call = callExpression$e(nullLiteral$2(), args);
	    var basePath = ".callee";
	    var hasYield = traverse.hasType(fn.body, "YieldExpression", FUNCTION_TYPES$1);

	    if (hasYield) {
	      fn.generator = true;
	      call = yieldExpression$2(call, true);
	      basePath = ".argument" + basePath;
	    }

	    var hasAsync = traverse.hasType(fn.body, "AwaitExpression", FUNCTION_TYPES$1);

	    if (hasAsync) {
	      fn.async = true;
	      call = awaitExpression$1(call);
	      basePath = ".argument" + basePath;
	    }

	    var placeholderPath;
	    var index;

	    if (this.has.hasReturn || this.has.hasBreakContinue) {
	      var ret = this.scope.generateUid("ret");
	      this.body.push(variableDeclaration$8("var", [variableDeclarator$8(identifier$j(ret), call)]));
	      placeholderPath = "declarations.0.init" + basePath;
	      index = this.body.length - 1;
	      this.buildHas(ret);
	    } else {
	      this.body.push(expressionStatement$a(call));
	      placeholderPath = "expression" + basePath;
	      index = this.body.length - 1;
	    }

	    var callPath;

	    if (isSwitch) {
	      var _this$blockPath = this.blockPath,
	          parentPath = _this$blockPath.parentPath,
	          listKey = _this$blockPath.listKey,
	          key = _this$blockPath.key;
	      this.blockPath.replaceWithMultiple(this.body);
	      callPath = parentPath.get(listKey)[key + index];
	    } else {
	      block.body = this.body;
	      callPath = this.blockPath.get("body")[index];
	    }

	    var placeholder = callPath.get(placeholderPath);
	    var fnPath;

	    if (this.loop) {
	      var loopId = this.scope.generateUid("loop");
	      var p = this.loopPath.insertBefore(variableDeclaration$8("var", [variableDeclarator$8(identifier$j(loopId), fn)]));
	      placeholder.replaceWith(identifier$j(loopId));
	      fnPath = p[0].get("declarations.0.init");
	    } else {
	      placeholder.replaceWith(fn);
	      fnPath = placeholder;
	    }

	    fnPath.unwrapFunctionEnvironment();
	  };

	  _proto.addContinuations = function addContinuations(fn) {
	    var _this = this;

	    var state = {
	      reassignments: {},
	      returnStatements: [],
	      outsideReferences: this.outsideLetReferences
	    };
	    this.scope.traverse(fn, continuationVisitor, state);

	    var _loop = function _loop(i) {
	      var param = fn.params[i];
	      if (!state.reassignments[param.name]) return "continue";
	      var paramName = param.name;

	      var newParamName = _this.scope.generateUid(param.name);

	      fn.params[i] = identifier$j(newParamName);

	      _this.scope.rename(paramName, newParamName, fn);

	      state.returnStatements.forEach(function (returnStatement) {
	        returnStatement.insertBefore(expressionStatement$a(assignmentExpression$c("=", identifier$j(paramName), identifier$j(newParamName))));
	      });
	      fn.body.body.push(expressionStatement$a(assignmentExpression$c("=", identifier$j(paramName), identifier$j(newParamName))));
	    };

	    for (var i = 0; i < fn.params.length; i++) {
	      var _ret = _loop(i);

	      if (_ret === "continue") continue;
	    }
	  };

	  _proto.getLetReferences = function getLetReferences() {
	    var _this2 = this;

	    var block = this.block;
	    var declarators = [];

	    if (this.loop) {
	      var init = this.loop.left || this.loop.init;

	      if (isBlockScoped(init)) {
	        declarators.push(init);
	        var names = getBindingIdentifiers$2(init);

	        for (var _i5 = 0, _Object$keys4 = Object.keys(names); _i5 < _Object$keys4.length; _i5++) {
	          var _name5 = _Object$keys4[_i5];
	          this.outsideLetReferences.set(_name5, names[_name5]);
	        }
	      }
	    }

	    var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
	      node = node || path.node;

	      if (isClassDeclaration$3(node) || isFunctionDeclaration$1(node) || isBlockScoped(node)) {
	        if (isBlockScoped(node)) {
	          convertBlockScopedToVar(path, node, block, _this2.scope);
	        }

	        if (node.declarations) {
	          for (var i = 0; i < node.declarations.length; i++) {
	            declarators.push(node.declarations[i]);
	          }
	        } else {
	          declarators.push(node);
	        }
	      }

	      if (isLabeledStatement(node)) {
	        addDeclarationsFromChild(path.get("body"), node.body);
	      }
	    };

	    if (block.body) {
	      var declarPaths = this.blockPath.get("body");

	      for (var i = 0; i < block.body.length; i++) {
	        addDeclarationsFromChild(declarPaths[i]);
	      }
	    }

	    if (block.cases) {
	      var _declarPaths = this.blockPath.get("cases");

	      for (var _i6 = 0; _i6 < block.cases.length; _i6++) {
	        var consequents = block.cases[_i6].consequent;

	        for (var j = 0; j < consequents.length; j++) {
	          var declar = consequents[j];
	          addDeclarationsFromChild(_declarPaths[_i6], declar);
	        }
	      }
	    }

	    for (var _i7 = 0; _i7 < declarators.length; _i7++) {
	      var _declar = declarators[_i7];
	      var keys = getBindingIdentifiers$2(_declar, false, true);

	      for (var _i8 = 0, _Object$keys5 = Object.keys(keys); _i8 < _Object$keys5.length; _i8++) {
	        var key = _Object$keys5[_i8];
	        this.letReferences.set(key, keys[key]);
	      }

	      this.hasLetReferences = true;
	    }

	    if (!this.hasLetReferences) return;
	    var state = {
	      letReferences: this.letReferences,
	      closurify: false,
	      loopDepth: 0,
	      tdzEnabled: this.tdzEnabled,
	      addHelper: function addHelper(name) {
	        return _this2.state.addHelper(name);
	      }
	    };

	    if (isInLoop(this.blockPath)) {
	      state.loopDepth++;
	    }

	    this.blockPath.traverse(letReferenceBlockVisitor, state);
	    return state.closurify;
	  };

	  _proto.checkLoop = function checkLoop() {
	    var state = {
	      hasBreakContinue: false,
	      ignoreLabeless: false,
	      inSwitchCase: false,
	      innerLabels: [],
	      hasReturn: false,
	      isLoop: !!this.loop,
	      map: {},
	      LOOP_IGNORE: Symbol()
	    };
	    this.blockPath.traverse(loopLabelVisitor, state);
	    this.blockPath.traverse(loopVisitor, state);
	    return state;
	  };

	  _proto.hoistVarDeclarations = function hoistVarDeclarations() {
	    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
	  };

	  _proto.pushDeclar = function pushDeclar(node) {
	    var declars = [];
	    var names = getBindingIdentifiers$2(node);

	    for (var _i9 = 0, _Object$keys6 = Object.keys(names); _i9 < _Object$keys6.length; _i9++) {
	      var _name6 = _Object$keys6[_i9];
	      declars.push(variableDeclarator$8(names[_name6]));
	    }

	    this.body.push(variableDeclaration$8(node.kind, declars));
	    var replace = [];

	    for (var i = 0; i < node.declarations.length; i++) {
	      var declar = node.declarations[i];
	      if (!declar.init) continue;
	      var expr = assignmentExpression$c("=", cloneNode$i(declar.id), cloneNode$i(declar.init));
	      replace.push(inherits$1(expr, declar));
	    }

	    return replace;
	  };

	  _proto.buildHas = function buildHas(ret) {
	    var body = this.body;
	    var has = this.has;

	    if (has.hasBreakContinue) {
	      for (var _i10 = 0, _Object$keys7 = Object.keys(has.map); _i10 < _Object$keys7.length; _i10++) {
	        var key = _Object$keys7[_i10];
	        body.push(ifStatement(binaryExpression$4("===", identifier$j(ret), stringLiteral$8(key)), has.map[key]));
	      }
	    }

	    if (has.hasReturn) {
	      body.push(buildRetCheck({
	        RETURN: identifier$j(ret)
	      }));
	    }
	  };

	  return BlockScoping;
	}();

	var _templateObject$b;
	var helperIDs = new WeakMap();
	function addCreateSuperHelper(file) {
	  if (helperIDs.has(file)) {
	    return (cloneNode$i || clone)(helperIDs.get(file));
	  }

	  try {
	    return file.addHelper("createSuper");
	  } catch (_unused) {}

	  var id = file.scope.generateUidIdentifier("createSuper");
	  helperIDs.set(file, id);
	  var fn = helper$1({
	    CREATE_SUPER: id,
	    GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
	    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
	  });
	  file.path.unshiftContainer("body", [fn]);
	  file.scope.registerDeclaration(file.path.get("body.0"));
	  return cloneNode$i(id);
	}
	var helper$1 = template$2.statement(_templateObject$b || (_templateObject$b = _taggedTemplateLiteralLoose(["\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n"])));

	var _templateObject$a;

	function buildConstructor(classRef, constructorBody, node) {
	  var func = functionDeclaration(cloneNode$i(classRef), [], constructorBody);
	  inherits$1(func, node);
	  return func;
	}

	function transformClass(path, file, builtinClasses, isLoose, assumptions) {
	  var classState = {
	    parent: undefined,
	    scope: undefined,
	    node: undefined,
	    path: undefined,
	    file: undefined,
	    classId: undefined,
	    classRef: undefined,
	    superFnId: undefined,
	    superName: undefined,
	    superReturns: [],
	    isDerived: false,
	    extendsNative: false,
	    construct: undefined,
	    constructorBody: undefined,
	    userConstructor: undefined,
	    userConstructorPath: undefined,
	    hasConstructor: false,
	    staticPropBody: [],
	    body: [],
	    superThises: [],
	    pushedConstructor: false,
	    pushedInherits: false,
	    pushedCreateClass: false,
	    protoAlias: null,
	    isLoose: false,
	    dynamicKeys: new Map(),
	    methods: {
	      instance: {
	        hasComputed: false,
	        list: [],
	        map: new Map()
	      },
	      "static": {
	        hasComputed: false,
	        list: [],
	        map: new Map()
	      }
	    }
	  };

	  var setState = function setState(newState) {
	    Object.assign(classState, newState);
	  };

	  var findThisesVisitor = traverse.visitors.merge([environmentVisitor, {
	    ThisExpression: function ThisExpression(path) {
	      classState.superThises.push(path);
	    }
	  }]);

	  function createClassHelper(args) {
	    return callExpression$e(classState.file.addHelper("createClass"), args);
	  }

	  function maybeCreateConstructor() {
	    var hasConstructor = false;
	    var paths = classState.path.get("body.body");

	    for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
	      var _path = _step.value;
	      hasConstructor = _path.equals("kind", "constructor");
	      if (hasConstructor) break;
	    }

	    if (hasConstructor) return;
	    var params, body;

	    if (classState.isDerived) {
	      var _constructor = template$2.expression.ast(_templateObject$a || (_templateObject$a = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "])));

	      params = _constructor.params;
	      body = _constructor.body;
	    } else {
	      params = [];
	      body = blockStatement$6([]);
	    }

	    classState.path.get("body").unshiftContainer("body", classMethod("constructor", identifier$j("constructor"), params, body));
	  }

	  function buildBody() {
	    maybeCreateConstructor();
	    pushBody();
	    verifyConstructor();

	    if (classState.userConstructor) {
	      var _constructorBody$body;

	      var constructorBody = classState.constructorBody,
	          userConstructor = classState.userConstructor,
	          construct = classState.construct;

	      (_constructorBody$body = constructorBody.body).push.apply(_constructorBody$body, _toConsumableArray(userConstructor.body.body));

	      inherits$1(construct, userConstructor);
	      inherits$1(constructorBody, userConstructor.body);
	    }

	    pushDescriptors();
	  }

	  function pushBody() {
	    var classBodyPaths = classState.path.get("body.body");

	    for (var _iterator2 = _createForOfIteratorHelperLoose(classBodyPaths), _step2; !(_step2 = _iterator2()).done;) {
	      var _path2 = _step2.value;
	      var node = _path2.node;

	      if (_path2.isClassProperty()) {
	        throw _path2.buildCodeFrameError("Missing class properties transform.");
	      }

	      if (node.decorators) {
	        throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
	      }

	      if (isClassMethod$1(node)) {
	        (function () {
	          var isConstructor = node.kind === "constructor";
	          var replaceSupers = new ReplaceSupers({
	            methodPath: _path2,
	            objectRef: classState.classRef,
	            superRef: classState.superName,
	            constantSuper: assumptions.constantSuper,
	            file: classState.file,
	            refToPreserve: classState.classRef
	          });
	          replaceSupers.replace();
	          var superReturns = [];

	          _path2.traverse(traverse.visitors.merge([environmentVisitor, {
	            ReturnStatement: function ReturnStatement(path) {
	              if (!path.getFunctionParent().isArrowFunctionExpression()) {
	                superReturns.push(path);
	              }
	            }
	          }]));

	          if (isConstructor) {
	            pushConstructor(superReturns, node, _path2);
	          } else {
	            pushMethod(node, _path2);
	          }
	        })();
	      }
	    }
	  }

	  function pushDescriptors() {
	    pushInheritsToBody();
	    var body = classState.body;
	    var props = {
	      instance: null,
	      "static": null
	    };

	    for (var _i = 0, _arr = ["static", "instance"]; _i < _arr.length; _i++) {
	      var placement = _arr[_i];

	      if (classState.methods[placement].list.length) {
	        props[placement] = classState.methods[placement].list.map(function (desc) {
	          var obj = objectExpression$4([objectProperty$2(identifier$j("key"), desc.key)]);

	          for (var _i2 = 0, _arr2 = ["get", "set", "value"]; _i2 < _arr2.length; _i2++) {
	            var kind = _arr2[_i2];

	            if (desc[kind] != null) {
	              obj.properties.push(objectProperty$2(identifier$j(kind), desc[kind]));
	            }
	          }

	          return obj;
	        });
	      }
	    }

	    if (props.instance || props["static"]) {
	      var args = [cloneNode$i(classState.classRef), props.instance ? arrayExpression$2(props.instance) : nullLiteral$2(), props["static"] ? arrayExpression$2(props["static"]) : nullLiteral$2()];
	      var lastNonNullIndex = 0;

	      for (var i = 0; i < args.length; i++) {
	        if (!isNullLiteral$1(args[i])) lastNonNullIndex = i;
	      }

	      args = args.slice(0, lastNonNullIndex + 1);
	      body.push(expressionStatement$a(createClassHelper(args)));
	      classState.pushedCreateClass = true;
	    }
	  }

	  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
	    var bareSuperNode = bareSuper.node;
	    var call;

	    if (assumptions.superIsCallableConstructor) {
	      bareSuperNode.arguments.unshift(thisExpression$3());

	      if (bareSuperNode.arguments.length === 2 && isSpreadElement$1(bareSuperNode.arguments[1]) && isIdentifier$g(bareSuperNode.arguments[1].argument, {
	        name: "arguments"
	      })) {
	        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
	        bareSuperNode.callee = memberExpression$b(cloneNode$i(superRef), identifier$j("apply"));
	      } else {
	        bareSuperNode.callee = memberExpression$b(cloneNode$i(superRef), identifier$j("call"));
	      }

	      call = logicalExpression$2("||", bareSuperNode, thisExpression$3());
	    } else {
	      call = optimiseCallExpression(cloneNode$i(classState.superFnId), thisExpression$3(), bareSuperNode.arguments, false);
	    }

	    if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
	      if (classState.superThises.length) {
	        call = assignmentExpression$c("=", thisRef(), call);
	      }

	      bareSuper.parentPath.replaceWith(returnStatement$3(call));
	    } else {
	      bareSuper.replaceWith(assignmentExpression$c("=", thisRef(), call));
	    }
	  }

	  function verifyConstructor() {
	    if (!classState.isDerived) return;
	    var path = classState.userConstructorPath;
	    var body = path.get("body");
	    path.traverse(findThisesVisitor);

	    var _thisRef = function thisRef() {
	      var ref = path.scope.generateDeclaredUidIdentifier("this");

	      _thisRef = function thisRef() {
	        return cloneNode$i(ref);
	      };

	      return ref;
	    };

	    for (var _iterator3 = _createForOfIteratorHelperLoose(classState.superThises), _step3; !(_step3 = _iterator3()).done;) {
	      var thisPath = _step3.value;
	      var node = thisPath.node,
	          parentPath = thisPath.parentPath;

	      if (parentPath.isMemberExpression({
	        object: node
	      })) {
	        thisPath.replaceWith(_thisRef());
	        continue;
	      }

	      thisPath.replaceWith(callExpression$e(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
	    }

	    var bareSupers = new Set();
	    path.traverse(traverse.visitors.merge([environmentVisitor, {
	      Super: function Super(path) {
	        var node = path.node,
	            parentPath = path.parentPath;

	        if (parentPath.isCallExpression({
	          callee: node
	        })) {
	          bareSupers.add(parentPath);
	        }
	      }
	    }]));
	    var guaranteedSuperBeforeFinish = !!bareSupers.size;

	    for (var _iterator4 = _createForOfIteratorHelperLoose(bareSupers), _step4; !(_step4 = _iterator4()).done;) {
	      var bareSuper = _step4.value;
	      wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

	      if (guaranteedSuperBeforeFinish) {
	        bareSuper.find(function (parentPath) {
	          if (parentPath === path) {
	            return true;
	          }

	          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
	            guaranteedSuperBeforeFinish = false;
	            return true;
	          }
	        });
	      }
	    }

	    var wrapReturn;

	    if (classState.isLoose) {
	      wrapReturn = function wrapReturn(returnArg) {
	        var thisExpr = callExpression$e(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);
	        return returnArg ? logicalExpression$2("||", returnArg, thisExpr) : thisExpr;
	      };
	    } else {
	      wrapReturn = function wrapReturn(returnArg) {
	        return callExpression$e(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
	      };
	    }

	    var bodyPaths = body.get("body");

	    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
	      body.pushContainer("body", returnStatement$3(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
	    }

	    for (var _iterator5 = _createForOfIteratorHelperLoose(classState.superReturns), _step5; !(_step5 = _iterator5()).done;) {
	      var returnPath = _step5.value;
	      returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
	    }
	  }

	  function pushMethod(node, path) {
	    var scope = path ? path.scope : classState.scope;

	    if (node.kind === "method") {
	      if (processMethod(node, scope)) return;
	    }

	    var placement = node["static"] ? "static" : "instance";
	    var methods = classState.methods[placement];
	    var descKey = node.kind === "method" ? "value" : node.kind;
	    var key = isNumericLiteral(node.key) || isBigIntLiteral(node.key) ? stringLiteral$8(String(node.key.value)) : toComputedKey$3(node);
	    var fn = toExpression$1(node);

	    if (isStringLiteral$7(key)) {
	      if (node.kind === "method") {
	        fn = nameFunction({
	          id: key,
	          node: node,
	          scope: scope
	        });
	      }
	    } else {
	      methods.hasComputed = true;
	    }

	    var descriptor;

	    if (!methods.hasComputed && methods.map.has(key.value)) {
	      descriptor = methods.map.get(key.value);
	      descriptor[descKey] = fn;

	      if (descKey === "value") {
	        descriptor.get = null;
	        descriptor.set = null;
	      } else {
	        descriptor.value = null;
	      }
	    } else {
	      var _descriptor;

	      descriptor = (_descriptor = {
	        key: key
	      }, _descriptor[descKey] = fn, _descriptor);
	      methods.list.push(descriptor);

	      if (!methods.hasComputed) {
	        methods.map.set(key.value, descriptor);
	      }
	    }
	  }

	  function processMethod(node, scope) {
	    if (assumptions.setClassMethods && !node.decorators) {
	      var classRef = classState.classRef;

	      if (!node["static"]) {
	        insertProtoAliasOnce();
	        classRef = classState.protoAlias;
	      }

	      var methodName = memberExpression$b(cloneNode$i(classRef), node.key, node.computed || isLiteral$7(node.key));
	      var func = functionExpression$3(null, node.params, node.body, node.generator, node.async);
	      inherits$1(func, node);
	      var key = toComputedKey$3(node, node.key);

	      if (isStringLiteral$7(key)) {
	        func = nameFunction({
	          node: func,
	          id: key,
	          scope: scope
	        });
	      }

	      var expr = expressionStatement$a(assignmentExpression$c("=", methodName, func));
	      inheritsComments$2(expr, node);
	      classState.body.push(expr);
	      return true;
	    }

	    return false;
	  }

	  function insertProtoAliasOnce() {
	    if (classState.protoAlias === null) {
	      setState({
	        protoAlias: classState.scope.generateUidIdentifier("proto")
	      });
	      var classProto = memberExpression$b(classState.classRef, identifier$j("prototype"));
	      var protoDeclaration = variableDeclaration$8("var", [variableDeclarator$8(classState.protoAlias, classProto)]);
	      classState.body.push(protoDeclaration);
	    }
	  }

	  function pushConstructor(superReturns, method, path) {
	    setState({
	      userConstructorPath: path,
	      userConstructor: method,
	      hasConstructor: true,
	      superReturns: superReturns
	    });
	    var construct = classState.construct;
	    inheritsComments$2(construct, method);
	    construct.params = method.params;
	    inherits$1(construct.body, method.body);
	    construct.body.directives = method.body.directives;
	    pushConstructorToBody();
	  }

	  function pushConstructorToBody() {
	    if (classState.pushedConstructor) return;
	    classState.pushedConstructor = true;

	    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
	      pushDescriptors();
	    }

	    classState.body.push(classState.construct);
	    pushInheritsToBody();
	  }

	  function pushInheritsToBody() {
	    if (!classState.isDerived || classState.pushedInherits) return;
	    var superFnId = path.scope.generateUidIdentifier("super");
	    setState({
	      pushedInherits: true,
	      superFnId: superFnId
	    });

	    if (!assumptions.superIsCallableConstructor) {
	      classState.body.unshift(variableDeclaration$8("var", [variableDeclarator$8(superFnId, callExpression$e(addCreateSuperHelper(classState.file), [cloneNode$i(classState.classRef)]))]));
	    }

	    classState.body.unshift(expressionStatement$a(callExpression$e(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [cloneNode$i(classState.classRef), cloneNode$i(classState.superName)])));
	  }

	  function extractDynamicKeys() {
	    var _ref = classState,
	        dynamicKeys = _ref.dynamicKeys,
	        node = _ref.node,
	        scope = _ref.scope;

	    for (var _iterator6 = _createForOfIteratorHelperLoose(node.body.body), _step6; !(_step6 = _iterator6()).done;) {
	      var elem = _step6.value;
	      if (!isClassMethod$1(elem) || !elem.computed) continue;
	      if (scope.isPure(elem.key, true)) continue;
	      var id = scope.generateUidIdentifierBasedOnNode(elem.key);
	      dynamicKeys.set(id.name, elem.key);
	      elem.key = id;
	    }
	  }

	  function setupClosureParamsArgs() {
	    var superName = classState.superName,
	        dynamicKeys = classState.dynamicKeys;
	    var closureParams = [];
	    var closureArgs = [];

	    if (classState.isDerived) {
	      var arg = cloneNode$i(superName);

	      if (classState.extendsNative) {
	        arg = callExpression$e(classState.file.addHelper("wrapNativeSuper"), [arg]);
	        annotateAsPure(arg);
	      }

	      var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
	      closureParams.push(param);
	      closureArgs.push(arg);
	      setState({
	        superName: cloneNode$i(param)
	      });
	    }

	    for (var _iterator7 = _createForOfIteratorHelperLoose(dynamicKeys), _step7; !(_step7 = _iterator7()).done;) {
	      var _step7$value = _slicedToArray$1(_step7.value, 2),
	          name = _step7$value[0],
	          value = _step7$value[1];

	      closureParams.push(identifier$j(name));
	      closureArgs.push(value);
	    }

	    return {
	      closureParams: closureParams,
	      closureArgs: closureArgs
	    };
	  }

	  function classTransformer(path, file, builtinClasses, isLoose) {
	    setState({
	      parent: path.parent,
	      scope: path.scope,
	      node: path.node,
	      path: path,
	      file: file,
	      isLoose: isLoose
	    });
	    setState({
	      classId: classState.node.id,
	      classRef: classState.node.id ? identifier$j(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
	      superName: classState.node.superClass,
	      isDerived: !!classState.node.superClass,
	      constructorBody: blockStatement$6([])
	    });
	    setState({
	      extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
	    });
	    var classRef = classState.classRef,
	        node = classState.node,
	        constructorBody = classState.constructorBody;
	    setState({
	      construct: buildConstructor(classRef, constructorBody, node)
	    });
	    extractDynamicKeys();
	    var body = classState.body;

	    var _setupClosureParamsAr = setupClosureParamsArgs(),
	        closureParams = _setupClosureParamsAr.closureParams,
	        closureArgs = _setupClosureParamsAr.closureArgs;

	    buildBody();

	    if (!assumptions.noClassCalls) {
	      constructorBody.body.unshift(expressionStatement$a(callExpression$e(classState.file.addHelper("classCallCheck"), [thisExpression$3(), cloneNode$i(classState.classRef)])));
	    }

	    body.push.apply(body, _toConsumableArray(classState.staticPropBody.map(function (fn) {
	      return fn(cloneNode$i(classState.classRef));
	    })));
	    var isStrict = path.isInStrictMode();
	    var constructorOnly = classState.classId && body.length === 1;

	    if (constructorOnly && !isStrict) {
	      for (var _iterator8 = _createForOfIteratorHelperLoose(classState.construct.params), _step8; !(_step8 = _iterator8()).done;) {
	        var param = _step8.value;

	        if (!isIdentifier$g(param)) {
	          constructorOnly = false;
	          break;
	        }
	      }
	    }

	    var directives = constructorOnly ? body[0].body.directives : [];

	    if (!isStrict) {
	      directives.push(directive$1(directiveLiteral$1("use strict")));
	    }

	    if (constructorOnly) {
	      var expr = toExpression$1(body[0]);
	      return classState.isLoose ? expr : createClassHelper([expr]);
	    }

	    var returnArg = cloneNode$i(classState.classRef);

	    if (!classState.pushedCreateClass && !classState.isLoose) {
	      returnArg = createClassHelper([returnArg]);
	    }

	    body.push(returnStatement$3(returnArg));
	    var container = arrowFunctionExpression$4(closureParams, blockStatement$6(body, directives));
	    return callExpression$e(container, closureArgs);
	  }

	  return classTransformer(path, file, builtinClasses, isLoose);
	}

	var getBuiltinClasses = function getBuiltinClasses(category) {
	  return Object.keys(globals[category]).filter(function (name) {
	    return /^[A-Z]/.test(name);
	  });
	};

	var builtinClasses = new Set([].concat(_toConsumableArray(getBuiltinClasses("builtin")), _toConsumableArray(getBuiltinClasses("browser"))));
	var _transformClasses = declare(function (api, options) {
	  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;

	  api.assertVersion(7);
	  var loose = options.loose;
	  var setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : options.loose;
	  var constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : options.loose;
	  var superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : options.loose;
	  var noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : options.loose;
	  var VISITED = Symbol();
	  return {
	    name: "transform-classes",
	    visitor: {
	      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
	        if (!path.get("declaration").isClassDeclaration()) return;
	        splitExportDeclaration(path);
	      },
	      ClassDeclaration: function ClassDeclaration(path) {
	        var node = path.node;
	        var ref = node.id || path.scope.generateUidIdentifier("class");
	        path.replaceWith(variableDeclaration$8("let", [variableDeclarator$8(ref, toExpression$1(node))]));
	      },
	      ClassExpression: function ClassExpression(path, state) {
	        var node = path.node;
	        if (node[VISITED]) return;
	        var inferred = nameFunction(path);

	        if (inferred && inferred !== node) {
	          path.replaceWith(inferred);
	          return;
	        }

	        node[VISITED] = true;
	        path.replaceWith(transformClass(path, state.file, builtinClasses, loose, {
	          setClassMethods: setClassMethods,
	          constantSuper: constantSuper,
	          superIsCallableConstructor: superIsCallableConstructor,
	          noClassCalls: noClassCalls
	        }));

	        if (path.isCallExpression()) {
	          annotateAsPure(path);
	          var callee = path.get("callee");

	          if (callee.isArrowFunctionExpression()) {
	            callee.arrowFunctionToExpression();
	          }
	        }
	      }
	    }
	  };
	});

	var _transformComputedProperties = declare(function (api, options) {
	  var _api$assumption;

	  api.assertVersion(7);
	  var setComputedProperties = (_api$assumption = api.assumption("setComputedProperties")) != null ? _api$assumption : options.loose;
	  var pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;
	  var buildMutatorMapAssign = template$2("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

	  function getValue(prop) {
	    if (isObjectProperty$4(prop)) {
	      return prop.value;
	    } else if (isObjectMethod$2(prop)) {
	      return functionExpression$3(null, prop.params, prop.body, prop.generator, prop.async);
	    }
	  }

	  function pushAssign(objId, prop, body) {
	    if (prop.kind === "get" && prop.kind === "set") {
	      pushMutatorDefine(objId, prop);
	    } else {
	      body.push(expressionStatement$a(assignmentExpression$c("=", memberExpression$b(cloneNode$i(objId), prop.key, prop.computed || isLiteral$7(prop.key)), getValue(prop))));
	    }
	  }

	  function pushMutatorDefine(_ref, prop) {
	    var body = _ref.body,
	        getMutatorId = _ref.getMutatorId,
	        scope = _ref.scope;
	    var key = !prop.computed && isIdentifier$g(prop.key) ? stringLiteral$8(prop.key.name) : prop.key;
	    var maybeMemoise = scope.maybeGenerateMemoised(key);

	    if (maybeMemoise) {
	      body.push(expressionStatement$a(assignmentExpression$c("=", maybeMemoise, key)));
	      key = maybeMemoise;
	    }

	    body.push.apply(body, _toConsumableArray(buildMutatorMapAssign({
	      MUTATOR_MAP_REF: getMutatorId(),
	      KEY: cloneNode$i(key),
	      VALUE: getValue(prop),
	      KIND: identifier$j(prop.kind)
	    })));
	  }

	  function pushComputedPropsLoose(info) {
	    for (var _iterator = _createForOfIteratorHelperLoose(info.computedProps), _step; !(_step = _iterator()).done;) {
	      var prop = _step.value;

	      if (prop.kind === "get" || prop.kind === "set") {
	        pushMutatorDefine(info, prop);
	      } else {
	        pushAssign(cloneNode$i(info.objId), prop, info.body);
	      }
	    }
	  }

	  function pushComputedPropsSpec(info) {
	    var objId = info.objId,
	        body = info.body,
	        computedProps = info.computedProps,
	        state = info.state;

	    for (var _iterator2 = _createForOfIteratorHelperLoose(computedProps), _step2; !(_step2 = _iterator2()).done;) {
	      var prop = _step2.value;
	      var key = toComputedKey$3(prop);

	      if (prop.kind === "get" || prop.kind === "set") {
	        pushMutatorDefine(info, prop);
	      } else {
	        if (computedProps.length === 1) {
	          return callExpression$e(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
	        } else {
	          body.push(expressionStatement$a(callExpression$e(state.addHelper("defineProperty"), [cloneNode$i(objId), key, getValue(prop)])));
	        }
	      }
	    }
	  }

	  return {
	    name: "transform-computed-properties",
	    visitor: {
	      ObjectExpression: {
	        exit: function exit(path, state) {
	          var node = path.node,
	              parent = path.parent,
	              scope = path.scope;
	          var hasComputed = false;

	          for (var _iterator3 = _createForOfIteratorHelperLoose(node.properties), _step3; !(_step3 = _iterator3()).done;) {
	            var prop = _step3.value;
	            hasComputed = prop.computed === true;
	            if (hasComputed) break;
	          }

	          if (!hasComputed) return;
	          var initProps = [];
	          var computedProps = [];
	          var foundComputed = false;

	          for (var _iterator4 = _createForOfIteratorHelperLoose(node.properties), _step4; !(_step4 = _iterator4()).done;) {
	            var _prop = _step4.value;

	            if (_prop.computed) {
	              foundComputed = true;
	            }

	            if (foundComputed) {
	              computedProps.push(_prop);
	            } else {
	              initProps.push(_prop);
	            }
	          }

	          var objId = scope.generateUidIdentifierBasedOnNode(parent);
	          var initPropExpression = objectExpression$4(initProps);
	          var body = [];
	          body.push(variableDeclaration$8("var", [variableDeclarator$8(objId, initPropExpression)]));
	          var mutatorRef;

	          var getMutatorId = function getMutatorId() {
	            if (!mutatorRef) {
	              mutatorRef = scope.generateUidIdentifier("mutatorMap");
	              body.push(variableDeclaration$8("var", [variableDeclarator$8(mutatorRef, objectExpression$4([]))]));
	            }

	            return cloneNode$i(mutatorRef);
	          };

	          var single = pushComputedProps({
	            scope: scope,
	            objId: objId,
	            body: body,
	            computedProps: computedProps,
	            initPropExpression: initPropExpression,
	            getMutatorId: getMutatorId,
	            state: state
	          });

	          if (mutatorRef) {
	            body.push(expressionStatement$a(callExpression$e(state.addHelper("defineEnumerableProperties"), [cloneNode$i(objId), cloneNode$i(mutatorRef)])));
	          }

	          if (single) {
	            path.replaceWith(single);
	          } else {
	            body.push(expressionStatement$a(cloneNode$i(objId)));
	            path.replaceWithMultiple(body);
	          }
	        }
	      }
	    }
	  };
	});

	var _transformDestructuring = declare(function (api, options) {
	  var _api$assumption, _options$allowArrayLi, _api$assumption2;

	  api.assertVersion(7);
	  var _options$useBuiltIns = options.useBuiltIns,
	      useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;
	  var iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
	  var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
	  var objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose;

	  function getExtendsHelper(file) {
	    return useBuiltIns ? memberExpression$b(identifier$j("Object"), identifier$j("assign")) : file.addHelper("extends");
	  }

	  function variableDeclarationHasPattern(node) {
	    for (var _iterator = _createForOfIteratorHelperLoose(node.declarations), _step; !(_step = _iterator()).done;) {
	      var declar = _step.value;

	      if (isPattern(declar.id)) {
	        return true;
	      }
	    }

	    return false;
	  }

	  function hasRest(pattern) {
	    for (var _iterator2 = _createForOfIteratorHelperLoose(pattern.elements), _step2; !(_step2 = _iterator2()).done;) {
	      var elem = _step2.value;

	      if (isRestElement$2(elem)) {
	        return true;
	      }
	    }

	    return false;
	  }

	  function hasObjectRest(pattern) {
	    for (var _iterator3 = _createForOfIteratorHelperLoose(pattern.properties), _step3; !(_step3 = _iterator3()).done;) {
	      var elem = _step3.value;

	      if (isRestElement$2(elem)) {
	        return true;
	      }
	    }

	    return false;
	  }

	  var STOP_TRAVERSAL = {};

	  var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
	    if (!ancestors.length) {
	      return;
	    }

	    if (isIdentifier$g(node) && isReferenced$2(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
	      state.deopt = true;
	      throw STOP_TRAVERSAL;
	    }
	  };

	  var DestructuringTransformer = function () {
	    function DestructuringTransformer(opts) {
	      this.blockHoist = void 0;
	      this.operator = void 0;
	      this.arrays = void 0;
	      this.nodes = void 0;
	      this.scope = void 0;
	      this.kind = void 0;
	      this.iterableIsArray = void 0;
	      this.arrayLikeIsIterable = void 0;
	      this.addHelper = void 0;
	      this.blockHoist = opts.blockHoist;
	      this.operator = opts.operator;
	      this.arrays = {};
	      this.nodes = opts.nodes || [];
	      this.scope = opts.scope;
	      this.kind = opts.kind;
	      this.iterableIsArray = opts.iterableIsArray;
	      this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
	      this.addHelper = opts.addHelper;
	    }

	    var _proto = DestructuringTransformer.prototype;

	    _proto.buildVariableAssignment = function buildVariableAssignment(id, init) {
	      var op = this.operator;
	      if (isMemberExpression$8(id)) op = "=";
	      var node;

	      if (op) {
	        node = expressionStatement$a(assignmentExpression$c(op, id, cloneNode$i(init) || this.scope.buildUndefinedNode()));
	      } else {
	        node = variableDeclaration$8(this.kind, [variableDeclarator$8(id, cloneNode$i(init))]);
	      }

	      node._blockHoist = this.blockHoist;
	      return node;
	    };

	    _proto.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
	      var declar = variableDeclaration$8("var", [variableDeclarator$8(cloneNode$i(id), cloneNode$i(init))]);
	      declar._blockHoist = this.blockHoist;
	      return declar;
	    };

	    _proto.push = function push(id, _init) {
	      var init = cloneNode$i(_init);

	      if (isObjectPattern$1(id)) {
	        this.pushObjectPattern(id, init);
	      } else if (isArrayPattern(id)) {
	        this.pushArrayPattern(id, init);
	      } else if (isAssignmentPattern$4(id)) {
	        this.pushAssignmentPattern(id, init);
	      } else {
	        this.nodes.push(this.buildVariableAssignment(id, init));
	      }
	    };

	    _proto.toArray = function toArray(node, count) {
	      if (this.iterableIsArray || isIdentifier$g(node) && this.arrays[node.name]) {
	        return node;
	      } else {
	        return this.scope.toArray(node, count, this.arrayLikeIsIterable);
	      }
	    };

	    _proto.pushAssignmentPattern = function pushAssignmentPattern(_ref, valueRef) {
	      var left = _ref.left,
	          right = _ref.right;
	      var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
	      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
	      var tempConditional = conditionalExpression$3(binaryExpression$4("===", cloneNode$i(tempId), this.scope.buildUndefinedNode()), right, cloneNode$i(tempId));

	      if (isPattern(left)) {
	        var patternId;
	        var node;

	        if (this.kind === "const" || this.kind === "let") {
	          patternId = this.scope.generateUidIdentifier(tempId.name);
	          node = this.buildVariableDeclaration(patternId, tempConditional);
	        } else {
	          patternId = tempId;
	          node = expressionStatement$a(assignmentExpression$c("=", cloneNode$i(tempId), tempConditional));
	        }

	        this.nodes.push(node);
	        this.push(left, patternId);
	      } else {
	        this.nodes.push(this.buildVariableAssignment(left, tempConditional));
	      }
	    };

	    _proto.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
	      var keys = [];
	      var allLiteral = true;
	      var hasTemplateLiteral = false;

	      for (var i = 0; i < pattern.properties.length; i++) {
	        var prop = pattern.properties[i];
	        if (i >= spreadPropIndex) break;
	        if (isRestElement$2(prop)) continue;
	        var key = prop.key;

	        if (isIdentifier$g(key) && !prop.computed) {
	          keys.push(stringLiteral$8(key.name));
	        } else if (isTemplateLiteral$2(key)) {
	          keys.push(cloneNode$i(key));
	          hasTemplateLiteral = true;
	        } else if (isLiteral$7(key)) {
	          keys.push(stringLiteral$8(String(key.value)));
	        } else {
	          keys.push(cloneNode$i(key));
	          allLiteral = false;
	        }
	      }

	      var value;

	      if (keys.length === 0) {
	        value = callExpression$e(getExtendsHelper(this), [objectExpression$4([]), cloneNode$i(objRef)]);
	      } else {
	        var keyExpression = arrayExpression$2(keys);

	        if (!allLiteral) {
	          keyExpression = callExpression$e(memberExpression$b(keyExpression, identifier$j("map")), [this.addHelper("toPropertyKey")]);
	        } else if (!hasTemplateLiteral && !isProgram$2(this.scope.block)) {
	          var program = this.scope.path.findParent(function (path) {
	            return path.isProgram();
	          });
	          var id = this.scope.generateUidIdentifier("excluded");
	          program.scope.push({
	            id: id,
	            init: keyExpression,
	            kind: "const"
	          });
	          keyExpression = cloneNode$i(id);
	        }

	        value = callExpression$e(this.addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [cloneNode$i(objRef), keyExpression]);
	      }

	      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
	    };

	    _proto.pushObjectProperty = function pushObjectProperty(prop, propRef) {
	      if (isLiteral$7(prop.key)) prop.computed = true;
	      var pattern = prop.value;
	      var objRef = memberExpression$b(cloneNode$i(propRef), prop.key, prop.computed);

	      if (isPattern(pattern)) {
	        this.push(pattern, objRef);
	      } else {
	        this.nodes.push(this.buildVariableAssignment(pattern, objRef));
	      }
	    };

	    _proto.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
	      if (!pattern.properties.length) {
	        this.nodes.push(expressionStatement$a(callExpression$e(this.addHelper("objectDestructuringEmpty"), [objRef])));
	      }

	      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
	        var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
	        this.nodes.push(this.buildVariableDeclaration(temp, objRef));
	        objRef = temp;
	      }

	      if (hasObjectRest(pattern)) {
	        var copiedPattern;

	        for (var i = 0; i < pattern.properties.length; i++) {
	          var prop = pattern.properties[i];

	          if (isRestElement$2(prop)) {
	            break;
	          }

	          var key = prop.key;

	          if (prop.computed && !this.scope.isPure(key)) {
	            var name = this.scope.generateUidIdentifierBasedOnNode(key);
	            this.nodes.push(this.buildVariableDeclaration(name, key));

	            if (!copiedPattern) {
	              copiedPattern = pattern = Object.assign({}, pattern, {
	                properties: pattern.properties.slice()
	              });
	            }

	            copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
	              key: name
	            });
	          }
	        }
	      }

	      for (var _i = 0; _i < pattern.properties.length; _i++) {
	        var _prop = pattern.properties[_i];

	        if (isRestElement$2(_prop)) {
	          this.pushObjectRest(pattern, objRef, _prop, _i);
	        } else {
	          this.pushObjectProperty(_prop, objRef);
	        }
	      }
	    };

	    _proto.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
	      if (!isArrayExpression$2(arr)) return false;
	      if (pattern.elements.length > arr.elements.length) return;

	      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
	        return false;
	      }

	      for (var _iterator4 = _createForOfIteratorHelperLoose(pattern.elements), _step4; !(_step4 = _iterator4()).done;) {
	        var elem = _step4.value;
	        if (!elem) return false;
	        if (isMemberExpression$8(elem)) return false;
	      }

	      for (var _iterator5 = _createForOfIteratorHelperLoose(arr.elements), _step5; !(_step5 = _iterator5()).done;) {
	        var _elem = _step5.value;
	        if (isSpreadElement$1(_elem)) return false;
	        if (isCallExpression$6(_elem)) return false;
	        if (isMemberExpression$8(_elem)) return false;
	      }

	      var bindings = getBindingIdentifiers$2(pattern);
	      var state = {
	        deopt: false,
	        bindings: bindings
	      };

	      try {
	        traverse$2(arr, arrayUnpackVisitor, state);
	      } catch (e) {
	        if (e !== STOP_TRAVERSAL) throw e;
	      }

	      return !state.deopt;
	    };

	    _proto.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
	      for (var i = 0; i < pattern.elements.length; i++) {
	        var elem = pattern.elements[i];

	        if (isRestElement$2(elem)) {
	          this.push(elem.argument, arrayExpression$2(arr.elements.slice(i)));
	        } else {
	          this.push(elem, arr.elements[i]);
	        }
	      }
	    };

	    _proto.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
	      if (!pattern.elements) return;

	      if (this.canUnpackArrayPattern(pattern, arrayRef)) {
	        return this.pushUnpackedArrayPattern(pattern, arrayRef);
	      }

	      var count = !hasRest(pattern) && pattern.elements.length;
	      var toArray = this.toArray(arrayRef, count);

	      if (isIdentifier$g(toArray)) {
	        arrayRef = toArray;
	      } else {
	        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
	        this.arrays[arrayRef.name] = true;
	        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
	      }

	      for (var i = 0; i < pattern.elements.length; i++) {
	        var elem = pattern.elements[i];
	        if (!elem) continue;
	        var elemRef = void 0;

	        if (isRestElement$2(elem)) {
	          elemRef = this.toArray(arrayRef);
	          elemRef = callExpression$e(memberExpression$b(elemRef, identifier$j("slice")), [numericLiteral$8(i)]);
	          elem = elem.argument;
	        } else {
	          elemRef = memberExpression$b(arrayRef, numericLiteral$8(i), true);
	        }

	        this.push(elem, elemRef);
	      }
	    };

	    _proto.init = function init(pattern, ref) {
	      if (!isArrayExpression$2(ref) && !isMemberExpression$8(ref)) {
	        var memo = this.scope.maybeGenerateMemoised(ref, true);

	        if (memo) {
	          this.nodes.push(this.buildVariableDeclaration(memo, cloneNode$i(ref)));
	          ref = memo;
	        }
	      }

	      this.push(pattern, ref);
	      return this.nodes;
	    };

	    return DestructuringTransformer;
	  }();

	  return {
	    name: "transform-destructuring",
	    visitor: {
	      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
	        var declaration = path.get("declaration");
	        if (!declaration.isVariableDeclaration()) return;
	        if (!variableDeclarationHasPattern(declaration.node)) return;
	        var specifiers = [];

	        for (var _i2 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i2 < _Object$keys.length; _i2++) {
	          var name = _Object$keys[_i2];
	          specifiers.push(exportSpecifier$2(identifier$j(name), identifier$j(name)));
	        }

	        path.replaceWith(declaration.node);
	        path.insertAfter(exportNamedDeclaration$2(null, specifiers));
	      },
	      ForXStatement: function ForXStatement(path) {
	        var _this = this;

	        var node = path.node,
	            scope = path.scope;
	        var left = node.left;

	        if (isPattern(left)) {
	          var temp = scope.generateUidIdentifier("ref");
	          node.left = variableDeclaration$8("var", [variableDeclarator$8(temp)]);
	          path.ensureBlock();

	          if (node.body.body.length === 0 && path.isCompletionRecord()) {
	            node.body.body.unshift(expressionStatement$a(scope.buildUndefinedNode()));
	          }

	          node.body.body.unshift(expressionStatement$a(assignmentExpression$c("=", left, temp)));
	          return;
	        }

	        if (!isVariableDeclaration$3(left)) return;
	        var pattern = left.declarations[0].id;
	        if (!isPattern(pattern)) return;
	        var key = scope.generateUidIdentifier("ref");
	        node.left = variableDeclaration$8(left.kind, [variableDeclarator$8(key, null)]);
	        var nodes = [];
	        var destructuring = new DestructuringTransformer({
	          kind: left.kind,
	          scope: scope,
	          nodes: nodes,
	          iterableIsArray: iterableIsArray,
	          arrayLikeIsIterable: arrayLikeIsIterable,
	          addHelper: function addHelper(name) {
	            return _this.addHelper(name);
	          }
	        });
	        destructuring.init(pattern, key);
	        path.ensureBlock();
	        var block = node.body;
	        block.body = nodes.concat(block.body);
	      },
	      CatchClause: function CatchClause(_ref2) {
	        var _this2 = this;

	        var node = _ref2.node,
	            scope = _ref2.scope;
	        var pattern = node.param;
	        if (!isPattern(pattern)) return;
	        var ref = scope.generateUidIdentifier("ref");
	        node.param = ref;
	        var nodes = [];
	        var destructuring = new DestructuringTransformer({
	          kind: "let",
	          scope: scope,
	          nodes: nodes,
	          iterableIsArray: iterableIsArray,
	          arrayLikeIsIterable: arrayLikeIsIterable,
	          addHelper: function addHelper(name) {
	            return _this2.addHelper(name);
	          }
	        });
	        destructuring.init(pattern, ref);
	        node.body.body = nodes.concat(node.body.body);
	      },
	      AssignmentExpression: function AssignmentExpression(path) {
	        var _this3 = this;

	        var node = path.node,
	            scope = path.scope;
	        if (!isPattern(node.left)) return;
	        var nodes = [];
	        var destructuring = new DestructuringTransformer({
	          operator: node.operator,
	          scope: scope,
	          nodes: nodes,
	          iterableIsArray: iterableIsArray,
	          arrayLikeIsIterable: arrayLikeIsIterable,
	          addHelper: function addHelper(name) {
	            return _this3.addHelper(name);
	          }
	        });
	        var ref;

	        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
	          ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
	          nodes.push(variableDeclaration$8("var", [variableDeclarator$8(ref, node.right)]));

	          if (isArrayExpression$2(node.right)) {
	            destructuring.arrays[ref.name] = true;
	          }
	        }

	        destructuring.init(node.left, ref || node.right);

	        if (ref) {
	          if (path.parentPath.isArrowFunctionExpression()) {
	            path.replaceWith(blockStatement$6([]));
	            nodes.push(returnStatement$3(cloneNode$i(ref)));
	          } else {
	            nodes.push(expressionStatement$a(cloneNode$i(ref)));
	          }
	        }

	        path.replaceWithMultiple(nodes);
	        path.scope.crawl();
	      },
	      VariableDeclaration: function VariableDeclaration(path) {
	        var _this4 = this;

	        var node = path.node,
	            scope = path.scope,
	            parent = path.parent;
	        if (isForXStatement$1(parent)) return;
	        if (!parent || !path.container) return;
	        if (!variableDeclarationHasPattern(node)) return;
	        var nodeKind = node.kind;
	        var nodeLoc = node.loc;
	        var nodes = [];
	        var declar;

	        for (var i = 0; i < node.declarations.length; i++) {
	          declar = node.declarations[i];
	          var patternId = declar.init;
	          var pattern = declar.id;
	          var destructuring = new DestructuringTransformer({
	            blockHoist: node._blockHoist,
	            nodes: nodes,
	            scope: scope,
	            kind: node.kind,
	            iterableIsArray: iterableIsArray,
	            arrayLikeIsIterable: arrayLikeIsIterable,
	            addHelper: function addHelper(name) {
	              return _this4.addHelper(name);
	            }
	          });

	          if (isPattern(pattern)) {
	            destructuring.init(pattern, patternId);

	            if (+i !== node.declarations.length - 1) {
	              inherits$1(nodes[nodes.length - 1], declar);
	            }
	          } else {
	            nodes.push(inherits$1(destructuring.buildVariableAssignment(declar.id, cloneNode$i(declar.init)), declar));
	          }
	        }

	        var tail = null;
	        var nodesOut = [];

	        for (var _i3 = 0, _nodes = nodes; _i3 < _nodes.length; _i3++) {
	          var _node = _nodes[_i3];

	          if (tail !== null && isVariableDeclaration$3(_node)) {
	            var _tail$declarations;

	            (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _toConsumableArray(_node.declarations));
	          } else {
	            _node.kind = nodeKind;

	            if (!_node.loc) {
	              _node.loc = nodeLoc;
	            }

	            nodesOut.push(_node);
	            tail = isVariableDeclaration$3(_node) ? _node : null;
	          }
	        }

	        for (var _i4 = 0, _nodesOut = nodesOut; _i4 < _nodesOut.length; _i4++) {
	          var nodeOut = _nodesOut[_i4];
	          if (!nodeOut.declarations) continue;

	          for (var _iterator6 = _createForOfIteratorHelperLoose(nodeOut.declarations), _step6; !(_step6 = _iterator6()).done;) {
	            var declaration = _step6.value;
	            var name = declaration.id.name;

	            if (scope.bindings[name]) {
	              scope.bindings[name].kind = nodeOut.kind;
	            }
	          }
	        }

	        if (nodesOut.length === 1) {
	          path.replaceWith(nodesOut[0]);
	        } else {
	          path.replaceWithMultiple(nodesOut);
	        }
	      }
	    }
	  };
	});

	var _transformDotallRegex = declare(function (api) {
	  api.assertVersion(7);
	  return createRegExpFeaturePlugin({
	    name: "transform-dotall-regex",
	    feature: "dotAllFlag"
	  });
	});

	function getName(key) {
	  if (isIdentifier$g(key)) {
	    return key.name;
	  }

	  return key.value.toString();
	}

	var _transformDuplicateKeys = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-duplicate-keys",
	    visitor: {
	      ObjectExpression: function ObjectExpression(path) {
	        var node = path.node;
	        var plainProps = node.properties.filter(function (prop) {
	          return !isSpreadElement$1(prop) && !prop.computed;
	        });
	        var alreadySeenData = Object.create(null);
	        var alreadySeenGetters = Object.create(null);
	        var alreadySeenSetters = Object.create(null);

	        for (var _iterator = _createForOfIteratorHelperLoose(plainProps), _step; !(_step = _iterator()).done;) {
	          var prop = _step.value;
	          var name = getName(prop.key);
	          var isDuplicate = false;

	          switch (prop.kind) {
	            case "get":
	              if (alreadySeenData[name] || alreadySeenGetters[name]) {
	                isDuplicate = true;
	              }

	              alreadySeenGetters[name] = true;
	              break;

	            case "set":
	              if (alreadySeenData[name] || alreadySeenSetters[name]) {
	                isDuplicate = true;
	              }

	              alreadySeenSetters[name] = true;
	              break;

	            default:
	              if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
	                isDuplicate = true;
	              }

	              alreadySeenData[name] = true;
	          }

	          if (isDuplicate) {
	            prop.computed = true;
	            prop.key = stringLiteral$8(name);
	          }
	        }
	      }
	    }
	  };
	});

	var assignmentExpression$1 = assignmentExpression$c,
	    cloneNode = cloneNode$i,
	    isIdentifier$2 = isIdentifier$g,
	    isLiteral$1 = isLiteral$7,
	    isMemberExpression = isMemberExpression$8,
	    isPrivateName = isPrivateName$1,
	    isPureish = isPureish$2,
	    isSuper = isSuper$2,
	    memberExpression$1 = memberExpression$b,
	    toComputedKey$1 = toComputedKey$3;

	function getObjRef(node, nodes, scope) {
	  var ref;

	  if (isIdentifier$2(node)) {
	    if (scope.hasBinding(node.name)) {
	      return node;
	    } else {
	      ref = node;
	    }
	  } else if (isMemberExpression(node)) {
	    ref = node.object;

	    if (isSuper(ref) || isIdentifier$2(ref) && scope.hasBinding(ref.name)) {
	      return ref;
	    }
	  } else {
	    throw new Error("We can't explode this node type " + node["type"]);
	  }

	  var temp = scope.generateUidIdentifierBasedOnNode(ref);
	  scope.push({
	    id: temp
	  });
	  nodes.push(assignmentExpression$1("=", cloneNode(temp), cloneNode(ref)));
	  return temp;
	}

	function getPropRef(node, nodes, scope) {
	  var prop = node.property;

	  if (isPrivateName(prop)) {
	    throw new Error("We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`");
	  }

	  var key = toComputedKey$1(node, prop);
	  if (isLiteral$1(key) && isPureish(key)) return key;
	  var temp = scope.generateUidIdentifierBasedOnNode(prop);
	  scope.push({
	    id: temp
	  });
	  nodes.push(assignmentExpression$1("=", cloneNode(temp), cloneNode(prop)));
	  return temp;
	}

	function explode (node, nodes, file, scope, allowedSingleIdent) {
	  var obj;

	  if (isIdentifier$2(node) && allowedSingleIdent) {
	    obj = node;
	  } else {
	    obj = getObjRef(node, nodes, scope);
	  }

	  var ref, uid;

	  if (isIdentifier$2(node)) {
	    ref = cloneNode(node);
	    uid = obj;
	  } else {
	    var prop = getPropRef(node, nodes, scope);
	    var computed = node.computed || isLiteral$1(prop);
	    uid = memberExpression$1(cloneNode(obj), cloneNode(prop), computed);
	    ref = memberExpression$1(cloneNode(obj), cloneNode(prop), computed);
	  }

	  return {
	    uid: uid,
	    ref: ref
	  };
	}

	var assignmentExpression = assignmentExpression$c,
	    sequenceExpression = sequenceExpression$7;
	function build (opts) {
	  var build = opts.build,
	      operator = opts.operator;
	  var visitor = {
	    AssignmentExpression: function AssignmentExpression(path) {
	      var node = path.node,
	          scope = path.scope;
	      if (node.operator !== operator + "=") return;
	      var nodes = [];
	      var exploded = explode(node.left, nodes, this, scope);
	      nodes.push(assignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
	      path.replaceWith(sequenceExpression(nodes));
	    },
	    BinaryExpression: function BinaryExpression(path) {
	      var node = path.node;

	      if (node.operator === operator) {
	        path.replaceWith(build(node.left, node.right));
	      }
	    }
	  };
	  return visitor;
	}

	var transformExponentialOperator = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-exponentiation-operator",
	    visitor: build({
	      operator: "**",
	      build: function build(left, right) {
	        return callExpression$e(memberExpression$b(identifier$j("Math"), identifier$j("pow")), [left, right]);
	      }
	    })
	  };
	});

	var transformFlowComments = declare(function (api) {
	  api.assertVersion(7);

	  function commentFromString(comment) {
	    return typeof comment === "string" ? {
	      type: "CommentBlock",
	      value: comment
	    } : comment;
	  }

	  function attachComment(_ref) {
	    var _toPath;

	    var ofPath = _ref.ofPath,
	        toPath = _ref.toPath,
	        _ref$where = _ref.where,
	        where = _ref$where === void 0 ? "trailing" : _ref$where,
	        _ref$optional = _ref.optional,
	        optional = _ref$optional === void 0 ? false : _ref$optional,
	        _ref$comments = _ref.comments,
	        comments = _ref$comments === void 0 ? generateComment(ofPath, optional) : _ref$comments,
	        _ref$keepType = _ref.keepType,
	        keepType = _ref$keepType === void 0 ? false : _ref$keepType;

	    if (!((_toPath = toPath) != null && _toPath.node)) {
	      toPath = ofPath.getPrevSibling();
	      where = "trailing";
	    }

	    if (!toPath.node) {
	      toPath = ofPath.getNextSibling();
	      where = "leading";
	    }

	    if (!toPath.node) {
	      toPath = ofPath.parentPath;
	      where = "inner";
	    }

	    if (!Array.isArray(comments)) {
	      comments = [comments];
	    }

	    comments = comments.map(commentFromString);

	    if (!keepType && ofPath != null && ofPath.node) {
	      var node = ofPath.node;
	      var parent = ofPath.parentPath;
	      var prev = ofPath.getPrevSibling();
	      var next = ofPath.getNextSibling();
	      var isSingleChild = !(prev.node || next.node);
	      var leading = node.leadingComments;
	      var trailing = node.trailingComments;

	      if (isSingleChild && leading) {
	        parent.addComments("inner", leading);
	      }

	      toPath.addComments(where, comments);
	      ofPath.remove();

	      if (isSingleChild && trailing) {
	        parent.addComments("inner", trailing);
	      }
	    } else {
	      toPath.addComments(where, comments);
	    }
	  }

	  function wrapInFlowComment(path) {
	    attachComment({
	      ofPath: path,
	      comments: generateComment(path, path.parent.optional)
	    });
	  }

	  function generateComment(path, optional) {
	    var comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
	    if (optional) comment = "?" + comment;
	    if (comment[0] !== ":") comment = ":: " + comment;
	    return comment;
	  }

	  function isTypeImport(importKind) {
	    return importKind === "type" || importKind === "typeof";
	  }

	  return {
	    name: "transform-flow-comments",
	    inherits: syntaxFlow,
	    visitor: {
	      TypeCastExpression: function TypeCastExpression(path) {
	        var node = path.node;
	        attachComment({
	          ofPath: path.get("typeAnnotation"),
	          toPath: path.get("expression"),
	          keepType: true
	        });
	        path.replaceWith(parenthesizedExpression(node.expression));
	      },
	      Identifier: function Identifier(path) {
	        if (path.parentPath.isFlow()) return;
	        var node = path.node;

	        if (node.typeAnnotation) {
	          attachComment({
	            ofPath: path.get("typeAnnotation"),
	            toPath: path,
	            optional: node.optional || node.typeAnnotation.optional
	          });

	          if (node.optional) {
	            node.optional = false;
	          }
	        } else if (node.optional) {
	          attachComment({
	            toPath: path,
	            comments: ":: ?"
	          });
	          node.optional = false;
	        }
	      },
	      AssignmentPattern: {
	        exit: function exit(_ref2) {
	          var node = _ref2.node;
	          var left = node.left;

	          if (left.optional) {
	            left.optional = false;
	          }
	        }
	      },
	      Function: function Function(path) {
	        if (path.isDeclareFunction()) return;
	        var node = path.node;

	        if (node.typeParameters) {
	          attachComment({
	            ofPath: path.get("typeParameters"),
	            toPath: path.get("id"),
	            optional: node.typeParameters.optional
	          });
	        }

	        if (node.returnType) {
	          attachComment({
	            ofPath: path.get("returnType"),
	            toPath: path.get("body"),
	            where: "leading",
	            optional: node.returnType.typeAnnotation.optional
	          });
	        }
	      },
	      ClassProperty: function ClassProperty(path) {
	        var node = path.node;

	        if (!node.value) {
	          wrapInFlowComment(path);
	        } else if (node.typeAnnotation) {
	          attachComment({
	            ofPath: path.get("typeAnnotation"),
	            toPath: path.get("key"),
	            optional: node.typeAnnotation.optional
	          });
	        }
	      },
	      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
	        var node = path.node;

	        if (node.exportKind !== "type" && !isFlow$1(node.declaration)) {
	          return;
	        }

	        wrapInFlowComment(path);
	      },
	      ImportDeclaration: function ImportDeclaration(path) {
	        var node = path.node;

	        if (isTypeImport(node.importKind)) {
	          wrapInFlowComment(path);
	          return;
	        }

	        var typeSpecifiers = node.specifiers.filter(function (specifier) {
	          return isTypeImport(specifier.importKind);
	        });
	        var nonTypeSpecifiers = node.specifiers.filter(function (specifier) {
	          return !isTypeImport(specifier.importKind);
	        });
	        node.specifiers = nonTypeSpecifiers;

	        if (typeSpecifiers.length > 0) {
	          var typeImportNode = cloneNode$i(node);
	          typeImportNode.specifiers = typeSpecifiers;
	          var comment = ":: " + generate$1(typeImportNode).code;

	          if (nonTypeSpecifiers.length > 0) {
	            attachComment({
	              toPath: path,
	              comments: comment
	            });
	          } else {
	            attachComment({
	              ofPath: path,
	              comments: comment
	            });
	          }
	        }
	      },
	      ObjectPattern: function ObjectPattern(path) {
	        var node = path.node;

	        if (node.typeAnnotation) {
	          attachComment({
	            ofPath: path.get("typeAnnotation"),
	            toPath: path,
	            optional: node.optional || node.typeAnnotation.optional
	          });
	        }
	      },
	      Flow: function Flow(path) {
	        wrapInFlowComment(path);
	      },
	      Class: function Class(path) {
	        var node = path.node;
	        var comments = [];

	        if (node.typeParameters) {
	          var typeParameters = path.get("typeParameters");
	          comments.push(generateComment(typeParameters, node.typeParameters.optional));
	          var trailingComments = node.typeParameters.trailingComments;

	          if (trailingComments) {
	            var _comments;

	            (_comments = comments).push.apply(_comments, _toConsumableArray(trailingComments));
	          }

	          typeParameters.remove();
	        }

	        if (node.superClass) {
	          if (comments.length > 0) {
	            attachComment({
	              toPath: path.get("id"),
	              comments: comments
	            });
	            comments = [];
	          }

	          if (node.superTypeParameters) {
	            var superTypeParameters = path.get("superTypeParameters");
	            comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
	            superTypeParameters.remove();
	          }
	        }

	        if (node["implements"]) {
	          var impls = path.get("implements");
	          var comment = "implements " + impls.map(function (impl) {
	            return generateComment(impl).replace(/^:: /, "");
	          }).join(", ");
	          delete node["implements"];

	          if (comments.length === 1) {
	            comments[0] += " " + comment;
	          } else {
	            comments.push(":: " + comment);
	          }
	        }

	        if (comments.length > 0) {
	          attachComment({
	            toPath: path.get("body"),
	            where: "leading",
	            comments: comments
	          });
	        }
	      }
	    }
	  };
	});

	var transformFlowStripTypes = declare(function (api, opts) {
	  api.assertVersion(7);
	  var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
	  var skipStrip = false;
	  var _opts$requireDirectiv = opts.requireDirective,
	      requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv;
	  {
	    var _opts$allowDeclareFie = opts.allowDeclareFields,
	        allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
	  }
	  return {
	    name: "transform-flow-strip-types",
	    inherits: syntaxFlow,
	    visitor: {
	      Program: function Program(path, _ref) {
	        var comments = _ref.file.ast.comments;
	        skipStrip = false;
	        var directiveFound = false;

	        if (comments) {
	          for (var _iterator = _createForOfIteratorHelperLoose(comments), _step; !(_step = _iterator()).done;) {
	            var comment = _step.value;

	            if (FLOW_DIRECTIVE.test(comment.value)) {
	              directiveFound = true;
	              comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

	              if (!comment.value.replace(/\*/g, "").trim()) {
	                comment.ignore = true;
	              }
	            }
	          }
	        }

	        if (!directiveFound && requireDirective) {
	          skipStrip = true;
	        }
	      },
	      ImportDeclaration: function ImportDeclaration(path) {
	        if (skipStrip) return;
	        if (!path.node.specifiers.length) return;
	        var typeCount = 0;
	        path.node.specifiers.forEach(function (_ref2) {
	          var importKind = _ref2.importKind;

	          if (importKind === "type" || importKind === "typeof") {
	            typeCount++;
	          }
	        });

	        if (typeCount === path.node.specifiers.length) {
	          path.remove();
	        }
	      },
	      Flow: function Flow(path) {
	        if (skipStrip) {
	          throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
	        }

	        path.remove();
	      },
	      ClassPrivateProperty: function ClassPrivateProperty(path) {
	        if (skipStrip) return;
	        path.node.typeAnnotation = null;
	      },
	      Class: function Class(path) {
	        if (skipStrip) return;
	        path.node["implements"] = null;
	        path.get("body.body").forEach(function (child) {
	          if (child.isClassProperty()) {
	            var node = child.node;
	            {
	              if (!allowDeclareFields && node.declare) {
	                throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
	              }
	            }

	            if (node.declare) {
	              child.remove();
	            } else {
	              {
	                if (!allowDeclareFields && !node.value && !node.decorators) {
	                  child.remove();
	                  return;
	                }
	              }
	              node.variance = null;
	              node.typeAnnotation = null;
	            }
	          }
	        });
	      },
	      AssignmentPattern: function AssignmentPattern(_ref3) {
	        var node = _ref3.node;
	        if (skipStrip) return;
	        node.left.optional = false;
	      },
	      Function: function Function(_ref4) {
	        var node = _ref4.node;
	        if (skipStrip) return;

	        if (node.params.length > 0 && node.params[0].type === "Identifier" && node.params[0].name === "this") {
	          node.params.shift();
	        }

	        for (var i = 0; i < node.params.length; i++) {
	          var param = node.params[i];
	          param.optional = false;

	          if (param.type === "AssignmentPattern") {
	            param.left.optional = false;
	          }
	        }

	        node.predicate = null;
	      },
	      TypeCastExpression: function TypeCastExpression(path) {
	        if (skipStrip) return;
	        var node = path.node;

	        do {
	          node = node.expression;
	        } while (isTypeCastExpression$1(node));

	        path.replaceWith(node);
	      },
	      CallExpression: function CallExpression(_ref5) {
	        var node = _ref5.node;
	        if (skipStrip) return;
	        node.typeArguments = null;
	      },
	      OptionalCallExpression: function OptionalCallExpression(_ref6) {
	        var node = _ref6.node;
	        if (skipStrip) return;
	        node.typeArguments = null;
	      },
	      NewExpression: function NewExpression(_ref7) {
	        var node = _ref7.node;
	        if (skipStrip) return;
	        node.typeArguments = null;
	      }
	    }
	  };
	});

	function transformWithoutHelper(loose, path, state) {
	  var _block$body;

	  var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
	  var node = path.node;
	  var build = pushComputedProps(path, state);
	  var declar = build.declar;
	  var loop = build.loop;
	  var block = loop.body;
	  path.ensureBlock();

	  if (declar) {
	    block.body.push(declar);
	  }

	  (_block$body = block.body).push.apply(_block$body, _toConsumableArray(node.body.body));

	  inherits$1(loop, node);
	  inherits$1(loop.body, node.body);

	  if (build.replaceParent) {
	    path.parentPath.replaceWithMultiple(build.node);
	    path.remove();
	  } else {
	    path.replaceWithMultiple(build.node);
	  }
	}
	var buildForOfLoose = template$2("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n");
	var buildForOf = template$2("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");

	function pushComputedPropsLoose(path, file) {
	  var node = path.node,
	      scope = path.scope,
	      parent = path.parent;
	  var left = node.left;
	  var declar, id, intermediate;

	  if (isIdentifier$g(left) || isPattern(left) || isMemberExpression$8(left)) {
	    id = left;
	    intermediate = null;
	  } else if (isVariableDeclaration$3(left)) {
	    id = scope.generateUidIdentifier("ref");
	    declar = variableDeclaration$8(left.kind, [variableDeclarator$8(left.declarations[0].id, identifier$j(id.name))]);
	    intermediate = variableDeclaration$8("var", [variableDeclarator$8(identifier$j(id.name))]);
	  } else {
	    throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
	  }

	  var iteratorKey = scope.generateUidIdentifier("iterator");
	  var isArrayKey = scope.generateUidIdentifier("isArray");
	  var loop = buildForOfLoose({
	    LOOP_OBJECT: iteratorKey,
	    IS_ARRAY: isArrayKey,
	    OBJECT: node.right,
	    INDEX: scope.generateUidIdentifier("i"),
	    ID: id,
	    INTERMEDIATE: intermediate
	  });
	  var isLabeledParent = isLabeledStatement(parent);
	  var labeled;

	  if (isLabeledParent) {
	    labeled = labeledStatement(parent.label, loop);
	  }

	  return {
	    replaceParent: isLabeledParent,
	    declar: declar,
	    node: labeled || loop,
	    loop: loop
	  };
	}

	function pushComputedPropsSpec(path, file) {
	  var node = path.node,
	      scope = path.scope,
	      parent = path.parent;
	  var left = node.left;
	  var declar;
	  var stepKey = scope.generateUid("step");
	  var stepValue = memberExpression$b(identifier$j(stepKey), identifier$j("value"));

	  if (isIdentifier$g(left) || isPattern(left) || isMemberExpression$8(left)) {
	    declar = expressionStatement$a(assignmentExpression$c("=", left, stepValue));
	  } else if (isVariableDeclaration$3(left)) {
	    declar = variableDeclaration$8(left.kind, [variableDeclarator$8(left.declarations[0].id, stepValue)]);
	  } else {
	    throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
	  }

	  var template = buildForOf({
	    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
	    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
	    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
	    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
	    STEP_KEY: identifier$j(stepKey),
	    OBJECT: node.right
	  });
	  var isLabeledParent = isLabeledStatement(parent);
	  var tryBody = template[3].block.body;
	  var loop = tryBody[0];

	  if (isLabeledParent) {
	    tryBody[0] = labeledStatement(parent.label, loop);
	  }

	  return {
	    replaceParent: isLabeledParent,
	    declar: declar,
	    loop: loop,
	    node: template
	  };
	}

	var _templateObject$9, _templateObject2$5, _templateObject3$4;
	var _transformForOf = declare(function (api, options) {
	  var _options$assumeArray, _options$allowArrayLi, _api$assumption;

	  api.assertVersion(7);
	  {
	    var assumeArray = options.assumeArray,
	        allowArrayLike = options.allowArrayLike,
	        loose = options.loose;

	    if (loose === true && assumeArray === true) {
	      throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
	    }

	    if (assumeArray === true && allowArrayLike === true) {
	      throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
	    }

	    if (allowArrayLike && /^7\.\d\./.test(api.version)) {
	      throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
	    }
	  }
	  var iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
	  var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
	  var skipteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;

	  if (iterableIsArray && arrayLikeIsIterable) {
	    throw new Error("The \"iterableIsArray\" and \"arrayLikeIsIterable\" assumptions are not compatible.");
	  }

	  if (iterableIsArray) {
	    return {
	      name: "transform-for-of",
	      visitor: {
	        ForOfStatement: function ForOfStatement(path) {
	          var scope = path.scope;
	          var _path$node = path.node,
	              left = _path$node.left,
	              right = _path$node.right,
	              isAwait = _path$node["await"];

	          if (isAwait) {
	            return;
	          }

	          var i = scope.generateUidIdentifier("i");
	          var array = scope.maybeGenerateMemoised(right, true);
	          var inits = [variableDeclarator$8(i, numericLiteral$8(0))];

	          if (array) {
	            inits.push(variableDeclarator$8(array, right));
	          } else {
	            array = right;
	          }

	          var item = memberExpression$b(cloneNode$i(array), cloneNode$i(i), true);
	          var assignment;

	          if (isVariableDeclaration$3(left)) {
	            assignment = left;
	            assignment.declarations[0].init = item;
	          } else {
	            assignment = expressionStatement$a(assignmentExpression$c("=", left, item));
	          }

	          var blockBody;
	          var body = path.get("body");

	          if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
	            return body.scope.hasOwnBinding(id);
	          })) {
	            blockBody = blockStatement$6([assignment, body.node]);
	          } else {
	            blockBody = toBlock(body.node);
	            blockBody.body.unshift(assignment);
	          }

	          path.replaceWith(forStatement(variableDeclaration$8("let", inits), binaryExpression$4("<", cloneNode$i(i), memberExpression$b(cloneNode$i(array), identifier$j("length"))), updateExpression("++", cloneNode$i(i)), blockBody));
	        }
	      }
	    };
	  }

	  var buildForOfArray = template$2(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteralLoose(["\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  "])));
	  var buildForOfNoIteratorClosing = template$2.statements(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteralLoose(["\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  "])));
	  var buildForOf = template$2.statements(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteralLoose(["\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  "])));
	  var builder = skipteratorClosing ? {
	    build: buildForOfNoIteratorClosing,
	    helper: "createForOfIteratorHelperLoose",
	    getContainer: function getContainer(nodes) {
	      return nodes;
	    }
	  } : {
	    build: buildForOf,
	    helper: "createForOfIteratorHelper",
	    getContainer: function getContainer(nodes) {
	      return nodes[1].block.body;
	    }
	  };

	  function _ForOfStatementArray(path) {
	    var node = path.node,
	        scope = path.scope;
	    var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
	    var iterationKey = scope.generateUidIdentifier("i");
	    var loop = buildForOfArray({
	      BODY: node.body,
	      KEY: iterationKey,
	      NAME: right,
	      ARR: node.right
	    });
	    inherits$1(loop, node);
	    ensureBlock$1(loop);
	    var iterationValue = memberExpression$b(cloneNode$i(right), cloneNode$i(iterationKey), true);
	    var left = node.left;

	    if (isVariableDeclaration$3(left)) {
	      left.declarations[0].init = iterationValue;
	      loop.body.body.unshift(left);
	    } else {
	      loop.body.body.unshift(expressionStatement$a(assignmentExpression$c("=", left, iterationValue)));
	    }

	    return loop;
	  }

	  return {
	    name: "transform-for-of",
	    visitor: {
	      ForOfStatement: function ForOfStatement(path, state) {
	        var right = path.get("right");

	        if (right.isArrayExpression() || right.isGenericType("Array") || isArrayTypeAnnotation$1(right.getTypeAnnotation())) {
	          path.replaceWith(_ForOfStatementArray(path));
	          return;
	        }

	        if (!state.availableHelper(builder.helper)) {
	          transformWithoutHelper(skipteratorClosing, path, state);
	          return;
	        }

	        var node = path.node,
	            parent = path.parent,
	            scope = path.scope;
	        var left = node.left;
	        var declar;
	        var stepKey = scope.generateUid("step");
	        var stepValue = memberExpression$b(identifier$j(stepKey), identifier$j("value"));

	        if (isVariableDeclaration$3(left)) {
	          declar = variableDeclaration$8(left.kind, [variableDeclarator$8(left.declarations[0].id, stepValue)]);
	        } else {
	          declar = expressionStatement$a(assignmentExpression$c("=", left, stepValue));
	        }

	        path.ensureBlock();
	        node.body.body.unshift(declar);
	        var nodes = builder.build({
	          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
	          ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
	          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? booleanLiteral$5(true) : null,
	          STEP_KEY: identifier$j(stepKey),
	          OBJECT: node.right,
	          BODY: node.body
	        });
	        var container = builder.getContainer(nodes);
	        inherits$1(container[0], node);
	        inherits$1(container[0].body, node.body);

	        if (isLabeledStatement(parent)) {
	          container[0] = labeledStatement(parent.label, container[0]);
	          path.parentPath.replaceWithMultiple(nodes);
	          path.skip();
	        } else {
	          path.replaceWithMultiple(nodes);
	        }
	      }
	    }
	  };
	});

	var _transformFunctionName = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-function-name",
	    visitor: {
	      FunctionExpression: {
	        exit: function exit(path) {
	          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
	            var replacement = nameFunction(path);
	            if (replacement) path.replaceWith(replacement);
	          }
	        }
	      },
	      ObjectProperty: function ObjectProperty(path) {
	        var value = path.get("value");

	        if (value.isFunction()) {
	          var newNode = nameFunction(value);
	          if (newNode) value.replaceWith(newNode);
	        }
	      }
	    }
	  };
	});

	var transformInstanceof = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-instanceof",
	    visitor: {
	      BinaryExpression: function BinaryExpression(path) {
	        var node = path.node;

	        if (node.operator === "instanceof") {
	          var helper = this.addHelper("instanceof");
	          var isUnderHelper = path.findParent(function (path) {
	            return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
	          });

	          if (isUnderHelper) {
	            return;
	          } else {
	            path.replaceWith(callExpression$e(helper, [node.left, node.right]));
	          }
	        }
	      }
	    }
	  };
	});

	var transformJscript = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-jscript",
	    visitor: {
	      FunctionExpression: {
	        exit: function exit(path) {
	          var node = path.node;
	          if (!node.id) return;
	          path.replaceWith(callExpression$e(functionExpression$3(null, [], blockStatement$6([toStatement(node), returnStatement$3(cloneNode$i(node.id))])), []));
	        }
	      }
	    }
	  };
	});

	var _transformLiterals = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-literals",
	    visitor: {
	      NumericLiteral: function NumericLiteral(_ref) {
	        var node = _ref.node;

	        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
	          node.extra = undefined;
	        }
	      },
	      StringLiteral: function StringLiteral(_ref2) {
	        var node = _ref2.node;

	        if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
	          node.extra = undefined;
	        }
	      }
	    }
	  };
	});

	var _transformMemberExpressionLiterals = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-member-expression-literals",
	    visitor: {
	      MemberExpression: {
	        exit: function exit(_ref) {
	          var node = _ref.node;
	          var prop = node.property;

	          if (!node.computed && isIdentifier$g(prop) && !isValidES3Identifier(prop.name)) {
	            node.property = stringLiteral$8(prop.name);
	            node.computed = true;
	          }
	        }
	      }
	    }
	  };
	});

	var _slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	var getImportSource_1 = getImportSource$3;
	var createDynamicImportTransform_1 = createDynamicImportTransform;

	function getImportSource$3(t, callNode) {
	  var importArguments = callNode.arguments;

	  var _importArguments = _slicedToArray(importArguments, 1),
	      importPath = _importArguments[0];

	  var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

	  if (isString) {
	    t.removeComments(importPath);
	    return importPath;
	  }

	  return t.templateLiteral([t.templateElement({
	    raw: '',
	    cooked: ''
	  }), t.templateElement({
	    raw: '',
	    cooked: ''
	  }, true)], importArguments);
	}

	function createDynamicImportTransform(_ref) {
	  var template = _ref.template,
	      t = _ref.types;
	  var builders = {
	    'static': {
	      interop: template('Promise.resolve().then(() => INTEROP(require(SOURCE)))'),
	      noInterop: template('Promise.resolve().then(() => require(SOURCE))')
	    },
	    dynamic: {
	      interop: template('Promise.resolve(SOURCE).then(s => INTEROP(require(s)))'),
	      noInterop: template('Promise.resolve(SOURCE).then(s => require(s))')
	    }
	  };
	  var visited = typeof WeakSet === 'function' && new WeakSet();

	  var isString = function isString(node) {
	    return t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0;
	  };

	  return function (context, path) {
	    if (visited) {
	      if (visited.has(path)) {
	        return;
	      }

	      visited.add(path);
	    }

	    var SOURCE = getImportSource$3(t, path.parent);
	    var builder = isString(SOURCE) ? builders['static'] : builders.dynamic;
	    var newImport = context.opts.noInterop ? builder.noInterop({
	      SOURCE: SOURCE
	    }) : builder.interop({
	      SOURCE: SOURCE,
	      INTEROP: context.addHelper('interopRequireWildcard')
	    });
	    path.parentPath.replaceWith(newImport);
	  };
	}

	var utils$1 = Object.defineProperty({
	  getImportSource: getImportSource_1,
	  createDynamicImportTransform: createDynamicImportTransform_1
	}, '__esModule', {
	  value: true
	});

	var utils = utils$1;

	var _templateObject$8;
	var buildWrapper$1 = template$2("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
	var buildAnonymousWrapper = template$2("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

	function injectWrapper(path, wrapper) {
	  var _path$node = path.node,
	      body = _path$node.body,
	      directives = _path$node.directives;
	  path.node.directives = [];
	  path.node.body = [];
	  var amdWrapper = path.pushContainer("body", wrapper)[0];
	  var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
	    return arg.isFunctionExpression();
	  })[0].get("body");
	  amdFactory.pushContainer("directives", directives);
	  amdFactory.pushContainer("body", body);
	}

	var _transformModulesAmd = declare(function (api, options) {
	  var _api$assumption, _api$assumption2;

	  api.assertVersion(7);
	  var allowTopLevelThis = options.allowTopLevelThis,
	      strict = options.strict,
	      strictMode = options.strictMode,
	      importInterop = options.importInterop,
	      noInterop = options.noInterop;
	  var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
	  var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
	  return {
	    name: "transform-modules-amd",
	    pre: function pre() {
	      this.file.set("@babel/plugin-transform-modules-*", "amd");
	    },
	    visitor: {
	      CallExpression: function CallExpression(path, state) {
	        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
	        if (!path.get("callee").isImport()) return;
	        var requireId = state.requireId,
	            resolveId = state.resolveId,
	            rejectId = state.rejectId;

	        if (!requireId) {
	          requireId = path.scope.generateUidIdentifier("require");
	          state.requireId = requireId;
	        }

	        if (!resolveId || !rejectId) {
	          resolveId = path.scope.generateUidIdentifier("resolve");
	          rejectId = path.scope.generateUidIdentifier("reject");
	          state.resolveId = resolveId;
	          state.rejectId = rejectId;
	        }

	        var result = identifier$j("imported");
	        if (!noInterop) result = wrapInterop(path, result, "namespace");
	        path.replaceWith(template$2.expression.ast(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteralLoose(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"])), resolveId, rejectId, requireId, utils.getImportSource(t$f, path.node), cloneNode$i(resolveId), result, cloneNode$i(rejectId)));
	      },
	      Program: {
	        exit: function exit(path, _ref) {
	          var requireId = _ref.requireId;

	          if (!isModule(path)) {
	            if (requireId) {
	              injectWrapper(path, buildAnonymousWrapper({
	                REQUIRE: cloneNode$i(requireId)
	              }));
	            }

	            return;
	          }

	          var amdArgs = [];
	          var importNames = [];

	          if (requireId) {
	            amdArgs.push(stringLiteral$8("require"));
	            importNames.push(cloneNode$i(requireId));
	          }

	          var moduleName = getModuleName(this.file.opts, options);
	          if (moduleName) moduleName = stringLiteral$8(moduleName);

	          var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
	            enumerableModuleMeta: enumerableModuleMeta,
	            constantReexports: constantReexports,
	            strict: strict,
	            strictMode: strictMode,
	            allowTopLevelThis: allowTopLevelThis,
	            importInterop: importInterop,
	            noInterop: noInterop
	          }),
	              meta = _rewriteModuleStateme.meta,
	              headers = _rewriteModuleStateme.headers;

	          if (hasExports(meta)) {
	            amdArgs.push(stringLiteral$8("exports"));
	            importNames.push(identifier$j(meta.exportName));
	          }

	          for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
	            var _step$value = _slicedToArray$1(_step.value, 2),
	                source = _step$value[0],
	                metadata = _step$value[1];

	            amdArgs.push(stringLiteral$8(source));
	            importNames.push(identifier$j(metadata.name));

	            if (!isSideEffectImport(metadata)) {
	              var interop = wrapInterop(path, identifier$j(metadata.name), metadata.interop);

	              if (interop) {
	                var header = expressionStatement$a(assignmentExpression$c("=", identifier$j(metadata.name), interop));
	                header.loc = metadata.loc;
	                headers.push(header);
	              }
	            }

	            headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
	          }

	          ensureStatementsHoisted(headers);
	          path.unshiftContainer("body", headers);
	          injectWrapper(path, buildWrapper$1({
	            MODULE_NAME: moduleName,
	            AMD_ARGUMENTS: arrayExpression$2(amdArgs),
	            IMPORT_NAMES: importNames
	          }));
	        }
	      }
	    }
	  };
	});

	var _templateObject$7, _templateObject2$4, _templateObject3$3;
	var _transformModulesCommonjs = declare(function (api, options) {
	  var _api$assumption, _api$assumption2, _api$assumption3;

	  api.assertVersion(7);
	  var transformImportCall = utils.createDynamicImportTransform(api);
	  var _options$strictNamesp = options.strictNamespace,
	      strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
	      _options$mjsStrictNam = options.mjsStrictNamespace,
	      mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
	      allowTopLevelThis = options.allowTopLevelThis,
	      strict = options.strict,
	      strictMode = options.strictMode,
	      noInterop = options.noInterop,
	      importInterop = options.importInterop,
	      _options$lazy = options.lazy,
	      lazy = _options$lazy === void 0 ? false : _options$lazy,
	      _options$allowCommonJ = options.allowCommonJSExports,
	      allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;
	  var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
	  var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
	  var noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : false;

	  if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
	    return typeof item === "string";
	  }))) {
	    throw new Error(".lazy must be a boolean, array of strings, or a function");
	  }

	  if (typeof strictNamespace !== "boolean") {
	    throw new Error(".strictNamespace must be a boolean, or undefined");
	  }

	  if (typeof mjsStrictNamespace !== "boolean") {
	    throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
	  }

	  var getAssertion = function getAssertion(localName) {
	    return template$2.expression.ast(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "])), localName);
	  };

	  var moduleExportsVisitor = {
	    ReferencedIdentifier: function ReferencedIdentifier(path) {
	      var localName = path.node.name;
	      if (localName !== "module" && localName !== "exports") return;
	      var localBinding = path.scope.getBinding(localName);
	      var rootBinding = this.scope.getBinding(localName);

	      if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
	        value: path.node
	      }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
	        left: path.node
	      }) || path.isAssignmentExpression({
	        left: path.node
	      })) {
	        return;
	      }

	      path.replaceWith(getAssertion(localName));
	    },
	    AssignmentExpression: function AssignmentExpression(path) {
	      var _this = this;

	      var left = path.get("left");

	      if (left.isIdentifier()) {
	        var localName = path.node.name;
	        if (localName !== "module" && localName !== "exports") return;
	        var localBinding = path.scope.getBinding(localName);
	        var rootBinding = this.scope.getBinding(localName);
	        if (rootBinding !== localBinding) return;
	        var right = path.get("right");
	        right.replaceWith(sequenceExpression$7([right.node, getAssertion(localName)]));
	      } else if (left.isPattern()) {
	        var ids = left.getOuterBindingIdentifiers();
	        var _localName = Object.keys(ids).filter(function (localName) {
	          if (localName !== "module" && localName !== "exports") return false;
	          return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
	        })[0];

	        if (_localName) {
	          var _right = path.get("right");

	          _right.replaceWith(sequenceExpression$7([_right.node, getAssertion(_localName)]));
	        }
	      }
	    }
	  };
	  return {
	    name: "transform-modules-commonjs",
	    pre: function pre() {
	      this.file.set("@babel/plugin-transform-modules-*", "commonjs");
	    },
	    visitor: {
	      CallExpression: function CallExpression(path) {
	        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
	        if (!path.get("callee").isImport()) return;
	        var scope = path.scope;

	        do {
	          scope.rename("require");
	        } while (scope = scope.parent);

	        transformImportCall(this, path.get("callee"));
	      },
	      Program: {
	        exit: function exit(path, state) {
	          if (!isModule(path)) return;
	          path.scope.rename("exports");
	          path.scope.rename("module");
	          path.scope.rename("require");
	          path.scope.rename("__filename");
	          path.scope.rename("__dirname");

	          if (!allowCommonJSExports) {
	            simplifyAccess(path, new Set(["module", "exports"]));
	            path.traverse(moduleExportsVisitor, {
	              scope: path.scope
	            });
	          }

	          var moduleName = getModuleName(this.file.opts, options);
	          if (moduleName) moduleName = stringLiteral$8(moduleName);

	          var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
	            exportName: "exports",
	            constantReexports: constantReexports,
	            enumerableModuleMeta: enumerableModuleMeta,
	            strict: strict,
	            strictMode: strictMode,
	            allowTopLevelThis: allowTopLevelThis,
	            noInterop: noInterop,
	            importInterop: importInterop,
	            lazy: lazy,
	            esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
	            noIncompleteNsImportDetection: noIncompleteNsImportDetection
	          }),
	              meta = _rewriteModuleStateme.meta,
	              headers = _rewriteModuleStateme.headers;

	          for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
	            var _step$value = _slicedToArray$1(_step.value, 2),
	                source = _step$value[0],
	                metadata = _step$value[1];

	            var loadExpr = callExpression$e(identifier$j("require"), [stringLiteral$8(source)]);
	            var header = void 0;

	            if (isSideEffectImport(metadata)) {
	              if (metadata.lazy) throw new Error("Assertion failure");
	              header = expressionStatement$a(loadExpr);
	            } else {
	              var init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;

	              if (metadata.lazy) {
	                header = template$2.ast(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteralLoose(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "])), metadata.name, init, metadata.name);
	              } else {
	                header = template$2.ast(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteralLoose(["\n                  var ", " = ", ";\n                "])), metadata.name, init);
	              }
	            }

	            header.loc = metadata.loc;
	            headers.push(header);
	            headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
	          }

	          ensureStatementsHoisted(headers);
	          path.unshiftContainer("body", headers);
	        }
	      }
	    }
	  };
	});

	var buildTemplate = template$2("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n");
	var buildExportAll = template$2("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
	var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";
	function getExportSpecifierName(node, stringSpecifiers) {
	  if (node.type === "Identifier") {
	    return node.name;
	  } else if (node.type === "StringLiteral") {
	    var stringValue = node.value;

	    if (!isIdentifierName(stringValue)) {
	      stringSpecifiers.add(stringValue);
	    }

	    return stringValue;
	  } else {
	    throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + node.type);
	  }
	}

	function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
	  var statements = [];

	  if (!exportStarTarget) {
	    if (exportNames.length === 1) {
	      statements.push(expressionStatement$a(callExpression$e(exportIdent, [stringLiteral$8(exportNames[0]), exportValues[0]])));
	    } else {
	      var objectProperties = [];

	      for (var i = 0; i < exportNames.length; i++) {
	        var exportName = exportNames[i];
	        var exportValue = exportValues[i];
	        objectProperties.push(objectProperty$2(stringSpecifiers.has(exportName) ? stringLiteral$8(exportName) : identifier$j(exportName), exportValue));
	      }

	      statements.push(expressionStatement$a(callExpression$e(exportIdent, [objectExpression$4(objectProperties)])));
	    }
	  } else {
	    var exportObj = path.scope.generateUid("exportObj");
	    statements.push(variableDeclaration$8("var", [variableDeclarator$8(identifier$j(exportObj), objectExpression$4([]))]));
	    statements.push(buildExportAll({
	      KEY: path.scope.generateUidIdentifier("key"),
	      EXPORT_OBJ: identifier$j(exportObj),
	      TARGET: exportStarTarget
	    }));

	    for (var _i = 0; _i < exportNames.length; _i++) {
	      var _exportName = exportNames[_i];
	      var _exportValue = exportValues[_i];
	      statements.push(expressionStatement$a(assignmentExpression$c("=", memberExpression$b(identifier$j(exportObj), identifier$j(_exportName)), _exportValue)));
	    }

	    statements.push(expressionStatement$a(callExpression$e(exportIdent, [identifier$j(exportObj)])));
	  }

	  return statements;
	}

	var _transformModulesSystemjs = declare(function (api, options) {
	  api.assertVersion(7);
	  var _options$systemGlobal = options.systemGlobal,
	      systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
	      _options$allowTopLeve = options.allowTopLevelThis,
	      allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
	  var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
	  var reassignmentVisitor = {
	    "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
	      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
	      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
	      var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

	      if (arg.isObjectPattern() || arg.isArrayPattern()) {
	        var exprs = [path.node];

	        for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
	          var _name = _Object$keys[_i2];

	          if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
	            return;
	          }

	          var _exportedNames = this.exports[_name];
	          if (!_exportedNames) return;

	          for (var _iterator = _createForOfIteratorHelperLoose(_exportedNames), _step; !(_step = _iterator()).done;) {
	            var exportedName = _step.value;
	            exprs.push(this.buildCall(exportedName, identifier$j(_name)).expression);
	          }
	        }

	        path.replaceWith(sequenceExpression$7(exprs));
	        return;
	      }

	      if (!arg.isIdentifier()) return;
	      var name = arg.node.name;
	      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
	      var exportedNames = this.exports[name];
	      if (!exportedNames) return;
	      var node = path.node;
	      var isPostUpdateExpression = path.isUpdateExpression({
	        prefix: false
	      });

	      if (isPostUpdateExpression) {
	        node = binaryExpression$4(node.operator[0], unaryExpression$7("+", cloneNode$i(node.argument)), numericLiteral$8(1));
	      }

	      for (var _iterator2 = _createForOfIteratorHelperLoose(exportedNames), _step2; !(_step2 = _iterator2()).done;) {
	        var _exportedName = _step2.value;
	        node = this.buildCall(_exportedName, node).expression;
	      }

	      if (isPostUpdateExpression) {
	        node = sequenceExpression$7([node, path.node]);
	      }

	      path.replaceWith(node);
	    }
	  };
	  return {
	    name: "transform-modules-systemjs",
	    pre: function pre() {
	      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
	    },
	    visitor: {
	      CallExpression: function CallExpression(path, state) {
	        if (isImport(path.node.callee)) {
	          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
	            {
	              console.warn(MISSING_PLUGIN_WARNING);
	            }
	          }

	          path.replaceWith(callExpression$e(memberExpression$b(identifier$j(state.contextIdent), identifier$j("import")), [utils.getImportSource(t$f, path.node)]));
	        }
	      },
	      MetaProperty: function MetaProperty(path, state) {
	        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
	          path.replaceWith(memberExpression$b(identifier$j(state.contextIdent), identifier$j("meta")));
	        }
	      },
	      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
	          path.replaceWith(memberExpression$b(identifier$j(state.contextIdent), identifier$j("id")));
	        }
	      },
	      Program: {
	        enter: function enter(path, state) {
	          state.contextIdent = path.scope.generateUid("context");
	          state.stringSpecifiers = new Set();

	          if (!allowTopLevelThis) {
	            rewriteThis(path);
	          }
	        },
	        exit: function exit(path, state) {
	          var scope = path.scope;
	          var exportIdent = scope.generateUid("export");
	          var contextIdent = state.contextIdent,
	              stringSpecifiers = state.stringSpecifiers;
	          var exportMap = Object.create(null);
	          var modules = [];
	          var beforeBody = [];
	          var setters = [];
	          var sources = [];
	          var variableIds = [];
	          var removedPaths = [];

	          function addExportName(key, val) {
	            exportMap[key] = exportMap[key] || [];
	            exportMap[key].push(val);
	          }

	          function pushModule(source, key, specifiers) {
	            var module;
	            modules.forEach(function (m) {
	              if (m.key === source) {
	                module = m;
	              }
	            });

	            if (!module) {
	              modules.push(module = {
	                key: source,
	                imports: [],
	                exports: []
	              });
	            }

	            module[key] = module[key].concat(specifiers);
	          }

	          function buildExportCall(name, val) {
	            return expressionStatement$a(callExpression$e(identifier$j(exportIdent), [stringLiteral$8(name), val]));
	          }

	          var exportNames = [];
	          var exportValues = [];
	          var body = path.get("body");

	          for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
	            var _path2 = _step3.value;

	            if (_path2.isFunctionDeclaration()) {
	              beforeBody.push(_path2.node);
	              removedPaths.push(_path2);
	            } else if (_path2.isClassDeclaration()) {
	              variableIds.push(cloneNode$i(_path2.node.id));

	              _path2.replaceWith(expressionStatement$a(assignmentExpression$c("=", cloneNode$i(_path2.node.id), toExpression$1(_path2.node))));
	            } else if (_path2.isImportDeclaration()) {
	              var source = _path2.node.source.value;
	              pushModule(source, "imports", _path2.node.specifiers);

	              for (var _i4 = 0, _Object$keys2 = Object.keys(_path2.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
	                var name = _Object$keys2[_i4];
	                scope.removeBinding(name);
	                variableIds.push(identifier$j(name));
	              }

	              _path2.remove();
	            } else if (_path2.isExportAllDeclaration()) {
	              pushModule(_path2.node.source.value, "exports", _path2.node);

	              _path2.remove();
	            } else if (_path2.isExportDefaultDeclaration()) {
	              var declar = _path2.get("declaration");

	              var id = declar.node.id;

	              if (declar.isClassDeclaration()) {
	                if (id) {
	                  exportNames.push("default");
	                  exportValues.push(scope.buildUndefinedNode());
	                  variableIds.push(cloneNode$i(id));
	                  addExportName(id.name, "default");

	                  _path2.replaceWith(expressionStatement$a(assignmentExpression$c("=", cloneNode$i(id), toExpression$1(declar.node))));
	                } else {
	                  exportNames.push("default");
	                  exportValues.push(toExpression$1(declar.node));
	                  removedPaths.push(_path2);
	                }
	              } else if (declar.isFunctionDeclaration()) {
	                if (id) {
	                  beforeBody.push(declar.node);
	                  exportNames.push("default");
	                  exportValues.push(cloneNode$i(id));
	                  addExportName(id.name, "default");
	                } else {
	                  exportNames.push("default");
	                  exportValues.push(toExpression$1(declar.node));
	                }

	                removedPaths.push(_path2);
	              } else {
	                _path2.replaceWith(buildExportCall("default", declar.node));
	              }
	            } else if (_path2.isExportNamedDeclaration()) {
	              var _declar = _path2.get("declaration");

	              if (_declar.node) {
	                _path2.replaceWith(_declar);

	                if (_path2.isFunction()) {
	                  var node = _declar.node;
	                  var _name2 = node.id.name;
	                  addExportName(_name2, _name2);
	                  beforeBody.push(node);
	                  exportNames.push(_name2);
	                  exportValues.push(cloneNode$i(node.id));
	                  removedPaths.push(_path2);
	                } else if (_path2.isClass()) {
	                  var _name3 = _declar.node.id.name;
	                  exportNames.push(_name3);
	                  exportValues.push(scope.buildUndefinedNode());
	                  variableIds.push(cloneNode$i(_declar.node.id));

	                  _path2.replaceWith(expressionStatement$a(assignmentExpression$c("=", cloneNode$i(_declar.node.id), toExpression$1(_declar.node))));

	                  addExportName(_name3, _name3);
	                } else {
	                  for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
	                    var _name4 = _Object$keys3[_i5];
	                    addExportName(_name4, _name4);
	                  }
	                }
	              } else {
	                var specifiers = _path2.node.specifiers;

	                if (specifiers != null && specifiers.length) {
	                  if (_path2.node.source) {
	                    pushModule(_path2.node.source.value, "exports", specifiers);

	                    _path2.remove();
	                  } else {
	                    var nodes = [];

	                    for (var _iterator7 = _createForOfIteratorHelperLoose(specifiers), _step7; !(_step7 = _iterator7()).done;) {
	                      var specifier = _step7.value;
	                      var local = specifier.local,
	                          exported = specifier.exported;
	                      var binding = scope.getBinding(local.name);
	                      var exportedName = getExportSpecifierName(exported, stringSpecifiers);

	                      if (binding && isFunctionDeclaration$1(binding.path.node)) {
	                        exportNames.push(exportedName);
	                        exportValues.push(cloneNode$i(local));
	                      } else if (!binding) {
	                        nodes.push(buildExportCall(exportedName, local));
	                      }

	                      addExportName(local.name, exportedName);
	                    }

	                    _path2.replaceWithMultiple(nodes);
	                  }
	                } else {
	                  _path2.remove();
	                }
	              }
	            }
	          }

	          modules.forEach(function (specifiers) {
	            var setterBody = [];
	            var target = scope.generateUid(specifiers.key);

	            for (var _iterator4 = _createForOfIteratorHelperLoose(specifiers.imports), _step4; !(_step4 = _iterator4()).done;) {
	              var specifier = _step4.value;

	              if (isImportNamespaceSpecifier$1(specifier)) {
	                setterBody.push(expressionStatement$a(assignmentExpression$c("=", specifier.local, identifier$j(target))));
	              } else if (isImportDefaultSpecifier$1(specifier)) {
	                specifier = importSpecifier$1(specifier.local, identifier$j("default"));
	              }

	              if (isImportSpecifier$1(specifier)) {
	                var _specifier = specifier,
	                    imported = _specifier.imported;
	                setterBody.push(expressionStatement$a(assignmentExpression$c("=", specifier.local, memberExpression$b(identifier$j(target), specifier.imported, imported.type === "StringLiteral"))));
	              }
	            }

	            if (specifiers.exports.length) {
	              var _exportNames = [];
	              var _exportValues = [];
	              var hasExportStar = false;

	              for (var _iterator5 = _createForOfIteratorHelperLoose(specifiers.exports), _step5; !(_step5 = _iterator5()).done;) {
	                var node = _step5.value;

	                if (isExportAllDeclaration$1(node)) {
	                  hasExportStar = true;
	                } else if (isExportSpecifier(node)) {
	                  var exportedName = getExportSpecifierName(node.exported, stringSpecifiers);

	                  _exportNames.push(exportedName);

	                  _exportValues.push(memberExpression$b(identifier$j(target), node.local, isStringLiteral$7(node.local)));
	                } else ;
	              }

	              setterBody.push.apply(setterBody, _toConsumableArray(constructExportCall(path, identifier$j(exportIdent), _exportNames, _exportValues, hasExportStar ? identifier$j(target) : null, stringSpecifiers)));
	            }

	            sources.push(stringLiteral$8(specifiers.key));
	            setters.push(functionExpression$3(null, [identifier$j(target)], blockStatement$6(setterBody)));
	          });
	          var moduleName = getModuleName(this.file.opts, options);
	          if (moduleName) moduleName = stringLiteral$8(moduleName);
	          hoistVariables(path, function (id, name, hasInit) {
	            variableIds.push(id);

	            if (!hasInit && name in exportMap) {
	              for (var _iterator6 = _createForOfIteratorHelperLoose(exportMap[name]), _step6; !(_step6 = _iterator6()).done;) {
	                var exported = _step6.value;
	                exportNames.push(exported);
	                exportValues.push(scope.buildUndefinedNode());
	              }
	            }
	          }, null);

	          if (variableIds.length) {
	            beforeBody.unshift(variableDeclaration$8("var", variableIds.map(function (id) {
	              return variableDeclarator$8(id);
	            })));
	          }

	          if (exportNames.length) {
	            beforeBody.push.apply(beforeBody, _toConsumableArray(constructExportCall(path, identifier$j(exportIdent), exportNames, exportValues, null, stringSpecifiers)));
	          }

	          path.traverse(reassignmentVisitor, {
	            exports: exportMap,
	            buildCall: buildExportCall,
	            scope: scope
	          });

	          for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
	            var _path = _removedPaths[_i3];

	            _path.remove();
	          }

	          var hasTLA = false;
	          path.traverse({
	            AwaitExpression: function AwaitExpression(path) {
	              hasTLA = true;
	              path.stop();
	            },
	            Function: function Function(path) {
	              path.skip();
	            },
	            noScope: true
	          });
	          path.node.body = [buildTemplate({
	            SYSTEM_REGISTER: memberExpression$b(identifier$j(systemGlobal), identifier$j("register")),
	            BEFORE_BODY: beforeBody,
	            MODULE_NAME: moduleName,
	            SETTERS: arrayExpression$2(setters),
	            EXECUTE: functionExpression$3(null, [], blockStatement$6(path.node.body), false, hasTLA),
	            SOURCES: arrayExpression$2(sources),
	            EXPORT_IDENTIFIER: identifier$j(exportIdent),
	            CONTEXT_IDENTIFIER: identifier$j(contextIdent)
	          })];
	        }
	      }
	    }
	  };
	});

	var buildPrerequisiteAssignment = template$2("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
	var buildWrapper = template$2("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");
	var _transformModulesUmd = declare(function (api, options) {
	  var _api$assumption, _api$assumption2;

	  api.assertVersion(7);
	  var globals = options.globals,
	      exactGlobals = options.exactGlobals,
	      allowTopLevelThis = options.allowTopLevelThis,
	      strict = options.strict,
	      strictMode = options.strictMode,
	      noInterop = options.noInterop,
	      importInterop = options.importInterop;
	  var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
	  var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;

	  function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
	    var moduleNameOrBasename = moduleName ? moduleName.value : basename(filename, extname(filename));
	    var globalToAssign = memberExpression$b(identifier$j("global"), identifier$j(toIdentifier$1(moduleNameOrBasename)));
	    var initAssignments = [];

	    if (exactGlobals) {
	      var globalName = browserGlobals[moduleNameOrBasename];

	      if (globalName) {
	        initAssignments = [];
	        var members = globalName.split(".");
	        globalToAssign = members.slice(1).reduce(function (accum, curr) {
	          initAssignments.push(buildPrerequisiteAssignment({
	            GLOBAL_REFERENCE: cloneNode$i(accum)
	          }));
	          return memberExpression$b(accum, identifier$j(curr));
	        }, memberExpression$b(identifier$j("global"), identifier$j(members[0])));
	      }
	    }

	    initAssignments.push(expressionStatement$a(assignmentExpression$c("=", globalToAssign, memberExpression$b(identifier$j("mod"), identifier$j("exports")))));
	    return initAssignments;
	  }

	  function buildBrowserArg(browserGlobals, exactGlobals, source) {
	    var memberExpression;

	    if (exactGlobals) {
	      var globalRef = browserGlobals[source];

	      if (globalRef) {
	        memberExpression = globalRef.split(".").reduce(function (accum, curr) {
	          return memberExpression$b(accum, identifier$j(curr));
	        }, identifier$j("global"));
	      } else {
	        memberExpression = memberExpression$b(identifier$j("global"), identifier$j(toIdentifier$1(source)));
	      }
	    } else {
	      var requireName = basename(source, extname(source));
	      var globalName = browserGlobals[requireName] || requireName;
	      memberExpression = memberExpression$b(identifier$j("global"), identifier$j(toIdentifier$1(globalName)));
	    }

	    return memberExpression;
	  }

	  return {
	    name: "transform-modules-umd",
	    visitor: {
	      Program: {
	        exit: function exit(path) {
	          if (!isModule(path)) return;
	          var browserGlobals = globals || {};
	          var moduleName = getModuleName(this.file.opts, options);
	          if (moduleName) moduleName = stringLiteral$8(moduleName);

	          var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
	            constantReexports: constantReexports,
	            enumerableModuleMeta: enumerableModuleMeta,
	            strict: strict,
	            strictMode: strictMode,
	            allowTopLevelThis: allowTopLevelThis,
	            noInterop: noInterop,
	            importInterop: importInterop
	          }),
	              meta = _rewriteModuleStateme.meta,
	              headers = _rewriteModuleStateme.headers;

	          var amdArgs = [];
	          var commonjsArgs = [];
	          var browserArgs = [];
	          var importNames = [];

	          if (hasExports(meta)) {
	            amdArgs.push(stringLiteral$8("exports"));
	            commonjsArgs.push(identifier$j("exports"));
	            browserArgs.push(memberExpression$b(identifier$j("mod"), identifier$j("exports")));
	            importNames.push(identifier$j(meta.exportName));
	          }

	          for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
	            var _step$value = _slicedToArray$1(_step.value, 2),
	                source = _step$value[0],
	                metadata = _step$value[1];

	            amdArgs.push(stringLiteral$8(source));
	            commonjsArgs.push(callExpression$e(identifier$j("require"), [stringLiteral$8(source)]));
	            browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
	            importNames.push(identifier$j(metadata.name));

	            if (!isSideEffectImport(metadata)) {
	              var interop = wrapInterop(path, identifier$j(metadata.name), metadata.interop);

	              if (interop) {
	                var header = expressionStatement$a(assignmentExpression$c("=", identifier$j(metadata.name), interop));
	                header.loc = meta.loc;
	                headers.push(header);
	              }
	            }

	            headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
	          }

	          ensureStatementsHoisted(headers);
	          path.unshiftContainer("body", headers);
	          var _path$node = path.node,
	              body = _path$node.body,
	              directives = _path$node.directives;
	          path.node.directives = [];
	          path.node.body = [];
	          var umdWrapper = path.pushContainer("body", [buildWrapper({
	            MODULE_NAME: moduleName,
	            AMD_ARGUMENTS: arrayExpression$2(amdArgs),
	            COMMONJS_ARGUMENTS: commonjsArgs,
	            BROWSER_ARGUMENTS: browserArgs,
	            IMPORT_NAMES: importNames,
	            GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
	          })])[0];
	          var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
	          umdFactory.pushContainer("directives", directives);
	          umdFactory.pushContainer("body", body);
	        }
	      }
	    }
	  };
	});

	function _transformNamedCapturingGroupsRegex (core, options) {
	  var _options$runtime = options.runtime,
	      runtime = _options$runtime === void 0 ? true : _options$runtime;

	  if (typeof runtime !== "boolean") {
	    throw new Error("The 'runtime' option must be boolean");
	  }

	  return createRegExpFeaturePlugin({
	    name: "transform-named-capturing-groups-regex",
	    feature: "namedCaptureGroups",
	    options: {
	      runtime: runtime
	    }
	  });
	}

	var _transformNewTarget = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-new-target",
	    visitor: {
	      MetaProperty: function MetaProperty(path) {
	        var meta = path.get("meta");
	        var property = path.get("property");
	        var scope = path.scope;

	        if (meta.isIdentifier({
	          name: "new"
	        }) && property.isIdentifier({
	          name: "target"
	        })) {
	          var func = path.findParent(function (path) {
	            if (path.isClass()) return true;

	            if (path.isFunction() && !path.isArrowFunctionExpression()) {
	              if (path.isClassMethod({
	                kind: "constructor"
	              })) {
	                return false;
	              }

	              return true;
	            }

	            return false;
	          });

	          if (!func) {
	            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
	          }

	          var node = func.node;

	          if (!node.id) {
	            if (func.isMethod()) {
	              path.replaceWith(scope.buildUndefinedNode());
	              return;
	            }

	            node.id = scope.generateUidIdentifier("target");
	          }

	          var _constructor = memberExpression$b(thisExpression$3(), identifier$j("constructor"));

	          if (func.isClass()) {
	            path.replaceWith(_constructor);
	            return;
	          }

	          path.replaceWith(conditionalExpression$3(binaryExpression$4("instanceof", thisExpression$3(), cloneNode$i(node.id)), _constructor, scope.buildUndefinedNode()));
	        }
	      }
	    }
	  };
	});

	var transformObjectAssign = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-object-assign",
	    visitor: {
	      CallExpression: function CallExpression(path, file) {
	        if (path.get("callee").matchesPattern("Object.assign")) {
	          path.node.callee = file.addHelper("extends");
	        }
	      }
	    }
	  };
	});

	function replacePropertySuper(path, getObjectRef, file) {
	  var replaceSupers = new ReplaceSupers({
	    getObjectRef: getObjectRef,
	    methodPath: path,
	    file: file
	  });
	  replaceSupers.replace();
	}

	var _transformObjectSuper = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-object-super",
	    visitor: {
	      ObjectExpression: function ObjectExpression(path, state) {
	        var objectRef;

	        var getObjectRef = function getObjectRef() {
	          return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
	        };

	        path.get("properties").forEach(function (propPath) {
	          if (!propPath.isMethod()) return;
	          replacePropertySuper(propPath, getObjectRef, state);
	        });

	        if (objectRef) {
	          path.scope.push({
	            id: cloneNode$i(objectRef)
	          });
	          path.replaceWith(assignmentExpression$c("=", cloneNode$i(objectRef), path.node));
	        }
	      }
	    }
	  };
	});

	var transformObjectSetPrototypeOfToAssign = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-object-set-prototype-of-to-assign",
	    visitor: {
	      CallExpression: function CallExpression(path, file) {
	        if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
	          path.node.callee = file.addHelper("defaults");
	        }
	      }
	    }
	  };
	});

	var _transformPropertyLiterals = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-property-literals",
	    visitor: {
	      ObjectProperty: {
	        exit: function exit(_ref) {
	          var node = _ref.node;
	          var key = node.key;

	          if (!node.computed && isIdentifier$g(key) && !isValidES3Identifier(key.name)) {
	            node.key = stringLiteral$8(key.name);
	          }
	        }
	      }
	    }
	  };
	});

	var arrayExpression = arrayExpression$2,
	    booleanLiteral$1 = booleanLiteral$5,
	    functionExpression = functionExpression$3,
	    identifier$1 = identifier$j,
	    inheritsComments = inheritsComments$2,
	    isClassMethod = isClassMethod$1,
	    isFunctionExpression = isFunctionExpression$1,
	    isObjectMethod = isObjectMethod$2,
	    isObjectProperty = isObjectProperty$4,
	    isProperty = isProperty$2,
	    isStringLiteral$2 = isStringLiteral$7,
	    objectExpression$1 = objectExpression$4,
	    objectProperty$1 = objectProperty$2,
	    removeComments = removeComments$2,
	    toComputedKey = toComputedKey$3,
	    toKeyAlias = toKeyAlias$1;

	function toKind(node) {
	  if (isClassMethod(node) || isObjectMethod(node)) {
	    if (node.kind === "get" || node.kind === "set") {
	      return node.kind;
	    }
	  }

	  return "value";
	}

	var has$7 = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
	function push(mutatorMap, node, kind, file, scope) {
	  var alias = toKeyAlias(node);
	  var map = {};
	  if (has$7(mutatorMap, alias)) map = mutatorMap[alias];
	  mutatorMap[alias] = map;
	  map._inherits = map._inherits || [];

	  map._inherits.push(node);

	  map._key = node.key;

	  if (node.computed) {
	    map._computed = true;
	  }

	  if (node.decorators) {
	    var _decorators$elements;

	    var decorators = map.decorators = map.decorators || arrayExpression([]);

	    (_decorators$elements = decorators.elements).push.apply(_decorators$elements, _toConsumableArray(node.decorators.map(function (dec) {
	      return dec.expression;
	    }).reverse()));
	  }

	  if (map.value || map.initializer) {
	    throw file.buildCodeFrameError(node, "Key conflict with sibling node");
	  }

	  var key, value;

	  if (isObjectProperty(node) || isObjectMethod(node) || isClassMethod(node)) {
	    key = toComputedKey(node, node.key);
	  }

	  if (isProperty(node)) {
	    value = node.value;
	  } else if (isObjectMethod(node) || isClassMethod(node)) {
	    value = functionExpression(null, node.params, node.body, node.generator, node.async);
	    value.returnType = node.returnType;
	  }

	  var inheritedKind = toKind(node);

	  if (!kind || inheritedKind !== "value") {
	    kind = inheritedKind;
	  }

	  if (scope && isStringLiteral$2(key) && (kind === "value" || kind === "initializer") && isFunctionExpression(value)) {
	    value = nameFunction({
	      id: key,
	      node: value,
	      scope: scope
	    });
	  }

	  if (value) {
	    inheritsComments(value, node);
	    map[kind] = value;
	  }

	  return map;
	}
	function toClassObject(mutatorMap) {
	  var objExpr = objectExpression$1([]);
	  Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
	    var map = mutatorMap[mutatorMapKey];
	    var mapNode = objectExpression$1([]);
	    var propNode = objectProperty$1(map._key, mapNode, map._computed);
	    Object.keys(map).forEach(function (key) {
	      var node = map[key];
	      if (key[0] === "_") return;
	      var prop = objectProperty$1(identifier$1(key), node);
	      inheritsComments(prop, node);
	      removeComments(node);
	      mapNode.properties.push(prop);
	    });
	    objExpr.properties.push(propNode);
	  });
	  return objExpr;
	}
	function toDefineObject(mutatorMap) {
	  Object.keys(mutatorMap).forEach(function (key) {
	    var map = mutatorMap[key];
	    if (map.value) map.writable = booleanLiteral$1(true);
	    map.configurable = booleanLiteral$1(true);
	    map.enumerable = booleanLiteral$1(true);
	  });
	  return toClassObject(mutatorMap);
	}

	var transformPropertyMutators = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-property-mutators",
	    visitor: {
	      ObjectExpression: function ObjectExpression(path, file) {
	        var node = path.node;
	        var hasAny = false;

	        for (var _iterator = _createForOfIteratorHelperLoose(node.properties), _step; !(_step = _iterator()).done;) {
	          var prop = _step.value;

	          if (prop.kind === "get" || prop.kind === "set") {
	            hasAny = true;
	            break;
	          }
	        }

	        if (!hasAny) return;
	        var mutatorMap = {};
	        node.properties = node.properties.filter(function (prop) {
	          if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
	            push(mutatorMap, prop, null, file);
	            return false;
	          } else {
	            return true;
	          }
	        });
	        path.replaceWith(callExpression$e(memberExpression$b(identifier$j("Object"), identifier$j("defineProperties")), [node, toDefineObject(mutatorMap)]));
	      }
	    }
	  };
	});

	var transformProtoToAssign = declare(function (api) {
	  api.assertVersion(7);

	  function isProtoKey(node) {
	    return isLiteral$7(toComputedKey$3(node, node.key), {
	      value: "__proto__"
	    });
	  }

	  function isProtoAssignmentExpression(node) {
	    var left = node.left;
	    return isMemberExpression$8(left) && isLiteral$7(toComputedKey$3(left, left.property), {
	      value: "__proto__"
	    });
	  }

	  function buildDefaultsCallExpression(expr, ref, file) {
	    return expressionStatement$a(callExpression$e(file.addHelper("defaults"), [ref, expr.right]));
	  }

	  return {
	    name: "transform-proto-to-assign",
	    visitor: {
	      AssignmentExpression: function AssignmentExpression(path, file) {
	        if (!isProtoAssignmentExpression(path.node)) return;
	        var nodes = [];
	        var left = path.node.left.object;
	        var temp = path.scope.maybeGenerateMemoised(left);

	        if (temp) {
	          nodes.push(expressionStatement$a(assignmentExpression$c("=", temp, left)));
	        }

	        nodes.push(buildDefaultsCallExpression(path.node, cloneNode$i(temp || left), file));
	        if (temp) nodes.push(cloneNode$i(temp));
	        path.replaceWithMultiple(nodes);
	      },
	      ExpressionStatement: function ExpressionStatement(path, file) {
	        var expr = path.node.expression;
	        if (!isAssignmentExpression$3(expr, {
	          operator: "="
	        })) return;

	        if (isProtoAssignmentExpression(expr)) {
	          path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
	        }
	      },
	      ObjectExpression: function ObjectExpression(path, file) {
	        var proto;
	        var node = path.node;
	        var properties = node.properties;

	        for (var i = 0; i < properties.length; i++) {
	          var prop = properties[i];

	          if (isProtoKey(prop)) {
	            proto = prop.value;
	            properties.splice(i, 1);
	            break;
	          }
	        }

	        if (proto) {
	          var args = [objectExpression$4([]), proto];
	          if (node.properties.length) args.push(node);
	          path.replaceWith(callExpression$e(file.addHelper("extends"), args));
	        }
	      }
	    }
	  };
	});

	var _templateObject$6;
	var transformReactConstantElements = declare(function (api, options) {
	  api.assertVersion(7);
	  var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

	  if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
	    throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
	  }

	  var HOISTED = new WeakMap();

	  function declares(node, scope) {
	    if (isJSXIdentifier$3(node, {
	      name: "this"
	    }) || isJSXIdentifier$3(node, {
	      name: "arguments"
	    }) || isJSXIdentifier$3(node, {
	      name: "super"
	    }) || isJSXIdentifier$3(node, {
	      name: "new"
	    })) {
	      var path = scope.path;
	      return path.isFunctionParent() && !path.isArrowFunctionExpression();
	    }

	    return scope.hasOwnBinding(node.name);
	  }

	  function isHoistingScope(_ref) {
	    var path = _ref.path;
	    return path.isFunctionParent() || path.isLoop() || path.isProgram();
	  }

	  function getHoistingScope(scope) {
	    while (!isHoistingScope(scope)) {
	      scope = scope.parent;
	    }

	    return scope;
	  }

	  var analyzer = {
	    enter: function enter(path, state) {
	      var stop = function stop() {
	        state.isImmutable = false;
	        path.stop();
	      };

	      if (path.isJSXClosingElement()) {
	        path.skip();
	        return;
	      }

	      if (path.isJSXIdentifier({
	        name: "ref"
	      }) && path.parentPath.isJSXAttribute({
	        name: path.node
	      })) {
	        return stop();
	      }

	      if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName()) {
	        return;
	      }

	      if (path.isIdentifier()) {
	        var binding = path.scope.getBinding(path.node.name);
	        if (binding && binding.constant) return;
	      }

	      if (!path.isImmutable()) {
	        if (path.isPure()) {
	          var expressionResult = path.evaluate();

	          if (expressionResult.confident) {
	            var value = expressionResult.value;
	            var isMutable = !state.mutablePropsAllowed && value && typeof value === "object" || typeof value === "function";

	            if (!isMutable) {
	              path.skip();
	              return;
	            }
	          } else if (isIdentifier$g(expressionResult.deopt)) {
	            return;
	          }
	        }

	        stop();
	      }
	    },
	    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
	      var node = path.node;
	      var scope = path.scope;

	      while (scope) {
	        if (scope === state.targetScope) return;
	        if (declares(node, scope)) break;
	        scope = scope.parent;
	      }

	      state.targetScope = getHoistingScope(scope);
	    }
	  };
	  return {
	    name: "transform-react-constant-elements",
	    visitor: {
	      JSXElement: function JSXElement(path) {
	        var _jsxScope;

	        if (HOISTED.has(path.node)) return;
	        HOISTED.set(path.node, path.scope);
	        var name = path.node.openingElement.name;
	        var mutablePropsAllowed = false;

	        if (allowMutablePropsOnTags != null) {
	          var lastSegment = name;

	          while (isJSXMemberExpression$2(lastSegment)) {
	            lastSegment = lastSegment.property;
	          }

	          var elementName = lastSegment.name;
	          mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);
	        }

	        var state = {
	          isImmutable: true,
	          mutablePropsAllowed: mutablePropsAllowed,
	          targetScope: path.scope.getProgramParent()
	        };
	        path.traverse(analyzer, state);
	        if (!state.isImmutable) return;
	        var targetScope = state.targetScope;
	        HOISTED.set(path.node, targetScope);
	        var jsxScope;
	        var current = path;

	        while (!jsxScope && current.parentPath.isJSX()) {
	          current = current.parentPath;
	          jsxScope = HOISTED.get(current.node);
	        }

	        (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = getHoistingScope(path.scope);
	        if (targetScope === jsxScope) return;
	        var id = path.scope.generateUidBasedOnNode(name);
	        targetScope.push({
	          id: identifier$j(id)
	        });
	        var replacement = template$2.expression.ast(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose(["\n          ", " || (", " = ", ")\n        "])), identifier$j(id), identifier$j(id), path.node);

	        if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute()) {
	          replacement = jsxExpressionContainer$1(replacement);
	        }

	        path.replaceWith(replacement);
	      }
	    }
	  };
	});

	var transformReactDisplayName = declare(function (api) {
	  api.assertVersion(7);

	  function addDisplayName(id, call) {
	    var props = call.arguments[0].properties;
	    var safe = true;

	    for (var i = 0; i < props.length; i++) {
	      var prop = props[i];
	      var key = toComputedKey$3(prop);

	      if (isLiteral$7(key, {
	        value: "displayName"
	      })) {
	        safe = false;
	        break;
	      }
	    }

	    if (safe) {
	      props.unshift(objectProperty$2(identifier$j("displayName"), stringLiteral$8(id)));
	    }
	  }

	  var isCreateClassCallExpression = buildMatchMemberExpression$1("React.createClass");

	  var isCreateClassAddon = function isCreateClassAddon(callee) {
	    return callee.name === "createReactClass";
	  };

	  function isCreateClass(node) {
	    if (!node || !isCallExpression$6(node)) return false;

	    if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
	      return false;
	    }

	    var args = node.arguments;
	    if (args.length !== 1) return false;
	    var first = args[0];
	    if (!isObjectExpression$3(first)) return false;
	    return true;
	  }

	  return {
	    name: "transform-react-display-name",
	    visitor: {
	      ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref, state) {
	        var node = _ref.node;

	        if (isCreateClass(node.declaration)) {
	          var filename = state.filename || "unknown";
	          var displayName = path$1.basename(filename, path$1.extname(filename));

	          if (displayName === "index") {
	            displayName = path$1.basename(path$1.dirname(filename));
	          }

	          addDisplayName(displayName, node.declaration);
	        }
	      },
	      CallExpression: function CallExpression(path) {
	        var node = path.node;
	        if (!isCreateClass(node)) return;
	        var id;
	        path.find(function (path) {
	          if (path.isAssignmentExpression()) {
	            id = path.node.left;
	          } else if (path.isObjectProperty()) {
	            id = path.node.key;
	          } else if (path.isVariableDeclarator()) {
	            id = path.node.id;
	          } else if (path.isStatement()) {
	            return true;
	          }

	          if (id) return true;
	        });
	        if (!id) return;

	        if (isMemberExpression$8(id)) {
	          id = id.property;
	        }

	        if (isIdentifier$g(id)) {
	          addDisplayName(id.name, node);
	        }
	      }
	    }
	  };
	});

	var booleanLiteral = booleanLiteral$5,
	    callExpression = callExpression$e,
	    identifier = identifier$j,
	    inherits = inherits$1,
	    isIdentifier$1 = isIdentifier$g,
	    isJSXExpressionContainer = isJSXExpressionContainer$1,
	    isJSXIdentifier = isJSXIdentifier$3,
	    isJSXMemberExpression = isJSXMemberExpression$2,
	    isJSXNamespacedName = isJSXNamespacedName$1,
	    isJSXSpreadAttribute = isJSXSpreadAttribute$1,
	    isLiteral = isLiteral$7,
	    isObjectExpression = isObjectExpression$3,
	    isReferenced = isReferenced$2,
	    isStringLiteral$1 = isStringLiteral$7,
	    isValidIdentifier = isValidIdentifier$1,
	    memberExpression = memberExpression$b,
	    nullLiteral = nullLiteral$2,
	    objectExpression = objectExpression$4,
	    objectProperty = objectProperty$2,
	    react = react$3,
	    spreadElement = spreadElement$2,
	    stringLiteral = stringLiteral$8,
	    thisExpression = thisExpression$3;
	function helper (opts) {
	  var visitor = {};

	  visitor.JSXNamespacedName = function (path) {
	    if (opts.throwIfNamespace) {
	      throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
	    }
	  };

	  visitor.JSXSpreadChild = function (path) {
	    throw path.buildCodeFrameError("Spread children are not supported in React.");
	  };

	  visitor.JSXElement = {
	    exit: function exit(path, file) {
	      var callExpr = buildElementCall(path, file);

	      if (callExpr) {
	        path.replaceWith(inherits(callExpr, path.node));
	      }
	    }
	  };
	  visitor.JSXFragment = {
	    exit: function exit(path, file) {
	      if (opts.compat) {
	        throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");
	      }

	      var callExpr = buildFragmentCall(path, file);

	      if (callExpr) {
	        path.replaceWith(inherits(callExpr, path.node));
	      }
	    }
	  };
	  return visitor;

	  function convertJSXIdentifier(node, parent) {
	    if (isJSXIdentifier(node)) {
	      if (node.name === "this" && isReferenced(node, parent)) {
	        return thisExpression();
	      } else if (isValidIdentifier(node.name, false)) {
	        node.type = "Identifier";
	      } else {
	        return stringLiteral(node.name);
	      }
	    } else if (isJSXMemberExpression(node)) {
	      return memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
	    } else if (isJSXNamespacedName(node)) {
	      return stringLiteral(node.namespace.name + ":" + node.name.name);
	    }

	    return node;
	  }

	  function convertAttributeValue(node) {
	    if (isJSXExpressionContainer(node)) {
	      return node.expression;
	    } else {
	      return node;
	    }
	  }

	  function convertAttribute(node) {
	    var value = convertAttributeValue(node.value || booleanLiteral(true));

	    if (isJSXSpreadAttribute(node)) {
	      return spreadElement(node.argument);
	    }

	    if (isStringLiteral$1(value) && !isJSXExpressionContainer(node.value)) {
	      var _value$extra;

	      value.value = value.value.replace(/\n\s+/g, " ");
	      (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
	    }

	    if (isJSXNamespacedName(node.name)) {
	      node.name = stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
	    } else if (isValidIdentifier(node.name.name, false)) {
	      node.name.type = "Identifier";
	    } else {
	      node.name = stringLiteral(node.name.name);
	    }

	    return inherits(objectProperty(node.name, value), node);
	  }

	  function buildElementCall(path, file) {
	    if (opts.filter && !opts.filter(path.node, file)) return;
	    var openingPath = path.get("openingElement");
	    openingPath.parent.children = react.buildChildren(openingPath.parent);
	    var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
	    var args = [];
	    var tagName;

	    if (isIdentifier$1(tagExpr)) {
	      tagName = tagExpr.name;
	    } else if (isLiteral(tagExpr)) {
	      tagName = tagExpr.value;
	    }

	    var state = {
	      tagExpr: tagExpr,
	      tagName: tagName,
	      args: args,
	      pure: false
	    };

	    if (opts.pre) {
	      opts.pre(state, file);
	    }

	    var attribs = openingPath.node.attributes;

	    if (attribs.length) {
	      {
	        attribs = buildOpeningElementAttributes(attribs, file);
	      }
	    } else {
	      attribs = nullLiteral();
	    }

	    args.push.apply(args, [attribs].concat(_toConsumableArray(path.node.children)));

	    if (opts.post) {
	      opts.post(state, file);
	    }

	    var call = state.call || callExpression(state.callee, args);
	    if (state.pure) annotateAsPure(call);
	    return call;
	  }

	  function pushProps(_props, objs) {
	    if (!_props.length) return _props;
	    objs.push(objectExpression(_props));
	    return [];
	  }

	  function buildOpeningElementAttributes(attribs, file) {
	    var _props = [];
	    var objs = [];
	    var _file$opts$useSpread = file.opts.useSpread,
	        useSpread = _file$opts$useSpread === void 0 ? false : _file$opts$useSpread;

	    if (typeof useSpread !== "boolean") {
	      throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
	    }

	    var useBuiltIns = file.opts.useBuiltIns || false;

	    if (typeof useBuiltIns !== "boolean") {
	      throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
	    }

	    if (useSpread && useBuiltIns) {
	      throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
	    }

	    if (useSpread) {
	      var props = attribs.map(convertAttribute);
	      return objectExpression(props);
	    }

	    while (attribs.length) {
	      var prop = attribs.shift();

	      if (isJSXSpreadAttribute(prop)) {
	        _props = pushProps(_props, objs);
	        objs.push(prop.argument);
	      } else {
	        _props.push(convertAttribute(prop));
	      }
	    }

	    pushProps(_props, objs);

	    if (objs.length === 1) {
	      attribs = objs[0];
	    } else {
	      if (!isObjectExpression(objs[0])) {
	        objs.unshift(objectExpression([]));
	      }

	      var helper = useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
	      attribs = callExpression(helper, objs);
	    }

	    return attribs;
	  }

	  function buildFragmentCall(path, file) {
	    if (opts.filter && !opts.filter(path.node, file)) return;
	    var openingPath = path.get("openingElement");
	    openingPath.parent.children = react.buildChildren(openingPath.parent);
	    var args = [];
	    var tagName = null;
	    var tagExpr = file.get("jsxFragIdentifier")();
	    var state = {
	      tagExpr: tagExpr,
	      tagName: tagName,
	      args: args,
	      pure: false
	    };

	    if (opts.pre) {
	      opts.pre(state, file);
	    }

	    args.push.apply(args, [nullLiteral()].concat(_toConsumableArray(path.node.children)));

	    if (opts.post) {
	      opts.post(state, file);
	    }

	    file.set("usedFragment", true);
	    var call = state.call || callExpression(state.callee, args);
	    if (state.pure) annotateAsPure(call);
	    return call;
	  }
	}

	var transformReactInlineElements = declare(function (api) {
	  api.assertVersion(7);

	  function hasRefOrSpread(attrs) {
	    for (var i = 0; i < attrs.length; i++) {
	      var attr = attrs[i];
	      if (isJSXSpreadAttribute$1(attr)) return true;
	      if (isJSXAttributeOfName(attr, "ref")) return true;
	    }

	    return false;
	  }

	  function isJSXAttributeOfName(attr, name) {
	    return isJSXAttribute(attr) && isJSXIdentifier$3(attr.name, {
	      name: name
	    });
	  }

	  var visitor = helper({
	    filter: function filter(node) {
	      return node.openingElement && !hasRefOrSpread(node.openingElement.attributes);
	    },
	    pre: function pre(state) {
	      var tagName = state.tagName;
	      var args = state.args;

	      if (react$3.isCompatTag(tagName)) {
	        args.push(stringLiteral$8(tagName));
	      } else {
	        args.push(state.tagExpr);
	      }
	    },
	    post: function post(state, pass) {
	      state.callee = pass.addHelper("jsx");
	      var props = state.args[1];
	      var hasKey = false;

	      if (isObjectExpression$3(props)) {
	        var keyIndex = props.properties.findIndex(function (prop) {
	          return isIdentifier$g(prop.key, {
	            name: "key"
	          });
	        });

	        if (keyIndex > -1) {
	          state.args.splice(2, 0, props.properties[keyIndex].value);
	          props.properties.splice(keyIndex, 1);
	          hasKey = true;
	        }
	      } else if (isNullLiteral$1(props)) {
	        state.args.splice(1, 1, objectExpression$4([]));
	      }

	      if (!hasKey && state.args.length > 2) {
	        state.args.splice(2, 0, unaryExpression$7("void", numericLiteral$8(0)));
	      }

	      state.pure = true;
	    }
	  });
	  return {
	    name: "transform-react-inline-elements",
	    visitor: visitor
	  };
	});

	var DEFAULT = {
	  importSource: "react",
	  runtime: "automatic",
	  pragma: "React.createElement",
	  pragmaFrag: "React.Fragment"
	};
	var JSX_SOURCE_ANNOTATION_REGEX = /^\s*\*?\s*@jsxImportSource\s+([^\s]+)\s*$/m;
	var JSX_RUNTIME_ANNOTATION_REGEX = /^\s*\*?\s*@jsxRuntime\s+([^\s]+)\s*$/m;
	var JSX_ANNOTATION_REGEX = /^\s*\*?\s*@jsx\s+([^\s]+)\s*$/m;
	var JSX_FRAG_ANNOTATION_REGEX = /^\s*\*?\s*@jsxFrag\s+([^\s]+)\s*$/m;

	var get = function get(pass, name) {
	  return pass.get("@babel/plugin-react-jsx/" + name);
	};

	var set = function set(pass, name, v) {
	  return pass.set("@babel/plugin-react-jsx/" + name, v);
	};

	function createPlugin(_ref) {
	  var name = _ref.name,
	      development = _ref.development;
	  return declare(function (api, options) {
	    var PURE_ANNOTATION = options.pure,
	        _options$throwIfNames = options.throwIfNamespace,
	        throwIfNamespace = _options$throwIfNames === void 0 ? true : _options$throwIfNames,
	        filter = options.filter,
	        _options$runtime = options.runtime,
	        RUNTIME_DEFAULT = _options$runtime === void 0 ? development ? "automatic" : "classic" : _options$runtime,
	        _options$importSource = options.importSource,
	        IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,
	        _options$pragma = options.pragma,
	        PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,
	        _options$pragmaFrag = options.pragmaFrag,
	        PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;
	    {
	      var _options$useSpread = options.useSpread,
	          useSpread = _options$useSpread === void 0 ? false : _options$useSpread,
	          _options$useBuiltIns = options.useBuiltIns,
	          useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

	      if (RUNTIME_DEFAULT === "classic") {
	        if (typeof useSpread !== "boolean") {
	          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
	        }

	        if (typeof useBuiltIns !== "boolean") {
	          throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
	        }

	        if (useSpread && useBuiltIns) {
	          throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
	        }
	      }
	    }
	    var injectMetaPropertiesVisitor = {
	      JSXOpeningElement: function JSXOpeningElement(path, state) {
	        var attributes = [];

	        if (isThisAllowed(path)) {
	          attributes.push(jsxAttribute(jsxIdentifier$2("__self"), jsxExpressionContainer$1(thisExpression$3())));
	        }

	        attributes.push(jsxAttribute(jsxIdentifier$2("__source"), jsxExpressionContainer$1(makeSource(path, state))));
	        path.pushContainer("attributes", attributes);
	      }
	    };
	    return {
	      name: name,
	      inherits: syntaxJsx,
	      visitor: {
	        JSXNamespacedName: function JSXNamespacedName(path) {
	          if (throwIfNamespace) {
	            throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
	          }
	        },
	        JSXSpreadChild: function JSXSpreadChild(path) {
	          throw path.buildCodeFrameError("Spread children are not supported in React.");
	        },
	        Program: {
	          enter: function enter(path, state) {
	            var file = state.file;
	            var runtime = RUNTIME_DEFAULT;
	            var source = IMPORT_SOURCE_DEFAULT;
	            var pragma = PRAGMA_DEFAULT;
	            var pragmaFrag = PRAGMA_FRAG_DEFAULT;
	            var sourceSet = !!options.importSource;
	            var pragmaSet = !!options.pragma;
	            var pragmaFragSet = !!options.pragmaFrag;

	            if (file.ast.comments) {
	              for (var _iterator = _createForOfIteratorHelperLoose(file.ast.comments), _step; !(_step = _iterator()).done;) {
	                var comment = _step.value;
	                var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

	                if (sourceMatches) {
	                  source = sourceMatches[1];
	                  sourceSet = true;
	                }

	                var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

	                if (runtimeMatches) {
	                  runtime = runtimeMatches[1];
	                }

	                var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

	                if (jsxMatches) {
	                  pragma = jsxMatches[1];
	                  pragmaSet = true;
	                }

	                var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

	                if (jsxFragMatches) {
	                  pragmaFrag = jsxFragMatches[1];
	                  pragmaFragSet = true;
	                }
	              }
	            }

	            set(state, "runtime", runtime);

	            if (runtime === "classic") {
	              if (sourceSet) {
	                throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
	              }

	              var createElement = toMemberExpression(pragma);
	              var fragment = toMemberExpression(pragmaFrag);
	              set(state, "id/createElement", function () {
	                return cloneNode$i(createElement);
	              });
	              set(state, "id/fragment", function () {
	                return cloneNode$i(fragment);
	              });
	              set(state, "defaultPure", pragma === DEFAULT.pragma);
	            } else if (runtime === "automatic") {
	              if (pragmaSet || pragmaFragSet) {
	                throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
	              }

	              var define = function define(name, id) {
	                return set(state, name, createImportLazily(state, path, id, source));
	              };

	              define("id/jsx", development ? "jsxDEV" : "jsx");
	              define("id/jsxs", development ? "jsxDEV" : "jsxs");
	              define("id/createElement", "createElement");
	              define("id/fragment", "Fragment");
	              set(state, "defaultPure", source === DEFAULT.importSource);
	            } else {
	              throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
	            }

	            if (development) {
	              path.traverse(injectMetaPropertiesVisitor, state);
	            }
	          }
	        },
	        JSXElement: {
	          exit: function exit(path, file) {
	            var callExpr;

	            if (get(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
	              callExpr = buildCreateElementCall(path, file);
	            } else {
	              callExpr = buildJSXElementCall(path, file);
	            }

	            path.replaceWith(inherits$1(callExpr, path.node));
	          }
	        },
	        JSXFragment: {
	          exit: function exit(path, file) {
	            var callExpr;

	            if (get(file, "runtime") === "classic") {
	              callExpr = buildCreateElementFragmentCall(path, file);
	            } else {
	              callExpr = buildJSXFragmentCall(path, file);
	            }

	            path.replaceWith(inherits$1(callExpr, path.node));
	          }
	        },
	        JSXAttribute: function JSXAttribute(path) {
	          if (isJSXElement(path.node.value)) {
	            path.node.value = jsxExpressionContainer$1(path.node.value);
	          }
	        }
	      }
	    };

	    function getThisFunctionParent(path) {
	      var scope = path.scope;

	      do {
	        if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {
	          return scope.path;
	        }
	      } while (scope = scope.parent);

	      return null;
	    }

	    function isDerivedClass(classPath) {
	      return classPath.node.superClass !== null;
	    }

	    function isThisAllowed(path) {
	      var parentMethodOrFunction = getThisFunctionParent(path);

	      if (parentMethodOrFunction === null) {
	        return true;
	      }

	      if (!parentMethodOrFunction.isMethod()) {
	        return true;
	      }

	      if (parentMethodOrFunction.node.kind !== "constructor") {
	        return true;
	      }

	      return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);
	    }

	    function call(pass, name, args) {
	      var node = callExpression$e(get(pass, "id/" + name)(), args);
	      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) annotateAsPure(node);
	      return node;
	    }

	    function shouldUseCreateElement(path) {
	      var openingPath = path.get("openingElement");
	      var attributes = openingPath.node.attributes;
	      var seenPropsSpread = false;

	      for (var i = 0; i < attributes.length; i++) {
	        var attr = attributes[i];

	        if (seenPropsSpread && isJSXAttribute(attr) && attr.name.name === "key") {
	          return true;
	        } else if (isJSXSpreadAttribute$1(attr)) {
	          seenPropsSpread = true;
	        }
	      }

	      return false;
	    }

	    function convertJSXIdentifier(node, parent) {
	      if (isJSXIdentifier$3(node)) {
	        if (node.name === "this" && isReferenced$2(node, parent)) {
	          return thisExpression$3();
	        } else if (isValidIdentifier$1(node.name, false)) {
	          node.type = "Identifier";
	        } else {
	          return stringLiteral$8(node.name);
	        }
	      } else if (isJSXMemberExpression$2(node)) {
	        return memberExpression$b(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
	      } else if (isJSXNamespacedName$1(node)) {
	        return stringLiteral$8(node.namespace.name + ":" + node.name.name);
	      }

	      return node;
	    }

	    function convertAttributeValue(node) {
	      if (isJSXExpressionContainer$1(node)) {
	        return node.expression;
	      } else {
	        return node;
	      }
	    }

	    function accumulateAttribute(array, attribute) {
	      if (isJSXSpreadAttribute$1(attribute.node)) {
	        var arg = attribute.node.argument;

	        if (isObjectExpression$3(arg)) {
	          array.push.apply(array, _toConsumableArray(arg.properties));
	        } else {
	          array.push(spreadElement$2(arg));
	        }

	        return array;
	      }

	      var value = convertAttributeValue(attribute.node.name.name !== "key" ? attribute.node.value || booleanLiteral$5(true) : attribute.node.value);

	      if (attribute.node.name.name === "key" && value === null) {
	        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
	      }

	      if (isStringLiteral$7(value) && !isJSXExpressionContainer$1(attribute.node.value)) {
	        var _value$extra;

	        value.value = value.value.replace(/\n\s+/g, " ");
	        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
	      }

	      if (isJSXNamespacedName$1(attribute.node.name)) {
	        attribute.node.name = stringLiteral$8(attribute.node.name.namespace.name + ":" + attribute.node.name.name.name);
	      } else if (isValidIdentifier$1(attribute.node.name.name, false)) {
	        attribute.node.name.type = "Identifier";
	      } else {
	        attribute.node.name = stringLiteral$8(attribute.node.name.name);
	      }

	      array.push(inherits$1(objectProperty$2(attribute.node.name, value), attribute.node));
	      return array;
	    }

	    function buildChildrenProperty(children) {
	      var childrenNode;

	      if (children.length === 1) {
	        childrenNode = children[0];
	      } else if (children.length > 1) {
	        childrenNode = arrayExpression$2(children);
	      } else {
	        return undefined;
	      }

	      return objectProperty$2(identifier$j("children"), childrenNode);
	    }

	    function buildJSXElementCall(path, file) {
	      var openingPath = path.get("openingElement");
	      var args = [getTag(openingPath)];
	      var attribsArray = [];
	      var extracted = Object.create(null);

	      for (var _iterator2 = _createForOfIteratorHelperLoose(openingPath.get("attributes")), _step2; !(_step2 = _iterator2()).done;) {
	        var attr = _step2.value;

	        if (attr.isJSXAttribute() && isJSXIdentifier$3(attr.node.name)) {
	          var _name = attr.node.name.name;

	          switch (_name) {
	            case "__source":
	            case "__self":
	              if (extracted[_name]) throw sourceSelfError(path, _name);

	            case "key":
	              {
	                var keyValue = convertAttributeValue(attr.node.value);

	                if (keyValue === null) {
	                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
	                }

	                extracted[_name] = keyValue;
	                break;
	              }

	            default:
	              attribsArray.push(attr);
	          }
	        } else {
	          attribsArray.push(attr);
	        }
	      }

	      var children = react$3.buildChildren(path.node);
	      var attribs;

	      if (attribsArray.length || children.length) {
	        attribs = buildJSXOpeningElementAttributes(attribsArray, children);
	      } else {
	        attribs = objectExpression$4([]);
	      }

	      args.push(attribs);

	      if (development) {
	        var _extracted$key, _extracted$__source, _extracted$__self;

	        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), booleanLiteral$5(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());
	      } else if (extracted.key !== undefined) {
	        args.push(extracted.key);
	      }

	      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
	    }

	    function buildJSXOpeningElementAttributes(attribs, children) {
	      var props = attribs.reduce(accumulateAttribute, []);

	      if ((children == null ? void 0 : children.length) > 0) {
	        props.push(buildChildrenProperty(children));
	      }

	      return objectExpression$4(props);
	    }

	    function buildJSXFragmentCall(path, file) {
	      var args = [get(file, "id/fragment")()];
	      var children = react$3.buildChildren(path.node);
	      args.push(objectExpression$4(children.length > 0 ? [buildChildrenProperty(children)] : []));

	      if (development) {
	        args.push(path.scope.buildUndefinedNode(), booleanLiteral$5(children.length > 1));
	      }

	      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
	    }

	    function buildCreateElementFragmentCall(path, file) {
	      if (filter && !filter(path.node, file)) return;
	      return call(file, "createElement", [get(file, "id/fragment")(), nullLiteral$2()].concat(_toConsumableArray(react$3.buildChildren(path.node))));
	    }

	    function buildCreateElementCall(path, file) {
	      var openingPath = path.get("openingElement");
	      return call(file, "createElement", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes"))].concat(_toConsumableArray(react$3.buildChildren(path.node))));
	    }

	    function getTag(openingPath) {
	      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
	      var tagName;

	      if (isIdentifier$g(tagExpr)) {
	        tagName = tagExpr.name;
	      } else if (isLiteral$7(tagExpr)) {
	        tagName = tagExpr.value;
	      }

	      if (react$3.isCompatTag(tagName)) {
	        return stringLiteral$8(tagName);
	      } else {
	        return tagExpr;
	      }
	    }

	    function buildCreateElementOpeningElementAttributes(file, path, attribs) {
	      var runtime = get(file, "runtime");
	      {
	        if (runtime !== "automatic") {
	          var objs = [];

	          var _props = attribs.reduce(accumulateAttribute, []);

	          if (!useSpread) {
	            var start = 0;

	            _props.forEach(function (prop, i) {
	              if (isSpreadElement$1(prop)) {
	                if (i > start) {
	                  objs.push(objectExpression$4(_props.slice(start, i)));
	                }

	                objs.push(prop.argument);
	                start = i + 1;
	              }
	            });

	            if (_props.length > start) {
	              objs.push(objectExpression$4(_props.slice(start)));
	            }
	          } else if (_props.length) {
	            objs.push(objectExpression$4(_props));
	          }

	          if (!objs.length) {
	            return nullLiteral$2();
	          }

	          if (objs.length === 1) {
	            return objs[0];
	          }

	          if (!isObjectExpression$3(objs[0])) {
	            objs.unshift(objectExpression$4([]));
	          }

	          var helper = useBuiltIns ? memberExpression$b(identifier$j("Object"), identifier$j("assign")) : file.addHelper("extends");
	          return callExpression$e(helper, objs);
	        }
	      }
	      var props = [];
	      var found = Object.create(null);

	      for (var _iterator3 = _createForOfIteratorHelperLoose(attribs), _step3; !(_step3 = _iterator3()).done;) {
	        var attr = _step3.value;

	        var _name2 = isJSXAttribute(attr) && isJSXIdentifier$3(attr.name) && attr.name.name;

	        if (runtime === "automatic" && (_name2 === "__source" || _name2 === "__self")) {
	          if (found[_name2]) throw sourceSelfError(path, _name2);
	          found[_name2] = true;
	        }

	        accumulateAttribute(props, attr);
	      }

	      return props.length === 1 && isSpreadElement$1(props[0]) ? props[0].argument : props.length > 0 ? objectExpression$4(props) : nullLiteral$2();
	    }
	  });

	  function getSource(source, importName) {
	    switch (importName) {
	      case "Fragment":
	        return source + "/" + (development ? "jsx-dev-runtime" : "jsx-runtime");

	      case "jsxDEV":
	        return source + "/jsx-dev-runtime";

	      case "jsx":
	      case "jsxs":
	        return source + "/jsx-runtime";

	      case "createElement":
	        return source;
	    }
	  }

	  function createImportLazily(pass, path, importName, source) {
	    return function () {
	      var actualSource = getSource(source, importName);

	      if (isModule(path)) {
	        var reference = get(pass, "imports/" + importName);
	        if (reference) return cloneNode$i(reference);
	        reference = addNamed(path, importName, actualSource, {
	          importedInterop: "uncompiled",
	          importPosition: "after"
	        });
	        set(pass, "imports/" + importName, reference);
	        return reference;
	      } else {
	        var _reference = get(pass, "requires/" + actualSource);

	        if (_reference) {
	          _reference = cloneNode$i(_reference);
	        } else {
	          _reference = addNamespace(path, actualSource, {
	            importedInterop: "uncompiled"
	          });
	          set(pass, "requires/" + actualSource, _reference);
	        }

	        return memberExpression$b(_reference, identifier$j(importName));
	      }
	    };
	  }
	}

	function toMemberExpression(id) {
	  return id.split(".").map(function (name) {
	    return identifier$j(name);
	  }).reduce(function (object, property) {
	    return memberExpression$b(object, property);
	  });
	}

	function makeSource(path, state) {
	  var location = path.node.loc;

	  if (!location) {
	    return path.scope.buildUndefinedNode();
	  }

	  if (!state.fileNameIdentifier) {
	    var _state$filename = state.filename,
	        filename = _state$filename === void 0 ? "" : _state$filename;
	    var fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
	    var scope = path.hub.getScope();

	    if (scope) {
	      scope.push({
	        id: fileNameIdentifier,
	        init: stringLiteral$8(filename)
	      });
	    }

	    state.fileNameIdentifier = fileNameIdentifier;
	  }

	  return makeTrace(cloneNode$i(state.fileNameIdentifier), location.start.line, location.start.column);
	}

	function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
	  var fileLineLiteral = lineNumber != null ? numericLiteral$8(lineNumber) : nullLiteral$2();
	  var fileColumnLiteral = column0Based != null ? numericLiteral$8(column0Based + 1) : nullLiteral$2();
	  var fileNameProperty = objectProperty$2(identifier$j("fileName"), fileNameIdentifier);
	  var lineNumberProperty = objectProperty$2(identifier$j("lineNumber"), fileLineLiteral);
	  var columnNumberProperty = objectProperty$2(identifier$j("columnNumber"), fileColumnLiteral);
	  return objectExpression$4([fileNameProperty, lineNumberProperty, columnNumberProperty]);
	}

	function sourceSelfError(path, name) {
	  var pluginName = "transform-react-jsx-" + name.slice(2);
	  return path.buildCodeFrameError("Duplicate " + name + " prop found. You are most likely using the deprecated " + pluginName + " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.");
	}

	var transformReactJSX = createPlugin({
	  name: "transform-react-jsx",
	  development: false
	});

	var transformReactJsxCompat = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-react-jsx-compat",
	    manipulateOptions: function manipulateOptions(opts, parserOpts) {
	      parserOpts.plugins.push("jsx");
	    },
	    visitor: helper({
	      pre: function pre(state) {
	        state.callee = state.tagExpr;
	      },
	      post: function post(state) {
	        if (react$3.isCompatTag(state.tagName)) {
	          state.call = callExpression$e(memberExpression$b(memberExpression$b(identifier$j("React"), identifier$j("DOM")), state.tagExpr, isLiteral$7(state.tagExpr)), state.args);
	        }
	      },
	      compat: true
	    })
	  };
	});

	var transformReactJSXDevelopment = createPlugin({
	  name: "transform-react-jsx/development",
	  development: true
	});

	var TRACE_ID$1 = "__self";

	function getThisFunctionParent(path) {
	  var scope = path.scope;

	  do {
	    if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {
	      return scope.path;
	    }
	  } while (scope = scope.parent);

	  return null;
	}

	function isDerivedClass(classPath) {
	  return classPath.node.superClass !== null;
	}

	function isThisAllowed(path) {
	  var parentMethodOrFunction = getThisFunctionParent(path);

	  if (parentMethodOrFunction === null) {
	    return true;
	  }

	  if (!parentMethodOrFunction.isMethod()) {
	    return true;
	  }

	  if (parentMethodOrFunction.node.kind !== "constructor") {
	    return true;
	  }

	  return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);
	}

	var transformReactJsxSelf = declare(function (api) {
	  api.assertVersion(7);
	  var visitor = {
	    JSXOpeningElement: function JSXOpeningElement(path) {
	      if (!isThisAllowed(path)) {
	        return;
	      }

	      var node = path.node;
	      var id = jsxIdentifier$2(TRACE_ID$1);
	      var trace = thisExpression$3();
	      node.attributes.push(jsxAttribute(id, jsxExpressionContainer$1(trace)));
	    }
	  };
	  return {
	    name: "transform-react-jsx-self",
	    visitor: {
	      Program: function Program(path) {
	        path.traverse(visitor);
	      }
	    }
	  };
	});

	var TRACE_ID = "__source";
	var FILE_NAME_VAR = "_jsxFileName";
	var transformReactJsxSource = declare(function (api) {
	  api.assertVersion(7);

	  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
	    var fileLineLiteral = lineNumber != null ? numericLiteral$8(lineNumber) : nullLiteral$2();
	    var fileColumnLiteral = column0Based != null ? numericLiteral$8(column0Based + 1) : nullLiteral$2();
	    var fileNameProperty = objectProperty$2(identifier$j("fileName"), fileNameIdentifier);
	    var lineNumberProperty = objectProperty$2(identifier$j("lineNumber"), fileLineLiteral);
	    var columnNumberProperty = objectProperty$2(identifier$j("columnNumber"), fileColumnLiteral);
	    return objectExpression$4([fileNameProperty, lineNumberProperty, columnNumberProperty]);
	  }

	  var visitor = {
	    JSXOpeningElement: function JSXOpeningElement(path, state) {
	      var id = jsxIdentifier$2(TRACE_ID);
	      var location = path.container.openingElement.loc;

	      if (!location) {
	        return;
	      }

	      var attributes = path.container.openingElement.attributes;

	      for (var i = 0; i < attributes.length; i++) {
	        var name = attributes[i].name;

	        if ((name == null ? void 0 : name.name) === TRACE_ID) {
	          return;
	        }
	      }

	      if (!state.fileNameIdentifier) {
	        var fileName = state.filename || "";
	        var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
	        var scope = path.hub.getScope();

	        if (scope) {
	          scope.push({
	            id: fileNameIdentifier,
	            init: stringLiteral$8(fileName)
	          });
	        }

	        state.fileNameIdentifier = fileNameIdentifier;
	      }

	      var trace = makeTrace(cloneNode$i(state.fileNameIdentifier), location.start.line, location.start.column);
	      attributes.push(jsxAttribute(id, jsxExpressionContainer$1(trace)));
	    }
	  };
	  return {
	    name: "transform-react-jsx-source",
	    visitor: visitor
	  };
	});

	var _typeof_1 = createCommonjsModule(function (module) {
	  function _typeof(obj) {
	    "@babel/helpers - typeof";

	    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	      module.exports = _typeof = function _typeof(obj) {
	        return typeof obj;
	      };

	      module.exports["default"] = module.exports, module.exports.__esModule = true;
	    } else {
	      module.exports = _typeof = function _typeof(obj) {
	        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	      };

	      module.exports["default"] = module.exports, module.exports.__esModule = true;
	    }

	    return _typeof(obj);
	  }

	  module.exports = _typeof;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	}, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

	var interopRequireWildcard = createCommonjsModule(function (module) {
	  var _typeof = _typeof_1["default"];

	  function _getRequireWildcardCache(nodeInterop) {
	    if (typeof WeakMap !== "function") return null;
	    var cacheBabelInterop = new WeakMap();
	    var cacheNodeInterop = new WeakMap();
	    return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
	      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
	    })(nodeInterop);
	  }

	  function _interopRequireWildcard(obj, nodeInterop) {
	    if (!nodeInterop && obj && obj.__esModule) {
	      return obj;
	    }

	    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
	      return {
	        "default": obj
	      };
	    }

	    var cache = _getRequireWildcardCache(nodeInterop);

	    if (cache && cache.has(obj)) {
	      return cache.get(obj);
	    }

	    var newObj = {};
	    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

	    for (var key in obj) {
	      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
	        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

	        if (desc && (desc.get || desc.set)) {
	          Object.defineProperty(newObj, key, desc);
	        } else {
	          newObj[key] = obj[key];
	        }
	      }
	    }

	    newObj["default"] = obj;

	    if (cache) {
	      cache.set(obj, newObj);
	    }

	    return newObj;
	  }

	  module.exports = _interopRequireWildcard;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	}, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

	var interopRequireDefault = createCommonjsModule(function (module) {
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }

	  module.exports = _interopRequireDefault;
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	}, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

	var wrapWithTypes_1 = wrapWithTypes;
	var getTypes_1 = getTypes;
	var runtimeProperty_1 = runtimeProperty;
	var isReference_1 = isReference;
	var replaceWithOrRemove_1 = replaceWithOrRemove;
	var currentTypes = null;

	function wrapWithTypes(types, fn) {
	  return function () {
	    var oldTypes = currentTypes;
	    currentTypes = types;

	    try {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return fn.apply(this, args);
	    } finally {
	      currentTypes = oldTypes;
	    }
	  };
	}

	function getTypes() {
	  return currentTypes;
	}

	function runtimeProperty(name) {
	  var t = getTypes();
	  return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
	}

	function isReference(path) {
	  return path.isReferenced() || path.parentPath.isAssignmentExpression({
	    left: path.node
	  });
	}

	function replaceWithOrRemove(path, replacement) {
	  if (replacement) {
	    path.replaceWith(replacement);
	  } else {
	    path.remove();
	  }
	}

	var util$3 = Object.defineProperty({
	  wrapWithTypes: wrapWithTypes_1,
	  getTypes: getTypes_1,
	  runtimeProperty: runtimeProperty_1,
	  isReference: isReference_1,
	  replaceWithOrRemove: replaceWithOrRemove_1
	}, '__esModule', {
	  value: true
	});

	var util$2 = interopRequireWildcard(util$3);

	var hasOwn$3 = Object.prototype.hasOwnProperty;

	var hoist_1 = function hoist_1(funPath) {
	  var t = util$2.getTypes();
	  t.assertFunction(funPath.node);
	  var vars = {};

	  function varDeclToExpr(_ref, includeIdentifiers) {
	    var vdec = _ref.node,
	        scope = _ref.scope;
	    t.assertVariableDeclaration(vdec);
	    var exprs = [];
	    vdec.declarations.forEach(function (dec) {
	      vars[dec.id.name] = t.identifier(dec.id.name);
	      scope.removeBinding(dec.id.name);

	      if (dec.init) {
	        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
	      } else if (includeIdentifiers) {
	        exprs.push(dec.id);
	      }
	    });
	    if (exprs.length === 0) return null;
	    if (exprs.length === 1) return exprs[0];
	    return t.sequenceExpression(exprs);
	  }

	  funPath.get("body").traverse({
	    VariableDeclaration: {
	      exit: function exit(path) {
	        var expr = varDeclToExpr(path, false);

	        if (expr === null) {
	          path.remove();
	        } else {
	          util$2.replaceWithOrRemove(path, t.expressionStatement(expr));
	        }

	        path.skip();
	      }
	    },
	    ForStatement: function ForStatement(path) {
	      var init = path.get("init");

	      if (init.isVariableDeclaration()) {
	        util$2.replaceWithOrRemove(init, varDeclToExpr(init, false));
	      }
	    },
	    ForXStatement: function ForXStatement(path) {
	      var left = path.get("left");

	      if (left.isVariableDeclaration()) {
	        util$2.replaceWithOrRemove(left, varDeclToExpr(left, true));
	      }
	    },
	    FunctionDeclaration: function FunctionDeclaration(path) {
	      var node = path.node;
	      vars[node.id.name] = node.id;
	      var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));

	      if (path.parentPath.isBlockStatement()) {
	        path.parentPath.unshiftContainer("body", assignment);
	        path.remove();
	      } else {
	        util$2.replaceWithOrRemove(path, assignment);
	      }

	      path.scope.removeBinding(node.id.name);
	      path.skip();
	    },
	    FunctionExpression: function FunctionExpression(path) {
	      path.skip();
	    },
	    ArrowFunctionExpression: function ArrowFunctionExpression(path) {
	      path.skip();
	    }
	  });
	  var paramNames = {};
	  funPath.get("params").forEach(function (paramPath) {
	    var param = paramPath.node;

	    if (t.isIdentifier(param)) {
	      paramNames[param.name] = param;
	    }
	  });
	  var declarations = [];
	  Object.keys(vars).forEach(function (name) {
	    if (!hasOwn$3.call(paramNames, name)) {
	      declarations.push(t.variableDeclarator(vars[name], null));
	    }
	  });

	  if (declarations.length === 0) {
	    return null;
	  }

	  return t.variableDeclaration("var", declarations);
	};

	var hoist$2 = {
	  hoist: hoist_1
	};

	var _assert$3 = interopRequireDefault(assert_1);

	function Entry() {
	  _assert$3["default"].ok(this instanceof Entry);
	}

	function FunctionEntry(returnLoc) {
	  Entry.call(this);
	  (0, util$3.getTypes)().assertLiteral(returnLoc);
	  this.returnLoc = returnLoc;
	}

	(0, util$4.inherits)(FunctionEntry, Entry);
	var FunctionEntry_1 = FunctionEntry;

	function LoopEntry(breakLoc, continueLoc, label) {
	  Entry.call(this);
	  var t = (0, util$3.getTypes)();
	  t.assertLiteral(breakLoc);
	  t.assertLiteral(continueLoc);

	  if (label) {
	    t.assertIdentifier(label);
	  } else {
	    label = null;
	  }

	  this.breakLoc = breakLoc;
	  this.continueLoc = continueLoc;
	  this.label = label;
	}

	(0, util$4.inherits)(LoopEntry, Entry);
	var LoopEntry_1 = LoopEntry;

	function SwitchEntry(breakLoc) {
	  Entry.call(this);
	  (0, util$3.getTypes)().assertLiteral(breakLoc);
	  this.breakLoc = breakLoc;
	}

	(0, util$4.inherits)(SwitchEntry, Entry);
	var SwitchEntry_1 = SwitchEntry;

	function TryEntry(firstLoc, catchEntry, finallyEntry) {
	  Entry.call(this);
	  var t = (0, util$3.getTypes)();
	  t.assertLiteral(firstLoc);

	  if (catchEntry) {
	    _assert$3["default"].ok(catchEntry instanceof CatchEntry);
	  } else {
	    catchEntry = null;
	  }

	  if (finallyEntry) {
	    _assert$3["default"].ok(finallyEntry instanceof FinallyEntry);
	  } else {
	    finallyEntry = null;
	  }

	  _assert$3["default"].ok(catchEntry || finallyEntry);

	  this.firstLoc = firstLoc;
	  this.catchEntry = catchEntry;
	  this.finallyEntry = finallyEntry;
	}

	(0, util$4.inherits)(TryEntry, Entry);
	var TryEntry_1 = TryEntry;

	function CatchEntry(firstLoc, paramId) {
	  Entry.call(this);
	  var t = (0, util$3.getTypes)();
	  t.assertLiteral(firstLoc);
	  t.assertIdentifier(paramId);
	  this.firstLoc = firstLoc;
	  this.paramId = paramId;
	}

	(0, util$4.inherits)(CatchEntry, Entry);
	var CatchEntry_1 = CatchEntry;

	function FinallyEntry(firstLoc, afterLoc) {
	  Entry.call(this);
	  var t = (0, util$3.getTypes)();
	  t.assertLiteral(firstLoc);
	  t.assertLiteral(afterLoc);
	  this.firstLoc = firstLoc;
	  this.afterLoc = afterLoc;
	}

	(0, util$4.inherits)(FinallyEntry, Entry);
	var FinallyEntry_1 = FinallyEntry;

	function LabeledEntry(breakLoc, label) {
	  Entry.call(this);
	  var t = (0, util$3.getTypes)();
	  t.assertLiteral(breakLoc);
	  t.assertIdentifier(label);
	  this.breakLoc = breakLoc;
	  this.label = label;
	}

	(0, util$4.inherits)(LabeledEntry, Entry);
	var LabeledEntry_1 = LabeledEntry;

	function LeapManager(emitter) {
	  _assert$3["default"].ok(this instanceof LeapManager);

	  _assert$3["default"].ok(emitter instanceof emit.Emitter);

	  this.emitter = emitter;
	  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
	}

	var LMp = LeapManager.prototype;
	var LeapManager_1 = LeapManager;

	LMp.withEntry = function (entry, callback) {
	  _assert$3["default"].ok(entry instanceof Entry);

	  this.entryStack.push(entry);

	  try {
	    callback.call(this.emitter);
	  } finally {
	    var popped = this.entryStack.pop();

	    _assert$3["default"].strictEqual(popped, entry);
	  }
	};

	LMp._findLeapLocation = function (property, label) {
	  for (var i = this.entryStack.length - 1; i >= 0; --i) {
	    var entry = this.entryStack[i];
	    var loc = entry[property];

	    if (loc) {
	      if (label) {
	        if (entry.label && entry.label.name === label.name) {
	          return loc;
	        }
	      } else if (entry instanceof LabeledEntry) ; else {
	        return loc;
	      }
	    }
	  }

	  return null;
	};

	LMp.getBreakLoc = function (label) {
	  return this._findLeapLocation("breakLoc", label);
	};

	LMp.getContinueLoc = function (label) {
	  return this._findLeapLocation("continueLoc", label);
	};

	var leap$1 = {
	  FunctionEntry: FunctionEntry_1,
	  LoopEntry: LoopEntry_1,
	  SwitchEntry: SwitchEntry_1,
	  TryEntry: TryEntry_1,
	  CatchEntry: CatchEntry_1,
	  FinallyEntry: FinallyEntry_1,
	  LabeledEntry: LabeledEntry_1,
	  LeapManager: LeapManager_1
	};

	var originalObject = Object;
	var originalDefProp = Object.defineProperty;
	var originalCreate = Object.create;

	function defProp(obj, name, value) {
	  if (originalDefProp) try {
	    originalDefProp.call(originalObject, obj, name, {
	      value: value
	    });
	  } catch (definePropertyIsBrokenInIE8) {
	    obj[name] = value;
	  } else {
	    obj[name] = value;
	  }
	}

	function makeSafeToCall(fun) {
	  if (fun) {
	    defProp(fun, "call", fun.call);
	    defProp(fun, "apply", fun.apply);
	  }

	  return fun;
	}

	makeSafeToCall(originalDefProp);
	makeSafeToCall(originalCreate);
	var hasOwn$2 = makeSafeToCall(Object.prototype.hasOwnProperty);
	var numToStr = makeSafeToCall(Number.prototype.toString);
	var strSlice = makeSafeToCall(String.prototype.slice);

	var cloner = function cloner() {};

	function create(prototype) {
	  if (originalCreate) {
	    return originalCreate.call(originalObject, prototype);
	  }

	  cloner.prototype = prototype || null;
	  return new cloner();
	}

	var rand = Math.random;
	var uniqueKeys = create(null);

	function makeUniqueKey() {
	  do {
	    var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
	  } while (hasOwn$2.call(uniqueKeys, uniqueKey));

	  return uniqueKeys[uniqueKey] = uniqueKey;
	}

	function internString(str) {
	  var obj = {};
	  obj[str] = true;
	  return Object.keys(obj)[0];
	}

	var makeUniqueKey_1 = makeUniqueKey;
	var originalGetOPNs = Object.getOwnPropertyNames;

	Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	  for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
	    if (!hasOwn$2.call(uniqueKeys, names[src])) {
	      if (src > dst) {
	        names[dst] = names[src];
	      }

	      ++dst;
	    }
	  }

	  names.length = dst;
	  return names;
	};

	function defaultCreatorFn(object) {
	  return create(null);
	}

	function makeAccessor(secretCreatorFn) {
	  var brand = makeUniqueKey();
	  var passkey = create(null);
	  secretCreatorFn = secretCreatorFn || defaultCreatorFn;

	  function register(object) {
	    var secret;

	    function vault(key, forget) {
	      if (key === passkey) {
	        return forget ? secret = null : secret || (secret = secretCreatorFn(object));
	      }
	    }

	    defProp(object, brand, vault);
	  }

	  function accessor(object) {
	    if (!hasOwn$2.call(object, brand)) register(object);
	    return object[brand](passkey);
	  }

	  accessor.forget = function (object) {
	    if (hasOwn$2.call(object, brand)) object[brand](passkey, true);
	  };

	  return accessor;
	}

	var makeAccessor_1 = makeAccessor;
	var _private = {
	  makeUniqueKey: makeUniqueKey_1,
	  makeAccessor: makeAccessor_1
	};

	var _assert$2 = interopRequireDefault(assert_1);

	var m = (0, _private.makeAccessor)();
	var hasOwn$1 = Object.prototype.hasOwnProperty;

	function makePredicate(propertyName, knownTypes) {
	  function onlyChildren(node) {
	    var t = (0, util$3.getTypes)();
	    t.assertNode(node);
	    var result = false;

	    function check(child) {
	      if (result) ; else if (Array.isArray(child)) {
	        child.some(check);
	      } else if (t.isNode(child)) {
	        _assert$2["default"].strictEqual(result, false);

	        result = predicate(child);
	      }

	      return result;
	    }

	    var keys = t.VISITOR_KEYS[node.type];

	    if (keys) {
	      for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var child = node[key];
	        check(child);
	      }
	    }

	    return result;
	  }

	  function predicate(node) {
	    (0, util$3.getTypes)().assertNode(node);
	    var meta = m(node);
	    if (hasOwn$1.call(meta, propertyName)) return meta[propertyName];
	    if (hasOwn$1.call(opaqueTypes, node.type)) return meta[propertyName] = false;
	    if (hasOwn$1.call(knownTypes, node.type)) return meta[propertyName] = true;
	    return meta[propertyName] = onlyChildren(node);
	  }

	  predicate.onlyChildren = onlyChildren;
	  return predicate;
	}

	var opaqueTypes = {
	  FunctionExpression: true,
	  ArrowFunctionExpression: true
	};
	var sideEffectTypes = {
	  CallExpression: true,
	  ForInStatement: true,
	  UnaryExpression: true,
	  BinaryExpression: true,
	  AssignmentExpression: true,
	  UpdateExpression: true,
	  NewExpression: true
	};
	var leapTypes = {
	  YieldExpression: true,
	  BreakStatement: true,
	  ContinueStatement: true,
	  ReturnStatement: true,
	  ThrowStatement: true
	};

	for (var type in leapTypes) {
	  if (hasOwn$1.call(leapTypes, type)) {
	    sideEffectTypes[type] = leapTypes[type];
	  }
	}

	var hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
	var containsLeap = makePredicate("containsLeap", leapTypes);
	var meta$1 = {
	  hasSideEffects: hasSideEffects,
	  containsLeap: containsLeap
	};

	var _assert$1 = interopRequireDefault(assert_1);

	var leap = interopRequireWildcard(leap$1);

	var meta = interopRequireWildcard(meta$1);

	var util$1 = interopRequireWildcard(util$3);

	var hasOwn = Object.prototype.hasOwnProperty;

	function Emitter(contextId) {
	  _assert$1["default"].ok(this instanceof Emitter);

	  util$1.getTypes().assertIdentifier(contextId);
	  this.nextTempId = 0;
	  this.contextId = contextId;
	  this.listing = [];
	  this.marked = [true];
	  this.insertedLocs = new Set();
	  this.finalLoc = this.loc();
	  this.tryEntries = [];
	  this.leapManager = new leap.LeapManager(this);
	}

	var Ep = Emitter.prototype;
	var Emitter_1 = Emitter;

	Ep.loc = function () {
	  var l = util$1.getTypes().numericLiteral(-1);
	  this.insertedLocs.add(l);
	  return l;
	};

	Ep.getInsertedLocs = function () {
	  return this.insertedLocs;
	};

	Ep.getContextId = function () {
	  return util$1.getTypes().clone(this.contextId);
	};

	Ep.mark = function (loc) {
	  util$1.getTypes().assertLiteral(loc);
	  var index = this.listing.length;

	  if (loc.value === -1) {
	    loc.value = index;
	  } else {
	    _assert$1["default"].strictEqual(loc.value, index);
	  }

	  this.marked[index] = true;
	  return loc;
	};

	Ep.emit = function (node) {
	  var t = util$1.getTypes();

	  if (t.isExpression(node)) {
	    node = t.expressionStatement(node);
	  }

	  t.assertStatement(node);
	  this.listing.push(node);
	};

	Ep.emitAssign = function (lhs, rhs) {
	  this.emit(this.assign(lhs, rhs));
	  return lhs;
	};

	Ep.assign = function (lhs, rhs) {
	  var t = util$1.getTypes();
	  return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
	};

	Ep.contextProperty = function (name, computed) {
	  var t = util$1.getTypes();
	  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
	};

	Ep.stop = function (rval) {
	  if (rval) {
	    this.setReturnValue(rval);
	  }

	  this.jump(this.finalLoc);
	};

	Ep.setReturnValue = function (valuePath) {
	  util$1.getTypes().assertExpression(valuePath.value);
	  this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
	};

	Ep.clearPendingException = function (tryLoc, assignee) {
	  var t = util$1.getTypes();
	  t.assertLiteral(tryLoc);
	  var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);

	  if (assignee) {
	    this.emitAssign(assignee, catchCall);
	  } else {
	    this.emit(catchCall);
	  }
	};

	Ep.jump = function (toLoc) {
	  this.emitAssign(this.contextProperty("next"), toLoc);
	  this.emit(util$1.getTypes().breakStatement());
	};

	Ep.jumpIf = function (test, toLoc) {
	  var t = util$1.getTypes();
	  t.assertExpression(test);
	  t.assertLiteral(toLoc);
	  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
	};

	Ep.jumpIfNot = function (test, toLoc) {
	  var t = util$1.getTypes();
	  t.assertExpression(test);
	  t.assertLiteral(toLoc);
	  var negatedTest;

	  if (t.isUnaryExpression(test) && test.operator === "!") {
	    negatedTest = test.argument;
	  } else {
	    negatedTest = t.unaryExpression("!", test);
	  }

	  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
	};

	Ep.makeTempVar = function () {
	  return this.contextProperty("t" + this.nextTempId++);
	};

	Ep.getContextFunction = function (id) {
	  var t = util$1.getTypes();
	  return t.functionExpression(id || null, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, false);
	};

	Ep.getDispatchLoop = function () {
	  var self = this;
	  var t = util$1.getTypes();
	  var cases = [];
	  var current;
	  var alreadyEnded = false;
	  self.listing.forEach(function (stmt, i) {
	    if (self.marked.hasOwnProperty(i)) {
	      cases.push(t.switchCase(t.numericLiteral(i), current = []));
	      alreadyEnded = false;
	    }

	    if (!alreadyEnded) {
	      current.push(stmt);
	      if (t.isCompletionStatement(stmt)) alreadyEnded = true;
	    }
	  });
	  this.finalLoc.value = this.listing.length;
	  cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
	  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
	};

	Ep.getTryLocsList = function () {
	  if (this.tryEntries.length === 0) {
	    return null;
	  }

	  var t = util$1.getTypes();
	  var lastLocValue = 0;
	  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
	    var thisLocValue = tryEntry.firstLoc.value;

	    _assert$1["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");

	    lastLocValue = thisLocValue;
	    var ce = tryEntry.catchEntry;
	    var fe = tryEntry.finallyEntry;
	    var locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];

	    if (fe) {
	      locs[2] = fe.firstLoc;
	      locs[3] = fe.afterLoc;
	    }

	    return t.arrayExpression(locs.map(function (loc) {
	      return loc && t.clone(loc);
	    }));
	  }));
	};

	Ep.explode = function (path, ignoreResult) {
	  var t = util$1.getTypes();
	  var node = path.node;
	  var self = this;
	  t.assertNode(node);
	  if (t.isDeclaration(node)) throw getDeclError(node);
	  if (t.isStatement(node)) return self.explodeStatement(path);
	  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);

	  switch (node.type) {
	    case "Program":
	      return path.get("body").map(self.explodeStatement, self);

	    case "VariableDeclarator":
	      throw getDeclError(node);

	    case "Property":
	    case "SwitchCase":
	    case "CatchClause":
	      throw new Error(node.type + " nodes should be handled by their parents");

	    default:
	      throw new Error("unknown Node of type " + JSON.stringify(node.type));
	  }
	};

	function getDeclError(node) {
	  return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
	}

	Ep.explodeStatement = function (path, labelId) {
	  var t = util$1.getTypes();
	  var stmt = path.node;
	  var self = this;
	  var before, after, head;
	  t.assertStatement(stmt);

	  if (labelId) {
	    t.assertIdentifier(labelId);
	  } else {
	    labelId = null;
	  }

	  if (t.isBlockStatement(stmt)) {
	    path.get("body").forEach(function (path) {
	      self.explodeStatement(path);
	    });
	    return;
	  }

	  if (!meta.containsLeap(stmt)) {
	    self.emit(stmt);
	    return;
	  }

	  switch (stmt.type) {
	    case "ExpressionStatement":
	      self.explodeExpression(path.get("expression"), true);
	      break;

	    case "LabeledStatement":
	      after = this.loc();
	      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {
	        self.explodeStatement(path.get("body"), stmt.label);
	      });
	      self.mark(after);
	      break;

	    case "WhileStatement":
	      before = this.loc();
	      after = this.loc();
	      self.mark(before);
	      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
	      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
	        self.explodeStatement(path.get("body"));
	      });
	      self.jump(before);
	      self.mark(after);
	      break;

	    case "DoWhileStatement":
	      var first = this.loc();
	      var test = this.loc();
	      after = this.loc();
	      self.mark(first);
	      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
	        self.explode(path.get("body"));
	      });
	      self.mark(test);
	      self.jumpIf(self.explodeExpression(path.get("test")), first);
	      self.mark(after);
	      break;

	    case "ForStatement":
	      head = this.loc();
	      var update = this.loc();
	      after = this.loc();

	      if (stmt.init) {
	        self.explode(path.get("init"), true);
	      }

	      self.mark(head);

	      if (stmt.test) {
	        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
	      }

	      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
	        self.explodeStatement(path.get("body"));
	      });
	      self.mark(update);

	      if (stmt.update) {
	        self.explode(path.get("update"), true);
	      }

	      self.jump(head);
	      self.mark(after);
	      break;

	    case "TypeCastExpression":
	      return self.explodeExpression(path.get("expression"));

	    case "ForInStatement":
	      head = this.loc();
	      after = this.loc();
	      var keyIterNextFn = self.makeTempVar();
	      self.emitAssign(keyIterNextFn, t.callExpression(util$1.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
	      self.mark(head);
	      var keyInfoTmpVar = self.makeTempVar();
	      self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
	      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
	      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
	        self.explodeStatement(path.get("body"));
	      });
	      self.jump(head);
	      self.mark(after);
	      break;

	    case "BreakStatement":
	      self.emitAbruptCompletion({
	        type: "break",
	        target: self.leapManager.getBreakLoc(stmt.label)
	      });
	      break;

	    case "ContinueStatement":
	      self.emitAbruptCompletion({
	        type: "continue",
	        target: self.leapManager.getContinueLoc(stmt.label)
	      });
	      break;

	    case "SwitchStatement":
	      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
	      after = this.loc();
	      var defaultLoc = this.loc();
	      var condition = defaultLoc;
	      var caseLocs = [];
	      var cases = stmt.cases || [];

	      for (var i = cases.length - 1; i >= 0; --i) {
	        var c = cases[i];
	        t.assertSwitchCase(c);

	        if (c.test) {
	          condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
	        } else {
	          caseLocs[i] = defaultLoc;
	        }
	      }

	      var discriminant = path.get("discriminant");
	      util$1.replaceWithOrRemove(discriminant, condition);
	      self.jump(self.explodeExpression(discriminant));
	      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
	        path.get("cases").forEach(function (casePath) {
	          var i = casePath.key;
	          self.mark(caseLocs[i]);
	          casePath.get("consequent").forEach(function (path) {
	            self.explodeStatement(path);
	          });
	        });
	      });
	      self.mark(after);

	      if (defaultLoc.value === -1) {
	        self.mark(defaultLoc);

	        _assert$1["default"].strictEqual(after.value, defaultLoc.value);
	      }

	      break;

	    case "IfStatement":
	      var elseLoc = stmt.alternate && this.loc();
	      after = this.loc();
	      self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
	      self.explodeStatement(path.get("consequent"));

	      if (elseLoc) {
	        self.jump(after);
	        self.mark(elseLoc);
	        self.explodeStatement(path.get("alternate"));
	      }

	      self.mark(after);
	      break;

	    case "ReturnStatement":
	      self.emitAbruptCompletion({
	        type: "return",
	        value: self.explodeExpression(path.get("argument"))
	      });
	      break;

	    case "WithStatement":
	      throw new Error("WithStatement not supported in generator functions.");

	    case "TryStatement":
	      after = this.loc();
	      var handler = stmt.handler;
	      var catchLoc = handler && this.loc();
	      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
	      var finallyLoc = stmt.finalizer && this.loc();
	      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
	      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
	      self.tryEntries.push(tryEntry);
	      self.updateContextPrevLoc(tryEntry.firstLoc);
	      self.leapManager.withEntry(tryEntry, function () {
	        self.explodeStatement(path.get("block"));

	        if (catchLoc) {
	          if (finallyLoc) {
	            self.jump(finallyLoc);
	          } else {
	            self.jump(after);
	          }

	          self.updateContextPrevLoc(self.mark(catchLoc));
	          var bodyPath = path.get("handler.body");
	          var safeParam = self.makeTempVar();
	          self.clearPendingException(tryEntry.firstLoc, safeParam);
	          bodyPath.traverse(catchParamVisitor, {
	            getSafeParam: function getSafeParam() {
	              return t.cloneDeep(safeParam);
	            },
	            catchParamName: handler.param.name
	          });
	          self.leapManager.withEntry(catchEntry, function () {
	            self.explodeStatement(bodyPath);
	          });
	        }

	        if (finallyLoc) {
	          self.updateContextPrevLoc(self.mark(finallyLoc));
	          self.leapManager.withEntry(finallyEntry, function () {
	            self.explodeStatement(path.get("finalizer"));
	          });
	          self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
	        }
	      });
	      self.mark(after);
	      break;

	    case "ThrowStatement":
	      self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
	      break;

	    default:
	      throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
	  }
	};

	var catchParamVisitor = {
	  Identifier: function Identifier(path, state) {
	    if (path.node.name === state.catchParamName && util$1.isReference(path)) {
	      util$1.replaceWithOrRemove(path, state.getSafeParam());
	    }
	  },
	  Scope: function Scope(path, state) {
	    if (path.scope.hasOwnBinding(state.catchParamName)) {
	      path.skip();
	    }
	  }
	};

	Ep.emitAbruptCompletion = function (record) {
	  if (!isValidCompletion(record)) {
	    _assert$1["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
	  }

	  _assert$1["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");

	  var t = util$1.getTypes();
	  var abruptArgs = [t.stringLiteral(record.type)];

	  if (record.type === "break" || record.type === "continue") {
	    t.assertLiteral(record.target);
	    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
	  } else if (record.type === "return" || record.type === "throw") {
	    if (record.value) {
	      t.assertExpression(record.value);
	      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
	    }
	  }

	  this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
	};

	function isValidCompletion(record) {
	  var type = record.type;

	  if (type === "normal") {
	    return !hasOwn.call(record, "target");
	  }

	  if (type === "break" || type === "continue") {
	    return !hasOwn.call(record, "value") && util$1.getTypes().isLiteral(record.target);
	  }

	  if (type === "return" || type === "throw") {
	    return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
	  }

	  return false;
	}

	Ep.getUnmarkedCurrentLoc = function () {
	  return util$1.getTypes().numericLiteral(this.listing.length);
	};

	Ep.updateContextPrevLoc = function (loc) {
	  var t = util$1.getTypes();

	  if (loc) {
	    t.assertLiteral(loc);

	    if (loc.value === -1) {
	      loc.value = this.listing.length;
	    } else {
	      _assert$1["default"].strictEqual(loc.value, this.listing.length);
	    }
	  } else {
	    loc = this.getUnmarkedCurrentLoc();
	  }

	  this.emitAssign(this.contextProperty("prev"), loc);
	};

	Ep.explodeExpression = function (path, ignoreResult) {
	  var t = util$1.getTypes();
	  var expr = path.node;

	  if (expr) {
	    t.assertExpression(expr);
	  } else {
	    return expr;
	  }

	  var self = this;
	  var result;
	  var after;

	  function finish(expr) {
	    t.assertExpression(expr);

	    if (ignoreResult) {
	      self.emit(expr);
	    } else {
	      return expr;
	    }
	  }

	  if (!meta.containsLeap(expr)) {
	    return finish(expr);
	  }

	  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);

	  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
	    _assert$1["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");

	    var result = self.explodeExpression(childPath, ignoreChildResult);

	    if (ignoreChildResult) ; else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
	      result = self.emitAssign(tempVar || self.makeTempVar(), result);
	    }

	    return result;
	  }

	  switch (expr.type) {
	    case "MemberExpression":
	      return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

	    case "CallExpression":
	      var calleePath = path.get("callee");
	      var argsPath = path.get("arguments");
	      var newCallee;
	      var newArgs = [];
	      var hasLeapingArgs = false;
	      argsPath.forEach(function (argPath) {
	        hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.node);
	      });

	      if (t.isMemberExpression(calleePath.node)) {
	        if (hasLeapingArgs) {
	          var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object"));
	          var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
	          newArgs.unshift(newObject);
	          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
	        } else {
	          newCallee = self.explodeExpression(calleePath);
	        }
	      } else {
	        newCallee = explodeViaTempVar(null, calleePath);

	        if (t.isMemberExpression(newCallee)) {
	          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
	        }
	      }

	      argsPath.forEach(function (argPath) {
	        newArgs.push(explodeViaTempVar(null, argPath));
	      });
	      return finish(t.callExpression(newCallee, newArgs.map(function (arg) {
	        return t.cloneDeep(arg);
	      })));

	    case "NewExpression":
	      return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function (argPath) {
	        return explodeViaTempVar(null, argPath);
	      })));

	    case "ObjectExpression":
	      return finish(t.objectExpression(path.get("properties").map(function (propPath) {
	        if (propPath.isObjectProperty()) {
	          return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed);
	        } else {
	          return propPath.node;
	        }
	      })));

	    case "ArrayExpression":
	      return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
	        return explodeViaTempVar(null, elemPath);
	      })));

	    case "SequenceExpression":
	      var lastIndex = expr.expressions.length - 1;
	      path.get("expressions").forEach(function (exprPath) {
	        if (exprPath.key === lastIndex) {
	          result = self.explodeExpression(exprPath, ignoreResult);
	        } else {
	          self.explodeExpression(exprPath, true);
	        }
	      });
	      return result;

	    case "LogicalExpression":
	      after = this.loc();

	      if (!ignoreResult) {
	        result = self.makeTempVar();
	      }

	      var left = explodeViaTempVar(result, path.get("left"));

	      if (expr.operator === "&&") {
	        self.jumpIfNot(left, after);
	      } else {
	        _assert$1["default"].strictEqual(expr.operator, "||");

	        self.jumpIf(left, after);
	      }

	      explodeViaTempVar(result, path.get("right"), ignoreResult);
	      self.mark(after);
	      return result;

	    case "ConditionalExpression":
	      var elseLoc = this.loc();
	      after = this.loc();
	      var test = self.explodeExpression(path.get("test"));
	      self.jumpIfNot(test, elseLoc);

	      if (!ignoreResult) {
	        result = self.makeTempVar();
	      }

	      explodeViaTempVar(result, path.get("consequent"), ignoreResult);
	      self.jump(after);
	      self.mark(elseLoc);
	      explodeViaTempVar(result, path.get("alternate"), ignoreResult);
	      self.mark(after);
	      return result;

	    case "UnaryExpression":
	      return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

	    case "BinaryExpression":
	      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

	    case "AssignmentExpression":
	      if (expr.operator === "=") {
	        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
	      }

	      var lhs = self.explodeExpression(path.get("left"));
	      var temp = self.emitAssign(self.makeTempVar(), lhs);
	      return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

	    case "UpdateExpression":
	      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

	    case "YieldExpression":
	      after = this.loc();
	      var arg = expr.argument && self.explodeExpression(path.get("argument"));

	      if (arg && expr.delegate) {
	        var _result = self.makeTempVar();

	        var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));

	        _ret.loc = expr.loc;
	        self.emit(_ret);
	        self.mark(after);
	        return _result;
	      }

	      self.emitAssign(self.contextProperty("next"), after);
	      var ret = t.returnStatement(t.cloneDeep(arg) || null);
	      ret.loc = expr.loc;
	      self.emit(ret);
	      self.mark(after);
	      return self.contextProperty("sent");

	    default:
	      throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
	  }
	};

	var emit = {
	  Emitter: Emitter_1
	};

	var replaceShorthandObjectMethod_1 = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = replaceShorthandObjectMethod;

	  var util = interopRequireWildcard(util$3);

	  function replaceShorthandObjectMethod(path) {
	    var t = util.getTypes();

	    if (!path.node || !t.isFunction(path.node)) {
	      throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
	    }

	    if (!t.isObjectMethod(path.node)) {
	      return path;
	    }

	    if (!path.node.generator) {
	      return path;
	    }

	    var parameters = path.node.params.map(function (param) {
	      return t.cloneDeep(param);
	    });
	    var functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
	    util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
	    return path.get("value");
	  }
	}, "/$$rollup_base$$/node_modules/regenerator-transform/lib");

	var _assert = interopRequireDefault(assert_1);

	var _replaceShorthandObjectMethod = interopRequireDefault(replaceShorthandObjectMethod_1);

	var util = interopRequireWildcard(util$3);

	var getVisitor = function getVisitor(_ref) {
	  var t = _ref.types;
	  return {
	    Method: function Method(path, state) {
	      var node = path.node;
	      if (!shouldRegenerate(node, state)) return;
	      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
	      path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
	      node.async = false;
	      node.generator = false;
	      path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
	    },
	    Function: {
	      exit: util.wrapWithTypes(t, function (path, state) {
	        var node = path.node;
	        if (!shouldRegenerate(node, state)) return;
	        path = (0, _replaceShorthandObjectMethod["default"])(path);
	        node = path.node;
	        var contextId = path.scope.generateUidIdentifier("context");
	        var argsId = path.scope.generateUidIdentifier("args");
	        path.ensureBlock();
	        var bodyBlockPath = path.get("body");

	        if (node.async) {
	          bodyBlockPath.traverse(awaitVisitor);
	        }

	        bodyBlockPath.traverse(functionSentVisitor, {
	          context: contextId
	        });
	        var outerBody = [];
	        var innerBody = [];
	        bodyBlockPath.get("body").forEach(function (childPath) {
	          var node = childPath.node;

	          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
	            outerBody.push(node);
	          } else if (node && node._blockHoist != null) {
	            outerBody.push(node);
	          } else {
	            innerBody.push(node);
	          }
	        });

	        if (outerBody.length > 0) {
	          bodyBlockPath.node.body = innerBody;
	        }

	        var outerFnExpr = getOuterFnExpr(path);
	        t.assertIdentifier(node.id);
	        var innerFnId = t.identifier(node.id.name + "$");
	        var vars = (0, hoist$2.hoist)(path);
	        var context = {
	          usesThis: false,
	          usesArguments: false,
	          getArgsId: function getArgsId() {
	            return t.clone(argsId);
	          }
	        };
	        path.traverse(argumentsThisVisitor, context);

	        if (context.usesArguments) {
	          vars = vars || t.variableDeclaration("var", []);
	          var argumentIdentifier = t.identifier("arguments");
	          argumentIdentifier._shadowedFunctionLiteral = path;
	          vars.declarations.push(t.variableDeclarator(t.clone(argsId), argumentIdentifier));
	        }

	        var emitter = new emit.Emitter(contextId);
	        emitter.explode(path.get("body"));

	        if (vars && vars.declarations.length > 0) {
	          outerBody.push(vars);
	        }

	        var wrapArgs = [emitter.getContextFunction(innerFnId)];
	        var tryLocsList = emitter.getTryLocsList();

	        if (node.generator) {
	          wrapArgs.push(outerFnExpr);
	        } else if (context.usesThis || tryLocsList || node.async) {
	          wrapArgs.push(t.nullLiteral());
	        }

	        if (context.usesThis) {
	          wrapArgs.push(t.thisExpression());
	        } else if (tryLocsList || node.async) {
	          wrapArgs.push(t.nullLiteral());
	        }

	        if (tryLocsList) {
	          wrapArgs.push(tryLocsList);
	        } else if (node.async) {
	          wrapArgs.push(t.nullLiteral());
	        }

	        if (node.async) {
	          var currentScope = path.scope;

	          do {
	            if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
	          } while (currentScope = currentScope.parent);

	          wrapArgs.push(t.identifier("Promise"));
	        }

	        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
	        outerBody.push(t.returnStatement(wrapCall));
	        node.body = t.blockStatement(outerBody);
	        path.get("body.body").forEach(function (p) {
	          return p.scope.registerDeclaration(p);
	        });
	        var oldDirectives = bodyBlockPath.node.directives;

	        if (oldDirectives) {
	          node.body.directives = oldDirectives;
	        }

	        var wasGeneratorFunction = node.generator;

	        if (wasGeneratorFunction) {
	          node.generator = false;
	        }

	        if (node.async) {
	          node.async = false;
	        }

	        if (wasGeneratorFunction && t.isExpression(node)) {
	          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [node]));
	          path.addComment("leading", "#__PURE__");
	        }

	        var insertedLocs = emitter.getInsertedLocs();
	        path.traverse({
	          NumericLiteral: function NumericLiteral(path) {
	            if (!insertedLocs.has(path.node)) {
	              return;
	            }

	            path.replaceWith(t.numericLiteral(path.node.value));
	          }
	        });
	        path.requeue();
	      })
	    }
	  };
	};

	function shouldRegenerate(node, state) {
	  if (node.generator) {
	    if (node.async) {
	      return state.opts.asyncGenerators !== false;
	    } else {
	      return state.opts.generators !== false;
	    }
	  } else if (node.async) {
	    return state.opts.async !== false;
	  } else {
	    return false;
	  }
	}

	function getOuterFnExpr(funPath) {
	  var t = util.getTypes();
	  var node = funPath.node;
	  t.assertFunction(node);

	  if (!node.id) {
	    node.id = funPath.scope.parent.generateUidIdentifier("callee");
	  }

	  if (node.generator && t.isFunctionDeclaration(node)) {
	    return getMarkedFunctionId(funPath);
	  }

	  return t.clone(node.id);
	}

	var getMarkInfo = (0, _private.makeAccessor)();

	function getMarkedFunctionId(funPath) {
	  var t = util.getTypes();
	  var node = funPath.node;
	  t.assertIdentifier(node.id);
	  var blockPath = funPath.findParent(function (path) {
	    return path.isProgram() || path.isBlockStatement();
	  });

	  if (!blockPath) {
	    return node.id;
	  }

	  var block = blockPath.node;

	  _assert["default"].ok(Array.isArray(block.body));

	  var info = getMarkInfo(block);

	  if (!info.decl) {
	    info.decl = t.variableDeclaration("var", []);
	    blockPath.unshiftContainer("body", info.decl);
	    info.declPath = blockPath.get("body.0");
	  }

	  _assert["default"].strictEqual(info.declPath.node, info.decl);

	  var markedId = blockPath.scope.generateUidIdentifier("marked");
	  var markCallExp = t.callExpression(util.runtimeProperty("mark"), [t.clone(node.id)]);
	  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
	  var markCallExpPath = info.declPath.get("declarations." + index + ".init");

	  _assert["default"].strictEqual(markCallExpPath.node, markCallExp);

	  markCallExpPath.addComment("leading", "#__PURE__");
	  return t.clone(markedId);
	}

	var argumentsThisVisitor = {
	  "FunctionExpression|FunctionDeclaration|Method": function FunctionExpressionFunctionDeclarationMethod(path) {
	    path.skip();
	  },
	  Identifier: function Identifier(path, state) {
	    if (path.node.name === "arguments" && util.isReference(path)) {
	      util.replaceWithOrRemove(path, state.getArgsId());
	      state.usesArguments = true;
	    }
	  },
	  ThisExpression: function ThisExpression(path, state) {
	    state.usesThis = true;
	  }
	};
	var functionSentVisitor = {
	  MetaProperty: function MetaProperty(path) {
	    var node = path.node;

	    if (node.meta.name === "function" && node.property.name === "sent") {
	      var t = util.getTypes();
	      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
	    }
	  }
	};
	var awaitVisitor = {
	  Function: function Function(path) {
	    path.skip();
	  },
	  AwaitExpression: function AwaitExpression(path) {
	    var t = util.getTypes();
	    var argument = path.node.argument;
	    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty("awrap"), [argument]), false));
	  }
	};
	var visit = {
	  getVisitor: getVisitor
	};

	var lib$e = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = _default;

	  function _default(context) {
	    var plugin = {
	      visitor: (0, visit.getVisitor)(context)
	    };
	    var version = context && context.version;

	    if (version && parseInt(version, 10) >= 7) {
	      plugin.name = "regenerator-transform";
	    }

	    return plugin;
	  }
	}, "/$$rollup_base$$/node_modules/regenerator-transform/lib");

	var _transformRegenerator = lib$e["default"];

	var _transformReservedWords = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-reserved-words",
	    visitor: {
	      "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
	        if (!isValidES3Identifier(path.node.name)) {
	          path.scope.rename(path.node.name);
	        }
	      }
	    }
	  };
	});

	function hasMinVersion$2(minVersion, runtimeVersion) {
	  if (!runtimeVersion) return true;
	  if (semver$4.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
	  return !semver$4.intersects("<" + minVersion, runtimeVersion) && !semver$4.intersects(">=8.0.0", runtimeVersion);
	}

	function getRuntimePath (moduleName, dirname, absoluteRuntime) {
	  if (absoluteRuntime === false) return moduleName;
	  resolveFSPath();
	}
	function resolveFSPath() {
	  throw new Error("The 'absoluteRuntime' option is not supported when using @babel/standalone.");
	}

	var semver$3 = createCommonjsModule(function (module, exports) {
	  exports = module.exports = SemVer;
	  var debug;

	  if (typeof browser$4 === 'object' && browser$4.env && browser$4.env.NODE_DEBUG && /\bsemver\b/i.test(browser$4.env.NODE_DEBUG)) {
	    debug = function debug() {
	      var args = Array.prototype.slice.call(arguments, 0);
	      args.unshift('SEMVER');
	      console.log.apply(console, args);
	    };
	  } else {
	    debug = function debug() {};
	  }

	  exports.SEMVER_SPEC_VERSION = '2.0.0';
	  var MAX_LENGTH = 256;
	  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	  var MAX_SAFE_COMPONENT_LENGTH = 16;
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var t = exports.tokens = {};
	  var R = 0;

	  function tok(n) {
	    t[n] = R++;
	  }

	  tok('NUMERICIDENTIFIER');
	  src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	  tok('NUMERICIDENTIFIERLOOSE');
	  src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
	  tok('NONNUMERICIDENTIFIER');
	  src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
	  tok('MAINVERSION');
	  src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
	  tok('MAINVERSIONLOOSE');
	  src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
	  tok('PRERELEASEIDENTIFIER');
	  src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASEIDENTIFIERLOOSE');
	  src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASE');
	  src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
	  tok('PRERELEASELOOSE');
	  src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
	  tok('BUILDIDENTIFIER');
	  src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
	  tok('BUILD');
	  src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
	  tok('FULL');
	  tok('FULLPLAIN');
	  src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
	  src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
	  tok('LOOSEPLAIN');
	  src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
	  tok('LOOSE');
	  src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
	  tok('GTLT');
	  src[t.GTLT] = '((?:<|>)?=?)';
	  tok('XRANGEIDENTIFIERLOOSE');
	  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	  tok('XRANGEIDENTIFIER');
	  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
	  tok('XRANGEPLAIN');
	  src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGEPLAINLOOSE');
	  src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGE');
	  src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
	  tok('XRANGELOOSE');
	  src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COERCE');
	  src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
	  tok('COERCERTL');
	  re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
	  tok('LONETILDE');
	  src[t.LONETILDE] = '(?:~>?)';
	  tok('TILDETRIM');
	  src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
	  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
	  var tildeTrimReplace = '$1~';
	  tok('TILDE');
	  src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
	  tok('TILDELOOSE');
	  src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('LONECARET');
	  src[t.LONECARET] = '(?:\\^)';
	  tok('CARETTRIM');
	  src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
	  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
	  var caretTrimReplace = '$1^';
	  tok('CARET');
	  src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
	  tok('CARETLOOSE');
	  src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COMPARATORLOOSE');
	  src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
	  tok('COMPARATOR');
	  src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
	  tok('COMPARATORTRIM');
	  src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
	  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
	  var comparatorTrimReplace = '$1$2$3';
	  tok('HYPHENRANGE');
	  src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
	  tok('HYPHENRANGELOOSE');
	  src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
	  tok('STAR');
	  src[t.STAR] = '(<|>)?=?\\s*\\*';

	  for (var i = 0; i < R; i++) {
	    debug(i, src[i]);

	    if (!re[i]) {
	      re[i] = new RegExp(src[i]);
	    }
	  }

	  exports.parse = parse;

	  function parse(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    if (version.length > MAX_LENGTH) {
	      return null;
	    }

	    var r = options.loose ? re[t.LOOSE] : re[t.FULL];

	    if (!r.test(version)) {
	      return null;
	    }

	    try {
	      return new SemVer(version, options);
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.valid = valid;

	  function valid(version, options) {
	    var v = parse(version, options);
	    return v ? v.version : null;
	  }

	  exports.clean = clean;

	  function clean(version, options) {
	    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
	    return s ? s.version : null;
	  }

	  exports.SemVer = SemVer;

	  function SemVer(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      if (version.loose === options.loose) {
	        return version;
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
	    }

	    if (!(this instanceof SemVer)) {
	      return new SemVer(version, options);
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version');
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version');
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version');
	    }

	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map(function (id) {
	        if (/^[0-9]+$/.test(id)) {
	          var num = +id;

	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num;
	          }
	        }

	        return id;
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  SemVer.prototype.format = function () {
	    this.version = this.major + '.' + this.minor + '.' + this.patch;

	    if (this.prerelease.length) {
	      this.version += '-' + this.prerelease.join('.');
	    }

	    return this.version;
	  };

	  SemVer.prototype.toString = function () {
	    return this.version;
	  };

	  SemVer.prototype.compare = function (other) {
	    debug('SemVer.compare', this.version, this.options, other);

	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  SemVer.prototype.compareMain = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
	  };

	  SemVer.prototype.comparePre = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1;
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1;
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0;
	    }

	    var i = 0;

	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.compareBuild = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    var i = 0;

	    do {
	      var a = this.build[i];
	      var b = other.build[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.inc = function (release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;

	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;

	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier);
	        }

	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
	          this.major++;
	        }

	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }

	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }

	        this.prerelease = [];
	        break;

	      case 'pre':
	        if (this.prerelease.length === 0) {
	          this.prerelease = [0];
	        } else {
	          var i = this.prerelease.length;

	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }

	          if (i === -1) {
	            this.prerelease.push(0);
	          }
	        }

	        if (identifier) {
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = [identifier, 0];
	            }
	          } else {
	            this.prerelease = [identifier, 0];
	          }
	        }

	        break;

	      default:
	        throw new Error('invalid increment argument: ' + release);
	    }

	    this.format();
	    this.raw = this.version;
	    return this;
	  };

	  exports.inc = inc;

	  function inc(version, release, loose, identifier) {
	    if (typeof loose === 'string') {
	      identifier = loose;
	      loose = undefined;
	    }

	    try {
	      return new SemVer(version, loose).inc(release, identifier).version;
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.diff = diff;

	  function diff(version1, version2) {
	    if (eq(version1, version2)) {
	      return null;
	    } else {
	      var v1 = parse(version1);
	      var v2 = parse(version2);
	      var prefix = '';

	      if (v1.prerelease.length || v2.prerelease.length) {
	        prefix = 'pre';
	        var defaultResult = 'prerelease';
	      }

	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return prefix + key;
	          }
	        }
	      }

	      return defaultResult;
	    }
	  }

	  exports.compareIdentifiers = compareIdentifiers;
	  var numeric = /^[0-9]+$/;

	  function compareIdentifiers(a, b) {
	    var anum = numeric.test(a);
	    var bnum = numeric.test(b);

	    if (anum && bnum) {
	      a = +a;
	      b = +b;
	    }

	    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	  }

	  exports.rcompareIdentifiers = rcompareIdentifiers;

	  function rcompareIdentifiers(a, b) {
	    return compareIdentifiers(b, a);
	  }

	  exports.major = major;

	  function major(a, loose) {
	    return new SemVer(a, loose).major;
	  }

	  exports.minor = minor;

	  function minor(a, loose) {
	    return new SemVer(a, loose).minor;
	  }

	  exports.patch = patch;

	  function patch(a, loose) {
	    return new SemVer(a, loose).patch;
	  }

	  exports.compare = compare;

	  function compare(a, b, loose) {
	    return new SemVer(a, loose).compare(new SemVer(b, loose));
	  }

	  exports.compareLoose = compareLoose;

	  function compareLoose(a, b) {
	    return compare(a, b, true);
	  }

	  exports.compareBuild = compareBuild;

	  function compareBuild(a, b, loose) {
	    var versionA = new SemVer(a, loose);
	    var versionB = new SemVer(b, loose);
	    return versionA.compare(versionB) || versionA.compareBuild(versionB);
	  }

	  exports.rcompare = rcompare;

	  function rcompare(a, b, loose) {
	    return compare(b, a, loose);
	  }

	  exports.sort = sort;

	  function sort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(a, b, loose);
	    });
	  }

	  exports.rsort = rsort;

	  function rsort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(b, a, loose);
	    });
	  }

	  exports.gt = gt;

	  function gt(a, b, loose) {
	    return compare(a, b, loose) > 0;
	  }

	  exports.lt = lt;

	  function lt(a, b, loose) {
	    return compare(a, b, loose) < 0;
	  }

	  exports.eq = eq;

	  function eq(a, b, loose) {
	    return compare(a, b, loose) === 0;
	  }

	  exports.neq = neq;

	  function neq(a, b, loose) {
	    return compare(a, b, loose) !== 0;
	  }

	  exports.gte = gte;

	  function gte(a, b, loose) {
	    return compare(a, b, loose) >= 0;
	  }

	  exports.lte = lte;

	  function lte(a, b, loose) {
	    return compare(a, b, loose) <= 0;
	  }

	  exports.cmp = cmp;

	  function cmp(a, op, b, loose) {
	    switch (op) {
	      case '===':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a === b;

	      case '!==':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a !== b;

	      case '':
	      case '=':
	      case '==':
	        return eq(a, b, loose);

	      case '!=':
	        return neq(a, b, loose);

	      case '>':
	        return gt(a, b, loose);

	      case '>=':
	        return gte(a, b, loose);

	      case '<':
	        return lt(a, b, loose);

	      case '<=':
	        return lte(a, b, loose);

	      default:
	        throw new TypeError('Invalid operator: ' + op);
	    }
	  }

	  exports.Comparator = Comparator;

	  function Comparator(comp, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp;
	      } else {
	        comp = comp.value;
	      }
	    }

	    if (!(this instanceof Comparator)) {
	      return new Comparator(comp, options);
	    }

	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  var ANY = {};

	  Comparator.prototype.parse = function (comp) {
	    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var m = comp.match(r);

	    if (!m) {
	      throw new TypeError('Invalid comparator: ' + comp);
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';

	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  };

	  Comparator.prototype.toString = function () {
	    return this.value;
	  };

	  Comparator.prototype.test = function (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options);
	  };

	  Comparator.prototype.intersects = function (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required');
	    }

	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    var rangeTmp;

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(comp.value, options);
	      return satisfies(this.value, rangeTmp, options);
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(this.value, options);
	      return satisfies(comp.semver, rangeTmp, options);
	    }

	    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
	    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
	    var sameSemVer = this.semver.version === comp.semver.version;
	    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
	    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
	    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
	    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
	  };

	  exports.Range = Range;

	  function Range(range, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (range instanceof Range) {
	      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
	        return range;
	      } else {
	        return new Range(range.raw, options);
	      }
	    }

	    if (range instanceof Comparator) {
	      return new Range(range.value, options);
	    }

	    if (!(this instanceof Range)) {
	      return new Range(range, options);
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    this.raw = range;
	    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
	      return this.parseRange(range.trim());
	    }, this).filter(function (c) {
	      return c.length;
	    });

	    if (!this.set.length) {
	      throw new TypeError('Invalid SemVer Range: ' + range);
	    }

	    this.format();
	  }

	  Range.prototype.format = function () {
	    this.range = this.set.map(function (comps) {
	      return comps.join(' ').trim();
	    }).join('||').trim();
	    return this.range;
	  };

	  Range.prototype.toString = function () {
	    return this.range;
	  };

	  Range.prototype.parseRange = function (range) {
	    var loose = this.options.loose;
	    range = range.trim();
	    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace);
	    debug('hyphen replace', range);
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range, re[t.COMPARATORTRIM]);
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    range = range.split(/\s+/).join(' ');
	    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var set = range.split(' ').map(function (comp) {
	      return parseComparator(comp, this.options);
	    }, this).join(' ').split(/\s+/);

	    if (this.options.loose) {
	      set = set.filter(function (comp) {
	        return !!comp.match(compRe);
	      });
	    }

	    set = set.map(function (comp) {
	      return new Comparator(comp, this.options);
	    }, this);
	    return set;
	  };

	  Range.prototype.intersects = function (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required');
	    }

	    return this.set.some(function (thisComparators) {
	      return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
	        return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
	          return rangeComparators.every(function (rangeComparator) {
	            return thisComparator.intersects(rangeComparator, options);
	          });
	        });
	      });
	    });
	  };

	  function isSatisfiable(comparators, options) {
	    var result = true;
	    var remainingComparators = comparators.slice();
	    var testComparator = remainingComparators.pop();

	    while (result && remainingComparators.length) {
	      result = remainingComparators.every(function (otherComparator) {
	        return testComparator.intersects(otherComparator, options);
	      });
	      testComparator = remainingComparators.pop();
	    }

	    return result;
	  }

	  exports.toComparators = toComparators;

	  function toComparators(range, options) {
	    return new Range(range, options).set.map(function (comp) {
	      return comp.map(function (c) {
	        return c.value;
	      }).join(' ').trim().split(' ');
	    });
	  }

	  function parseComparator(comp, options) {
	    debug('comp', comp, options);
	    comp = replaceCarets(comp, options);
	    debug('caret', comp);
	    comp = replaceTildes(comp, options);
	    debug('tildes', comp);
	    comp = replaceXRanges(comp, options);
	    debug('xrange', comp);
	    comp = replaceStars(comp, options);
	    debug('stars', comp);
	    return comp;
	  }

	  function isX(id) {
	    return !id || id.toLowerCase() === 'x' || id === '*';
	  }

	  function replaceTildes(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceTilde(comp, options);
	    }).join(' ');
	  }

	  function replaceTilde(comp, options) {
	    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('tilde', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      } else if (pr) {
	        debug('replaceTilde pr', pr);
	        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	      } else {
	        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	      }

	      debug('tilde return', ret);
	      return ret;
	    });
	  }

	  function replaceCarets(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceCaret(comp, options);
	    }).join(' ');
	  }

	  function replaceCaret(comp, options) {
	    debug('caret', comp, options);
	    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('caret', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        if (M === '0') {
	          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	        } else {
	          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	        }
	      } else if (pr) {
	        debug('replaceCaret pr', pr);

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
	        }
	      } else {
	        debug('no pr');

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
	        }
	      }

	      debug('caret return', ret);
	      return ret;
	    });
	  }

	  function replaceXRanges(comp, options) {
	    debug('replaceXRanges', comp, options);
	    return comp.split(/\s+/).map(function (comp) {
	      return replaceXRange(comp, options);
	    }).join(' ');
	  }

	  function replaceXRange(comp, options) {
	    comp = comp.trim();
	    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
	      debug('xRange', comp, ret, gtlt, M, m, p, pr);
	      var xM = isX(M);
	      var xm = xM || isX(m);
	      var xp = xm || isX(p);
	      var anyX = xp;

	      if (gtlt === '=' && anyX) {
	        gtlt = '';
	      }

	      pr = options.includePrerelease ? '-0' : '';

	      if (xM) {
	        if (gtlt === '>' || gtlt === '<') {
	          ret = '<0.0.0-0';
	        } else {
	          ret = '*';
	        }
	      } else if (gtlt && anyX) {
	        if (xm) {
	          m = 0;
	        }

	        p = 0;

	        if (gtlt === '>') {
	          gtlt = '>=';

	          if (xm) {
	            M = +M + 1;
	            m = 0;
	            p = 0;
	          } else {
	            m = +m + 1;
	            p = 0;
	          }
	        } else if (gtlt === '<=') {
	          gtlt = '<';

	          if (xm) {
	            M = +M + 1;
	          } else {
	            m = +m + 1;
	          }
	        }

	        ret = gtlt + M + '.' + m + '.' + p + pr;
	      } else if (xm) {
	        ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
	      } else if (xp) {
	        ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
	      }

	      debug('xRange return', ret);
	      return ret;
	    });
	  }

	  function replaceStars(comp, options) {
	    debug('replaceStars', comp, options);
	    return comp.trim().replace(re[t.STAR], '');
	  }

	  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
	    if (isX(fM)) {
	      from = '';
	    } else if (isX(fm)) {
	      from = '>=' + fM + '.0.0';
	    } else if (isX(fp)) {
	      from = '>=' + fM + '.' + fm + '.0';
	    } else {
	      from = '>=' + from;
	    }

	    if (isX(tM)) {
	      to = '';
	    } else if (isX(tm)) {
	      to = '<' + (+tM + 1) + '.0.0';
	    } else if (isX(tp)) {
	      to = '<' + tM + '.' + (+tm + 1) + '.0';
	    } else if (tpr) {
	      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	    } else {
	      to = '<=' + to;
	    }

	    return (from + ' ' + to).trim();
	  }

	  Range.prototype.test = function (version) {
	    if (!version) {
	      return false;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    for (var i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  function testSet(set, version, options) {
	    for (var i = 0; i < set.length; i++) {
	      if (!set[i].test(version)) {
	        return false;
	      }
	    }

	    if (version.prerelease.length && !options.includePrerelease) {
	      for (i = 0; i < set.length; i++) {
	        debug(set[i].semver);

	        if (set[i].semver === ANY) {
	          continue;
	        }

	        if (set[i].semver.prerelease.length > 0) {
	          var allowed = set[i].semver;

	          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
	            return true;
	          }
	        }
	      }

	      return false;
	    }

	    return true;
	  }

	  exports.satisfies = satisfies;

	  function satisfies(version, range, options) {
	    try {
	      range = new Range(range, options);
	    } catch (er) {
	      return false;
	    }

	    return range.test(version);
	  }

	  exports.maxSatisfying = maxSatisfying;

	  function maxSatisfying(versions, range, options) {
	    var max = null;
	    var maxSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!max || maxSV.compare(v) === -1) {
	          max = v;
	          maxSV = new SemVer(max, options);
	        }
	      }
	    });
	    return max;
	  }

	  exports.minSatisfying = minSatisfying;

	  function minSatisfying(versions, range, options) {
	    var min = null;
	    var minSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!min || minSV.compare(v) === 1) {
	          min = v;
	          minSV = new SemVer(min, options);
	        }
	      }
	    });
	    return min;
	  }

	  exports.minVersion = minVersion;

	  function minVersion(range, loose) {
	    range = new Range(range, loose);
	    var minver = new SemVer('0.0.0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = new SemVer('0.0.0-0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = null;

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      comparators.forEach(function (comparator) {
	        var compver = new SemVer(comparator.semver.version);

	        switch (comparator.operator) {
	          case '>':
	            if (compver.prerelease.length === 0) {
	              compver.patch++;
	            } else {
	              compver.prerelease.push(0);
	            }

	            compver.raw = compver.format();

	          case '':
	          case '>=':
	            if (!minver || gt(minver, compver)) {
	              minver = compver;
	            }

	            break;

	          case '<':
	          case '<=':
	            break;

	          default:
	            throw new Error('Unexpected operation: ' + comparator.operator);
	        }
	      });
	    }

	    if (minver && range.test(minver)) {
	      return minver;
	    }

	    return null;
	  }

	  exports.validRange = validRange;

	  function validRange(range, options) {
	    try {
	      return new Range(range, options).range || '*';
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.ltr = ltr;

	  function ltr(version, range, options) {
	    return outside(version, range, '<', options);
	  }

	  exports.gtr = gtr;

	  function gtr(version, range, options) {
	    return outside(version, range, '>', options);
	  }

	  exports.outside = outside;

	  function outside(version, range, hilo, options) {
	    version = new SemVer(version, options);
	    range = new Range(range, options);
	    var gtfn, ltefn, ltfn, comp, ecomp;

	    switch (hilo) {
	      case '>':
	        gtfn = gt;
	        ltefn = lte;
	        ltfn = lt;
	        comp = '>';
	        ecomp = '>=';
	        break;

	      case '<':
	        gtfn = lt;
	        ltefn = gte;
	        ltfn = gt;
	        comp = '<';
	        ecomp = '<=';
	        break;

	      default:
	        throw new TypeError('Must provide a hilo val of "<" or ">"');
	    }

	    if (satisfies(version, range, options)) {
	      return false;
	    }

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      var high = null;
	      var low = null;
	      comparators.forEach(function (comparator) {
	        if (comparator.semver === ANY) {
	          comparator = new Comparator('>=0.0.0');
	        }

	        high = high || comparator;
	        low = low || comparator;

	        if (gtfn(comparator.semver, high.semver, options)) {
	          high = comparator;
	        } else if (ltfn(comparator.semver, low.semver, options)) {
	          low = comparator;
	        }
	      });

	      if (high.operator === comp || high.operator === ecomp) {
	        return false;
	      }

	      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
	        return false;
	      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  exports.prerelease = prerelease;

	  function prerelease(version, options) {
	    var parsed = parse(version, options);
	    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	  }

	  exports.intersects = intersects;

	  function intersects(r1, r2, options) {
	    r1 = new Range(r1, options);
	    r2 = new Range(r2, options);
	    return r1.intersects(r2);
	  }

	  exports.coerce = coerce;

	  function coerce(version, options) {
	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version === 'number') {
	      version = String(version);
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    options = options || {};
	    var match = null;

	    if (!options.rtl) {
	      match = version.match(re[t.COERCE]);
	    } else {
	      var next;

	      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
	        if (!match || next.index + next[0].length !== match.index + match[0].length) {
	          match = next;
	        }

	        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
	      }

	      re[t.COERCERTL].lastIndex = -1;
	    }

	    if (match === null) {
	      return null;
	    }

	    return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
	  }
	}, "/$$rollup_base$$/packages/babel-plugin-transform-runtime/node_modules/babel-plugin-polyfill-corejs2/node_modules/semver");

	var _excluded$1 = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];

	var _templateObject$5, _templateObject2$3, _templateObject3$2;

	var _ref$5 = undefined || babel,
	    t$1$3 = _ref$5.types,
	    template$1 = _ref$5.template;

	function intersection$3(a, b) {
	  var result = new Set();
	  a.forEach(function (v) {
	    return b.has(v) && result.add(v);
	  });
	  return result;
	}

	function has$1$1(object, key) {
	  return Object.prototype.hasOwnProperty.call(object, key);
	}

	function getType$1(target) {
	  return Object.prototype.toString.call(target).slice(8, -1);
	}

	function resolveId$1(path) {
	  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, true)) {
	    return path.node.name;
	  }

	  var _path$evaluate = path.evaluate(),
	      deopt = _path$evaluate.deopt;

	  if (deopt && deopt.isIdentifier()) {
	    return deopt.node.name;
	  }
	}

	function resolveKey$1(path, computed) {
	  if (computed === void 0) {
	    computed = false;
	  }

	  var node = path.node,
	      parent = path.parent,
	      scope = path.scope;
	  if (path.isStringLiteral()) return node.value;
	  var name = node.name;
	  var isIdentifier = path.isIdentifier();
	  if (isIdentifier && !(computed || parent.computed)) return name;

	  if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
	    name: "Symbol"
	  }) && !scope.hasBinding("Symbol", true)) {
	    var sym = resolveKey$1(path.get("property"), path.node.computed);
	    if (sym) return "Symbol." + sym;
	  }

	  if (!isIdentifier || scope.hasBinding(name, true)) {
	    var _path$evaluate2 = path.evaluate(),
	        value = _path$evaluate2.value;

	    if (typeof value === "string") return value;
	  }
	}

	function resolveSource$1(obj) {
	  if (obj.isMemberExpression() && obj.get("property").isIdentifier({
	    name: "prototype"
	  })) {
	    var _id = resolveId$1(obj.get("object"));

	    if (_id) {
	      return {
	        id: _id,
	        placement: "prototype"
	      };
	    }

	    return {
	      id: null,
	      placement: null
	    };
	  }

	  var id = resolveId$1(obj);

	  if (id) {
	    return {
	      id: id,
	      placement: "static"
	    };
	  }

	  var _obj$evaluate = obj.evaluate(),
	      value = _obj$evaluate.value;

	  if (value !== undefined) {
	    return {
	      id: getType$1(value),
	      placement: "prototype"
	    };
	  } else if (obj.isRegExpLiteral()) {
	    return {
	      id: "RegExp",
	      placement: "prototype"
	    };
	  } else if (obj.isFunction()) {
	    return {
	      id: "Function",
	      placement: "prototype"
	    };
	  }

	  return {
	    id: null,
	    placement: null
	  };
	}

	function getImportSource$2(_ref2) {
	  var node = _ref2.node;
	  if (node.specifiers.length === 0) return node.source.value;
	}

	function getRequireSource$2(_ref3) {
	  var node = _ref3.node;
	  if (!t$1$3.isExpressionStatement(node)) return;
	  var expression = node.expression;
	  var isRequire = t$1$3.isCallExpression(expression) && t$1$3.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t$1$3.isStringLiteral(expression.arguments[0]);
	  if (isRequire) return expression.arguments[0].value;
	}

	function hoist$1(node) {
	  node._blockHoist = 3;
	  return node;
	}

	function createUtilsGetter$1(cache) {
	  return function (path) {
	    var prog = path.findParent(function (p) {
	      return p.isProgram();
	    });
	    return {
	      injectGlobalImport: function injectGlobalImport(url) {
	        cache.storeAnonymous(prog, url, function (isScript, source) {
	          return isScript ? template$1.statement.ast(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose(["require(", ")"])), source) : t$1$3.importDeclaration([], source);
	        });
	      },
	      injectNamedImport: function injectNamedImport(url, name, hint) {
	        if (hint === void 0) {
	          hint = name;
	        }

	        return cache.storeNamed(prog, url, name, function (isScript, source, name) {
	          var id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist$1(template$1.statement.ast(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose(["\n                  var ", " = require(", ").", "\n                "])), id, source, name)) : t$1$3.importDeclaration([t$1$3.importSpecifier(id, name)], source),
	            name: id.name
	          };
	        });
	      },
	      injectDefaultImport: function injectDefaultImport(url, hint) {
	        if (hint === void 0) {
	          hint = url;
	        }

	        return cache.storeNamed(prog, url, "default", function (isScript, source) {
	          var id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist$1(template$1.statement.ast(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose(["var ", " = require(", ")"])), id, source)) : t$1$3.importDeclaration([t$1$3.importDefaultSpecifier(id)], source),
	            name: id.name
	          };
	        });
	      }
	    };
	  };
	}

	var _ref4$1 = undefined || babel,
	    t$9 = _ref4$1.types;

	var ImportsCache$1 = function () {
	  function ImportsCache(resolver) {
	    this._imports = new WeakMap();
	    this._anonymousImports = new WeakMap();
	    this._lastImports = new WeakMap();
	    this._resolver = resolver;
	  }

	  var _proto = ImportsCache.prototype;

	  _proto.storeAnonymous = function storeAnonymous(programPath, url, getVal) {
	    var key = this._normalizeKey(programPath, url);

	    var imports = this._ensure(this._anonymousImports, programPath, Set);

	    if (imports.has(key)) return;
	    var node = getVal(programPath.node.sourceType === "script", t$9.stringLiteral(this._resolver(url)));
	    imports.add(key);

	    this._injectImport(programPath, node);
	  };

	  _proto.storeNamed = function storeNamed(programPath, url, name, getVal) {
	    var key = this._normalizeKey(programPath, url, name);

	    var imports = this._ensure(this._imports, programPath, Map);

	    if (!imports.has(key)) {
	      var _getVal = getVal(programPath.node.sourceType === "script", t$9.stringLiteral(this._resolver(url)), t$9.identifier(name)),
	          node = _getVal.node,
	          id = _getVal.name;

	      imports.set(key, id);

	      this._injectImport(programPath, node);
	    }

	    return t$9.identifier(imports.get(key));
	  };

	  _proto._injectImport = function _injectImport(programPath, node) {
	    var lastImport = this._lastImports.get(programPath);

	    if (lastImport && lastImport.node && lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {
	      lastImport = lastImport.insertAfter(node);
	    } else {
	      lastImport = programPath.unshiftContainer("body", node);
	    }

	    lastImport = lastImport[lastImport.length - 1];

	    this._lastImports.set(programPath, lastImport);
	  };

	  _proto._ensure = function _ensure(map, programPath, Collection) {
	    var collection = map.get(programPath);

	    if (!collection) {
	      collection = new Collection();
	      map.set(programPath, collection);
	    }

	    return collection;
	  };

	  _proto._normalizeKey = function _normalizeKey(programPath, url, name) {
	    if (name === void 0) {
	      name = "";
	    }

	    var sourceType = programPath.node.sourceType;
	    return (name && sourceType) + "::" + url + "::" + name;
	  };

	  return ImportsCache;
	}();

	var presetEnvSilentDebugHeader$1 = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";

	function stringifyTargetsMultiline$1(targets) {
	  return JSON.stringify(prettifyTargets(targets), null, 2);
	}

	function patternToRegExp$1(pattern) {
	  if (pattern instanceof RegExp) return pattern;

	  try {
	    return new RegExp("^" + pattern + "$");
	  } catch (_unused) {
	    return null;
	  }
	}

	function buildUnusedError$1(label, unused) {
	  if (!unused.length) return "";
	  return "  - The following \"" + label + "\" patterns didn't match any polyfill:\n" + unused.map(function (original) {
	    return "    " + String(original) + "\n";
	  }).join("");
	}

	function buldDuplicatesError$1(duplicates) {
	  if (!duplicates.size) return "";
	  return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
	    return "    " + name + "\n";
	  }).join("");
	}

	function validateIncludeExclude$1(provider, polyfills, includePatterns, excludePatterns) {
	  var current;

	  var filter = function filter(pattern) {
	    var regexp = patternToRegExp$1(pattern);
	    if (!regexp) return false;
	    var matched = false;

	    for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
	      var polyfill = _step.value;

	      if (regexp.test(polyfill)) {
	        matched = true;
	        current.add(polyfill);
	      }
	    }

	    return !matched;
	  };

	  var include = current = new Set();
	  var unusedInclude = Array.from(includePatterns).filter(filter);
	  var exclude = current = new Set();
	  var unusedExclude = Array.from(excludePatterns).filter(filter);
	  var duplicates = intersection$3(include, exclude);

	  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
	    throw new Error("Error while validating the \"" + provider + "\" provider options:\n" + buildUnusedError$1("include", unusedInclude) + buildUnusedError$1("exclude", unusedExclude) + buldDuplicatesError$1(duplicates));
	  }

	  return {
	    include: include,
	    exclude: exclude
	  };
	}

	function applyMissingDependenciesDefaults$1(options, babelApi) {
	  var _options$missingDepen = options.missingDependencies,
	      missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
	  if (missingDependencies === false) return false;
	  var caller = babelApi.caller(function (caller) {
	    return caller == null ? void 0 : caller.name;
	  });
	  var _missingDependencies$ = missingDependencies.log,
	      log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
	      _missingDependencies$2 = missingDependencies.inject,
	      inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
	      _missingDependencies$3 = missingDependencies.all,
	      all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
	  return {
	    log: log,
	    inject: inject,
	    all: all
	  };
	}

	var usage$1 = function usage(callProvider) {
	  function property(object, key, placement, path) {
	    return callProvider({
	      kind: "property",
	      object: object,
	      key: key,
	      placement: placement
	    }, path);
	  }

	  return {
	    ReferencedIdentifier: function ReferencedIdentifier(path) {
	      var name = path.node.name,
	          scope = path.scope;
	      if (scope.getBindingIdentifier(name)) return;
	      callProvider({
	        kind: "global",
	        name: name
	      }, path);
	    },
	    MemberExpression: function MemberExpression(path) {
	      var key = resolveKey$1(path.get("property"), path.node.computed);
	      if (!key || key === "prototype") return;
	      var object = path.get("object");
	      var binding = object.scope.getBinding(object.node.name);
	      if (binding && binding.path.isImportNamespaceSpecifier()) return;
	      var source = resolveSource$1(object);
	      return property(source.id, key, source.placement, path);
	    },
	    ObjectPattern: function ObjectPattern(path) {
	      var parentPath = path.parentPath,
	          parent = path.parent;
	      var obj;

	      if (parentPath.isVariableDeclarator()) {
	        obj = parentPath.get("init");
	      } else if (parentPath.isAssignmentExpression()) {
	        obj = parentPath.get("right");
	      } else if (parentPath.isFunction()) {
	        var grand = parentPath.parentPath;

	        if (grand.isCallExpression() || grand.isNewExpression()) {
	          if (grand.node.callee === parent) {
	            obj = grand.get("arguments")[path.key];
	          }
	        }
	      }

	      var id = null;
	      var placement = null;

	      if (obj) {
	        var _resolveSource = resolveSource$1(obj);

	        id = _resolveSource.id;
	        placement = _resolveSource.placement;
	      }

	      for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
	        var prop = _step2.value;

	        if (prop.isObjectProperty()) {
	          var key = resolveKey$1(prop.get("key"));
	          if (key) property(id, key, placement, prop);
	        }
	      }
	    },
	    BinaryExpression: function BinaryExpression(path) {
	      if (path.node.operator !== "in") return;
	      var source = resolveSource$1(path.get("right"));
	      var key = resolveKey$1(path.get("left"), true);
	      if (!key) return;
	      callProvider({
	        kind: "in",
	        object: source.id,
	        key: key,
	        placement: source.placement
	      }, path);
	    }
	  };
	};

	var entry$1 = function entry(callProvider) {
	  return {
	    ImportDeclaration: function ImportDeclaration(path) {
	      var source = getImportSource$2(path);
	      if (!source) return;
	      callProvider({
	        kind: "import",
	        source: source
	      }, path);
	    },
	    Program: function Program(path) {
	      path.get("body").forEach(function (bodyPath) {
	        var source = getRequireSource$2(bodyPath);
	        if (!source) return;
	        callProvider({
	          kind: "import",
	          source: source
	        }, bodyPath);
	      });
	    }
	  };
	};

	function resolve$1(dirname, moduleName, absoluteImports) {
	  if (absoluteImports === false) return moduleName;
	  throw new Error("\"absoluteImports\" is not supported in bundles prepared for the browser.");
	}

	function has$6(basedir, name) {
	  return true;
	}

	function logMissing$1(missingDeps) {}

	function laterLogMissing$1(missingDeps) {}

	var PossibleGlobalObjects$1 = new Set(["global", "globalThis", "self", "window"]);

	function createMetaResolver$1(polyfills) {
	  var staticP = polyfills["static"],
	      instanceP = polyfills.instance,
	      globalP = polyfills.global;
	  return function (meta) {
	    if (meta.kind === "global" && globalP && has$1$1(globalP, meta.name)) {
	      return {
	        kind: "global",
	        desc: globalP[meta.name],
	        name: meta.name
	      };
	    }

	    if (meta.kind === "property" || meta.kind === "in") {
	      var placement = meta.placement,
	          object = meta.object,
	          key = meta.key;

	      if (object && placement === "static") {
	        if (globalP && PossibleGlobalObjects$1.has(object) && has$1$1(globalP, key)) {
	          return {
	            kind: "global",
	            desc: globalP[key],
	            name: key
	          };
	        }

	        if (staticP && has$1$1(staticP, object) && has$1$1(staticP[object], key)) {
	          return {
	            kind: "static",
	            desc: staticP[object][key],
	            name: object + "$" + key
	          };
	        }
	      }

	      if (instanceP && has$1$1(instanceP, key)) {
	        return {
	          kind: "instance",
	          desc: instanceP[key],
	          name: "" + key
	        };
	      }
	    }
	  };
	}

	var getTargets$1 = getTargets$2["default"] || getTargets$2;

	function resolveOptions$1(options, babelApi) {
	  var method = options.method,
	      targetsOption = options.targets,
	      ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
	      configPath = options.configPath,
	      debug = options.debug,
	      shouldInjectPolyfill = options.shouldInjectPolyfill,
	      absoluteImports = options.absoluteImports,
	      providerOptions = _objectWithoutProperties(options, _excluded$1);

	  var methodName;
	  if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
	    throw new Error(".method must be a string");
	  } else {
	    throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + (" or \"usage-pure\" (received " + JSON.stringify(method) + ")"));
	  }

	  if (typeof shouldInjectPolyfill === "function") {
	    if (options.include || options.exclude) {
	      throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
	    }
	  } else if (shouldInjectPolyfill != null) {
	    throw new Error(".shouldInjectPolyfill must be a function, or undefined" + (" (received " + JSON.stringify(shouldInjectPolyfill) + ")"));
	  }

	  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
	    throw new Error(".absoluteImports must be a boolean, a string, or undefined" + (" (received " + JSON.stringify(absoluteImports) + ")"));
	  }

	  var targets;

	  if (targetsOption || configPath || ignoreBrowserslistConfig) {
	    var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
	      browsers: targetsOption
	    } : targetsOption;
	    targets = getTargets$1(targetsObj, {
	      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
	      configPath: configPath
	    });
	  } else {
	    targets = babelApi.targets();
	  }

	  return {
	    method: method,
	    methodName: methodName,
	    targets: targets,
	    absoluteImports: absoluteImports != null ? absoluteImports : false,
	    shouldInjectPolyfill: shouldInjectPolyfill,
	    debug: !!debug,
	    providerOptions: providerOptions
	  };
	}

	function instantiateProvider$1(factory, options, missingDependencies, dirname, debugLog, babelApi) {
	  var _resolveOptions = resolveOptions$1(options, babelApi),
	      method = _resolveOptions.method,
	      methodName = _resolveOptions.methodName,
	      targets = _resolveOptions.targets,
	      _debug = _resolveOptions.debug,
	      _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
	      providerOptions = _resolveOptions.providerOptions,
	      absoluteImports = _resolveOptions.absoluteImports;

	  var getUtils = createUtilsGetter$1(new ImportsCache$1(function (moduleName) {
	    return resolve$1(dirname, moduleName, absoluteImports);
	  }));
	  var include, exclude;
	  var polyfillsSupport;
	  var polyfillsNames;
	  var filterPolyfills;
	  var depsCache = new Map();
	  var api = {
	    babel: babelApi,
	    getUtils: getUtils,
	    method: options.method,
	    targets: targets,
	    createMetaResolver: createMetaResolver$1,
	    shouldInjectPolyfill: function shouldInjectPolyfill(name) {
	      if (polyfillsNames === undefined) {
	        throw new Error("Internal error in the " + factory.name + " provider: " + "shouldInjectPolyfill() can't be called during initialization.");
	      }

	      if (!polyfillsNames.has(name)) {
	        console.warn("Internal error in the " + provider.name + " provider: " + ("unknown polyfill \"" + name + "\"."));
	      }

	      if (filterPolyfills && !filterPolyfills(name)) return false;
	      var shouldInject = isRequired(name, targets, {
	        compatData: polyfillsSupport,
	        includes: include,
	        excludes: exclude
	      });

	      if (_shouldInjectPolyfill) {
	        shouldInject = _shouldInjectPolyfill(name, shouldInject);

	        if (typeof shouldInject !== "boolean") {
	          throw new Error(".shouldInjectPolyfill must return a boolean.");
	        }
	      }

	      return shouldInject;
	    },
	    debug: function debug(name) {
	      debugLog().found = true;
	      if (!_debug || !name) return;
	      if (debugLog().polyfills.has(provider.name)) return;
	      debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);
	    },
	    assertDependency: function assertDependency(name, version) {
	      if (version === void 0) {
	        version = "*";
	      }

	      if (missingDependencies === false) return;

	      if (absoluteImports) {
	        return;
	      }

	      var dep = version === "*" ? name : name + "@^" + version;
	      var found = missingDependencies.all ? false : mapGetOr$1(depsCache, name + " :: " + dirname, function () {
	        return has$6();
	      });

	      if (!found) {
	        debugLog().missingDeps.add(dep);
	      }
	    }
	  };
	  var provider = factory(api, providerOptions, dirname);

	  if (typeof provider[methodName] !== "function") {
	    throw new Error("The \"" + (provider.name || factory.name) + "\" provider doesn't " + ("support the \"" + method + "\" polyfilling method."));
	  }

	  if (Array.isArray(provider.polyfills)) {
	    polyfillsNames = new Set(provider.polyfills);
	    filterPolyfills = provider.filterPolyfills;
	  } else if (provider.polyfills) {
	    polyfillsNames = new Set(Object.keys(provider.polyfills));
	    polyfillsSupport = provider.polyfills;
	    filterPolyfills = provider.filterPolyfills;
	  } else {
	    polyfillsNames = new Set();
	  }

	  var _validateIncludeExclu = validateIncludeExclude$1(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);

	  include = _validateIncludeExclu.include;
	  exclude = _validateIncludeExclu.exclude;
	  return {
	    debug: _debug,
	    method: method,
	    targets: targets,
	    provider: provider,
	    callProvider: function callProvider(payload, path) {
	      var utils = getUtils(path);
	      provider[methodName](payload, utils, path);
	    }
	  };
	}

	function definePolyfillProvider$1(factory) {
	  return declare(function (babelApi, options, dirname) {
	    babelApi.assertVersion(7);
	    var traverse = babelApi.traverse;
	    var debugLog;
	    var missingDependencies = applyMissingDependenciesDefaults$1(options, babelApi);

	    var _instantiateProvider = instantiateProvider$1(factory, options, missingDependencies, dirname, function () {
	      return debugLog;
	    }, babelApi),
	        debug = _instantiateProvider.debug,
	        method = _instantiateProvider.method,
	        targets = _instantiateProvider.targets,
	        provider = _instantiateProvider.provider,
	        callProvider = _instantiateProvider.callProvider;

	    var createVisitor = method === "entry-global" ? entry$1 : usage$1;
	    var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);

	    if (debug && debug !== presetEnvSilentDebugHeader$1) {
	      console.log(provider.name + ": `DEBUG` option");
	      console.log("\nUsing targets: " + stringifyTargetsMultiline$1(targets));
	      console.log("\nUsing polyfills with `" + method + "` method:");
	    }

	    return {
	      name: "inject-polyfills",
	      visitor: visitor,
	      pre: function pre() {
	        var _provider$pre;

	        debugLog = {
	          polyfills: new Map(),
	          found: false,
	          providers: new Set(),
	          missingDeps: new Set()
	        };
	        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
	      },
	      post: function post() {
	        var _provider$post;

	        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);

	        if (missingDependencies !== false) {
	          if (missingDependencies.log === "per-file") {
	            logMissing$1(debugLog.missingDeps);
	          } else {
	            laterLogMissing$1(debugLog.missingDeps);
	          }
	        }

	        if (!debug) return;
	        if (this.filename) console.log("\n[" + this.filename + "]");

	        if (debugLog.polyfills.size === 0) {
	          console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the " + provider.name + " polyfill did not add any polyfill." : "The entry point for the " + provider.name + " polyfill has not been found." : "Based on your code and targets, the " + provider.name + " polyfill did not add any polyfill.");
	          return;
	        }

	        if (method === "entry-global") {
	          console.log("The " + provider.name + " polyfill entry has been replaced with " + "the following polyfills:");
	        } else {
	          console.log("The " + provider.name + " polyfill added the following polyfills:");
	        }

	        for (var _iterator3 = _createForOfIteratorHelperLoose(debugLog.polyfills), _step3; !(_step3 = _iterator3()).done;) {
	          var _step3$value = _slicedToArray$1(_step3.value, 2),
	              name = _step3$value[0],
	              support = _step3$value[1];

	          if (support) {
	            var filteredTargets = getInclusionReasons(name, targets, support);
	            var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
	            console.log("  " + name + " " + formattedTargets);
	          } else {
	            console.log("  " + name);
	          }
	        }
	      }
	    };
	  });
	}

	function mapGetOr$1(map, key, getDefault) {
	  var val = map.get(key);

	  if (val === undefined) {
	    val = getDefault();
	    map.set(key, val);
	  }

	  return val;
	}

	var define$3 = function define(name, pure, global, meta) {
	  if (global === void 0) {
	    global = [];
	  }

	  return {
	    name: name,
	    pure: pure,
	    global: global,
	    meta: meta
	  };
	};

	var pureAndGlobal$1 = function pureAndGlobal(pure, global, minRuntimeVersion) {
	  if (minRuntimeVersion === void 0) {
	    minRuntimeVersion = null;
	  }

	  return define$3(global[0], pure, global, {
	    minRuntimeVersion: minRuntimeVersion
	  });
	};

	var globalOnly$1 = function globalOnly(global) {
	  return define$3(global[0], null, global);
	};

	var pureOnly$1 = function pureOnly(pure, name) {
	  return define$3(name, pure, []);
	};

	var ArrayNatureIterators$3 = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
	var CommonIterators$3 = ["es6.string.iterator"].concat(ArrayNatureIterators$3);
	var PromiseDependencies$3 = ["es6.object.to-string", "es6.promise"];
	var BuiltIns$3 = {
	  DataView: globalOnly$1(["es6.typed.data-view"]),
	  Float32Array: globalOnly$1(["es6.typed.float32-array"]),
	  Float64Array: globalOnly$1(["es6.typed.float64-array"]),
	  Int8Array: globalOnly$1(["es6.typed.int8-array"]),
	  Int16Array: globalOnly$1(["es6.typed.int16-array"]),
	  Int32Array: globalOnly$1(["es6.typed.int32-array"]),
	  Map: pureAndGlobal$1("map", ["es6.map"].concat(_toConsumableArray(CommonIterators$3))),
	  Number: globalOnly$1(["es6.number.constructor"]),
	  Promise: pureAndGlobal$1("promise", PromiseDependencies$3),
	  RegExp: globalOnly$1(["es6.regexp.constructor"]),
	  Set: pureAndGlobal$1("set", ["es6.set"].concat(_toConsumableArray(CommonIterators$3))),
	  Symbol: pureAndGlobal$1("symbol", ["es6.symbol"]),
	  Uint8Array: globalOnly$1(["es6.typed.uint8-array"]),
	  Uint8ClampedArray: globalOnly$1(["es6.typed.uint8-clamped-array"]),
	  Uint16Array: globalOnly$1(["es6.typed.uint16-array"]),
	  Uint32Array: globalOnly$1(["es6.typed.uint32-array"]),
	  WeakMap: pureAndGlobal$1("weak-map", ["es6.weak-map"].concat(_toConsumableArray(CommonIterators$3))),
	  WeakSet: pureAndGlobal$1("weak-set", ["es6.weak-set"].concat(_toConsumableArray(CommonIterators$3))),
	  setImmediate: pureOnly$1("set-immediate", "web.immediate"),
	  clearImmediate: pureOnly$1("clear-immediate", "web.immediate"),
	  parseFloat: pureOnly$1("parse-float", "es6.parse-float"),
	  parseInt: pureOnly$1("parse-int", "es6.parse-int")
	};
	var InstanceProperties$3 = {
	  __defineGetter__: globalOnly$1(["es7.object.define-getter"]),
	  __defineSetter__: globalOnly$1(["es7.object.define-setter"]),
	  __lookupGetter__: globalOnly$1(["es7.object.lookup-getter"]),
	  __lookupSetter__: globalOnly$1(["es7.object.lookup-setter"]),
	  anchor: globalOnly$1(["es6.string.anchor"]),
	  big: globalOnly$1(["es6.string.big"]),
	  bind: globalOnly$1(["es6.function.bind"]),
	  blink: globalOnly$1(["es6.string.blink"]),
	  bold: globalOnly$1(["es6.string.bold"]),
	  codePointAt: globalOnly$1(["es6.string.code-point-at"]),
	  copyWithin: globalOnly$1(["es6.array.copy-within"]),
	  endsWith: globalOnly$1(["es6.string.ends-with"]),
	  entries: globalOnly$1(ArrayNatureIterators$3),
	  every: globalOnly$1(["es6.array.every"]),
	  fill: globalOnly$1(["es6.array.fill"]),
	  filter: globalOnly$1(["es6.array.filter"]),
	  "finally": globalOnly$1(["es7.promise.finally"].concat(PromiseDependencies$3)),
	  find: globalOnly$1(["es6.array.find"]),
	  findIndex: globalOnly$1(["es6.array.find-index"]),
	  fixed: globalOnly$1(["es6.string.fixed"]),
	  flags: globalOnly$1(["es6.regexp.flags"]),
	  flatMap: globalOnly$1(["es7.array.flat-map"]),
	  fontcolor: globalOnly$1(["es6.string.fontcolor"]),
	  fontsize: globalOnly$1(["es6.string.fontsize"]),
	  forEach: globalOnly$1(["es6.array.for-each"]),
	  includes: globalOnly$1(["es6.string.includes", "es7.array.includes"]),
	  indexOf: globalOnly$1(["es6.array.index-of"]),
	  italics: globalOnly$1(["es6.string.italics"]),
	  keys: globalOnly$1(ArrayNatureIterators$3),
	  lastIndexOf: globalOnly$1(["es6.array.last-index-of"]),
	  link: globalOnly$1(["es6.string.link"]),
	  map: globalOnly$1(["es6.array.map"]),
	  match: globalOnly$1(["es6.regexp.match"]),
	  name: globalOnly$1(["es6.function.name"]),
	  padStart: globalOnly$1(["es7.string.pad-start"]),
	  padEnd: globalOnly$1(["es7.string.pad-end"]),
	  reduce: globalOnly$1(["es6.array.reduce"]),
	  reduceRight: globalOnly$1(["es6.array.reduce-right"]),
	  repeat: globalOnly$1(["es6.string.repeat"]),
	  replace: globalOnly$1(["es6.regexp.replace"]),
	  search: globalOnly$1(["es6.regexp.search"]),
	  small: globalOnly$1(["es6.string.small"]),
	  some: globalOnly$1(["es6.array.some"]),
	  sort: globalOnly$1(["es6.array.sort"]),
	  split: globalOnly$1(["es6.regexp.split"]),
	  startsWith: globalOnly$1(["es6.string.starts-with"]),
	  strike: globalOnly$1(["es6.string.strike"]),
	  sub: globalOnly$1(["es6.string.sub"]),
	  sup: globalOnly$1(["es6.string.sup"]),
	  toISOString: globalOnly$1(["es6.date.to-iso-string"]),
	  toJSON: globalOnly$1(["es6.date.to-json"]),
	  toString: globalOnly$1(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
	  trim: globalOnly$1(["es6.string.trim"]),
	  trimEnd: globalOnly$1(["es7.string.trim-right"]),
	  trimLeft: globalOnly$1(["es7.string.trim-left"]),
	  trimRight: globalOnly$1(["es7.string.trim-right"]),
	  trimStart: globalOnly$1(["es7.string.trim-left"]),
	  values: globalOnly$1(ArrayNatureIterators$3)
	};

	if ("es6.array.slice" in corejs2BuiltIns) {
	  InstanceProperties$3.slice = globalOnly$1(["es6.array.slice"]);
	}

	var StaticProperties$3 = {
	  Array: {
	    from: pureAndGlobal$1("array/from", ["es6.symbol", "es6.array.from"].concat(_toConsumableArray(CommonIterators$3))),
	    isArray: pureAndGlobal$1("array/is-array", ["es6.array.is-array"]),
	    of: pureAndGlobal$1("array/of", ["es6.array.of"])
	  },
	  Date: {
	    now: pureAndGlobal$1("date/now", ["es6.date.now"])
	  },
	  JSON: {
	    stringify: pureOnly$1("json/stringify", "es6.symbol")
	  },
	  Math: {
	    acosh: pureAndGlobal$1("math/acosh", ["es6.math.acosh"], "7.0.1"),
	    asinh: pureAndGlobal$1("math/asinh", ["es6.math.asinh"], "7.0.1"),
	    atanh: pureAndGlobal$1("math/atanh", ["es6.math.atanh"], "7.0.1"),
	    cbrt: pureAndGlobal$1("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
	    clz32: pureAndGlobal$1("math/clz32", ["es6.math.clz32"], "7.0.1"),
	    cosh: pureAndGlobal$1("math/cosh", ["es6.math.cosh"], "7.0.1"),
	    expm1: pureAndGlobal$1("math/expm1", ["es6.math.expm1"], "7.0.1"),
	    fround: pureAndGlobal$1("math/fround", ["es6.math.fround"], "7.0.1"),
	    hypot: pureAndGlobal$1("math/hypot", ["es6.math.hypot"], "7.0.1"),
	    imul: pureAndGlobal$1("math/imul", ["es6.math.imul"], "7.0.1"),
	    log1p: pureAndGlobal$1("math/log1p", ["es6.math.log1p"], "7.0.1"),
	    log10: pureAndGlobal$1("math/log10", ["es6.math.log10"], "7.0.1"),
	    log2: pureAndGlobal$1("math/log2", ["es6.math.log2"], "7.0.1"),
	    sign: pureAndGlobal$1("math/sign", ["es6.math.sign"], "7.0.1"),
	    sinh: pureAndGlobal$1("math/sinh", ["es6.math.sinh"], "7.0.1"),
	    tanh: pureAndGlobal$1("math/tanh", ["es6.math.tanh"], "7.0.1"),
	    trunc: pureAndGlobal$1("math/trunc", ["es6.math.trunc"], "7.0.1")
	  },
	  Number: {
	    EPSILON: pureAndGlobal$1("number/epsilon", ["es6.number.epsilon"]),
	    MIN_SAFE_INTEGER: pureAndGlobal$1("number/min-safe-integer", ["es6.number.min-safe-integer"]),
	    MAX_SAFE_INTEGER: pureAndGlobal$1("number/max-safe-integer", ["es6.number.max-safe-integer"]),
	    isFinite: pureAndGlobal$1("number/is-finite", ["es6.number.is-finite"]),
	    isInteger: pureAndGlobal$1("number/is-integer", ["es6.number.is-integer"]),
	    isSafeInteger: pureAndGlobal$1("number/is-safe-integer", ["es6.number.is-safe-integer"]),
	    isNaN: pureAndGlobal$1("number/is-nan", ["es6.number.is-nan"]),
	    parseFloat: pureAndGlobal$1("number/parse-float", ["es6.number.parse-float"]),
	    parseInt: pureAndGlobal$1("number/parse-int", ["es6.number.parse-int"])
	  },
	  Object: {
	    assign: pureAndGlobal$1("object/assign", ["es6.object.assign"]),
	    create: pureAndGlobal$1("object/create", ["es6.object.create"]),
	    defineProperties: pureAndGlobal$1("object/define-properties", ["es6.object.define-properties"]),
	    defineProperty: pureAndGlobal$1("object/define-property", ["es6.object.define-property"]),
	    entries: pureAndGlobal$1("object/entries", ["es7.object.entries"]),
	    freeze: pureAndGlobal$1("object/freeze", ["es6.object.freeze"]),
	    getOwnPropertyDescriptor: pureAndGlobal$1("object/get-own-property-descriptor", ["es6.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: pureAndGlobal$1("object/get-own-property-descriptors", ["es7.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: pureAndGlobal$1("object/get-own-property-names", ["es6.object.get-own-property-names"]),
	    getOwnPropertySymbols: pureAndGlobal$1("object/get-own-property-symbols", ["es6.symbol"]),
	    getPrototypeOf: pureAndGlobal$1("object/get-prototype-of", ["es6.object.get-prototype-of"]),
	    is: pureAndGlobal$1("object/is", ["es6.object.is"]),
	    isExtensible: pureAndGlobal$1("object/is-extensible", ["es6.object.is-extensible"]),
	    isFrozen: pureAndGlobal$1("object/is-frozen", ["es6.object.is-frozen"]),
	    isSealed: pureAndGlobal$1("object/is-sealed", ["es6.object.is-sealed"]),
	    keys: pureAndGlobal$1("object/keys", ["es6.object.keys"]),
	    preventExtensions: pureAndGlobal$1("object/prevent-extensions", ["es6.object.prevent-extensions"]),
	    seal: pureAndGlobal$1("object/seal", ["es6.object.seal"]),
	    setPrototypeOf: pureAndGlobal$1("object/set-prototype-of", ["es6.object.set-prototype-of"]),
	    values: pureAndGlobal$1("object/values", ["es7.object.values"])
	  },
	  Promise: {
	    all: globalOnly$1(CommonIterators$3),
	    race: globalOnly$1(CommonIterators$3)
	  },
	  Reflect: {
	    apply: pureAndGlobal$1("reflect/apply", ["es6.reflect.apply"]),
	    construct: pureAndGlobal$1("reflect/construct", ["es6.reflect.construct"]),
	    defineProperty: pureAndGlobal$1("reflect/define-property", ["es6.reflect.define-property"]),
	    deleteProperty: pureAndGlobal$1("reflect/delete-property", ["es6.reflect.delete-property"]),
	    get: pureAndGlobal$1("reflect/get", ["es6.reflect.get"]),
	    getOwnPropertyDescriptor: pureAndGlobal$1("reflect/get-own-property-descriptor", ["es6.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: pureAndGlobal$1("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
	    has: pureAndGlobal$1("reflect/has", ["es6.reflect.has"]),
	    isExtensible: pureAndGlobal$1("reflect/is-extensible", ["es6.reflect.is-extensible"]),
	    ownKeys: pureAndGlobal$1("reflect/own-keys", ["es6.reflect.own-keys"]),
	    preventExtensions: pureAndGlobal$1("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
	    set: pureAndGlobal$1("reflect/set", ["es6.reflect.set"]),
	    setPrototypeOf: pureAndGlobal$1("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
	  },
	  String: {
	    at: pureOnly$1("string/at", "es7.string.at"),
	    fromCodePoint: pureAndGlobal$1("string/from-code-point", ["es6.string.from-code-point"]),
	    raw: pureAndGlobal$1("string/raw", ["es6.string.raw"])
	  },
	  Symbol: {
	    asyncIterator: globalOnly$1(["es6.symbol", "es7.symbol.async-iterator"]),
	    "for": pureOnly$1("symbol/for", "es6.symbol"),
	    hasInstance: pureOnly$1("symbol/has-instance", "es6.symbol"),
	    isConcatSpreadable: pureOnly$1("symbol/is-concat-spreadable", "es6.symbol"),
	    iterator: define$3("es6.symbol", "symbol/iterator", CommonIterators$3),
	    keyFor: pureOnly$1("symbol/key-for", "es6.symbol"),
	    match: pureAndGlobal$1("symbol/match", ["es6.regexp.match"]),
	    replace: pureOnly$1("symbol/replace", "es6.symbol"),
	    search: pureOnly$1("symbol/search", "es6.symbol"),
	    species: pureOnly$1("symbol/species", "es6.symbol"),
	    split: pureOnly$1("symbol/split", "es6.symbol"),
	    toPrimitive: pureOnly$1("symbol/to-primitive", "es6.symbol"),
	    toStringTag: pureOnly$1("symbol/to-string-tag", "es6.symbol"),
	    unscopables: pureOnly$1("symbol/unscopables", "es6.symbol")
	  }
	};
	var webPolyfills$1 = {
	  "web.timers": {},
	  "web.immediate": {},
	  "web.dom.iterable": {}
	};
	var purePolyfills$1 = {
	  "es6.parse-float": {},
	  "es6.parse-int": {},
	  "es7.string.at": {}
	};

	function addPlatformSpecificPolyfills$1(targets, method, polyfills) {
	  var targetNames = Object.keys(targets);
	  var isAnyTarget = !targetNames.length;
	  var isWebTarget = targetNames.some(function (name) {
	    return name !== "node";
	  });
	  return Object.assign(Object.assign(Object.assign({}, polyfills), method === "usage-pure" ? purePolyfills$1 : null), isAnyTarget || isWebTarget ? webPolyfills$1 : null);
	}

	function hasMinVersion$1(minVersion, runtimeVersion) {
	  if (!runtimeVersion || !minVersion) return true;
	  if (semver$3.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
	  return !semver$3.intersects("<" + minVersion, runtimeVersion) && !semver$3.intersects(">=8.0.0", runtimeVersion);
	}

	var _ref$4 = undefined || babel,
	    t$8 = _ref$4.types;

	var presetEnvCompat$1 = "#__secret_key__@babel/preset-env__compatibility";
	var runtimeCompat$5 = "#__secret_key__@babel/runtime__compatibility";
	var has$5 = Function.call.bind(Object.hasOwnProperty);
	var index$5 = definePolyfillProvider$1(function (api, _ref2) {
	  var _ref2$presetEnvCompat = _ref2[presetEnvCompat$1];
	  _ref2$presetEnvCompat = _ref2$presetEnvCompat === void 0 ? {} : _ref2$presetEnvCompat;
	  var entryInjectRegenerator = _ref2$presetEnvCompat.entryInjectRegenerator,
	      _ref2$runtimeCompat = _ref2[runtimeCompat$5];
	  _ref2$runtimeCompat = _ref2$runtimeCompat === void 0 ? {} : _ref2$runtimeCompat;
	  var useBabelRuntime = _ref2$runtimeCompat.useBabelRuntime,
	      runtimeVersion = _ref2$runtimeCompat.runtimeVersion,
	      _ref2$runtimeCompat$e = _ref2$runtimeCompat.ext,
	      ext = _ref2$runtimeCompat$e === void 0 ? ".js" : _ref2$runtimeCompat$e;
	  var resolve = api.createMetaResolver({
	    global: BuiltIns$3,
	    "static": StaticProperties$3,
	    instance: InstanceProperties$3
	  });
	  var debug = api.debug,
	      shouldInjectPolyfill = api.shouldInjectPolyfill,
	      method = api.method;
	  var polyfills = addPlatformSpecificPolyfills$1(api.targets, method, corejs2BuiltIns);
	  var coreJSBase = useBabelRuntime ? useBabelRuntime + "/core-js" : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";

	  function inject(name, utils) {
	    if (typeof name === "string") {
	      if (has$5(polyfills, name) && shouldInjectPolyfill(name)) {
	        debug(name);
	        utils.injectGlobalImport(coreJSBase + "/" + name + ".js");
	      }

	      return;
	    }

	    name.forEach(function (name) {
	      return inject(name, utils);
	    });
	  }

	  function maybeInjectPure(desc, hint, utils) {
	    var pure = desc.pure,
	        meta = desc.meta,
	        name = desc.name;
	    if (!pure || !shouldInjectPolyfill(name)) return;

	    if (runtimeVersion && meta && meta.minRuntimeVersion && !hasMinVersion$1(meta && meta.minRuntimeVersion, runtimeVersion)) {
	      return;
	    }

	    return utils.injectDefaultImport(coreJSBase + "/" + pure + ext, hint);
	  }

	  return {
	    name: "corejs2",
	    polyfills: polyfills,
	    entryGlobal: function entryGlobal(meta, utils, path) {
	      if (meta.kind === "import" && meta.source === "core-js") {
	        debug(null);
	        inject(Object.keys(polyfills), utils);

	        if (entryInjectRegenerator) {
	          utils.injectGlobalImport("regenerator-runtime/runtime.js");
	        }

	        path.remove();
	      }
	    },
	    usageGlobal: function usageGlobal(meta, utils) {
	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var deps = resolved.desc.global;

	      if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
	        var low = meta.object.toLowerCase();
	        deps = deps.filter(function (m) {
	          return m.includes(low);
	        });
	      }

	      inject(deps, utils);
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t$8.callExpression(utils.injectDefaultImport(coreJSBase + "/is-iterable" + ext, "isIterable"), [path.node.right]));
	        }

	        return;
	      }

	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;

	      if (meta.kind === "property") {
	        if (!path.isMemberExpression()) return;
	        if (!path.isReferenced()) return;

	        if (meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
	          callee: path.node
	        }) && path.parent.arguments.length === 0) {
	          path.parentPath.replaceWith(t$8.callExpression(utils.injectDefaultImport(coreJSBase + "/get-iterator" + ext, "getIterator"), [path.node.object]));
	          path.skip();
	          return;
	        }
	      }

	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var id = maybeInjectPure(resolved.desc, resolved.name, utils);
	      if (id) path.replaceWith(id);
	    },
	    visitor: method === "usage-global" && {
	      YieldExpression: function YieldExpression(path) {
	        if (path.node.delegate) {
	          inject("web.dom.iterable", api.getUtils(path));
	        }
	      },
	      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
	        CommonIterators$3.forEach(function (name) {
	          return inject(name, api.getUtils(path));
	        });
	      }
	    }
	  };
	});

	var require$$0$3 = {
		"es.symbol": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "51",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.description": {
		android: "70",
		chrome: "70",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "63",
		ios: "12.2",
		node: "11.0",
		opera: "57",
		opera_mobile: "49",
		safari: "12.1",
		samsung: "10.0"
	},
		"es.symbol.async-iterator": {
		android: "63",
		chrome: "63",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "55",
		ios: "12.0",
		node: "10.0",
		opera: "50",
		opera_mobile: "46",
		safari: "12.0",
		samsung: "8.0"
	},
		"es.symbol.has-instance": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "15",
		electron: "1.1",
		firefox: "49",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.is-concat-spreadable": {
		android: "48",
		chrome: "48",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "48",
		ios: "10.0",
		node: "6.0",
		opera: "35",
		opera_mobile: "35",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.iterator": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "36",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.symbol.match": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "74",
		electron: "1.1",
		firefox: "40",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.match-all": {
		android: "73",
		chrome: "73",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "67",
		ios: "13.0",
		node: "12.0",
		opera: "60",
		opera_mobile: "52",
		safari: "13",
		samsung: "11.0"
	},
		"es.symbol.replace": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "74",
		electron: "1.1",
		firefox: "49",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.search": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "74",
		electron: "1.1",
		firefox: "49",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.species": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "41",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.split": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "74",
		electron: "1.1",
		firefox: "49",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.to-primitive": {
		android: "47",
		chrome: "47",
		deno: "1.0",
		edge: "15",
		electron: "0.36",
		firefox: "44",
		ios: "10.0",
		node: "6.0",
		opera: "34",
		opera_mobile: "34",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.to-string-tag": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "51",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.symbol.unscopables": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "48",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.aggregate-error": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "79",
		ios: "14.0",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "14.0",
		samsung: "14.0"
	},
		"es.array.at": {
		android: "92",
		chrome: "92",
		deno: "1.12",
		edge: "92",
		electron: "14.0",
		firefox: "90",
		node: "16.6",
		opera: "78",
		opera_mobile: "65",
		safari: "15.1",
		samsung: "16.0"
	},
		"es.array.concat": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "48",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.copy-within": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "12",
		electron: "0.31",
		firefox: "48",
		ios: "9.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.every": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.array.fill": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "12",
		electron: "0.31",
		firefox: "48",
		ios: "9.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.filter": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "48",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.find": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "48",
		ios: "9.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.find-index": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "48",
		ios: "9.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.flat": {
		android: "69",
		chrome: "69",
		deno: "1.0",
		edge: "74",
		electron: "4.0",
		firefox: "62",
		ios: "12.0",
		node: "11.0",
		opera: "56",
		opera_mobile: "48",
		safari: "12.0",
		samsung: "10.0"
	},
		"es.array.flat-map": {
		android: "69",
		chrome: "69",
		deno: "1.0",
		edge: "74",
		electron: "4.0",
		firefox: "62",
		ios: "12.0",
		node: "11.0",
		opera: "56",
		opera_mobile: "48",
		safari: "12.0",
		samsung: "10.0"
	},
		"es.array.for-each": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.array.from": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "53",
		ios: "9.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.includes": {
		android: "53",
		chrome: "53",
		deno: "1.0",
		edge: "14",
		electron: "1.4",
		firefox: "48",
		ios: "10.0",
		node: "7.0",
		opera: "40",
		opera_mobile: "40",
		safari: "10.0",
		samsung: "6.0"
	},
		"es.array.index-of": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "12",
		electron: "1.2",
		firefox: "47",
		ie: "9",
		ios: "8.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "5.0"
	},
		"es.array.is-array": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "3.2",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "4.0",
		samsung: "1.0"
	},
		"es.array.iterator": {
		android: "66",
		chrome: "66",
		deno: "1.0",
		edge: "15",
		electron: "3.0",
		firefox: "60",
		ios: "10.0",
		node: "10.0",
		opera: "53",
		opera_mobile: "47",
		safari: "10.0",
		samsung: "9.0"
	},
		"es.array.join": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "4",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.array.last-index-of": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "12",
		electron: "1.2",
		firefox: "47",
		ie: "9",
		ios: "8.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "5.0"
	},
		"es.array.map": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "50",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.of": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "25",
		ios: "9.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.array.reduce": {
		android: "83",
		chrome: "83",
		deno: "1.0",
		edge: "12",
		electron: "9.0",
		firefox: "4",
		ie: "9",
		ios: "8.0",
		node: "6.0",
		opera: "69",
		opera_mobile: "59",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "13.0"
	},
		"es.array.reduce-right": {
		android: "83",
		chrome: "83",
		deno: "1.0",
		edge: "12",
		electron: "9.0",
		firefox: "4",
		ie: "9",
		ios: "8.0",
		node: "6.0",
		opera: "69",
		opera_mobile: "59",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "13.0"
	},
		"es.array.reverse": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "5.5",
		ios: "12.2",
		node: "0.0.3",
		opera: "10.50",
		opera_mobile: "10.50",
		rhino: "1.7.13",
		safari: "12.0.2",
		samsung: "1.0"
	},
		"es.array.slice": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "48",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.some": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.array.sort": {
		android: "70",
		chrome: "70",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "4",
		ios: "12.0",
		node: "11.0",
		opera: "57",
		opera_mobile: "49",
		safari: "12.0",
		samsung: "10.0"
	},
		"es.array.species": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "48",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.splice": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "49",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.array.unscopables.flat": {
		android: "73",
		chrome: "73",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "67",
		ios: "13.0",
		node: "12.0",
		opera: "60",
		opera_mobile: "52",
		safari: "13",
		samsung: "11.0"
	},
		"es.array.unscopables.flat-map": {
		android: "73",
		chrome: "73",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "67",
		ios: "13.0",
		node: "12.0",
		opera: "60",
		opera_mobile: "52",
		safari: "13",
		samsung: "11.0"
	},
		"es.array-buffer.constructor": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "14",
		electron: "0.20",
		firefox: "44",
		ios: "12.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		safari: "12.0",
		samsung: "1.5"
	},
		"es.array-buffer.is-view": {
		android: "4.4.3",
		chrome: "32",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "29",
		ie: "11",
		ios: "8.0",
		node: "0.11.9",
		opera: "19",
		opera_mobile: "19",
		safari: "7.1",
		samsung: "2.0"
	},
		"es.array-buffer.slice": {
		android: "4.4.3",
		chrome: "31",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "46",
		ie: "11",
		ios: "12.2",
		node: "0.11.8",
		opera: "18",
		opera_mobile: "18",
		rhino: "1.7.13",
		safari: "12.1",
		samsung: "2.0"
	},
		"es.data-view": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "15",
		ie: "10",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.date.get-year": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "9",
		ios: "1.0",
		node: "0.0.3",
		opera: "3",
		opera_mobile: "3",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.date.now": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ie: "9",
		ios: "3.2",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "4.0",
		samsung: "1.0"
	},
		"es.date.set-year": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "3",
		ios: "1.0",
		node: "0.0.3",
		opera: "3",
		opera_mobile: "3",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.date.to-gmt-string": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "3",
		ios: "1.0",
		node: "0.0.3",
		opera: "3",
		opera_mobile: "3",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.date.to-iso-string": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "7",
		ie: "9",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.date.to-json": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "10.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "1.5"
	},
		"es.date.to-primitive": {
		android: "47",
		chrome: "47",
		deno: "1.0",
		edge: "15",
		electron: "0.36",
		firefox: "44",
		ios: "10.0",
		node: "6.0",
		opera: "34",
		opera_mobile: "34",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.date.to-string": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ie: "9",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.escape": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "3",
		ios: "1.0",
		node: "0.0.3",
		opera: "3",
		opera_mobile: "3",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.function.bind": {
		android: "3.0",
		chrome: "7",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "5.1",
		node: "0.1.101",
		opera: "12",
		opera_mobile: "12",
		phantom: "2.0",
		rhino: "1.7.13",
		safari: "5.1",
		samsung: "1.0"
	},
		"es.function.has-instance": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "50",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.function.name": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "3.2",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "4.0",
		samsung: "1.0"
	},
		"es.global-this": {
		android: "71",
		chrome: "71",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "65",
		ios: "12.2",
		node: "12.0",
		opera: "58",
		opera_mobile: "50",
		safari: "12.1",
		samsung: "10.0"
	},
		"es.json.stringify": {
		android: "72",
		chrome: "72",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "64",
		ios: "12.2",
		node: "12.0",
		opera: "59",
		opera_mobile: "51",
		safari: "12.1",
		samsung: "11.0"
	},
		"es.json.to-string-tag": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "15",
		electron: "1.1",
		firefox: "51",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.map": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "53",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.math.acosh": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "13",
		electron: "1.4",
		firefox: "25",
		ios: "8.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "7.1",
		samsung: "6.0"
	},
		"es.math.asinh": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.atanh": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.cbrt": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.clz32": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "31",
		ios: "9.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.0"
	},
		"es.math.cosh": {
		android: "39",
		chrome: "39",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "1.0",
		opera: "26",
		opera_mobile: "26",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.4"
	},
		"es.math.expm1": {
		android: "39",
		chrome: "39",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "46",
		ios: "8.0",
		node: "1.0",
		opera: "26",
		opera_mobile: "26",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.4"
	},
		"es.math.fround": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "26",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.hypot": {
		android: "78",
		chrome: "78",
		deno: "1.0",
		edge: "12",
		electron: "7.0",
		firefox: "27",
		ios: "8.0",
		node: "13.0",
		opera: "65",
		opera_mobile: "56",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "12.0"
	},
		"es.math.imul": {
		android: "4.4",
		chrome: "28",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "20",
		ios: "9.0",
		node: "0.11.1",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "1.5"
	},
		"es.math.log10": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.log1p": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.log2": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.sign": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "9.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.0"
	},
		"es.math.sinh": {
		android: "39",
		chrome: "39",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "1.0",
		opera: "26",
		opera_mobile: "26",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.4"
	},
		"es.math.tanh": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.math.to-string-tag": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "15",
		electron: "1.1",
		firefox: "51",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.math.trunc": {
		android: "38",
		chrome: "38",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "8.0",
		node: "0.11.15",
		opera: "25",
		opera_mobile: "25",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.number.constructor": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "46",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.number.epsilon": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "25",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.number.is-finite": {
		android: "4.1",
		chrome: "19",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "16",
		ios: "9.0",
		node: "0.7.3",
		opera: "15",
		opera_mobile: "15",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "1.5"
	},
		"es.number.is-integer": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "16",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.number.is-nan": {
		android: "4.1",
		chrome: "19",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "15",
		ios: "9.0",
		node: "0.7.3",
		opera: "15",
		opera_mobile: "15",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "1.5"
	},
		"es.number.is-safe-integer": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "32",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.number.max-safe-integer": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "31",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.number.min-safe-integer": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "31",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.number.parse-float": {
		android: "37",
		chrome: "35",
		deno: "1.0",
		edge: "74",
		electron: "0.20",
		firefox: "39",
		ios: "11.0",
		node: "0.11.13",
		opera: "22",
		opera_mobile: "22",
		safari: "11.0",
		samsung: "3.0"
	},
		"es.number.parse-int": {
		android: "37",
		chrome: "35",
		deno: "1.0",
		edge: "74",
		electron: "0.20",
		firefox: "39",
		ios: "9.0",
		node: "0.11.13",
		opera: "22",
		opera_mobile: "22",
		safari: "9.0",
		samsung: "3.0"
	},
		"es.number.to-fixed": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "74",
		electron: "0.20",
		firefox: "4",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.number.to-precision": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "8",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.object.assign": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "74",
		electron: "0.37",
		firefox: "36",
		ios: "9.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "9.0",
		samsung: "5.0"
	},
		"es.object.create": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "3.2",
		node: "0.1.27",
		opera: "12",
		opera_mobile: "12",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "4.0",
		samsung: "1.0"
	},
		"es.object.define-getter": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "16",
		electron: "3.0",
		firefox: "48",
		ios: "8.0",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "8.0"
	},
		"es.object.define-properties": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "5.1",
		node: "0.1.27",
		opera: "12",
		opera_mobile: "12",
		phantom: "2.0",
		rhino: "1.7.13",
		safari: "5.1",
		samsung: "1.0"
	},
		"es.object.define-property": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "4",
		ie: "9",
		ios: "5.1",
		node: "0.1.27",
		opera: "12",
		opera_mobile: "12",
		phantom: "2.0",
		rhino: "1.7.13",
		safari: "5.1",
		samsung: "1.0"
	},
		"es.object.define-setter": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "16",
		electron: "3.0",
		firefox: "48",
		ios: "8.0",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "8.0"
	},
		"es.object.entries": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "14",
		electron: "1.4",
		firefox: "47",
		ios: "10.3",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "10.1",
		samsung: "6.0"
	},
		"es.object.freeze": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.from-entries": {
		android: "73",
		chrome: "73",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "63",
		ios: "12.2",
		node: "12.0",
		opera: "60",
		opera_mobile: "52",
		safari: "12.1",
		samsung: "11.0"
	},
		"es.object.get-own-property-descriptor": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.get-own-property-descriptors": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "50",
		ios: "10.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "10.0",
		samsung: "6.0"
	},
		"es.object.get-own-property-names": {
		android: "40",
		chrome: "40",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "34",
		ios: "9.0",
		node: "1.0",
		opera: "27",
		opera_mobile: "27",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.object.get-prototype-of": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.has-own": {
		android: "93",
		chrome: "93",
		deno: "1.13",
		edge: "93",
		electron: "14.0",
		firefox: "92",
		node: "16.9",
		opera: "79",
		safari: "15.1"
	},
		"es.object.is": {
		android: "4.1",
		chrome: "19",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "22",
		ios: "9.0",
		node: "0.7.3",
		opera: "15",
		opera_mobile: "15",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "1.5"
	},
		"es.object.is-extensible": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.is-frozen": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.is-sealed": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.keys": {
		android: "40",
		chrome: "40",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "35",
		ios: "9.0",
		node: "1.0",
		opera: "27",
		opera_mobile: "27",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.object.lookup-getter": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "16",
		electron: "3.0",
		firefox: "48",
		ios: "8.0",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "8.0"
	},
		"es.object.lookup-setter": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "16",
		electron: "3.0",
		firefox: "48",
		ios: "8.0",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "8.0"
	},
		"es.object.prevent-extensions": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.seal": {
		android: "44",
		chrome: "44",
		deno: "1.0",
		edge: "13",
		electron: "0.30",
		firefox: "35",
		ios: "9.0",
		node: "3.0",
		opera: "31",
		opera_mobile: "31",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "4.0"
	},
		"es.object.set-prototype-of": {
		android: "37",
		chrome: "34",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "31",
		ie: "11",
		ios: "9.0",
		node: "0.11.13",
		opera: "21",
		opera_mobile: "21",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "2.0"
	},
		"es.object.to-string": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "51",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.object.values": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "14",
		electron: "1.4",
		firefox: "47",
		ios: "10.3",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "10.1",
		samsung: "6.0"
	},
		"es.parse-float": {
		android: "37",
		chrome: "35",
		deno: "1.0",
		edge: "74",
		electron: "0.20",
		firefox: "8",
		ie: "8",
		ios: "8.0",
		node: "0.11.13",
		opera: "22",
		opera_mobile: "22",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.parse-int": {
		android: "37",
		chrome: "35",
		deno: "1.0",
		edge: "74",
		electron: "0.20",
		firefox: "21",
		ie: "9",
		ios: "8.0",
		node: "0.11.13",
		opera: "22",
		opera_mobile: "22",
		rhino: "1.7.13",
		safari: "7.1",
		samsung: "3.0"
	},
		"es.promise": {
		android: "67",
		chrome: "67",
		deno: "1.0",
		edge: "74",
		electron: "4.0",
		firefox: "69",
		ios: "11.0",
		node: "10.4",
		opera: "54",
		opera_mobile: "48",
		safari: "11.0",
		samsung: "9.0"
	},
		"es.promise.all-settled": {
		android: "76",
		chrome: "76",
		deno: "1.0",
		edge: "76",
		electron: "6.0",
		firefox: "71",
		ios: "13.0",
		node: "12.9",
		opera: "63",
		opera_mobile: "54",
		safari: "13",
		samsung: "12.0"
	},
		"es.promise.any": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "79",
		ios: "14.0",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "14.0",
		samsung: "14.0"
	},
		"es.promise.finally": {
		android: "67",
		chrome: "67",
		deno: "1.0",
		edge: "74",
		electron: "4.0",
		firefox: "69",
		ios: "13.2.3",
		node: "10.4",
		opera: "54",
		opera_mobile: "48",
		safari: "13.0.3",
		samsung: "9.0"
	},
		"es.reflect.apply": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.construct": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "15",
		electron: "0.37",
		firefox: "44",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.define-property": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "13",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.delete-property": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.get": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.get-own-property-descriptor": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.get-prototype-of": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.has": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.is-extensible": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.own-keys": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.prevent-extensions": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.set": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "74",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.set-prototype-of": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "12",
		electron: "0.37",
		firefox: "42",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.reflect.to-string-tag": {
		android: "86",
		chrome: "86",
		deno: "1.3",
		edge: "86",
		electron: "11.0",
		firefox: "82",
		ios: "14.0",
		node: "15.0",
		opera: "72",
		opera_mobile: "61",
		safari: "14.0",
		samsung: "14.0"
	},
		"es.regexp.constructor": {
		android: "64",
		chrome: "64",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "78",
		ios: "11.3",
		node: "10.0",
		opera: "51",
		opera_mobile: "47",
		safari: "11.1",
		samsung: "9.0"
	},
		"es.regexp.dot-all": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "78",
		ios: "11.3",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		safari: "11.1",
		samsung: "8.0"
	},
		"es.regexp.exec": {
		android: "64",
		chrome: "64",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "78",
		ios: "11.3",
		node: "10.0",
		opera: "51",
		opera_mobile: "47",
		safari: "11.1",
		samsung: "9.0"
	},
		"es.regexp.flags": {
		android: "62",
		chrome: "62",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "78",
		ios: "11.3",
		node: "8.10",
		opera: "49",
		opera_mobile: "46",
		safari: "11.1",
		samsung: "8.0"
	},
		"es.regexp.sticky": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "13",
		electron: "0.37",
		firefox: "3",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.regexp.test": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "46",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.regexp.to-string": {
		android: "50",
		chrome: "50",
		deno: "1.0",
		edge: "74",
		electron: "1.1",
		firefox: "46",
		ios: "10.0",
		node: "6.0",
		opera: "37",
		opera_mobile: "37",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.set": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "53",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.at-alternative": {
		android: "92",
		chrome: "92",
		deno: "1.12",
		edge: "92",
		electron: "14.0",
		firefox: "90",
		node: "16.6",
		opera: "78",
		opera_mobile: "65",
		safari: "15.1",
		samsung: "16.0"
	},
		"es.string.code-point-at": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "29",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.string.ends-with": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "40",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.from-code-point": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "29",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.string.includes": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "40",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.iterator": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "36",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.string.match": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "49",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.match-all": {
		android: "80",
		chrome: "80",
		deno: "1.0",
		edge: "80",
		electron: "8.0",
		firefox: "73",
		ios: "13.4",
		node: "14.0",
		opera: "67",
		opera_mobile: "57",
		safari: "13.1",
		samsung: "13.0"
	},
		"es.string.pad-end": {
		android: "57",
		chrome: "57",
		deno: "1.0",
		edge: "15",
		electron: "1.7",
		firefox: "48",
		ios: "11.0",
		node: "8.0",
		opera: "44",
		opera_mobile: "43",
		rhino: "1.7.13",
		safari: "11.0",
		samsung: "7.0"
	},
		"es.string.pad-start": {
		android: "57",
		chrome: "57",
		deno: "1.0",
		edge: "15",
		electron: "1.7",
		firefox: "48",
		ios: "11.0",
		node: "8.0",
		opera: "44",
		opera_mobile: "43",
		rhino: "1.7.13",
		safari: "11.0",
		samsung: "7.0"
	},
		"es.string.raw": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "34",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.string.repeat": {
		android: "41",
		chrome: "41",
		deno: "1.0",
		edge: "13",
		electron: "0.21",
		firefox: "24",
		ios: "9.0",
		node: "1.0",
		opera: "28",
		opera_mobile: "28",
		rhino: "1.7.13",
		safari: "9.0",
		samsung: "3.4"
	},
		"es.string.replace": {
		android: "64",
		chrome: "64",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "78",
		ios: "14.0",
		node: "10.0",
		opera: "51",
		opera_mobile: "47",
		safari: "14.0",
		samsung: "9.0"
	},
		"es.string.replace-all": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "77",
		ios: "13.4",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "13.1",
		samsung: "14.0"
	},
		"es.string.search": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "49",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.split": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "74",
		electron: "1.4",
		firefox: "49",
		ios: "10.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "10.0",
		samsung: "6.0"
	},
		"es.string.starts-with": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "74",
		electron: "1.2",
		firefox: "40",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.string.substr": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "9",
		ios: "1.0",
		node: "0.0.3",
		opera: "4",
		opera_mobile: "4",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.string.trim": {
		android: "59",
		chrome: "59",
		deno: "1.0",
		edge: "15",
		electron: "1.8",
		firefox: "52",
		ios: "12.2",
		node: "8.3",
		opera: "46",
		opera_mobile: "43",
		rhino: "1.7.13",
		safari: "12.1",
		samsung: "7.0"
	},
		"es.string.trim-end": {
		android: "66",
		chrome: "66",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "61",
		ios: "12.2",
		node: "10.0",
		opera: "53",
		opera_mobile: "47",
		safari: "12.1",
		samsung: "9.0"
	},
		"es.string.trim-start": {
		android: "66",
		chrome: "66",
		deno: "1.0",
		edge: "74",
		electron: "3.0",
		firefox: "61",
		ios: "12.0",
		node: "10.0",
		opera: "53",
		opera_mobile: "47",
		safari: "12.0",
		samsung: "9.0"
	},
		"es.string.anchor": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "17",
		ios: "6.0",
		node: "0.1.27",
		opera: "15",
		opera_mobile: "15",
		phantom: "2.0",
		safari: "6.0",
		samsung: "1.0"
	},
		"es.string.big": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.blink": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.bold": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.fixed": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.fontcolor": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "17",
		ios: "6.0",
		node: "0.1.27",
		opera: "15",
		opera_mobile: "15",
		phantom: "2.0",
		safari: "6.0",
		samsung: "1.0"
	},
		"es.string.fontsize": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "17",
		ios: "6.0",
		node: "0.1.27",
		opera: "15",
		opera_mobile: "15",
		phantom: "2.0",
		safari: "6.0",
		samsung: "1.0"
	},
		"es.string.italics": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.link": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "17",
		ios: "6.0",
		node: "0.1.27",
		opera: "15",
		opera_mobile: "15",
		phantom: "2.0",
		safari: "6.0",
		samsung: "1.0"
	},
		"es.string.small": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.strike": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.sub": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.string.sup": {
		android: "3.0",
		chrome: "5",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "2",
		ios: "2.0",
		node: "0.1.27",
		opera: "10.50",
		opera_mobile: "10.50",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "3.1",
		samsung: "1.0"
	},
		"es.typed-array.float32-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.float64-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.int8-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.int16-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.int32-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.uint8-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.uint8-clamped-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.uint16-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.uint32-array": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.at": {
		android: "92",
		chrome: "92",
		deno: "1.12",
		edge: "92",
		electron: "14.0",
		firefox: "90",
		node: "16.6",
		opera: "78",
		opera_mobile: "65",
		safari: "15.1",
		samsung: "16.0"
	},
		"es.typed-array.copy-within": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "34",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.every": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.fill": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.filter": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "38",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.find": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.find-index": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.for-each": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "38",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.from": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.includes": {
		android: "49",
		chrome: "49",
		deno: "1.0",
		edge: "14",
		electron: "0.37",
		firefox: "43",
		ios: "10.0",
		node: "6.0",
		opera: "36",
		opera_mobile: "36",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.index-of": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.iterator": {
		android: "47",
		chrome: "47",
		deno: "1.0",
		edge: "13",
		electron: "0.36",
		firefox: "37",
		ios: "10.0",
		node: "6.0",
		opera: "34",
		opera_mobile: "34",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.join": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.last-index-of": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.map": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "38",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.of": {
		android: "54",
		chrome: "54",
		deno: "1.0",
		edge: "15",
		electron: "1.4",
		firefox: "55",
		ios: "14.0",
		node: "7.0",
		opera: "41",
		opera_mobile: "41",
		safari: "14.0",
		samsung: "6.0"
	},
		"es.typed-array.reduce": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.reduce-right": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.reverse": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.set": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "15",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.typed-array.slice": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "38",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.some": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "13",
		electron: "0.31",
		firefox: "37",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.sort": {
		android: "74",
		chrome: "74",
		deno: "1.0",
		edge: "74",
		electron: "6.0",
		firefox: "67",
		ios: "14.5",
		node: "12.0",
		opera: "61",
		opera_mobile: "53",
		safari: "14.1",
		samsung: "11.0"
	},
		"es.typed-array.subarray": {
		android: "4.4",
		chrome: "26",
		deno: "1.0",
		edge: "13",
		electron: "0.20",
		firefox: "15",
		ios: "8.0",
		node: "0.11.0",
		opera: "16",
		opera_mobile: "16",
		safari: "7.1",
		samsung: "1.5"
	},
		"es.typed-array.to-locale-string": {
		android: "45",
		chrome: "45",
		deno: "1.0",
		edge: "74",
		electron: "0.31",
		firefox: "51",
		ios: "10.0",
		node: "4.0",
		opera: "32",
		opera_mobile: "32",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.typed-array.to-string": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "13",
		electron: "1.2",
		firefox: "51",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.unescape": {
		android: "3.0",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		electron: "0.20",
		firefox: "1",
		ie: "3",
		ios: "1.0",
		node: "0.0.3",
		opera: "3",
		opera_mobile: "3",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1",
		samsung: "1.0"
	},
		"es.weak-map": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "53",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"es.weak-set": {
		android: "51",
		chrome: "51",
		deno: "1.0",
		edge: "15",
		electron: "1.2",
		firefox: "53",
		ios: "10.0",
		node: "6.5",
		opera: "38",
		opera_mobile: "38",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "5.0"
	},
		"esnext.aggregate-error": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "79",
		ios: "14.0",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "14.0",
		samsung: "14.0"
	},
		"esnext.array.from-async": {
	},
		"esnext.array.at": {
		android: "92",
		chrome: "92",
		deno: "1.12",
		edge: "92",
		electron: "14.0",
		firefox: "90",
		node: "16.6",
		opera: "78",
		opera_mobile: "65",
		safari: "15.1",
		samsung: "16.0"
	},
		"esnext.array.filter-out": {
	},
		"esnext.array.filter-reject": {
	},
		"esnext.array.find-last": {
		safari: "15.1"
	},
		"esnext.array.find-last-index": {
		safari: "15.1"
	},
		"esnext.array.group-by": {
	},
		"esnext.array.is-template-object": {
	},
		"esnext.array.last-index": {
	},
		"esnext.array.last-item": {
	},
		"esnext.array.unique-by": {
	},
		"esnext.async-iterator.constructor": {
	},
		"esnext.async-iterator.as-indexed-pairs": {
	},
		"esnext.async-iterator.drop": {
	},
		"esnext.async-iterator.every": {
	},
		"esnext.async-iterator.filter": {
	},
		"esnext.async-iterator.find": {
	},
		"esnext.async-iterator.flat-map": {
	},
		"esnext.async-iterator.for-each": {
	},
		"esnext.async-iterator.from": {
	},
		"esnext.async-iterator.map": {
	},
		"esnext.async-iterator.reduce": {
	},
		"esnext.async-iterator.some": {
	},
		"esnext.async-iterator.take": {
	},
		"esnext.async-iterator.to-array": {
	},
		"esnext.bigint.range": {
	},
		"esnext.composite-key": {
	},
		"esnext.composite-symbol": {
	},
		"esnext.global-this": {
		android: "71",
		chrome: "71",
		deno: "1.0",
		edge: "74",
		electron: "5.0",
		firefox: "65",
		ios: "12.2",
		node: "12.0",
		opera: "58",
		opera_mobile: "50",
		safari: "12.1",
		samsung: "10.0"
	},
		"esnext.iterator.constructor": {
	},
		"esnext.iterator.as-indexed-pairs": {
	},
		"esnext.iterator.drop": {
	},
		"esnext.iterator.every": {
	},
		"esnext.iterator.filter": {
	},
		"esnext.iterator.find": {
	},
		"esnext.iterator.flat-map": {
	},
		"esnext.iterator.for-each": {
	},
		"esnext.iterator.from": {
	},
		"esnext.iterator.map": {
	},
		"esnext.iterator.reduce": {
	},
		"esnext.iterator.some": {
	},
		"esnext.iterator.take": {
	},
		"esnext.iterator.to-array": {
	},
		"esnext.map.delete-all": {
	},
		"esnext.map.emplace": {
	},
		"esnext.map.every": {
	},
		"esnext.map.filter": {
	},
		"esnext.map.find": {
	},
		"esnext.map.find-key": {
	},
		"esnext.map.from": {
	},
		"esnext.map.group-by": {
	},
		"esnext.map.includes": {
	},
		"esnext.map.key-by": {
	},
		"esnext.map.key-of": {
	},
		"esnext.map.map-keys": {
	},
		"esnext.map.map-values": {
	},
		"esnext.map.merge": {
	},
		"esnext.map.of": {
	},
		"esnext.map.reduce": {
	},
		"esnext.map.some": {
	},
		"esnext.map.update": {
	},
		"esnext.map.update-or-insert": {
	},
		"esnext.map.upsert": {
	},
		"esnext.math.clamp": {
	},
		"esnext.math.deg-per-rad": {
	},
		"esnext.math.degrees": {
	},
		"esnext.math.fscale": {
	},
		"esnext.math.iaddh": {
	},
		"esnext.math.imulh": {
	},
		"esnext.math.isubh": {
	},
		"esnext.math.rad-per-deg": {
	},
		"esnext.math.radians": {
	},
		"esnext.math.scale": {
	},
		"esnext.math.seeded-prng": {
	},
		"esnext.math.signbit": {
	},
		"esnext.math.umulh": {
	},
		"esnext.number.from-string": {
	},
		"esnext.number.range": {
	},
		"esnext.object.has-own": {
		android: "93",
		chrome: "93",
		deno: "1.13",
		edge: "93",
		electron: "14.0",
		firefox: "92",
		node: "16.9",
		opera: "79",
		safari: "15.1"
	},
		"esnext.object.iterate-entries": {
	},
		"esnext.object.iterate-keys": {
	},
		"esnext.object.iterate-values": {
	},
		"esnext.observable": {
	},
		"esnext.promise.all-settled": {
		android: "76",
		chrome: "76",
		deno: "1.0",
		edge: "76",
		electron: "6.0",
		firefox: "71",
		ios: "13.0",
		node: "12.9",
		opera: "63",
		opera_mobile: "54",
		safari: "13",
		samsung: "12.0"
	},
		"esnext.promise.any": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "79",
		ios: "14.0",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "14.0",
		samsung: "14.0"
	},
		"esnext.promise.try": {
	},
		"esnext.reflect.define-metadata": {
	},
		"esnext.reflect.delete-metadata": {
	},
		"esnext.reflect.get-metadata": {
	},
		"esnext.reflect.get-metadata-keys": {
	},
		"esnext.reflect.get-own-metadata": {
	},
		"esnext.reflect.get-own-metadata-keys": {
	},
		"esnext.reflect.has-metadata": {
	},
		"esnext.reflect.has-own-metadata": {
	},
		"esnext.reflect.metadata": {
	},
		"esnext.set.add-all": {
	},
		"esnext.set.delete-all": {
	},
		"esnext.set.difference": {
	},
		"esnext.set.every": {
	},
		"esnext.set.filter": {
	},
		"esnext.set.find": {
	},
		"esnext.set.from": {
	},
		"esnext.set.intersection": {
	},
		"esnext.set.is-disjoint-from": {
	},
		"esnext.set.is-subset-of": {
	},
		"esnext.set.is-superset-of": {
	},
		"esnext.set.join": {
	},
		"esnext.set.map": {
	},
		"esnext.set.of": {
	},
		"esnext.set.reduce": {
	},
		"esnext.set.some": {
	},
		"esnext.set.symmetric-difference": {
	},
		"esnext.set.union": {
	},
		"esnext.string.at": {
	},
		"esnext.string.code-points": {
	},
		"esnext.string.match-all": {
		android: "80",
		chrome: "80",
		deno: "1.0",
		edge: "80",
		electron: "8.0",
		firefox: "73",
		ios: "13.4",
		node: "14.0",
		opera: "67",
		opera_mobile: "57",
		safari: "13.1",
		samsung: "13.0"
	},
		"esnext.string.replace-all": {
		android: "85",
		chrome: "85",
		deno: "1.2",
		edge: "85",
		electron: "10.0",
		firefox: "77",
		ios: "13.4",
		node: "15.0",
		opera: "71",
		opera_mobile: "60",
		safari: "13.1",
		samsung: "14.0"
	},
		"esnext.symbol.async-dispose": {
	},
		"esnext.symbol.dispose": {
	},
		"esnext.symbol.matcher": {
	},
		"esnext.symbol.metadata": {
	},
		"esnext.symbol.observable": {
	},
		"esnext.symbol.pattern-match": {
	},
		"esnext.symbol.replace-all": {
	},
		"esnext.typed-array.from-async": {
	},
		"esnext.typed-array.at": {
		android: "92",
		chrome: "92",
		deno: "1.12",
		edge: "92",
		electron: "14.0",
		firefox: "90",
		node: "16.6",
		opera: "78",
		opera_mobile: "65",
		safari: "15.1",
		samsung: "16.0"
	},
		"esnext.typed-array.filter-out": {
	},
		"esnext.typed-array.filter-reject": {
	},
		"esnext.typed-array.find-last": {
		safari: "15.1"
	},
		"esnext.typed-array.find-last-index": {
		safari: "15.1"
	},
		"esnext.typed-array.group-by": {
	},
		"esnext.typed-array.unique-by": {
	},
		"esnext.weak-map.delete-all": {
	},
		"esnext.weak-map.from": {
	},
		"esnext.weak-map.of": {
	},
		"esnext.weak-map.emplace": {
	},
		"esnext.weak-map.upsert": {
	},
		"esnext.weak-set.add-all": {
	},
		"esnext.weak-set.delete-all": {
	},
		"esnext.weak-set.from": {
	},
		"esnext.weak-set.of": {
	},
		"web.dom-collections.for-each": {
		android: "58",
		chrome: "58",
		deno: "1.0",
		edge: "16",
		firefox: "50",
		ios: "10.0",
		node: "0.0.1",
		opera: "45",
		opera_mobile: "43",
		rhino: "1.7.13",
		safari: "10.0",
		samsung: "7.0"
	},
		"web.dom-collections.iterator": {
		android: "66",
		chrome: "66",
		deno: "1.0",
		edge: "74",
		firefox: "60",
		ios: "13.4",
		node: "0.0.1",
		opera: "53",
		opera_mobile: "47",
		rhino: "1.7.13",
		safari: "13.1",
		samsung: "9.0"
	},
		"web.immediate": {
		ie: "10",
		node: "0.9.1"
	},
		"web.queue-microtask": {
		android: "71",
		chrome: "71",
		deno: "1.0",
		edge: "74",
		firefox: "69",
		ios: "12.2",
		node: "12.0",
		opera: "58",
		opera_mobile: "50",
		safari: "12.1",
		samsung: "10.0"
	},
		"web.timers": {
		android: "1.5",
		chrome: "1",
		deno: "1.0",
		edge: "12",
		firefox: "1",
		ie: "10",
		ios: "1.0",
		node: "0.0.1",
		opera: "7",
		opera_mobile: "7",
		phantom: "1.9",
		rhino: "1.7.13",
		safari: "1.0",
		samsung: "1.0"
	},
		"web.url": {
		android: "67",
		chrome: "67",
		deno: "1.0",
		edge: "74",
		firefox: "57",
		ios: "14.0",
		node: "10.0",
		opera: "54",
		opera_mobile: "48",
		safari: "14.0",
		samsung: "9.0"
	},
		"web.url.to-json": {
		android: "71",
		chrome: "71",
		deno: "1.0",
		edge: "74",
		firefox: "57",
		ios: "14.0",
		node: "10.0",
		opera: "58",
		opera_mobile: "50",
		safari: "14.0",
		samsung: "10.0"
	},
		"web.url-search-params": {
		android: "67",
		chrome: "67",
		deno: "1.0",
		edge: "74",
		firefox: "57",
		ios: "14.0",
		node: "10.0",
		opera: "54",
		opera_mobile: "48",
		safari: "14.0",
		samsung: "9.0"
	}
	};

	var data$1 = require$$0$3;

	var debug = typeof browser$4 === 'object' && browser$4.env && browser$4.env.NODE_DEBUG && /\bsemver\b/i.test(browser$4.env.NODE_DEBUG) ? function () {
	  var _console;

	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
	} : function () {};
	var debug_1 = debug;

	var SEMVER_SPEC_VERSION = '2.0.0';
	var MAX_LENGTH$2 = 256;
	var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
	var MAX_SAFE_COMPONENT_LENGTH = 16;
	var constants = {
	  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
	  MAX_LENGTH: MAX_LENGTH$2,
	  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
	  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
	};

	var re_1 = createCommonjsModule(function (module, exports) {
	  var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;
	  exports = module.exports = {};
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var t = exports.t = {};
	  var R = 0;

	  var createToken = function createToken(name, value, isGlobal) {
	    var index = R++;
	    debug_1(index, value);
	    t[name] = index;
	    src[index] = value;
	    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
	  };

	  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
	  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
	  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
	  createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
	  createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
	  createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
	  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
	  createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
	  createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
	  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
	  createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
	  createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
	  createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
	  createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
	  createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
	  createToken('GTLT', '((?:<|>)?=?)');
	  createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
	  createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
	  createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
	  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
	  createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
	  createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
	  createToken('COERCERTL', src[t.COERCE], true);
	  createToken('LONETILDE', '(?:~>?)');
	  createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
	  exports.tildeTrimReplace = '$1~';
	  createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
	  createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('LONECARET', '(?:\\^)');
	  createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
	  exports.caretTrimReplace = '$1^';
	  createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
	  createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
	  createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
	  createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
	  createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
	  exports.comparatorTrimReplace = '$1$2$3';
	  createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
	  createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
	  createToken('STAR', '(<|>)?=?\\s*\\*');
	}, "/$$rollup_base$$/node_modules/core-js-compat/node_modules/semver/internal");

	var numeric = /^[0-9]+$/;

	var compareIdentifiers$1 = function compareIdentifiers(a, b) {
	  var anum = numeric.test(a);
	  var bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	};

	var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
	  return compareIdentifiers$1(b, a);
	};

	var identifiers = {
	  compareIdentifiers: compareIdentifiers$1,
	  rcompareIdentifiers: rcompareIdentifiers
	};

	var MAX_LENGTH$1 = constants.MAX_LENGTH,
	    MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
	var re$2 = re_1.re,
	    t$7 = re_1.t;
	var compareIdentifiers = identifiers.compareIdentifiers;

	var SemVer = function () {
	  function SemVer(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
	        return version;
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError("Invalid Version: " + version);
	    }

	    if (version.length > MAX_LENGTH$1) {
	      throw new TypeError("version is longer than " + MAX_LENGTH$1 + " characters");
	    }

	    debug_1('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    var m = version.trim().match(options.loose ? re$2[t$7.LOOSE] : re$2[t$7.FULL]);

	    if (!m) {
	      throw new TypeError("Invalid Version: " + version);
	    }

	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version');
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version');
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version');
	    }

	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map(function (id) {
	        if (/^[0-9]+$/.test(id)) {
	          var num = +id;

	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num;
	          }
	        }

	        return id;
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  var _proto = SemVer.prototype;

	  _proto.format = function format() {
	    this.version = this.major + "." + this.minor + "." + this.patch;

	    if (this.prerelease.length) {
	      this.version += "-" + this.prerelease.join('.');
	    }

	    return this.version;
	  };

	  _proto.toString = function toString() {
	    return this.version;
	  };

	  _proto.compare = function compare(other) {
	    debug_1('SemVer.compare', this.version, this.options, other);

	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0;
	      }

	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0;
	    }

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  _proto.compareMain = function compareMain(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
	  };

	  _proto.comparePre = function comparePre(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1;
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1;
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0;
	    }

	    var i = 0;

	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      debug_1('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  _proto.compareBuild = function compareBuild(other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    var i = 0;

	    do {
	      var a = this.build[i];
	      var b = other.build[i];
	      debug_1('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  _proto.inc = function inc(release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;

	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;

	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier);
	        }

	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
	          this.major++;
	        }

	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }

	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }

	        this.prerelease = [];
	        break;

	      case 'pre':
	        if (this.prerelease.length === 0) {
	          this.prerelease = [0];
	        } else {
	          var i = this.prerelease.length;

	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }

	          if (i === -1) {
	            this.prerelease.push(0);
	          }
	        }

	        if (identifier) {
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = [identifier, 0];
	            }
	          } else {
	            this.prerelease = [identifier, 0];
	          }
	        }

	        break;

	      default:
	        throw new Error("invalid increment argument: " + release);
	    }

	    this.format();
	    this.raw = this.version;
	    return this;
	  };

	  return SemVer;
	}();

	var semver$2 = SemVer;

	var compare$2 = function compare(a, b, loose) {
	  return new semver$2(a, loose).compare(new semver$2(b, loose));
	};

	var compare_1 = compare$2;

	var eq = function eq(a, b, loose) {
	  return compare_1(a, b, loose) === 0;
	};

	var eq_1 = eq;

	var neq = function neq(a, b, loose) {
	  return compare_1(a, b, loose) !== 0;
	};

	var neq_1 = neq;

	var gt = function gt(a, b, loose) {
	  return compare_1(a, b, loose) > 0;
	};

	var gt_1 = gt;

	var gte = function gte(a, b, loose) {
	  return compare_1(a, b, loose) >= 0;
	};

	var gte_1 = gte;

	var lt = function lt(a, b, loose) {
	  return compare_1(a, b, loose) < 0;
	};

	var lt_1 = lt;

	var lte = function lte(a, b, loose) {
	  return compare_1(a, b, loose) <= 0;
	};

	var lte_1 = lte;

	var cmp = function cmp(a, op, b, loose) {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      return a === b;

	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      return a !== b;

	    case '':
	    case '=':
	    case '==':
	      return eq_1(a, b, loose);

	    case '!=':
	      return neq_1(a, b, loose);

	    case '>':
	      return gt_1(a, b, loose);

	    case '>=':
	      return gte_1(a, b, loose);

	    case '<':
	      return lt_1(a, b, loose);

	    case '<=':
	      return lte_1(a, b, loose);

	    default:
	      throw new TypeError("Invalid operator: " + op);
	  }
	};

	var cmp_1 = cmp;

	var MAX_LENGTH = constants.MAX_LENGTH;
	var re$1 = re_1.re,
	    t$6 = re_1.t;

	var parse = function parse(version, options) {
	  if (!options || typeof options !== 'object') {
	    options = {
	      loose: !!options,
	      includePrerelease: false
	    };
	  }

	  if (version instanceof semver$2) {
	    return version;
	  }

	  if (typeof version !== 'string') {
	    return null;
	  }

	  if (version.length > MAX_LENGTH) {
	    return null;
	  }

	  var r = options.loose ? re$1[t$6.LOOSE] : re$1[t$6.FULL];

	  if (!r.test(version)) {
	    return null;
	  }

	  try {
	    return new semver$2(version, options);
	  } catch (er) {
	    return null;
	  }
	};

	var parse_1 = parse;

	var re = re_1.re,
	    t$5 = re_1.t;

	var coerce = function coerce(version, options) {
	  if (version instanceof semver$2) {
	    return version;
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null;
	  }

	  options = options || {};
	  var match = null;

	  if (!options.rtl) {
	    match = version.match(re[t$5.COERCE]);
	  } else {
	    var next;

	    while ((next = re[t$5.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
	      if (!match || next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }

	      re[t$5.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
	    }

	    re[t$5.COERCERTL].lastIndex = -1;
	  }

	  if (match === null) return null;
	  return parse_1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
	};

	var coerce_1 = coerce;

	var has$4 = Function.call.bind({}.hasOwnProperty);

	function compare$1(a, operator, b) {
	  return cmp_1(coerce_1(a), operator, coerce_1(b));
	}

	function intersection$2(list, order) {
	  var set = list instanceof Set ? list : new Set(list);
	  return order.filter(function (name) {
	    return set.has(name);
	  });
	}

	function sortObjectByKey(object, fn) {
	  return Object.keys(object).sort(fn).reduce(function (memo, key) {
	    memo[key] = object[key];
	    return memo;
	  }, {});
	}

	var helpers = {
	  compare: compare$1,
	  has: has$4,
	  intersection: intersection$2,
	  semver: coerce_1,
	  sortObjectByKey: sortObjectByKey
	};

	var modulesByVersions = {
		"3.0": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.now",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.regexp.constructor",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.to-string",
		"es.set",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.weak-map",
		"es.weak-set",
		"esnext.aggregate-error",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.map.delete-all",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.dispose",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"3.1": [
		"es.string.match-all",
		"es.symbol.match-all",
		"esnext.symbol.replace-all"
	],
		"3.2": [
		"es.promise.all-settled",
		"esnext.array.is-template-object",
		"esnext.map.update-or-insert",
		"esnext.symbol.async-dispose"
	],
		"3.3": [
		"es.global-this",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.upsert",
		"esnext.weak-map.upsert"
	],
		"3.4": [
		"es.json.stringify"
	],
		"3.5": [
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values"
	],
		"3.6": [
		"es.regexp.sticky",
		"es.regexp.test"
	],
		"3.7": [
		"es.aggregate-error",
		"es.promise.any",
		"es.reflect.to-string-tag",
		"es.string.replace-all",
		"esnext.map.emplace",
		"esnext.weak-map.emplace"
	],
		"3.8": [
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.unique-by",
		"esnext.bigint.range",
		"esnext.number.range",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out"
	],
		"3.9": [
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.unique-by"
	],
		"3.11": [
		"esnext.object.has-own"
	],
		"3.12": [
		"esnext.symbol.matcher",
		"esnext.symbol.metadata"
	],
		"3.15": [
		"es.date.get-year",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.escape",
		"es.regexp.dot-all",
		"es.string.substr",
		"es.unescape"
	],
		"3.16": [
		"esnext.array.filter-reject",
		"esnext.array.group-by",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.group-by"
	],
		"3.17": [
		"es.array.at",
		"es.object.has-own",
		"es.string.at-alternative",
		"es.typed-array.at"
	],
		"3.18": [
		"esnext.array.from-async",
		"esnext.typed-array.from-async"
	]
	};

	var modules = [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.aggregate-error",
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.escape",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.global-this",
		"es.json.stringify",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.set",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.unescape",
		"es.weak-map",
		"es.weak-set",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	];

	var compare = helpers.compare,
	    intersection$1 = helpers.intersection,
	    semver$1 = helpers.semver;

	var getModulesListForTargetVersion$2 = function getModulesListForTargetVersion(raw) {
	  var corejs = semver$1(raw);

	  if (corejs.major !== 3) {
	    throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
	  }

	  var result = [];

	  for (var _i = 0, _Object$keys = Object.keys(modulesByVersions); _i < _Object$keys.length; _i++) {
	    var version = _Object$keys[_i];

	    if (compare(version, '<=', corejs)) {
	      result.push.apply(result, _toConsumableArray(modulesByVersions[version]));
	    }
	  }

	  return intersection$1(result, modules);
	};

	var getModulesListForTargetVersion$1 = getModulesListForTargetVersion$2;

	var require$$0$2 = {
		"core-js": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.aggregate-error",
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.escape",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.global-this",
		"es.json.stringify",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.set",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.unescape",
		"es.weak-map",
		"es.weak-set",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/es": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.aggregate-error",
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.escape",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.global-this",
		"es.json.stringify",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.set",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.unescape",
		"es.weak-map",
		"es.weak-set"
	],
		"core-js/es/aggregate-error": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.string.iterator"
	],
		"core-js/es/array": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/es/array-buffer": [
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.object.to-string"
	],
		"core-js/es/array-buffer/constructor": [
		"es.array-buffer.constructor",
		"es.object.to-string"
	],
		"core-js/es/array-buffer/is-view": [
		"es.array-buffer.is-view"
	],
		"core-js/es/array-buffer/slice": [
		"es.array-buffer.slice"
	],
		"core-js/es/array/at": [
		"es.array.at"
	],
		"core-js/es/array/concat": [
		"es.array.concat"
	],
		"core-js/es/array/copy-within": [
		"es.array.copy-within"
	],
		"core-js/es/array/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/every": [
		"es.array.every"
	],
		"core-js/es/array/fill": [
		"es.array.fill"
	],
		"core-js/es/array/filter": [
		"es.array.filter"
	],
		"core-js/es/array/find": [
		"es.array.find"
	],
		"core-js/es/array/find-index": [
		"es.array.find-index"
	],
		"core-js/es/array/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/es/array/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/es/array/for-each": [
		"es.array.for-each"
	],
		"core-js/es/array/from": [
		"es.array.from",
		"es.string.iterator"
	],
		"core-js/es/array/includes": [
		"es.array.includes"
	],
		"core-js/es/array/index-of": [
		"es.array.index-of"
	],
		"core-js/es/array/is-array": [
		"es.array.is-array"
	],
		"core-js/es/array/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/join": [
		"es.array.join"
	],
		"core-js/es/array/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/es/array/map": [
		"es.array.map"
	],
		"core-js/es/array/of": [
		"es.array.of"
	],
		"core-js/es/array/reduce": [
		"es.array.reduce"
	],
		"core-js/es/array/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/es/array/reverse": [
		"es.array.reverse"
	],
		"core-js/es/array/slice": [
		"es.array.slice"
	],
		"core-js/es/array/some": [
		"es.array.some"
	],
		"core-js/es/array/sort": [
		"es.array.sort"
	],
		"core-js/es/array/splice": [
		"es.array.splice"
	],
		"core-js/es/array/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/virtual": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.includes",
		"es.array.index-of",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.object.to-string"
	],
		"core-js/es/array/virtual/at": [
		"es.array.at"
	],
		"core-js/es/array/virtual/concat": [
		"es.array.concat"
	],
		"core-js/es/array/virtual/copy-within": [
		"es.array.copy-within"
	],
		"core-js/es/array/virtual/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/virtual/every": [
		"es.array.every"
	],
		"core-js/es/array/virtual/fill": [
		"es.array.fill"
	],
		"core-js/es/array/virtual/filter": [
		"es.array.filter"
	],
		"core-js/es/array/virtual/find": [
		"es.array.find"
	],
		"core-js/es/array/virtual/find-index": [
		"es.array.find-index"
	],
		"core-js/es/array/virtual/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/es/array/virtual/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/es/array/virtual/for-each": [
		"es.array.for-each"
	],
		"core-js/es/array/virtual/includes": [
		"es.array.includes"
	],
		"core-js/es/array/virtual/index-of": [
		"es.array.index-of"
	],
		"core-js/es/array/virtual/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/virtual/join": [
		"es.array.join"
	],
		"core-js/es/array/virtual/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/array/virtual/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/es/array/virtual/map": [
		"es.array.map"
	],
		"core-js/es/array/virtual/reduce": [
		"es.array.reduce"
	],
		"core-js/es/array/virtual/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/es/array/virtual/reverse": [
		"es.array.reverse"
	],
		"core-js/es/array/virtual/slice": [
		"es.array.slice"
	],
		"core-js/es/array/virtual/some": [
		"es.array.some"
	],
		"core-js/es/array/virtual/sort": [
		"es.array.sort"
	],
		"core-js/es/array/virtual/splice": [
		"es.array.splice"
	],
		"core-js/es/array/virtual/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/data-view": [
		"es.data-view",
		"es.object.to-string"
	],
		"core-js/es/date": [
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string"
	],
		"core-js/es/date/get-year": [
		"es.date.get-year"
	],
		"core-js/es/date/now": [
		"es.date.now"
	],
		"core-js/es/date/set-year": [
		"es.date.set-year"
	],
		"core-js/es/date/to-gmt-string": [
		"es.date.to-gmt-string"
	],
		"core-js/es/date/to-iso-string": [
		"es.date.to-iso-string",
		"es.date.to-json"
	],
		"core-js/es/date/to-json": [
		"es.date.to-json"
	],
		"core-js/es/date/to-primitive": [
		"es.date.to-primitive"
	],
		"core-js/es/date/to-string": [
		"es.date.to-string"
	],
		"core-js/es/escape": [
		"es.escape"
	],
		"core-js/es/function": [
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name"
	],
		"core-js/es/function/bind": [
		"es.function.bind"
	],
		"core-js/es/function/has-instance": [
		"es.function.has-instance"
	],
		"core-js/es/function/name": [
		"es.function.name"
	],
		"core-js/es/function/virtual": [
		"es.function.bind"
	],
		"core-js/es/function/virtual/bind": [
		"es.function.bind"
	],
		"core-js/es/get-iterator": [
		"es.array.iterator",
		"es.string.iterator"
	],
		"core-js/es/get-iterator-method": [
		"es.array.iterator",
		"es.string.iterator"
	],
		"core-js/es/global-this": [
		"es.global-this"
	],
		"core-js/es/instance/at": [
		"es.array.at",
		"es.string.at-alternative"
	],
		"core-js/es/instance/bind": [
		"es.function.bind"
	],
		"core-js/es/instance/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/es/instance/concat": [
		"es.array.concat"
	],
		"core-js/es/instance/copy-within": [
		"es.array.copy-within"
	],
		"core-js/es/instance/ends-with": [
		"es.string.ends-with"
	],
		"core-js/es/instance/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/instance/every": [
		"es.array.every"
	],
		"core-js/es/instance/fill": [
		"es.array.fill"
	],
		"core-js/es/instance/filter": [
		"es.array.filter"
	],
		"core-js/es/instance/find": [
		"es.array.find"
	],
		"core-js/es/instance/find-index": [
		"es.array.find-index"
	],
		"core-js/es/instance/flags": [
		"es.regexp.flags"
	],
		"core-js/es/instance/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/es/instance/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/es/instance/for-each": [
		"es.array.for-each"
	],
		"core-js/es/instance/includes": [
		"es.array.includes",
		"es.string.includes"
	],
		"core-js/es/instance/index-of": [
		"es.array.index-of"
	],
		"core-js/es/instance/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/instance/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/es/instance/map": [
		"es.array.map"
	],
		"core-js/es/instance/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/es/instance/pad-end": [
		"es.string.pad-end"
	],
		"core-js/es/instance/pad-start": [
		"es.string.pad-start"
	],
		"core-js/es/instance/reduce": [
		"es.array.reduce"
	],
		"core-js/es/instance/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/es/instance/repeat": [
		"es.string.repeat"
	],
		"core-js/es/instance/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/es/instance/reverse": [
		"es.array.reverse"
	],
		"core-js/es/instance/slice": [
		"es.array.slice"
	],
		"core-js/es/instance/some": [
		"es.array.some"
	],
		"core-js/es/instance/sort": [
		"es.array.sort"
	],
		"core-js/es/instance/splice": [
		"es.array.splice"
	],
		"core-js/es/instance/starts-with": [
		"es.string.starts-with"
	],
		"core-js/es/instance/trim": [
		"es.string.trim"
	],
		"core-js/es/instance/trim-end": [
		"es.string.trim-end"
	],
		"core-js/es/instance/trim-left": [
		"es.string.trim-start"
	],
		"core-js/es/instance/trim-right": [
		"es.string.trim-end"
	],
		"core-js/es/instance/trim-start": [
		"es.string.trim-start"
	],
		"core-js/es/instance/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/es/is-iterable": [
		"es.array.iterator",
		"es.string.iterator"
	],
		"core-js/es/json": [
		"es.json.stringify",
		"es.json.to-string-tag"
	],
		"core-js/es/json/stringify": [
		"es.json.stringify"
	],
		"core-js/es/json/to-string-tag": [
		"es.json.to-string-tag"
	],
		"core-js/es/map": [
		"es.array.iterator",
		"es.map",
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/es/math": [
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc"
	],
		"core-js/es/math/acosh": [
		"es.math.acosh"
	],
		"core-js/es/math/asinh": [
		"es.math.asinh"
	],
		"core-js/es/math/atanh": [
		"es.math.atanh"
	],
		"core-js/es/math/cbrt": [
		"es.math.cbrt"
	],
		"core-js/es/math/clz32": [
		"es.math.clz32"
	],
		"core-js/es/math/cosh": [
		"es.math.cosh"
	],
		"core-js/es/math/expm1": [
		"es.math.expm1"
	],
		"core-js/es/math/fround": [
		"es.math.fround"
	],
		"core-js/es/math/hypot": [
		"es.math.hypot"
	],
		"core-js/es/math/imul": [
		"es.math.imul"
	],
		"core-js/es/math/log10": [
		"es.math.log10"
	],
		"core-js/es/math/log1p": [
		"es.math.log1p"
	],
		"core-js/es/math/log2": [
		"es.math.log2"
	],
		"core-js/es/math/sign": [
		"es.math.sign"
	],
		"core-js/es/math/sinh": [
		"es.math.sinh"
	],
		"core-js/es/math/tanh": [
		"es.math.tanh"
	],
		"core-js/es/math/to-string-tag": [
		"es.math.to-string-tag"
	],
		"core-js/es/math/trunc": [
		"es.math.trunc"
	],
		"core-js/es/number": [
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision"
	],
		"core-js/es/number/constructor": [
		"es.number.constructor"
	],
		"core-js/es/number/epsilon": [
		"es.number.epsilon"
	],
		"core-js/es/number/is-finite": [
		"es.number.is-finite"
	],
		"core-js/es/number/is-integer": [
		"es.number.is-integer"
	],
		"core-js/es/number/is-nan": [
		"es.number.is-nan"
	],
		"core-js/es/number/is-safe-integer": [
		"es.number.is-safe-integer"
	],
		"core-js/es/number/max-safe-integer": [
		"es.number.max-safe-integer"
	],
		"core-js/es/number/min-safe-integer": [
		"es.number.min-safe-integer"
	],
		"core-js/es/number/parse-float": [
		"es.number.parse-float"
	],
		"core-js/es/number/parse-int": [
		"es.number.parse-int"
	],
		"core-js/es/number/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/es/number/to-precision": [
		"es.number.to-precision"
	],
		"core-js/es/number/virtual": [
		"es.number.to-fixed",
		"es.number.to-precision"
	],
		"core-js/es/number/virtual/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/es/number/virtual/to-precision": [
		"es.number.to-precision"
	],
		"core-js/es/object": [
		"es.symbol",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.reflect.to-string-tag"
	],
		"core-js/es/object/assign": [
		"es.object.assign"
	],
		"core-js/es/object/create": [
		"es.object.create"
	],
		"core-js/es/object/define-getter": [
		"es.object.define-getter"
	],
		"core-js/es/object/define-properties": [
		"es.object.define-properties"
	],
		"core-js/es/object/define-property": [
		"es.object.define-property"
	],
		"core-js/es/object/define-setter": [
		"es.object.define-setter"
	],
		"core-js/es/object/entries": [
		"es.object.entries"
	],
		"core-js/es/object/freeze": [
		"es.object.freeze"
	],
		"core-js/es/object/from-entries": [
		"es.array.iterator",
		"es.object.from-entries"
	],
		"core-js/es/object/get-own-property-descriptor": [
		"es.object.get-own-property-descriptor"
	],
		"core-js/es/object/get-own-property-descriptors": [
		"es.object.get-own-property-descriptors"
	],
		"core-js/es/object/get-own-property-names": [
		"es.object.get-own-property-names"
	],
		"core-js/es/object/get-own-property-symbols": [
		"es.symbol"
	],
		"core-js/es/object/get-prototype-of": [
		"es.object.get-prototype-of"
	],
		"core-js/es/object/has-own": [
		"es.object.has-own"
	],
		"core-js/es/object/is": [
		"es.object.is"
	],
		"core-js/es/object/is-extensible": [
		"es.object.is-extensible"
	],
		"core-js/es/object/is-frozen": [
		"es.object.is-frozen"
	],
		"core-js/es/object/is-sealed": [
		"es.object.is-sealed"
	],
		"core-js/es/object/keys": [
		"es.object.keys"
	],
		"core-js/es/object/lookup-getter": [
		"es.object.lookup-setter"
	],
		"core-js/es/object/lookup-setter": [
		"es.object.lookup-setter"
	],
		"core-js/es/object/prevent-extensions": [
		"es.object.prevent-extensions"
	],
		"core-js/es/object/seal": [
		"es.object.seal"
	],
		"core-js/es/object/set-prototype-of": [
		"es.object.set-prototype-of"
	],
		"core-js/es/object/to-string": [
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/es/object/values": [
		"es.object.values"
	],
		"core-js/es/parse-float": [
		"es.parse-float"
	],
		"core-js/es/parse-int": [
		"es.parse-int"
	],
		"core-js/es/promise": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.string.iterator"
	],
		"core-js/es/promise/all-settled": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.string.iterator"
	],
		"core-js/es/promise/any": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.any",
		"es.string.iterator"
	],
		"core-js/es/promise/finally": [
		"es.object.to-string",
		"es.promise",
		"es.promise.finally"
	],
		"core-js/es/reflect": [
		"es.object.to-string",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag"
	],
		"core-js/es/reflect/apply": [
		"es.reflect.apply"
	],
		"core-js/es/reflect/construct": [
		"es.reflect.construct"
	],
		"core-js/es/reflect/define-property": [
		"es.reflect.define-property"
	],
		"core-js/es/reflect/delete-property": [
		"es.reflect.delete-property"
	],
		"core-js/es/reflect/get": [
		"es.reflect.get"
	],
		"core-js/es/reflect/get-own-property-descriptor": [
		"es.reflect.get-own-property-descriptor"
	],
		"core-js/es/reflect/get-prototype-of": [
		"es.reflect.get-prototype-of"
	],
		"core-js/es/reflect/has": [
		"es.reflect.has"
	],
		"core-js/es/reflect/is-extensible": [
		"es.reflect.is-extensible"
	],
		"core-js/es/reflect/own-keys": [
		"es.reflect.own-keys"
	],
		"core-js/es/reflect/prevent-extensions": [
		"es.reflect.prevent-extensions"
	],
		"core-js/es/reflect/set": [
		"es.reflect.set"
	],
		"core-js/es/reflect/set-prototype-of": [
		"es.reflect.set-prototype-of"
	],
		"core-js/es/reflect/to-string-tag": [
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/es/regexp": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.string.match",
		"es.string.replace",
		"es.string.search",
		"es.string.split"
	],
		"core-js/es/regexp/constructor": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/es/regexp/dot-all": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec"
	],
		"core-js/es/regexp/flags": [
		"es.regexp.flags"
	],
		"core-js/es/regexp/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/es/regexp/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/es/regexp/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/es/regexp/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/es/regexp/sticky": [
		"es.regexp.constructor",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/es/regexp/test": [
		"es.regexp.exec",
		"es.regexp.test"
	],
		"core-js/es/regexp/to-string": [
		"es.regexp.to-string"
	],
		"core-js/es/set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.set",
		"es.string.iterator"
	],
		"core-js/es/string": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup"
	],
		"core-js/es/string/anchor": [
		"es.string.anchor"
	],
		"core-js/es/string/at": [
		"es.string.at-alternative"
	],
		"core-js/es/string/big": [
		"es.string.big"
	],
		"core-js/es/string/blink": [
		"es.string.blink"
	],
		"core-js/es/string/bold": [
		"es.string.bold"
	],
		"core-js/es/string/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/es/string/ends-with": [
		"es.string.ends-with"
	],
		"core-js/es/string/fixed": [
		"es.string.fixed"
	],
		"core-js/es/string/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/es/string/fontsize": [
		"es.string.fontsize"
	],
		"core-js/es/string/from-code-point": [
		"es.string.from-code-point"
	],
		"core-js/es/string/includes": [
		"es.string.includes"
	],
		"core-js/es/string/italics": [
		"es.string.italics"
	],
		"core-js/es/string/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/es/string/link": [
		"es.string.link"
	],
		"core-js/es/string/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/es/string/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/es/string/pad-end": [
		"es.string.pad-end"
	],
		"core-js/es/string/pad-start": [
		"es.string.pad-start"
	],
		"core-js/es/string/raw": [
		"es.string.raw"
	],
		"core-js/es/string/repeat": [
		"es.string.repeat"
	],
		"core-js/es/string/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/es/string/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/es/string/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/es/string/small": [
		"es.string.small"
	],
		"core-js/es/string/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/es/string/starts-with": [
		"es.string.starts-with"
	],
		"core-js/es/string/strike": [
		"es.string.strike"
	],
		"core-js/es/string/sub": [
		"es.string.sub"
	],
		"core-js/es/string/substr": [
		"es.string.substr"
	],
		"core-js/es/string/sup": [
		"es.string.sup"
	],
		"core-js/es/string/trim": [
		"es.string.trim"
	],
		"core-js/es/string/trim-end": [
		"es.string.trim-end"
	],
		"core-js/es/string/trim-left": [
		"es.string.trim-start"
	],
		"core-js/es/string/trim-right": [
		"es.string.trim-end"
	],
		"core-js/es/string/trim-start": [
		"es.string.trim-start"
	],
		"core-js/es/string/virtual": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup"
	],
		"core-js/es/string/virtual/anchor": [
		"es.string.anchor"
	],
		"core-js/es/string/virtual/at": [
		"es.string.at-alternative"
	],
		"core-js/es/string/virtual/big": [
		"es.string.big"
	],
		"core-js/es/string/virtual/blink": [
		"es.string.blink"
	],
		"core-js/es/string/virtual/bold": [
		"es.string.bold"
	],
		"core-js/es/string/virtual/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/es/string/virtual/ends-with": [
		"es.string.ends-with"
	],
		"core-js/es/string/virtual/fixed": [
		"es.string.fixed"
	],
		"core-js/es/string/virtual/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/es/string/virtual/fontsize": [
		"es.string.fontsize"
	],
		"core-js/es/string/virtual/includes": [
		"es.string.includes"
	],
		"core-js/es/string/virtual/italics": [
		"es.string.italics"
	],
		"core-js/es/string/virtual/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/es/string/virtual/link": [
		"es.string.link"
	],
		"core-js/es/string/virtual/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/es/string/virtual/pad-end": [
		"es.string.pad-end"
	],
		"core-js/es/string/virtual/pad-start": [
		"es.string.pad-start"
	],
		"core-js/es/string/virtual/repeat": [
		"es.string.repeat"
	],
		"core-js/es/string/virtual/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/es/string/virtual/small": [
		"es.string.small"
	],
		"core-js/es/string/virtual/starts-with": [
		"es.string.starts-with"
	],
		"core-js/es/string/virtual/strike": [
		"es.string.strike"
	],
		"core-js/es/string/virtual/sub": [
		"es.string.sub"
	],
		"core-js/es/string/virtual/substr": [
		"es.string.substr"
	],
		"core-js/es/string/virtual/sup": [
		"es.string.sup"
	],
		"core-js/es/string/virtual/trim": [
		"es.string.trim"
	],
		"core-js/es/string/virtual/trim-end": [
		"es.string.trim-end"
	],
		"core-js/es/string/virtual/trim-left": [
		"es.string.trim-start"
	],
		"core-js/es/string/virtual/trim-right": [
		"es.string.trim-end"
	],
		"core-js/es/string/virtual/trim-start": [
		"es.string.trim-start"
	],
		"core-js/es/symbol": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.array.concat",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/es/symbol/async-iterator": [
		"es.symbol.async-iterator"
	],
		"core-js/es/symbol/description": [
		"es.symbol.description"
	],
		"core-js/es/symbol/for": [
		"es.symbol"
	],
		"core-js/es/symbol/has-instance": [
		"es.symbol.has-instance",
		"es.function.has-instance"
	],
		"core-js/es/symbol/is-concat-spreadable": [
		"es.symbol.is-concat-spreadable",
		"es.array.concat"
	],
		"core-js/es/symbol/iterator": [
		"es.symbol.iterator",
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/es/symbol/key-for": [
		"es.symbol"
	],
		"core-js/es/symbol/match": [
		"es.symbol.match",
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/es/symbol/match-all": [
		"es.symbol.match-all",
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/es/symbol/replace": [
		"es.symbol.replace",
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/es/symbol/search": [
		"es.symbol.search",
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/es/symbol/species": [
		"es.symbol.species"
	],
		"core-js/es/symbol/split": [
		"es.symbol.split",
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/es/symbol/to-primitive": [
		"es.symbol.to-primitive",
		"es.date.to-primitive"
	],
		"core-js/es/symbol/to-string-tag": [
		"es.symbol.to-string-tag",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/es/symbol/unscopables": [
		"es.symbol.unscopables"
	],
		"core-js/es/typed-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/at": [
		"es.typed-array.at"
	],
		"core-js/es/typed-array/copy-within": [
		"es.typed-array.copy-within"
	],
		"core-js/es/typed-array/entries": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/es/typed-array/every": [
		"es.typed-array.every"
	],
		"core-js/es/typed-array/fill": [
		"es.typed-array.fill"
	],
		"core-js/es/typed-array/filter": [
		"es.typed-array.filter"
	],
		"core-js/es/typed-array/find": [
		"es.typed-array.find"
	],
		"core-js/es/typed-array/find-index": [
		"es.typed-array.find-index"
	],
		"core-js/es/typed-array/float32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/float64-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float64-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/for-each": [
		"es.typed-array.for-each"
	],
		"core-js/es/typed-array/from": [
		"es.typed-array.from"
	],
		"core-js/es/typed-array/includes": [
		"es.typed-array.includes"
	],
		"core-js/es/typed-array/index-of": [
		"es.typed-array.index-of"
	],
		"core-js/es/typed-array/int16-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/int32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/int8-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/iterator": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/es/typed-array/join": [
		"es.typed-array.join"
	],
		"core-js/es/typed-array/keys": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/es/typed-array/last-index-of": [
		"es.typed-array.last-index-of"
	],
		"core-js/es/typed-array/map": [
		"es.typed-array.map"
	],
		"core-js/es/typed-array/methods": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/of": [
		"es.typed-array.of"
	],
		"core-js/es/typed-array/reduce": [
		"es.typed-array.reduce"
	],
		"core-js/es/typed-array/reduce-right": [
		"es.typed-array.reduce-right"
	],
		"core-js/es/typed-array/reverse": [
		"es.typed-array.reverse"
	],
		"core-js/es/typed-array/set": [
		"es.typed-array.set"
	],
		"core-js/es/typed-array/slice": [
		"es.typed-array.slice"
	],
		"core-js/es/typed-array/some": [
		"es.typed-array.some"
	],
		"core-js/es/typed-array/sort": [
		"es.typed-array.sort"
	],
		"core-js/es/typed-array/subarray": [
		"es.typed-array.subarray"
	],
		"core-js/es/typed-array/to-locale-string": [
		"es.typed-array.to-locale-string"
	],
		"core-js/es/typed-array/to-string": [
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/uint16-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/uint32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/uint8-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/uint8-clamped-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/es/typed-array/values": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/es/unescape": [
		"es.unescape"
	],
		"core-js/es/weak-map": [
		"es.array.iterator",
		"es.object.to-string",
		"es.weak-map"
	],
		"core-js/es/weak-set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.weak-set"
	],
		"core-js/features": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.aggregate-error",
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.escape",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.global-this",
		"es.json.stringify",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.set",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.unescape",
		"es.weak-map",
		"es.weak-set",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/features/aggregate-error": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.string.iterator",
		"esnext.aggregate-error",
		"web.dom-collections.iterator"
	],
		"core-js/features/array": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by"
	],
		"core-js/features/array-buffer": [
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.object.to-string"
	],
		"core-js/features/array-buffer/constructor": [
		"es.array-buffer.constructor",
		"es.object.to-string"
	],
		"core-js/features/array-buffer/is-view": [
		"es.array-buffer.is-view"
	],
		"core-js/features/array-buffer/slice": [
		"es.array-buffer.slice"
	],
		"core-js/features/array/at": [
		"es.array.at",
		"esnext.array.at"
	],
		"core-js/features/array/concat": [
		"es.array.concat"
	],
		"core-js/features/array/copy-within": [
		"es.array.copy-within"
	],
		"core-js/features/array/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/every": [
		"es.array.every"
	],
		"core-js/features/array/fill": [
		"es.array.fill"
	],
		"core-js/features/array/filter": [
		"es.array.filter"
	],
		"core-js/features/array/filter-out": [
		"esnext.array.filter-out"
	],
		"core-js/features/array/filter-reject": [
		"esnext.array.filter-reject"
	],
		"core-js/features/array/find": [
		"es.array.find"
	],
		"core-js/features/array/find-index": [
		"es.array.find-index"
	],
		"core-js/features/array/find-last": [
		"esnext.array.find-last"
	],
		"core-js/features/array/find-last-index": [
		"esnext.array.find-last-index"
	],
		"core-js/features/array/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/features/array/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/features/array/for-each": [
		"es.array.for-each"
	],
		"core-js/features/array/from": [
		"es.array.from",
		"es.string.iterator"
	],
		"core-js/features/array/from-async": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"esnext.array.from-async"
	],
		"core-js/features/array/group-by": [
		"esnext.array.group-by"
	],
		"core-js/features/array/includes": [
		"es.array.includes"
	],
		"core-js/features/array/index-of": [
		"es.array.index-of"
	],
		"core-js/features/array/is-array": [
		"es.array.is-array"
	],
		"core-js/features/array/is-template-object": [
		"esnext.array.is-template-object"
	],
		"core-js/features/array/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/join": [
		"es.array.join"
	],
		"core-js/features/array/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/last-index": [
		"esnext.array.last-index"
	],
		"core-js/features/array/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/features/array/last-item": [
		"esnext.array.last-item"
	],
		"core-js/features/array/map": [
		"es.array.map"
	],
		"core-js/features/array/of": [
		"es.array.of"
	],
		"core-js/features/array/reduce": [
		"es.array.reduce"
	],
		"core-js/features/array/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/features/array/reverse": [
		"es.array.reverse"
	],
		"core-js/features/array/slice": [
		"es.array.slice"
	],
		"core-js/features/array/some": [
		"es.array.some"
	],
		"core-js/features/array/sort": [
		"es.array.sort"
	],
		"core-js/features/array/splice": [
		"es.array.splice"
	],
		"core-js/features/array/unique-by": [
		"es.map",
		"esnext.array.unique-by"
	],
		"core-js/features/array/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/virtual": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.includes",
		"es.array.index-of",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.map",
		"es.object.to-string",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.unique-by"
	],
		"core-js/features/array/virtual/at": [
		"es.array.at",
		"esnext.array.at"
	],
		"core-js/features/array/virtual/concat": [
		"es.array.concat"
	],
		"core-js/features/array/virtual/copy-within": [
		"es.array.copy-within"
	],
		"core-js/features/array/virtual/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/virtual/every": [
		"es.array.every"
	],
		"core-js/features/array/virtual/fill": [
		"es.array.fill"
	],
		"core-js/features/array/virtual/filter": [
		"es.array.filter"
	],
		"core-js/features/array/virtual/filter-out": [
		"esnext.array.filter-out"
	],
		"core-js/features/array/virtual/filter-reject": [
		"esnext.array.filter-reject"
	],
		"core-js/features/array/virtual/find": [
		"es.array.find"
	],
		"core-js/features/array/virtual/find-index": [
		"es.array.find-index"
	],
		"core-js/features/array/virtual/find-last": [
		"esnext.array.find-last"
	],
		"core-js/features/array/virtual/find-last-index": [
		"esnext.array.find-last-index"
	],
		"core-js/features/array/virtual/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/features/array/virtual/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/features/array/virtual/for-each": [
		"es.array.for-each"
	],
		"core-js/features/array/virtual/group-by": [
		"esnext.array.group-by"
	],
		"core-js/features/array/virtual/includes": [
		"es.array.includes"
	],
		"core-js/features/array/virtual/index-of": [
		"es.array.index-of"
	],
		"core-js/features/array/virtual/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/virtual/join": [
		"es.array.join"
	],
		"core-js/features/array/virtual/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/array/virtual/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/features/array/virtual/map": [
		"es.array.map"
	],
		"core-js/features/array/virtual/reduce": [
		"es.array.reduce"
	],
		"core-js/features/array/virtual/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/features/array/virtual/reverse": [
		"es.array.reverse"
	],
		"core-js/features/array/virtual/slice": [
		"es.array.slice"
	],
		"core-js/features/array/virtual/some": [
		"es.array.some"
	],
		"core-js/features/array/virtual/sort": [
		"es.array.sort"
	],
		"core-js/features/array/virtual/splice": [
		"es.array.splice"
	],
		"core-js/features/array/virtual/unique-by": [
		"es.map",
		"esnext.array.unique-by"
	],
		"core-js/features/array/virtual/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/features/async-iterator": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"web.dom-collections.iterator"
	],
		"core-js/features/async-iterator/as-indexed-pairs": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs"
	],
		"core-js/features/async-iterator/drop": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.drop"
	],
		"core-js/features/async-iterator/every": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.every"
	],
		"core-js/features/async-iterator/filter": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.filter"
	],
		"core-js/features/async-iterator/find": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.find"
	],
		"core-js/features/async-iterator/flat-map": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.flat-map"
	],
		"core-js/features/async-iterator/for-each": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.for-each"
	],
		"core-js/features/async-iterator/from": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/async-iterator/map": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.map"
	],
		"core-js/features/async-iterator/reduce": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.reduce"
	],
		"core-js/features/async-iterator/some": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.some"
	],
		"core-js/features/async-iterator/take": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.take"
	],
		"core-js/features/async-iterator/to-array": [
		"es.object.to-string",
		"es.promise",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.to-array"
	],
		"core-js/features/bigint": [
		"es.object.to-string",
		"esnext.bigint.range"
	],
		"core-js/features/bigint/range": [
		"es.object.to-string",
		"esnext.bigint.range"
	],
		"core-js/features/clear-immediate": [
		"web.immediate"
	],
		"core-js/features/composite-key": [
		"esnext.composite-key"
	],
		"core-js/features/composite-symbol": [
		"es.symbol",
		"esnext.composite-symbol"
	],
		"core-js/features/data-view": [
		"es.data-view",
		"es.object.to-string"
	],
		"core-js/features/date": [
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string"
	],
		"core-js/features/date/get-year": [
		"es.date.get-year"
	],
		"core-js/features/date/now": [
		"es.date.now"
	],
		"core-js/features/date/set-year": [
		"es.date.set-year"
	],
		"core-js/features/date/to-gmt-string": [
		"es.date.to-gmt-string"
	],
		"core-js/features/date/to-iso-string": [
		"es.date.to-iso-string",
		"es.date.to-json"
	],
		"core-js/features/date/to-json": [
		"es.date.to-json"
	],
		"core-js/features/date/to-primitive": [
		"es.date.to-primitive"
	],
		"core-js/features/date/to-string": [
		"es.date.to-string"
	],
		"core-js/features/dom-collections": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator"
	],
		"core-js/features/dom-collections/for-each": [
		"web.dom-collections.for-each"
	],
		"core-js/features/dom-collections/iterator": [
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/features/escape": [
		"es.escape"
	],
		"core-js/features/function": [
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name"
	],
		"core-js/features/function/bind": [
		"es.function.bind"
	],
		"core-js/features/function/has-instance": [
		"es.function.has-instance"
	],
		"core-js/features/function/name": [
		"es.function.name"
	],
		"core-js/features/function/virtual": [
		"es.function.bind"
	],
		"core-js/features/function/virtual/bind": [
		"es.function.bind"
	],
		"core-js/features/get-iterator": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/features/get-iterator-method": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/features/global-this": [
		"es.global-this",
		"esnext.global-this"
	],
		"core-js/features/instance/at": [
		"es.array.at",
		"es.string.at-alternative",
		"esnext.array.at",
		"esnext.string.at"
	],
		"core-js/features/instance/bind": [
		"es.function.bind"
	],
		"core-js/features/instance/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/features/instance/code-points": [
		"es.object.to-string",
		"esnext.string.code-points"
	],
		"core-js/features/instance/concat": [
		"es.array.concat"
	],
		"core-js/features/instance/copy-within": [
		"es.array.copy-within"
	],
		"core-js/features/instance/ends-with": [
		"es.string.ends-with"
	],
		"core-js/features/instance/entries": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/features/instance/every": [
		"es.array.every"
	],
		"core-js/features/instance/fill": [
		"es.array.fill"
	],
		"core-js/features/instance/filter": [
		"es.array.filter"
	],
		"core-js/features/instance/filter-out": [
		"esnext.array.filter-out"
	],
		"core-js/features/instance/filter-reject": [
		"esnext.array.filter-reject"
	],
		"core-js/features/instance/find": [
		"es.array.find"
	],
		"core-js/features/instance/find-index": [
		"es.array.find-index"
	],
		"core-js/features/instance/find-last": [
		"esnext.array.find-last"
	],
		"core-js/features/instance/find-last-index": [
		"esnext.array.find-last-index"
	],
		"core-js/features/instance/flags": [
		"es.regexp.flags"
	],
		"core-js/features/instance/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/features/instance/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/features/instance/for-each": [
		"es.array.for-each",
		"web.dom-collections.iterator"
	],
		"core-js/features/instance/group-by": [
		"esnext.array.group-by"
	],
		"core-js/features/instance/includes": [
		"es.array.includes",
		"es.string.includes"
	],
		"core-js/features/instance/index-of": [
		"es.array.index-of"
	],
		"core-js/features/instance/keys": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/features/instance/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/features/instance/map": [
		"es.array.map"
	],
		"core-js/features/instance/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all",
		"esnext.string.match-all"
	],
		"core-js/features/instance/pad-end": [
		"es.string.pad-end"
	],
		"core-js/features/instance/pad-start": [
		"es.string.pad-start"
	],
		"core-js/features/instance/reduce": [
		"es.array.reduce"
	],
		"core-js/features/instance/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/features/instance/repeat": [
		"es.string.repeat"
	],
		"core-js/features/instance/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/features/instance/reverse": [
		"es.array.reverse"
	],
		"core-js/features/instance/slice": [
		"es.array.slice"
	],
		"core-js/features/instance/some": [
		"es.array.some"
	],
		"core-js/features/instance/sort": [
		"es.array.sort"
	],
		"core-js/features/instance/splice": [
		"es.array.splice"
	],
		"core-js/features/instance/starts-with": [
		"es.string.starts-with"
	],
		"core-js/features/instance/trim": [
		"es.string.trim"
	],
		"core-js/features/instance/trim-end": [
		"es.string.trim-end"
	],
		"core-js/features/instance/trim-left": [
		"es.string.trim-start"
	],
		"core-js/features/instance/trim-right": [
		"es.string.trim-end"
	],
		"core-js/features/instance/trim-start": [
		"es.string.trim-start"
	],
		"core-js/features/instance/unique-by": [
		"es.map",
		"esnext.array.unique-by"
	],
		"core-js/features/instance/values": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/features/is-iterable": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/features/iterator": [
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"web.dom-collections.iterator"
	],
		"core-js/features/iterator/as-indexed-pairs": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs"
	],
		"core-js/features/iterator/drop": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.drop"
	],
		"core-js/features/iterator/every": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.every"
	],
		"core-js/features/iterator/filter": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.filter"
	],
		"core-js/features/iterator/find": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.find"
	],
		"core-js/features/iterator/flat-map": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.flat-map"
	],
		"core-js/features/iterator/for-each": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.for-each"
	],
		"core-js/features/iterator/from": [
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"esnext.iterator.constructor",
		"esnext.iterator.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/iterator/map": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.map"
	],
		"core-js/features/iterator/reduce": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.reduce"
	],
		"core-js/features/iterator/some": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.some"
	],
		"core-js/features/iterator/take": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.take"
	],
		"core-js/features/iterator/to-array": [
		"es.object.to-string",
		"esnext.iterator.constructor",
		"esnext.iterator.to-array"
	],
		"core-js/features/json": [
		"es.json.stringify",
		"es.json.to-string-tag"
	],
		"core-js/features/json/stringify": [
		"es.json.stringify"
	],
		"core-js/features/json/to-string-tag": [
		"es.json.to-string-tag"
	],
		"core-js/features/map": [
		"es.array.iterator",
		"es.map",
		"es.object.to-string",
		"es.string.iterator",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"web.dom-collections.iterator"
	],
		"core-js/features/map/delete-all": [
		"es.map",
		"esnext.map.delete-all"
	],
		"core-js/features/map/emplace": [
		"es.map",
		"esnext.map.emplace"
	],
		"core-js/features/map/every": [
		"es.map",
		"esnext.map.every"
	],
		"core-js/features/map/filter": [
		"es.map",
		"esnext.map.filter"
	],
		"core-js/features/map/find": [
		"es.map",
		"esnext.map.find"
	],
		"core-js/features/map/find-key": [
		"es.map",
		"esnext.map.find-key"
	],
		"core-js/features/map/from": [
		"es.array.iterator",
		"es.map",
		"es.string.iterator",
		"esnext.map.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/map/group-by": [
		"es.map",
		"esnext.map.group-by"
	],
		"core-js/features/map/includes": [
		"es.map",
		"esnext.map.includes"
	],
		"core-js/features/map/key-by": [
		"es.map",
		"esnext.map.key-by"
	],
		"core-js/features/map/key-of": [
		"es.map",
		"esnext.map.key-of"
	],
		"core-js/features/map/map-keys": [
		"es.map",
		"esnext.map.map-keys"
	],
		"core-js/features/map/map-values": [
		"es.map",
		"esnext.map.map-values"
	],
		"core-js/features/map/merge": [
		"es.map",
		"esnext.map.merge"
	],
		"core-js/features/map/of": [
		"es.array.iterator",
		"es.map",
		"esnext.map.of"
	],
		"core-js/features/map/reduce": [
		"es.map",
		"esnext.map.reduce"
	],
		"core-js/features/map/some": [
		"es.map",
		"esnext.map.some"
	],
		"core-js/features/map/update": [
		"es.map",
		"esnext.map.update"
	],
		"core-js/features/map/update-or-insert": [
		"es.map",
		"esnext.map.update-or-insert"
	],
		"core-js/features/map/upsert": [
		"es.map",
		"esnext.map.upsert"
	],
		"core-js/features/math": [
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh"
	],
		"core-js/features/math/acosh": [
		"es.math.acosh"
	],
		"core-js/features/math/asinh": [
		"es.math.asinh"
	],
		"core-js/features/math/atanh": [
		"es.math.atanh"
	],
		"core-js/features/math/cbrt": [
		"es.math.cbrt"
	],
		"core-js/features/math/clamp": [
		"esnext.math.clamp"
	],
		"core-js/features/math/clz32": [
		"es.math.clz32"
	],
		"core-js/features/math/cosh": [
		"es.math.cosh"
	],
		"core-js/features/math/deg-per-rad": [
		"esnext.math.deg-per-rad"
	],
		"core-js/features/math/degrees": [
		"esnext.math.degrees"
	],
		"core-js/features/math/expm1": [
		"es.math.expm1"
	],
		"core-js/features/math/fround": [
		"es.math.fround"
	],
		"core-js/features/math/fscale": [
		"esnext.math.fscale"
	],
		"core-js/features/math/hypot": [
		"es.math.hypot"
	],
		"core-js/features/math/iaddh": [
		"esnext.math.iaddh"
	],
		"core-js/features/math/imul": [
		"es.math.imul"
	],
		"core-js/features/math/imulh": [
		"esnext.math.imulh"
	],
		"core-js/features/math/isubh": [
		"esnext.math.isubh"
	],
		"core-js/features/math/log10": [
		"es.math.log10"
	],
		"core-js/features/math/log1p": [
		"es.math.log1p"
	],
		"core-js/features/math/log2": [
		"es.math.log2"
	],
		"core-js/features/math/rad-per-deg": [
		"esnext.math.rad-per-deg"
	],
		"core-js/features/math/radians": [
		"esnext.math.radians"
	],
		"core-js/features/math/scale": [
		"esnext.math.scale"
	],
		"core-js/features/math/seeded-prng": [
		"esnext.math.seeded-prng"
	],
		"core-js/features/math/sign": [
		"es.math.sign"
	],
		"core-js/features/math/signbit": [
		"esnext.math.signbit"
	],
		"core-js/features/math/sinh": [
		"es.math.sinh"
	],
		"core-js/features/math/tanh": [
		"es.math.tanh"
	],
		"core-js/features/math/to-string-tag": [
		"es.math.to-string-tag"
	],
		"core-js/features/math/trunc": [
		"es.math.trunc"
	],
		"core-js/features/math/umulh": [
		"esnext.math.umulh"
	],
		"core-js/features/number": [
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.to-string",
		"esnext.number.from-string",
		"esnext.number.range"
	],
		"core-js/features/number/constructor": [
		"es.number.constructor"
	],
		"core-js/features/number/epsilon": [
		"es.number.epsilon"
	],
		"core-js/features/number/from-string": [
		"esnext.number.from-string"
	],
		"core-js/features/number/is-finite": [
		"es.number.is-finite"
	],
		"core-js/features/number/is-integer": [
		"es.number.is-integer"
	],
		"core-js/features/number/is-nan": [
		"es.number.is-nan"
	],
		"core-js/features/number/is-safe-integer": [
		"es.number.is-safe-integer"
	],
		"core-js/features/number/max-safe-integer": [
		"es.number.max-safe-integer"
	],
		"core-js/features/number/min-safe-integer": [
		"es.number.min-safe-integer"
	],
		"core-js/features/number/parse-float": [
		"es.number.parse-float"
	],
		"core-js/features/number/parse-int": [
		"es.number.parse-int"
	],
		"core-js/features/number/range": [
		"es.object.to-string",
		"esnext.number.range"
	],
		"core-js/features/number/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/features/number/to-precision": [
		"es.number.to-precision"
	],
		"core-js/features/number/virtual": [
		"es.number.to-fixed",
		"es.number.to-precision"
	],
		"core-js/features/number/virtual/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/features/number/virtual/to-precision": [
		"es.number.to-precision"
	],
		"core-js/features/object": [
		"es.symbol",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.reflect.to-string-tag",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"web.dom-collections.iterator"
	],
		"core-js/features/object/assign": [
		"es.object.assign"
	],
		"core-js/features/object/create": [
		"es.object.create"
	],
		"core-js/features/object/define-getter": [
		"es.object.define-getter"
	],
		"core-js/features/object/define-properties": [
		"es.object.define-properties"
	],
		"core-js/features/object/define-property": [
		"es.object.define-property"
	],
		"core-js/features/object/define-setter": [
		"es.object.define-setter"
	],
		"core-js/features/object/entries": [
		"es.object.entries"
	],
		"core-js/features/object/freeze": [
		"es.object.freeze"
	],
		"core-js/features/object/from-entries": [
		"es.array.iterator",
		"es.object.from-entries",
		"web.dom-collections.iterator"
	],
		"core-js/features/object/get-own-property-descriptor": [
		"es.object.get-own-property-descriptor"
	],
		"core-js/features/object/get-own-property-descriptors": [
		"es.object.get-own-property-descriptors"
	],
		"core-js/features/object/get-own-property-names": [
		"es.object.get-own-property-names"
	],
		"core-js/features/object/get-own-property-symbols": [
		"es.symbol"
	],
		"core-js/features/object/get-prototype-of": [
		"es.object.get-prototype-of"
	],
		"core-js/features/object/has-own": [
		"es.object.has-own",
		"esnext.object.has-own"
	],
		"core-js/features/object/is": [
		"es.object.is"
	],
		"core-js/features/object/is-extensible": [
		"es.object.is-extensible"
	],
		"core-js/features/object/is-frozen": [
		"es.object.is-frozen"
	],
		"core-js/features/object/is-sealed": [
		"es.object.is-sealed"
	],
		"core-js/features/object/iterate-entries": [
		"esnext.object.iterate-entries"
	],
		"core-js/features/object/iterate-keys": [
		"esnext.object.iterate-keys"
	],
		"core-js/features/object/iterate-values": [
		"esnext.object.iterate-values"
	],
		"core-js/features/object/keys": [
		"es.object.keys"
	],
		"core-js/features/object/lookup-getter": [
		"es.object.lookup-setter"
	],
		"core-js/features/object/lookup-setter": [
		"es.object.lookup-setter"
	],
		"core-js/features/object/prevent-extensions": [
		"es.object.prevent-extensions"
	],
		"core-js/features/object/seal": [
		"es.object.seal"
	],
		"core-js/features/object/set-prototype-of": [
		"es.object.set-prototype-of"
	],
		"core-js/features/object/to-string": [
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/features/object/values": [
		"es.object.values"
	],
		"core-js/features/observable": [
		"es.object.to-string",
		"es.string.iterator",
		"esnext.observable",
		"esnext.symbol.observable",
		"web.dom-collections.iterator"
	],
		"core-js/features/parse-float": [
		"es.parse-float"
	],
		"core-js/features/parse-int": [
		"es.parse-int"
	],
		"core-js/features/promise": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.string.iterator",
		"esnext.aggregate-error",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"web.dom-collections.iterator"
	],
		"core-js/features/promise/all-settled": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.string.iterator",
		"esnext.promise.all-settled",
		"web.dom-collections.iterator"
	],
		"core-js/features/promise/any": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.any",
		"es.string.iterator",
		"esnext.aggregate-error",
		"esnext.promise.any",
		"web.dom-collections.iterator"
	],
		"core-js/features/promise/finally": [
		"es.object.to-string",
		"es.promise",
		"es.promise.finally"
	],
		"core-js/features/promise/try": [
		"es.promise",
		"esnext.promise.try"
	],
		"core-js/features/queue-microtask": [
		"web.queue-microtask"
	],
		"core-js/features/reflect": [
		"es.object.to-string",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata"
	],
		"core-js/features/reflect/apply": [
		"es.reflect.apply"
	],
		"core-js/features/reflect/construct": [
		"es.reflect.construct"
	],
		"core-js/features/reflect/define-metadata": [
		"esnext.reflect.define-metadata"
	],
		"core-js/features/reflect/define-property": [
		"es.reflect.define-property"
	],
		"core-js/features/reflect/delete-metadata": [
		"esnext.reflect.delete-metadata"
	],
		"core-js/features/reflect/delete-property": [
		"es.reflect.delete-property"
	],
		"core-js/features/reflect/get": [
		"es.reflect.get"
	],
		"core-js/features/reflect/get-metadata": [
		"esnext.reflect.get-metadata"
	],
		"core-js/features/reflect/get-metadata-keys": [
		"esnext.reflect.get-metadata-keys"
	],
		"core-js/features/reflect/get-own-metadata": [
		"esnext.reflect.get-own-metadata"
	],
		"core-js/features/reflect/get-own-metadata-keys": [
		"esnext.reflect.get-own-metadata-keys"
	],
		"core-js/features/reflect/get-own-property-descriptor": [
		"es.reflect.get-own-property-descriptor"
	],
		"core-js/features/reflect/get-prototype-of": [
		"es.reflect.get-prototype-of"
	],
		"core-js/features/reflect/has": [
		"es.reflect.has"
	],
		"core-js/features/reflect/has-metadata": [
		"esnext.reflect.has-metadata"
	],
		"core-js/features/reflect/has-own-metadata": [
		"esnext.reflect.has-own-metadata"
	],
		"core-js/features/reflect/is-extensible": [
		"es.reflect.is-extensible"
	],
		"core-js/features/reflect/metadata": [
		"esnext.reflect.metadata"
	],
		"core-js/features/reflect/own-keys": [
		"es.reflect.own-keys"
	],
		"core-js/features/reflect/prevent-extensions": [
		"es.reflect.prevent-extensions"
	],
		"core-js/features/reflect/set": [
		"es.reflect.set"
	],
		"core-js/features/reflect/set-prototype-of": [
		"es.reflect.set-prototype-of"
	],
		"core-js/features/reflect/to-string-tag": [
		"es.reflect.to-string-tag"
	],
		"core-js/features/regexp": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.string.match",
		"es.string.replace",
		"es.string.search",
		"es.string.split"
	],
		"core-js/features/regexp/constructor": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/features/regexp/dot-all": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec"
	],
		"core-js/features/regexp/flags": [
		"es.regexp.flags"
	],
		"core-js/features/regexp/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/features/regexp/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/features/regexp/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/features/regexp/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/features/regexp/sticky": [
		"es.regexp.constructor",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/features/regexp/test": [
		"es.regexp.exec",
		"es.regexp.test"
	],
		"core-js/features/regexp/to-string": [
		"es.regexp.to-string"
	],
		"core-js/features/set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.set",
		"es.string.iterator",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"web.dom-collections.iterator"
	],
		"core-js/features/set-immediate": [
		"web.immediate"
	],
		"core-js/features/set-interval": [
		"web.timers"
	],
		"core-js/features/set-timeout": [
		"web.timers"
	],
		"core-js/features/set/add-all": [
		"es.set",
		"esnext.set.add-all"
	],
		"core-js/features/set/delete-all": [
		"es.set",
		"esnext.set.delete-all"
	],
		"core-js/features/set/difference": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.difference",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/every": [
		"es.set",
		"esnext.set.every"
	],
		"core-js/features/set/filter": [
		"es.set",
		"esnext.set.filter"
	],
		"core-js/features/set/find": [
		"es.set",
		"esnext.set.find"
	],
		"core-js/features/set/from": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/intersection": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.intersection",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/is-disjoint-from": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.is-disjoint-from",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/is-subset-of": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.is-subset-of",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/is-superset-of": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.is-superset-of",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/join": [
		"es.set",
		"esnext.set.join"
	],
		"core-js/features/set/map": [
		"es.set",
		"esnext.set.map"
	],
		"core-js/features/set/of": [
		"es.array.iterator",
		"es.set",
		"esnext.set.of"
	],
		"core-js/features/set/reduce": [
		"es.set",
		"esnext.set.reduce"
	],
		"core-js/features/set/some": [
		"es.set",
		"esnext.set.some"
	],
		"core-js/features/set/symmetric-difference": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.symmetric-difference",
		"web.dom-collections.iterator"
	],
		"core-js/features/set/union": [
		"es.array.iterator",
		"es.set",
		"es.string.iterator",
		"esnext.set.union",
		"web.dom-collections.iterator"
	],
		"core-js/features/string": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all"
	],
		"core-js/features/string/anchor": [
		"es.string.anchor"
	],
		"core-js/features/string/at": [
		"es.string.at-alternative",
		"esnext.string.at"
	],
		"core-js/features/string/big": [
		"es.string.big"
	],
		"core-js/features/string/blink": [
		"es.string.blink"
	],
		"core-js/features/string/bold": [
		"es.string.bold"
	],
		"core-js/features/string/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/features/string/code-points": [
		"es.object.to-string",
		"esnext.string.code-points"
	],
		"core-js/features/string/ends-with": [
		"es.string.ends-with"
	],
		"core-js/features/string/fixed": [
		"es.string.fixed"
	],
		"core-js/features/string/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/features/string/fontsize": [
		"es.string.fontsize"
	],
		"core-js/features/string/from-code-point": [
		"es.string.from-code-point"
	],
		"core-js/features/string/includes": [
		"es.string.includes"
	],
		"core-js/features/string/italics": [
		"es.string.italics"
	],
		"core-js/features/string/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/features/string/link": [
		"es.string.link"
	],
		"core-js/features/string/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/features/string/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all",
		"esnext.string.match-all"
	],
		"core-js/features/string/pad-end": [
		"es.string.pad-end"
	],
		"core-js/features/string/pad-start": [
		"es.string.pad-start"
	],
		"core-js/features/string/raw": [
		"es.string.raw"
	],
		"core-js/features/string/repeat": [
		"es.string.repeat"
	],
		"core-js/features/string/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/features/string/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all",
		"esnext.string.replace-all"
	],
		"core-js/features/string/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/features/string/small": [
		"es.string.small"
	],
		"core-js/features/string/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/features/string/starts-with": [
		"es.string.starts-with"
	],
		"core-js/features/string/strike": [
		"es.string.strike"
	],
		"core-js/features/string/sub": [
		"es.string.sub"
	],
		"core-js/features/string/substr": [
		"es.string.substr"
	],
		"core-js/features/string/sup": [
		"es.string.sup"
	],
		"core-js/features/string/trim": [
		"es.string.trim"
	],
		"core-js/features/string/trim-end": [
		"es.string.trim-end"
	],
		"core-js/features/string/trim-left": [
		"es.string.trim-start"
	],
		"core-js/features/string/trim-right": [
		"es.string.trim-end"
	],
		"core-js/features/string/trim-start": [
		"es.string.trim-start"
	],
		"core-js/features/string/virtual": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all"
	],
		"core-js/features/string/virtual/anchor": [
		"es.string.anchor"
	],
		"core-js/features/string/virtual/at": [
		"es.string.at-alternative",
		"esnext.string.at"
	],
		"core-js/features/string/virtual/big": [
		"es.string.big"
	],
		"core-js/features/string/virtual/blink": [
		"es.string.blink"
	],
		"core-js/features/string/virtual/bold": [
		"es.string.bold"
	],
		"core-js/features/string/virtual/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/features/string/virtual/code-points": [
		"es.object.to-string",
		"esnext.string.code-points"
	],
		"core-js/features/string/virtual/ends-with": [
		"es.string.ends-with"
	],
		"core-js/features/string/virtual/fixed": [
		"es.string.fixed"
	],
		"core-js/features/string/virtual/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/features/string/virtual/fontsize": [
		"es.string.fontsize"
	],
		"core-js/features/string/virtual/includes": [
		"es.string.includes"
	],
		"core-js/features/string/virtual/italics": [
		"es.string.italics"
	],
		"core-js/features/string/virtual/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/features/string/virtual/link": [
		"es.string.link"
	],
		"core-js/features/string/virtual/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all",
		"esnext.string.match-all"
	],
		"core-js/features/string/virtual/pad-end": [
		"es.string.pad-end"
	],
		"core-js/features/string/virtual/pad-start": [
		"es.string.pad-start"
	],
		"core-js/features/string/virtual/repeat": [
		"es.string.repeat"
	],
		"core-js/features/string/virtual/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all",
		"esnext.string.replace-all"
	],
		"core-js/features/string/virtual/small": [
		"es.string.small"
	],
		"core-js/features/string/virtual/starts-with": [
		"es.string.starts-with"
	],
		"core-js/features/string/virtual/strike": [
		"es.string.strike"
	],
		"core-js/features/string/virtual/sub": [
		"es.string.sub"
	],
		"core-js/features/string/virtual/substr": [
		"es.string.substr"
	],
		"core-js/features/string/virtual/sup": [
		"es.string.sup"
	],
		"core-js/features/string/virtual/trim": [
		"es.string.trim"
	],
		"core-js/features/string/virtual/trim-end": [
		"es.string.trim-end"
	],
		"core-js/features/string/virtual/trim-left": [
		"es.string.trim-start"
	],
		"core-js/features/string/virtual/trim-right": [
		"es.string.trim-end"
	],
		"core-js/features/string/virtual/trim-start": [
		"es.string.trim-start"
	],
		"core-js/features/symbol": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.array.concat",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"web.dom-collections.iterator"
	],
		"core-js/features/symbol/async-dispose": [
		"esnext.symbol.async-dispose"
	],
		"core-js/features/symbol/async-iterator": [
		"es.symbol.async-iterator"
	],
		"core-js/features/symbol/description": [
		"es.symbol.description"
	],
		"core-js/features/symbol/dispose": [
		"esnext.symbol.dispose"
	],
		"core-js/features/symbol/for": [
		"es.symbol"
	],
		"core-js/features/symbol/has-instance": [
		"es.symbol.has-instance",
		"es.function.has-instance"
	],
		"core-js/features/symbol/is-concat-spreadable": [
		"es.symbol.is-concat-spreadable",
		"es.array.concat"
	],
		"core-js/features/symbol/iterator": [
		"es.symbol.iterator",
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/features/symbol/key-for": [
		"es.symbol"
	],
		"core-js/features/symbol/match": [
		"es.symbol.match",
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/features/symbol/match-all": [
		"es.symbol.match-all",
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/features/symbol/matcher": [
		"esnext.symbol.matcher"
	],
		"core-js/features/symbol/metadata": [
		"esnext.symbol.metadata"
	],
		"core-js/features/symbol/observable": [
		"esnext.symbol.observable"
	],
		"core-js/features/symbol/pattern-match": [
		"esnext.symbol.pattern-match"
	],
		"core-js/features/symbol/replace": [
		"es.symbol.replace",
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/features/symbol/replace-all": [
		"esnext.symbol.replace-all"
	],
		"core-js/features/symbol/search": [
		"es.symbol.search",
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/features/symbol/species": [
		"es.symbol.species"
	],
		"core-js/features/symbol/split": [
		"es.symbol.split",
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/features/symbol/to-primitive": [
		"es.symbol.to-primitive",
		"es.date.to-primitive"
	],
		"core-js/features/symbol/to-string-tag": [
		"es.symbol.to-string-tag",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/features/symbol/unscopables": [
		"es.symbol.unscopables"
	],
		"core-js/features/typed-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/at": [
		"es.typed-array.every",
		"esnext.typed-array.at"
	],
		"core-js/features/typed-array/copy-within": [
		"es.typed-array.copy-within"
	],
		"core-js/features/typed-array/entries": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/features/typed-array/every": [
		"es.typed-array.every"
	],
		"core-js/features/typed-array/fill": [
		"es.typed-array.fill"
	],
		"core-js/features/typed-array/filter": [
		"es.typed-array.filter"
	],
		"core-js/features/typed-array/filter-out": [
		"esnext.typed-array.filter-out"
	],
		"core-js/features/typed-array/filter-reject": [
		"esnext.typed-array.filter-reject"
	],
		"core-js/features/typed-array/find": [
		"es.typed-array.find"
	],
		"core-js/features/typed-array/find-index": [
		"es.typed-array.find-index"
	],
		"core-js/features/typed-array/find-last": [
		"esnext.typed-array.find-last"
	],
		"core-js/features/typed-array/find-last-index": [
		"esnext.typed-array.find-last-index"
	],
		"core-js/features/typed-array/float32-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/float64-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.float64-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/for-each": [
		"es.typed-array.for-each"
	],
		"core-js/features/typed-array/from": [
		"es.typed-array.from"
	],
		"core-js/features/typed-array/from-async": [
		"esnext.typed-array.from-async"
	],
		"core-js/features/typed-array/group-by": [
		"esnext.typed-array.group-by"
	],
		"core-js/features/typed-array/includes": [
		"es.typed-array.includes"
	],
		"core-js/features/typed-array/index-of": [
		"es.typed-array.index-of"
	],
		"core-js/features/typed-array/int16-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.int16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/int32-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.int32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/int8-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.int8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/iterator": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/features/typed-array/join": [
		"es.typed-array.join"
	],
		"core-js/features/typed-array/keys": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/features/typed-array/last-index-of": [
		"es.typed-array.last-index-of"
	],
		"core-js/features/typed-array/map": [
		"es.typed-array.map"
	],
		"core-js/features/typed-array/methods": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/of": [
		"es.typed-array.of"
	],
		"core-js/features/typed-array/reduce": [
		"es.typed-array.reduce"
	],
		"core-js/features/typed-array/reduce-right": [
		"es.typed-array.reduce-right"
	],
		"core-js/features/typed-array/reverse": [
		"es.typed-array.reverse"
	],
		"core-js/features/typed-array/set": [
		"es.typed-array.set"
	],
		"core-js/features/typed-array/slice": [
		"es.typed-array.slice"
	],
		"core-js/features/typed-array/some": [
		"es.typed-array.some"
	],
		"core-js/features/typed-array/sort": [
		"es.typed-array.sort"
	],
		"core-js/features/typed-array/subarray": [
		"es.typed-array.subarray"
	],
		"core-js/features/typed-array/to-locale-string": [
		"es.typed-array.to-locale-string"
	],
		"core-js/features/typed-array/to-string": [
		"es.typed-array.to-string"
	],
		"core-js/features/typed-array/uint16-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.uint16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/uint32-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/uint8-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.uint8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/uint8-clamped-array": [
		"es.map",
		"es.object.to-string",
		"es.promise",
		"es.string.iterator",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/unique-by": [
		"es.map",
		"esnext.typed-array.unique-by"
	],
		"core-js/features/typed-array/values": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/features/unescape": [
		"es.unescape"
	],
		"core-js/features/url": [
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/features/url-search-params": [
		"web.dom-collections.iterator",
		"web.url-search-params"
	],
		"core-js/features/url/to-json": [
		"web.url.to-json"
	],
		"core-js/features/weak-map": [
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"es.weak-map",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"web.dom-collections.iterator"
	],
		"core-js/features/weak-map/delete-all": [
		"es.weak-map",
		"esnext.weak-map.delete-all"
	],
		"core-js/features/weak-map/emplace": [
		"es.weak-map",
		"esnext.weak-map.emplace"
	],
		"core-js/features/weak-map/from": [
		"es.array.iterator",
		"es.string.iterator",
		"es.weak-map",
		"esnext.weak-map.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/weak-map/of": [
		"es.array.iterator",
		"es.weak-map",
		"esnext.weak-map.of"
	],
		"core-js/features/weak-map/upsert": [
		"es.weak-map",
		"esnext.weak-map.upsert"
	],
		"core-js/features/weak-set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"es.weak-set",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.dom-collections.iterator"
	],
		"core-js/features/weak-set/add-all": [
		"es.weak-set",
		"esnext.weak-set.add-all"
	],
		"core-js/features/weak-set/delete-all": [
		"es.weak-set",
		"esnext.weak-set.delete-all"
	],
		"core-js/features/weak-set/from": [
		"es.array.iterator",
		"es.string.iterator",
		"es.weak-set",
		"esnext.weak-set.from",
		"web.dom-collections.iterator"
	],
		"core-js/features/weak-set/of": [
		"es.array.iterator",
		"es.weak-set",
		"esnext.weak-set.of"
	],
		"core-js/modules/es.aggregate-error": [
		"es.aggregate-error"
	],
		"core-js/modules/es.array-buffer.constructor": [
		"es.array-buffer.constructor"
	],
		"core-js/modules/es.array-buffer.is-view": [
		"es.array-buffer.is-view"
	],
		"core-js/modules/es.array-buffer.slice": [
		"es.array-buffer.slice"
	],
		"core-js/modules/es.array.at": [
		"es.array.at"
	],
		"core-js/modules/es.array.concat": [
		"es.array.concat"
	],
		"core-js/modules/es.array.copy-within": [
		"es.array.copy-within"
	],
		"core-js/modules/es.array.every": [
		"es.array.every"
	],
		"core-js/modules/es.array.fill": [
		"es.array.fill"
	],
		"core-js/modules/es.array.filter": [
		"es.array.filter"
	],
		"core-js/modules/es.array.find": [
		"es.array.find"
	],
		"core-js/modules/es.array.find-index": [
		"es.array.find-index"
	],
		"core-js/modules/es.array.flat": [
		"es.array.flat"
	],
		"core-js/modules/es.array.flat-map": [
		"es.array.flat-map"
	],
		"core-js/modules/es.array.for-each": [
		"es.array.for-each"
	],
		"core-js/modules/es.array.from": [
		"es.array.from"
	],
		"core-js/modules/es.array.includes": [
		"es.array.includes"
	],
		"core-js/modules/es.array.index-of": [
		"es.array.index-of"
	],
		"core-js/modules/es.array.is-array": [
		"es.array.is-array"
	],
		"core-js/modules/es.array.iterator": [
		"es.array.iterator"
	],
		"core-js/modules/es.array.join": [
		"es.array.join"
	],
		"core-js/modules/es.array.last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/modules/es.array.map": [
		"es.array.map"
	],
		"core-js/modules/es.array.of": [
		"es.array.of"
	],
		"core-js/modules/es.array.reduce": [
		"es.array.reduce"
	],
		"core-js/modules/es.array.reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/modules/es.array.reverse": [
		"es.array.reverse"
	],
		"core-js/modules/es.array.slice": [
		"es.array.slice"
	],
		"core-js/modules/es.array.some": [
		"es.array.some"
	],
		"core-js/modules/es.array.sort": [
		"es.array.sort"
	],
		"core-js/modules/es.array.species": [
		"es.array.species"
	],
		"core-js/modules/es.array.splice": [
		"es.array.splice"
	],
		"core-js/modules/es.array.unscopables.flat": [
		"es.array.unscopables.flat"
	],
		"core-js/modules/es.array.unscopables.flat-map": [
		"es.array.unscopables.flat-map"
	],
		"core-js/modules/es.data-view": [
		"es.data-view"
	],
		"core-js/modules/es.date.get-year": [
		"es.date.get-year"
	],
		"core-js/modules/es.date.now": [
		"es.date.now"
	],
		"core-js/modules/es.date.set-year": [
		"es.date.set-year"
	],
		"core-js/modules/es.date.to-gmt-string": [
		"es.date.to-gmt-string"
	],
		"core-js/modules/es.date.to-iso-string": [
		"es.date.to-iso-string"
	],
		"core-js/modules/es.date.to-json": [
		"es.date.to-json"
	],
		"core-js/modules/es.date.to-primitive": [
		"es.date.to-primitive"
	],
		"core-js/modules/es.date.to-string": [
		"es.date.to-string"
	],
		"core-js/modules/es.escape": [
		"es.escape"
	],
		"core-js/modules/es.function.bind": [
		"es.function.bind"
	],
		"core-js/modules/es.function.has-instance": [
		"es.function.has-instance"
	],
		"core-js/modules/es.function.name": [
		"es.function.name"
	],
		"core-js/modules/es.global-this": [
		"es.global-this"
	],
		"core-js/modules/es.json.stringify": [
		"es.json.stringify"
	],
		"core-js/modules/es.json.to-string-tag": [
		"es.json.to-string-tag"
	],
		"core-js/modules/es.map": [
		"es.map"
	],
		"core-js/modules/es.math.acosh": [
		"es.math.acosh"
	],
		"core-js/modules/es.math.asinh": [
		"es.math.asinh"
	],
		"core-js/modules/es.math.atanh": [
		"es.math.atanh"
	],
		"core-js/modules/es.math.cbrt": [
		"es.math.cbrt"
	],
		"core-js/modules/es.math.clz32": [
		"es.math.clz32"
	],
		"core-js/modules/es.math.cosh": [
		"es.math.cosh"
	],
		"core-js/modules/es.math.expm1": [
		"es.math.expm1"
	],
		"core-js/modules/es.math.fround": [
		"es.math.fround"
	],
		"core-js/modules/es.math.hypot": [
		"es.math.hypot"
	],
		"core-js/modules/es.math.imul": [
		"es.math.imul"
	],
		"core-js/modules/es.math.log10": [
		"es.math.log10"
	],
		"core-js/modules/es.math.log1p": [
		"es.math.log1p"
	],
		"core-js/modules/es.math.log2": [
		"es.math.log2"
	],
		"core-js/modules/es.math.sign": [
		"es.math.sign"
	],
		"core-js/modules/es.math.sinh": [
		"es.math.sinh"
	],
		"core-js/modules/es.math.tanh": [
		"es.math.tanh"
	],
		"core-js/modules/es.math.to-string-tag": [
		"es.math.to-string-tag"
	],
		"core-js/modules/es.math.trunc": [
		"es.math.trunc"
	],
		"core-js/modules/es.number.constructor": [
		"es.number.constructor"
	],
		"core-js/modules/es.number.epsilon": [
		"es.number.epsilon"
	],
		"core-js/modules/es.number.is-finite": [
		"es.number.is-finite"
	],
		"core-js/modules/es.number.is-integer": [
		"es.number.is-integer"
	],
		"core-js/modules/es.number.is-nan": [
		"es.number.is-nan"
	],
		"core-js/modules/es.number.is-safe-integer": [
		"es.number.is-safe-integer"
	],
		"core-js/modules/es.number.max-safe-integer": [
		"es.number.max-safe-integer"
	],
		"core-js/modules/es.number.min-safe-integer": [
		"es.number.min-safe-integer"
	],
		"core-js/modules/es.number.parse-float": [
		"es.number.parse-float"
	],
		"core-js/modules/es.number.parse-int": [
		"es.number.parse-int"
	],
		"core-js/modules/es.number.to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/modules/es.number.to-precision": [
		"es.number.to-precision"
	],
		"core-js/modules/es.object.assign": [
		"es.object.assign"
	],
		"core-js/modules/es.object.create": [
		"es.object.create"
	],
		"core-js/modules/es.object.define-getter": [
		"es.object.define-getter"
	],
		"core-js/modules/es.object.define-properties": [
		"es.object.define-properties"
	],
		"core-js/modules/es.object.define-property": [
		"es.object.define-property"
	],
		"core-js/modules/es.object.define-setter": [
		"es.object.define-setter"
	],
		"core-js/modules/es.object.entries": [
		"es.object.entries"
	],
		"core-js/modules/es.object.freeze": [
		"es.object.freeze"
	],
		"core-js/modules/es.object.from-entries": [
		"es.object.from-entries"
	],
		"core-js/modules/es.object.get-own-property-descriptor": [
		"es.object.get-own-property-descriptor"
	],
		"core-js/modules/es.object.get-own-property-descriptors": [
		"es.object.get-own-property-descriptors"
	],
		"core-js/modules/es.object.get-own-property-names": [
		"es.object.get-own-property-names"
	],
		"core-js/modules/es.object.get-prototype-of": [
		"es.object.get-prototype-of"
	],
		"core-js/modules/es.object.has-own": [
		"es.object.has-own"
	],
		"core-js/modules/es.object.is": [
		"es.object.is"
	],
		"core-js/modules/es.object.is-extensible": [
		"es.object.is-extensible"
	],
		"core-js/modules/es.object.is-frozen": [
		"es.object.is-frozen"
	],
		"core-js/modules/es.object.is-sealed": [
		"es.object.is-sealed"
	],
		"core-js/modules/es.object.keys": [
		"es.object.keys"
	],
		"core-js/modules/es.object.lookup-getter": [
		"es.object.lookup-getter"
	],
		"core-js/modules/es.object.lookup-setter": [
		"es.object.lookup-setter"
	],
		"core-js/modules/es.object.prevent-extensions": [
		"es.object.prevent-extensions"
	],
		"core-js/modules/es.object.seal": [
		"es.object.seal"
	],
		"core-js/modules/es.object.set-prototype-of": [
		"es.object.set-prototype-of"
	],
		"core-js/modules/es.object.to-string": [
		"es.object.to-string"
	],
		"core-js/modules/es.object.values": [
		"es.object.values"
	],
		"core-js/modules/es.parse-float": [
		"es.parse-float"
	],
		"core-js/modules/es.parse-int": [
		"es.parse-int"
	],
		"core-js/modules/es.promise": [
		"es.promise"
	],
		"core-js/modules/es.promise.all-settled": [
		"es.promise.all-settled"
	],
		"core-js/modules/es.promise.any": [
		"es.promise.any"
	],
		"core-js/modules/es.promise.finally": [
		"es.promise.finally"
	],
		"core-js/modules/es.reflect.apply": [
		"es.reflect.apply"
	],
		"core-js/modules/es.reflect.construct": [
		"es.reflect.construct"
	],
		"core-js/modules/es.reflect.define-property": [
		"es.reflect.define-property"
	],
		"core-js/modules/es.reflect.delete-property": [
		"es.reflect.delete-property"
	],
		"core-js/modules/es.reflect.get": [
		"es.reflect.get"
	],
		"core-js/modules/es.reflect.get-own-property-descriptor": [
		"es.reflect.get-own-property-descriptor"
	],
		"core-js/modules/es.reflect.get-prototype-of": [
		"es.reflect.get-prototype-of"
	],
		"core-js/modules/es.reflect.has": [
		"es.reflect.has"
	],
		"core-js/modules/es.reflect.is-extensible": [
		"es.reflect.is-extensible"
	],
		"core-js/modules/es.reflect.own-keys": [
		"es.reflect.own-keys"
	],
		"core-js/modules/es.reflect.prevent-extensions": [
		"es.reflect.prevent-extensions"
	],
		"core-js/modules/es.reflect.set": [
		"es.reflect.set"
	],
		"core-js/modules/es.reflect.set-prototype-of": [
		"es.reflect.set-prototype-of"
	],
		"core-js/modules/es.reflect.to-string-tag": [
		"es.reflect.to-string-tag"
	],
		"core-js/modules/es.regexp.constructor": [
		"es.regexp.constructor"
	],
		"core-js/modules/es.regexp.dot-all": [
		"es.regexp.dot-all"
	],
		"core-js/modules/es.regexp.exec": [
		"es.regexp.exec"
	],
		"core-js/modules/es.regexp.flags": [
		"es.regexp.flags"
	],
		"core-js/modules/es.regexp.sticky": [
		"es.regexp.sticky"
	],
		"core-js/modules/es.regexp.test": [
		"es.regexp.test"
	],
		"core-js/modules/es.regexp.to-string": [
		"es.regexp.to-string"
	],
		"core-js/modules/es.set": [
		"es.set"
	],
		"core-js/modules/es.string.anchor": [
		"es.string.anchor"
	],
		"core-js/modules/es.string.at-alternative": [
		"es.string.at-alternative"
	],
		"core-js/modules/es.string.big": [
		"es.string.big"
	],
		"core-js/modules/es.string.blink": [
		"es.string.blink"
	],
		"core-js/modules/es.string.bold": [
		"es.string.bold"
	],
		"core-js/modules/es.string.code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/modules/es.string.ends-with": [
		"es.string.ends-with"
	],
		"core-js/modules/es.string.fixed": [
		"es.string.fixed"
	],
		"core-js/modules/es.string.fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/modules/es.string.fontsize": [
		"es.string.fontsize"
	],
		"core-js/modules/es.string.from-code-point": [
		"es.string.from-code-point"
	],
		"core-js/modules/es.string.includes": [
		"es.string.includes"
	],
		"core-js/modules/es.string.italics": [
		"es.string.italics"
	],
		"core-js/modules/es.string.iterator": [
		"es.string.iterator"
	],
		"core-js/modules/es.string.link": [
		"es.string.link"
	],
		"core-js/modules/es.string.match": [
		"es.string.match"
	],
		"core-js/modules/es.string.match-all": [
		"es.string.match-all"
	],
		"core-js/modules/es.string.pad-end": [
		"es.string.pad-end"
	],
		"core-js/modules/es.string.pad-start": [
		"es.string.pad-start"
	],
		"core-js/modules/es.string.raw": [
		"es.string.raw"
	],
		"core-js/modules/es.string.repeat": [
		"es.string.repeat"
	],
		"core-js/modules/es.string.replace": [
		"es.string.replace"
	],
		"core-js/modules/es.string.replace-all": [
		"es.string.replace-all"
	],
		"core-js/modules/es.string.search": [
		"es.string.search"
	],
		"core-js/modules/es.string.small": [
		"es.string.small"
	],
		"core-js/modules/es.string.split": [
		"es.string.split"
	],
		"core-js/modules/es.string.starts-with": [
		"es.string.starts-with"
	],
		"core-js/modules/es.string.strike": [
		"es.string.strike"
	],
		"core-js/modules/es.string.sub": [
		"es.string.sub"
	],
		"core-js/modules/es.string.substr": [
		"es.string.substr"
	],
		"core-js/modules/es.string.sup": [
		"es.string.sup"
	],
		"core-js/modules/es.string.trim": [
		"es.string.trim"
	],
		"core-js/modules/es.string.trim-end": [
		"es.string.trim-end"
	],
		"core-js/modules/es.string.trim-start": [
		"es.string.trim-start"
	],
		"core-js/modules/es.symbol": [
		"es.symbol"
	],
		"core-js/modules/es.symbol.async-iterator": [
		"es.symbol.async-iterator"
	],
		"core-js/modules/es.symbol.description": [
		"es.symbol.description"
	],
		"core-js/modules/es.symbol.has-instance": [
		"es.symbol.has-instance"
	],
		"core-js/modules/es.symbol.is-concat-spreadable": [
		"es.symbol.is-concat-spreadable"
	],
		"core-js/modules/es.symbol.iterator": [
		"es.symbol.iterator"
	],
		"core-js/modules/es.symbol.match": [
		"es.symbol.match"
	],
		"core-js/modules/es.symbol.match-all": [
		"es.symbol.match-all"
	],
		"core-js/modules/es.symbol.replace": [
		"es.symbol.replace"
	],
		"core-js/modules/es.symbol.search": [
		"es.symbol.search"
	],
		"core-js/modules/es.symbol.species": [
		"es.symbol.species"
	],
		"core-js/modules/es.symbol.split": [
		"es.symbol.split"
	],
		"core-js/modules/es.symbol.to-primitive": [
		"es.symbol.to-primitive"
	],
		"core-js/modules/es.symbol.to-string-tag": [
		"es.symbol.to-string-tag"
	],
		"core-js/modules/es.symbol.unscopables": [
		"es.symbol.unscopables"
	],
		"core-js/modules/es.typed-array.at": [
		"es.typed-array.at"
	],
		"core-js/modules/es.typed-array.copy-within": [
		"es.typed-array.copy-within"
	],
		"core-js/modules/es.typed-array.every": [
		"es.typed-array.every"
	],
		"core-js/modules/es.typed-array.fill": [
		"es.typed-array.fill"
	],
		"core-js/modules/es.typed-array.filter": [
		"es.typed-array.filter"
	],
		"core-js/modules/es.typed-array.find": [
		"es.typed-array.find"
	],
		"core-js/modules/es.typed-array.find-index": [
		"es.typed-array.find-index"
	],
		"core-js/modules/es.typed-array.float32-array": [
		"es.typed-array.float32-array"
	],
		"core-js/modules/es.typed-array.float64-array": [
		"es.typed-array.float64-array"
	],
		"core-js/modules/es.typed-array.for-each": [
		"es.typed-array.for-each"
	],
		"core-js/modules/es.typed-array.from": [
		"es.typed-array.from"
	],
		"core-js/modules/es.typed-array.includes": [
		"es.typed-array.includes"
	],
		"core-js/modules/es.typed-array.index-of": [
		"es.typed-array.index-of"
	],
		"core-js/modules/es.typed-array.int16-array": [
		"es.typed-array.int16-array"
	],
		"core-js/modules/es.typed-array.int32-array": [
		"es.typed-array.int32-array"
	],
		"core-js/modules/es.typed-array.int8-array": [
		"es.typed-array.int8-array"
	],
		"core-js/modules/es.typed-array.iterator": [
		"es.typed-array.iterator"
	],
		"core-js/modules/es.typed-array.join": [
		"es.typed-array.join"
	],
		"core-js/modules/es.typed-array.last-index-of": [
		"es.typed-array.last-index-of"
	],
		"core-js/modules/es.typed-array.map": [
		"es.typed-array.map"
	],
		"core-js/modules/es.typed-array.of": [
		"es.typed-array.of"
	],
		"core-js/modules/es.typed-array.reduce": [
		"es.typed-array.reduce"
	],
		"core-js/modules/es.typed-array.reduce-right": [
		"es.typed-array.reduce-right"
	],
		"core-js/modules/es.typed-array.reverse": [
		"es.typed-array.reverse"
	],
		"core-js/modules/es.typed-array.set": [
		"es.typed-array.set"
	],
		"core-js/modules/es.typed-array.slice": [
		"es.typed-array.slice"
	],
		"core-js/modules/es.typed-array.some": [
		"es.typed-array.some"
	],
		"core-js/modules/es.typed-array.sort": [
		"es.typed-array.sort"
	],
		"core-js/modules/es.typed-array.subarray": [
		"es.typed-array.subarray"
	],
		"core-js/modules/es.typed-array.to-locale-string": [
		"es.typed-array.to-locale-string"
	],
		"core-js/modules/es.typed-array.to-string": [
		"es.typed-array.to-string"
	],
		"core-js/modules/es.typed-array.uint16-array": [
		"es.typed-array.uint16-array"
	],
		"core-js/modules/es.typed-array.uint32-array": [
		"es.typed-array.uint32-array"
	],
		"core-js/modules/es.typed-array.uint8-array": [
		"es.typed-array.uint8-array"
	],
		"core-js/modules/es.typed-array.uint8-clamped-array": [
		"es.typed-array.uint8-clamped-array"
	],
		"core-js/modules/es.unescape": [
		"es.unescape"
	],
		"core-js/modules/es.weak-map": [
		"es.weak-map"
	],
		"core-js/modules/es.weak-set": [
		"es.weak-set"
	],
		"core-js/modules/esnext.aggregate-error": [
		"esnext.aggregate-error"
	],
		"core-js/modules/esnext.array.at": [
		"esnext.array.at"
	],
		"core-js/modules/esnext.array.filter-out": [
		"esnext.array.filter-out"
	],
		"core-js/modules/esnext.array.filter-reject": [
		"esnext.array.filter-reject"
	],
		"core-js/modules/esnext.array.find-last": [
		"esnext.array.find-last"
	],
		"core-js/modules/esnext.array.find-last-index": [
		"esnext.array.find-last-index"
	],
		"core-js/modules/esnext.array.from-async": [
		"esnext.array.from-async"
	],
		"core-js/modules/esnext.array.group-by": [
		"esnext.array.group-by"
	],
		"core-js/modules/esnext.array.is-template-object": [
		"esnext.array.is-template-object"
	],
		"core-js/modules/esnext.array.last-index": [
		"esnext.array.last-index"
	],
		"core-js/modules/esnext.array.last-item": [
		"esnext.array.last-item"
	],
		"core-js/modules/esnext.array.unique-by": [
		"esnext.array.unique-by"
	],
		"core-js/modules/esnext.async-iterator.as-indexed-pairs": [
		"esnext.async-iterator.as-indexed-pairs"
	],
		"core-js/modules/esnext.async-iterator.constructor": [
		"esnext.async-iterator.constructor"
	],
		"core-js/modules/esnext.async-iterator.drop": [
		"esnext.async-iterator.drop"
	],
		"core-js/modules/esnext.async-iterator.every": [
		"esnext.async-iterator.every"
	],
		"core-js/modules/esnext.async-iterator.filter": [
		"esnext.async-iterator.filter"
	],
		"core-js/modules/esnext.async-iterator.find": [
		"esnext.async-iterator.find"
	],
		"core-js/modules/esnext.async-iterator.flat-map": [
		"esnext.async-iterator.flat-map"
	],
		"core-js/modules/esnext.async-iterator.for-each": [
		"esnext.async-iterator.for-each"
	],
		"core-js/modules/esnext.async-iterator.from": [
		"esnext.async-iterator.from"
	],
		"core-js/modules/esnext.async-iterator.map": [
		"esnext.async-iterator.map"
	],
		"core-js/modules/esnext.async-iterator.reduce": [
		"esnext.async-iterator.reduce"
	],
		"core-js/modules/esnext.async-iterator.some": [
		"esnext.async-iterator.some"
	],
		"core-js/modules/esnext.async-iterator.take": [
		"esnext.async-iterator.take"
	],
		"core-js/modules/esnext.async-iterator.to-array": [
		"esnext.async-iterator.to-array"
	],
		"core-js/modules/esnext.bigint.range": [
		"esnext.bigint.range"
	],
		"core-js/modules/esnext.composite-key": [
		"esnext.composite-key"
	],
		"core-js/modules/esnext.composite-symbol": [
		"esnext.composite-symbol"
	],
		"core-js/modules/esnext.global-this": [
		"esnext.global-this"
	],
		"core-js/modules/esnext.iterator.as-indexed-pairs": [
		"esnext.iterator.as-indexed-pairs"
	],
		"core-js/modules/esnext.iterator.constructor": [
		"esnext.iterator.constructor"
	],
		"core-js/modules/esnext.iterator.drop": [
		"esnext.iterator.drop"
	],
		"core-js/modules/esnext.iterator.every": [
		"esnext.iterator.every"
	],
		"core-js/modules/esnext.iterator.filter": [
		"esnext.iterator.filter"
	],
		"core-js/modules/esnext.iterator.find": [
		"esnext.iterator.find"
	],
		"core-js/modules/esnext.iterator.flat-map": [
		"esnext.iterator.flat-map"
	],
		"core-js/modules/esnext.iterator.for-each": [
		"esnext.iterator.for-each"
	],
		"core-js/modules/esnext.iterator.from": [
		"esnext.iterator.from"
	],
		"core-js/modules/esnext.iterator.map": [
		"esnext.iterator.map"
	],
		"core-js/modules/esnext.iterator.reduce": [
		"esnext.iterator.reduce"
	],
		"core-js/modules/esnext.iterator.some": [
		"esnext.iterator.some"
	],
		"core-js/modules/esnext.iterator.take": [
		"esnext.iterator.take"
	],
		"core-js/modules/esnext.iterator.to-array": [
		"esnext.iterator.to-array"
	],
		"core-js/modules/esnext.map.delete-all": [
		"esnext.map.delete-all"
	],
		"core-js/modules/esnext.map.emplace": [
		"esnext.map.emplace"
	],
		"core-js/modules/esnext.map.every": [
		"esnext.map.every"
	],
		"core-js/modules/esnext.map.filter": [
		"esnext.map.filter"
	],
		"core-js/modules/esnext.map.find": [
		"esnext.map.find"
	],
		"core-js/modules/esnext.map.find-key": [
		"esnext.map.find-key"
	],
		"core-js/modules/esnext.map.from": [
		"esnext.map.from"
	],
		"core-js/modules/esnext.map.group-by": [
		"esnext.map.group-by"
	],
		"core-js/modules/esnext.map.includes": [
		"esnext.map.includes"
	],
		"core-js/modules/esnext.map.key-by": [
		"esnext.map.key-by"
	],
		"core-js/modules/esnext.map.key-of": [
		"esnext.map.key-of"
	],
		"core-js/modules/esnext.map.map-keys": [
		"esnext.map.map-keys"
	],
		"core-js/modules/esnext.map.map-values": [
		"esnext.map.map-values"
	],
		"core-js/modules/esnext.map.merge": [
		"esnext.map.merge"
	],
		"core-js/modules/esnext.map.of": [
		"esnext.map.of"
	],
		"core-js/modules/esnext.map.reduce": [
		"esnext.map.reduce"
	],
		"core-js/modules/esnext.map.some": [
		"esnext.map.some"
	],
		"core-js/modules/esnext.map.update": [
		"esnext.map.update"
	],
		"core-js/modules/esnext.map.update-or-insert": [
		"esnext.map.update-or-insert"
	],
		"core-js/modules/esnext.map.upsert": [
		"esnext.map.upsert"
	],
		"core-js/modules/esnext.math.clamp": [
		"esnext.math.clamp"
	],
		"core-js/modules/esnext.math.deg-per-rad": [
		"esnext.math.deg-per-rad"
	],
		"core-js/modules/esnext.math.degrees": [
		"esnext.math.degrees"
	],
		"core-js/modules/esnext.math.fscale": [
		"esnext.math.fscale"
	],
		"core-js/modules/esnext.math.iaddh": [
		"esnext.math.iaddh"
	],
		"core-js/modules/esnext.math.imulh": [
		"esnext.math.imulh"
	],
		"core-js/modules/esnext.math.isubh": [
		"esnext.math.isubh"
	],
		"core-js/modules/esnext.math.rad-per-deg": [
		"esnext.math.rad-per-deg"
	],
		"core-js/modules/esnext.math.radians": [
		"esnext.math.radians"
	],
		"core-js/modules/esnext.math.scale": [
		"esnext.math.scale"
	],
		"core-js/modules/esnext.math.seeded-prng": [
		"esnext.math.seeded-prng"
	],
		"core-js/modules/esnext.math.signbit": [
		"esnext.math.signbit"
	],
		"core-js/modules/esnext.math.umulh": [
		"esnext.math.umulh"
	],
		"core-js/modules/esnext.number.from-string": [
		"esnext.number.from-string"
	],
		"core-js/modules/esnext.number.range": [
		"esnext.number.range"
	],
		"core-js/modules/esnext.object.has-own": [
		"esnext.object.has-own"
	],
		"core-js/modules/esnext.object.iterate-entries": [
		"esnext.object.iterate-entries"
	],
		"core-js/modules/esnext.object.iterate-keys": [
		"esnext.object.iterate-keys"
	],
		"core-js/modules/esnext.object.iterate-values": [
		"esnext.object.iterate-values"
	],
		"core-js/modules/esnext.observable": [
		"esnext.observable"
	],
		"core-js/modules/esnext.promise.all-settled": [
		"esnext.promise.all-settled"
	],
		"core-js/modules/esnext.promise.any": [
		"esnext.promise.any"
	],
		"core-js/modules/esnext.promise.try": [
		"esnext.promise.try"
	],
		"core-js/modules/esnext.reflect.define-metadata": [
		"esnext.reflect.define-metadata"
	],
		"core-js/modules/esnext.reflect.delete-metadata": [
		"esnext.reflect.delete-metadata"
	],
		"core-js/modules/esnext.reflect.get-metadata": [
		"esnext.reflect.get-metadata"
	],
		"core-js/modules/esnext.reflect.get-metadata-keys": [
		"esnext.reflect.get-metadata-keys"
	],
		"core-js/modules/esnext.reflect.get-own-metadata": [
		"esnext.reflect.get-own-metadata"
	],
		"core-js/modules/esnext.reflect.get-own-metadata-keys": [
		"esnext.reflect.get-own-metadata-keys"
	],
		"core-js/modules/esnext.reflect.has-metadata": [
		"esnext.reflect.has-metadata"
	],
		"core-js/modules/esnext.reflect.has-own-metadata": [
		"esnext.reflect.has-own-metadata"
	],
		"core-js/modules/esnext.reflect.metadata": [
		"esnext.reflect.metadata"
	],
		"core-js/modules/esnext.set.add-all": [
		"esnext.set.add-all"
	],
		"core-js/modules/esnext.set.delete-all": [
		"esnext.set.delete-all"
	],
		"core-js/modules/esnext.set.difference": [
		"esnext.set.difference"
	],
		"core-js/modules/esnext.set.every": [
		"esnext.set.every"
	],
		"core-js/modules/esnext.set.filter": [
		"esnext.set.filter"
	],
		"core-js/modules/esnext.set.find": [
		"esnext.set.find"
	],
		"core-js/modules/esnext.set.from": [
		"esnext.set.from"
	],
		"core-js/modules/esnext.set.intersection": [
		"esnext.set.intersection"
	],
		"core-js/modules/esnext.set.is-disjoint-from": [
		"esnext.set.is-disjoint-from"
	],
		"core-js/modules/esnext.set.is-subset-of": [
		"esnext.set.is-subset-of"
	],
		"core-js/modules/esnext.set.is-superset-of": [
		"esnext.set.is-superset-of"
	],
		"core-js/modules/esnext.set.join": [
		"esnext.set.join"
	],
		"core-js/modules/esnext.set.map": [
		"esnext.set.map"
	],
		"core-js/modules/esnext.set.of": [
		"esnext.set.of"
	],
		"core-js/modules/esnext.set.reduce": [
		"esnext.set.reduce"
	],
		"core-js/modules/esnext.set.some": [
		"esnext.set.some"
	],
		"core-js/modules/esnext.set.symmetric-difference": [
		"esnext.set.symmetric-difference"
	],
		"core-js/modules/esnext.set.union": [
		"esnext.set.union"
	],
		"core-js/modules/esnext.string.at": [
		"esnext.string.at"
	],
		"core-js/modules/esnext.string.at-alternative": [
		"esnext.string.at-alternative"
	],
		"core-js/modules/esnext.string.code-points": [
		"esnext.string.code-points"
	],
		"core-js/modules/esnext.string.match-all": [
		"esnext.string.match-all"
	],
		"core-js/modules/esnext.string.replace-all": [
		"esnext.string.replace-all"
	],
		"core-js/modules/esnext.symbol.async-dispose": [
		"esnext.symbol.async-dispose"
	],
		"core-js/modules/esnext.symbol.dispose": [
		"esnext.symbol.dispose"
	],
		"core-js/modules/esnext.symbol.matcher": [
		"esnext.symbol.matcher"
	],
		"core-js/modules/esnext.symbol.metadata": [
		"esnext.symbol.metadata"
	],
		"core-js/modules/esnext.symbol.observable": [
		"esnext.symbol.observable"
	],
		"core-js/modules/esnext.symbol.pattern-match": [
		"esnext.symbol.pattern-match"
	],
		"core-js/modules/esnext.symbol.replace-all": [
		"esnext.symbol.replace-all"
	],
		"core-js/modules/esnext.typed-array.at": [
		"esnext.typed-array.at"
	],
		"core-js/modules/esnext.typed-array.filter-out": [
		"esnext.typed-array.filter-out"
	],
		"core-js/modules/esnext.typed-array.filter-reject": [
		"esnext.typed-array.filter-reject"
	],
		"core-js/modules/esnext.typed-array.find-last": [
		"esnext.typed-array.find-last"
	],
		"core-js/modules/esnext.typed-array.find-last-index": [
		"esnext.typed-array.find-last-index"
	],
		"core-js/modules/esnext.typed-array.from-async": [
		"esnext.typed-array.from-async"
	],
		"core-js/modules/esnext.typed-array.group-by": [
		"esnext.typed-array.group-by"
	],
		"core-js/modules/esnext.typed-array.unique-by": [
		"esnext.typed-array.unique-by"
	],
		"core-js/modules/esnext.weak-map.delete-all": [
		"esnext.weak-map.delete-all"
	],
		"core-js/modules/esnext.weak-map.emplace": [
		"esnext.weak-map.emplace"
	],
		"core-js/modules/esnext.weak-map.from": [
		"esnext.weak-map.from"
	],
		"core-js/modules/esnext.weak-map.of": [
		"esnext.weak-map.of"
	],
		"core-js/modules/esnext.weak-map.upsert": [
		"esnext.weak-map.upsert"
	],
		"core-js/modules/esnext.weak-set.add-all": [
		"esnext.weak-set.add-all"
	],
		"core-js/modules/esnext.weak-set.delete-all": [
		"esnext.weak-set.delete-all"
	],
		"core-js/modules/esnext.weak-set.from": [
		"esnext.weak-set.from"
	],
		"core-js/modules/esnext.weak-set.of": [
		"esnext.weak-set.of"
	],
		"core-js/modules/web.dom-collections.for-each": [
		"web.dom-collections.for-each"
	],
		"core-js/modules/web.dom-collections.iterator": [
		"web.dom-collections.iterator"
	],
		"core-js/modules/web.immediate": [
		"web.immediate"
	],
		"core-js/modules/web.queue-microtask": [
		"web.queue-microtask"
	],
		"core-js/modules/web.timers": [
		"web.timers"
	],
		"core-js/modules/web.url": [
		"web.url"
	],
		"core-js/modules/web.url-search-params": [
		"web.url-search-params"
	],
		"core-js/modules/web.url.to-json": [
		"web.url.to-json"
	],
		"core-js/proposals": [
		"es.map",
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/proposals/accessible-object-hasownproperty": [
		"esnext.object.has-own"
	],
		"core-js/proposals/array-filtering": [
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject"
	],
		"core-js/proposals/array-find-from-last": [
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index"
	],
		"core-js/proposals/array-from-async": [
		"esnext.array.from-async",
		"esnext.typed-array.from-async"
	],
		"core-js/proposals/array-grouping": [
		"esnext.array.group-by",
		"esnext.typed-array.group-by"
	],
		"core-js/proposals/array-is-template-object": [
		"esnext.array.is-template-object"
	],
		"core-js/proposals/array-last": [
		"esnext.array.last-index",
		"esnext.array.last-item"
	],
		"core-js/proposals/array-unique": [
		"es.map",
		"esnext.array.unique-by",
		"esnext.typed-array.unique-by"
	],
		"core-js/proposals/collection-methods": [
		"esnext.map.delete-all",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.weak-map.delete-all",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all"
	],
		"core-js/proposals/collection-of-from": [
		"esnext.map.from",
		"esnext.map.of",
		"esnext.set.from",
		"esnext.set.of",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-set.from",
		"esnext.weak-set.of"
	],
		"core-js/proposals/decorators": [
		"esnext.symbol.metadata"
	],
		"core-js/proposals/efficient-64-bit-arithmetic": [
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.umulh"
	],
		"core-js/proposals/global-this": [
		"esnext.global-this"
	],
		"core-js/proposals/iterator-helpers": [
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array"
	],
		"core-js/proposals/keys-composition": [
		"esnext.composite-key",
		"esnext.composite-symbol"
	],
		"core-js/proposals/map-update-or-insert": [
		"esnext.map.emplace",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert"
	],
		"core-js/proposals/map-upsert": [
		"esnext.map.emplace",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert"
	],
		"core-js/proposals/math-extensions": [
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale"
	],
		"core-js/proposals/math-signbit": [
		"esnext.math.signbit"
	],
		"core-js/proposals/number-from-string": [
		"esnext.number.from-string"
	],
		"core-js/proposals/number-range": [
		"esnext.bigint.range",
		"esnext.number.range"
	],
		"core-js/proposals/object-iteration": [
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values"
	],
		"core-js/proposals/observable": [
		"esnext.observable",
		"esnext.symbol.observable"
	],
		"core-js/proposals/pattern-matching": [
		"esnext.symbol.matcher",
		"esnext.symbol.pattern-match"
	],
		"core-js/proposals/promise-all-settled": [
		"esnext.promise.all-settled"
	],
		"core-js/proposals/promise-any": [
		"esnext.aggregate-error",
		"esnext.promise.any"
	],
		"core-js/proposals/promise-try": [
		"esnext.promise.try"
	],
		"core-js/proposals/reflect-metadata": [
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata"
	],
		"core-js/proposals/relative-indexing-method": [
		"es.string.at-alternative",
		"esnext.array.at",
		"esnext.typed-array.at"
	],
		"core-js/proposals/seeded-random": [
		"esnext.math.seeded-prng"
	],
		"core-js/proposals/set-methods": [
		"esnext.set.difference",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.symmetric-difference",
		"esnext.set.union"
	],
		"core-js/proposals/string-at": [
		"esnext.string.at"
	],
		"core-js/proposals/string-code-points": [
		"esnext.string.code-points"
	],
		"core-js/proposals/string-match-all": [
		"esnext.string.match-all"
	],
		"core-js/proposals/string-replace-all": [
		"esnext.string.replace-all",
		"esnext.symbol.replace-all"
	],
		"core-js/proposals/url": [
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/proposals/using-statement": [
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose"
	],
		"core-js/stable": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.aggregate-error",
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.data-view",
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string",
		"es.escape",
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name",
		"es.global-this",
		"es.json.stringify",
		"es.json.to-string-tag",
		"es.map",
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc",
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.parse-float",
		"es.parse-int",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag",
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.set",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string",
		"es.unescape",
		"es.weak-map",
		"es.weak-set",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/stable/aggregate-error": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.string.iterator",
		"esnext.aggregate-error",
		"web.dom-collections.iterator"
	],
		"core-js/stable/array": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.from",
		"es.array.includes",
		"es.array.index-of",
		"es.array.is-array",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.of",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/stable/array-buffer": [
		"es.array-buffer.constructor",
		"es.array-buffer.is-view",
		"es.array-buffer.slice",
		"es.object.to-string"
	],
		"core-js/stable/array-buffer/constructor": [
		"es.array-buffer.constructor",
		"es.object.to-string"
	],
		"core-js/stable/array-buffer/is-view": [
		"es.array-buffer.is-view"
	],
		"core-js/stable/array-buffer/slice": [
		"es.array-buffer.slice"
	],
		"core-js/stable/array/at": [
		"es.array.at"
	],
		"core-js/stable/array/concat": [
		"es.array.concat"
	],
		"core-js/stable/array/copy-within": [
		"es.array.copy-within"
	],
		"core-js/stable/array/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/every": [
		"es.array.every"
	],
		"core-js/stable/array/fill": [
		"es.array.fill"
	],
		"core-js/stable/array/filter": [
		"es.array.filter"
	],
		"core-js/stable/array/find": [
		"es.array.find"
	],
		"core-js/stable/array/find-index": [
		"es.array.find-index"
	],
		"core-js/stable/array/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/stable/array/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/stable/array/for-each": [
		"es.array.for-each"
	],
		"core-js/stable/array/from": [
		"es.array.from",
		"es.string.iterator"
	],
		"core-js/stable/array/includes": [
		"es.array.includes"
	],
		"core-js/stable/array/index-of": [
		"es.array.index-of"
	],
		"core-js/stable/array/is-array": [
		"es.array.is-array"
	],
		"core-js/stable/array/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/join": [
		"es.array.join"
	],
		"core-js/stable/array/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/stable/array/map": [
		"es.array.map"
	],
		"core-js/stable/array/of": [
		"es.array.of"
	],
		"core-js/stable/array/reduce": [
		"es.array.reduce"
	],
		"core-js/stable/array/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/stable/array/reverse": [
		"es.array.reverse"
	],
		"core-js/stable/array/slice": [
		"es.array.slice"
	],
		"core-js/stable/array/some": [
		"es.array.some"
	],
		"core-js/stable/array/sort": [
		"es.array.sort"
	],
		"core-js/stable/array/splice": [
		"es.array.splice"
	],
		"core-js/stable/array/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/virtual": [
		"es.array.at",
		"es.array.concat",
		"es.array.copy-within",
		"es.array.every",
		"es.array.fill",
		"es.array.filter",
		"es.array.find",
		"es.array.find-index",
		"es.array.flat",
		"es.array.flat-map",
		"es.array.for-each",
		"es.array.includes",
		"es.array.index-of",
		"es.array.iterator",
		"es.array.join",
		"es.array.last-index-of",
		"es.array.map",
		"es.array.reduce",
		"es.array.reduce-right",
		"es.array.reverse",
		"es.array.slice",
		"es.array.some",
		"es.array.sort",
		"es.array.species",
		"es.array.splice",
		"es.array.unscopables.flat",
		"es.array.unscopables.flat-map",
		"es.object.to-string"
	],
		"core-js/stable/array/virtual/at": [
		"es.array.at"
	],
		"core-js/stable/array/virtual/concat": [
		"es.array.concat"
	],
		"core-js/stable/array/virtual/copy-within": [
		"es.array.copy-within"
	],
		"core-js/stable/array/virtual/entries": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/virtual/every": [
		"es.array.every"
	],
		"core-js/stable/array/virtual/fill": [
		"es.array.fill"
	],
		"core-js/stable/array/virtual/filter": [
		"es.array.filter"
	],
		"core-js/stable/array/virtual/find": [
		"es.array.find"
	],
		"core-js/stable/array/virtual/find-index": [
		"es.array.find-index"
	],
		"core-js/stable/array/virtual/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/stable/array/virtual/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/stable/array/virtual/for-each": [
		"es.array.for-each"
	],
		"core-js/stable/array/virtual/includes": [
		"es.array.includes"
	],
		"core-js/stable/array/virtual/index-of": [
		"es.array.index-of"
	],
		"core-js/stable/array/virtual/iterator": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/virtual/join": [
		"es.array.join"
	],
		"core-js/stable/array/virtual/keys": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/array/virtual/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/stable/array/virtual/map": [
		"es.array.map"
	],
		"core-js/stable/array/virtual/reduce": [
		"es.array.reduce"
	],
		"core-js/stable/array/virtual/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/stable/array/virtual/reverse": [
		"es.array.reverse"
	],
		"core-js/stable/array/virtual/slice": [
		"es.array.slice"
	],
		"core-js/stable/array/virtual/some": [
		"es.array.some"
	],
		"core-js/stable/array/virtual/sort": [
		"es.array.sort"
	],
		"core-js/stable/array/virtual/splice": [
		"es.array.splice"
	],
		"core-js/stable/array/virtual/values": [
		"es.array.iterator",
		"es.object.to-string"
	],
		"core-js/stable/clear-immediate": [
		"web.immediate"
	],
		"core-js/stable/data-view": [
		"es.data-view",
		"es.object.to-string"
	],
		"core-js/stable/date": [
		"es.date.get-year",
		"es.date.now",
		"es.date.set-year",
		"es.date.to-gmt-string",
		"es.date.to-iso-string",
		"es.date.to-json",
		"es.date.to-primitive",
		"es.date.to-string"
	],
		"core-js/stable/date/get-year": [
		"es.date.get-year"
	],
		"core-js/stable/date/now": [
		"es.date.now"
	],
		"core-js/stable/date/set-year": [
		"es.date.set-year"
	],
		"core-js/stable/date/to-gmt-string": [
		"es.date.to-gmt-string"
	],
		"core-js/stable/date/to-iso-string": [
		"es.date.to-iso-string",
		"es.date.to-json"
	],
		"core-js/stable/date/to-json": [
		"es.date.to-json"
	],
		"core-js/stable/date/to-primitive": [
		"es.date.to-primitive"
	],
		"core-js/stable/date/to-string": [
		"es.date.to-string"
	],
		"core-js/stable/dom-collections": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.for-each",
		"web.dom-collections.iterator"
	],
		"core-js/stable/dom-collections/for-each": [
		"web.dom-collections.for-each"
	],
		"core-js/stable/dom-collections/iterator": [
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/stable/escape": [
		"es.escape"
	],
		"core-js/stable/function": [
		"es.function.bind",
		"es.function.has-instance",
		"es.function.name"
	],
		"core-js/stable/function/bind": [
		"es.function.bind"
	],
		"core-js/stable/function/has-instance": [
		"es.function.has-instance"
	],
		"core-js/stable/function/name": [
		"es.function.name"
	],
		"core-js/stable/function/virtual": [
		"es.function.bind"
	],
		"core-js/stable/function/virtual/bind": [
		"es.function.bind"
	],
		"core-js/stable/get-iterator": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/get-iterator-method": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/global-this": [
		"es.global-this"
	],
		"core-js/stable/instance/at": [
		"es.array.at",
		"es.string.at-alternative"
	],
		"core-js/stable/instance/bind": [
		"es.function.bind"
	],
		"core-js/stable/instance/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/stable/instance/concat": [
		"es.array.concat"
	],
		"core-js/stable/instance/copy-within": [
		"es.array.copy-within"
	],
		"core-js/stable/instance/ends-with": [
		"es.string.ends-with"
	],
		"core-js/stable/instance/entries": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/stable/instance/every": [
		"es.array.every"
	],
		"core-js/stable/instance/fill": [
		"es.array.fill"
	],
		"core-js/stable/instance/filter": [
		"es.array.filter"
	],
		"core-js/stable/instance/find": [
		"es.array.find"
	],
		"core-js/stable/instance/find-index": [
		"es.array.find-index"
	],
		"core-js/stable/instance/flags": [
		"es.regexp.flags"
	],
		"core-js/stable/instance/flat": [
		"es.array.flat",
		"es.array.unscopables.flat"
	],
		"core-js/stable/instance/flat-map": [
		"es.array.flat-map",
		"es.array.unscopables.flat-map"
	],
		"core-js/stable/instance/for-each": [
		"es.array.for-each",
		"web.dom-collections.iterator"
	],
		"core-js/stable/instance/includes": [
		"es.array.includes",
		"es.string.includes"
	],
		"core-js/stable/instance/index-of": [
		"es.array.index-of"
	],
		"core-js/stable/instance/keys": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/stable/instance/last-index-of": [
		"es.array.last-index-of"
	],
		"core-js/stable/instance/map": [
		"es.array.map"
	],
		"core-js/stable/instance/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/stable/instance/pad-end": [
		"es.string.pad-end"
	],
		"core-js/stable/instance/pad-start": [
		"es.string.pad-start"
	],
		"core-js/stable/instance/reduce": [
		"es.array.reduce"
	],
		"core-js/stable/instance/reduce-right": [
		"es.array.reduce-right"
	],
		"core-js/stable/instance/repeat": [
		"es.string.repeat"
	],
		"core-js/stable/instance/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/stable/instance/reverse": [
		"es.array.reverse"
	],
		"core-js/stable/instance/slice": [
		"es.array.slice"
	],
		"core-js/stable/instance/some": [
		"es.array.some"
	],
		"core-js/stable/instance/sort": [
		"es.array.sort"
	],
		"core-js/stable/instance/splice": [
		"es.array.splice"
	],
		"core-js/stable/instance/starts-with": [
		"es.string.starts-with"
	],
		"core-js/stable/instance/trim": [
		"es.string.trim"
	],
		"core-js/stable/instance/trim-end": [
		"es.string.trim-end"
	],
		"core-js/stable/instance/trim-left": [
		"es.string.trim-start"
	],
		"core-js/stable/instance/trim-right": [
		"es.string.trim-end"
	],
		"core-js/stable/instance/trim-start": [
		"es.string.trim-start"
	],
		"core-js/stable/instance/values": [
		"es.array.iterator",
		"es.object.to-string",
		"web.dom-collections.iterator"
	],
		"core-js/stable/is-iterable": [
		"es.array.iterator",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/json": [
		"es.json.stringify",
		"es.json.to-string-tag"
	],
		"core-js/stable/json/stringify": [
		"es.json.stringify"
	],
		"core-js/stable/json/to-string-tag": [
		"es.json.to-string-tag"
	],
		"core-js/stable/map": [
		"es.array.iterator",
		"es.map",
		"es.object.to-string",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/math": [
		"es.math.acosh",
		"es.math.asinh",
		"es.math.atanh",
		"es.math.cbrt",
		"es.math.clz32",
		"es.math.cosh",
		"es.math.expm1",
		"es.math.fround",
		"es.math.hypot",
		"es.math.imul",
		"es.math.log10",
		"es.math.log1p",
		"es.math.log2",
		"es.math.sign",
		"es.math.sinh",
		"es.math.tanh",
		"es.math.to-string-tag",
		"es.math.trunc"
	],
		"core-js/stable/math/acosh": [
		"es.math.acosh"
	],
		"core-js/stable/math/asinh": [
		"es.math.asinh"
	],
		"core-js/stable/math/atanh": [
		"es.math.atanh"
	],
		"core-js/stable/math/cbrt": [
		"es.math.cbrt"
	],
		"core-js/stable/math/clz32": [
		"es.math.clz32"
	],
		"core-js/stable/math/cosh": [
		"es.math.cosh"
	],
		"core-js/stable/math/expm1": [
		"es.math.expm1"
	],
		"core-js/stable/math/fround": [
		"es.math.fround"
	],
		"core-js/stable/math/hypot": [
		"es.math.hypot"
	],
		"core-js/stable/math/imul": [
		"es.math.imul"
	],
		"core-js/stable/math/log10": [
		"es.math.log10"
	],
		"core-js/stable/math/log1p": [
		"es.math.log1p"
	],
		"core-js/stable/math/log2": [
		"es.math.log2"
	],
		"core-js/stable/math/sign": [
		"es.math.sign"
	],
		"core-js/stable/math/sinh": [
		"es.math.sinh"
	],
		"core-js/stable/math/tanh": [
		"es.math.tanh"
	],
		"core-js/stable/math/to-string-tag": [
		"es.math.to-string-tag"
	],
		"core-js/stable/math/trunc": [
		"es.math.trunc"
	],
		"core-js/stable/number": [
		"es.number.constructor",
		"es.number.epsilon",
		"es.number.is-finite",
		"es.number.is-integer",
		"es.number.is-nan",
		"es.number.is-safe-integer",
		"es.number.max-safe-integer",
		"es.number.min-safe-integer",
		"es.number.parse-float",
		"es.number.parse-int",
		"es.number.to-fixed",
		"es.number.to-precision"
	],
		"core-js/stable/number/constructor": [
		"es.number.constructor"
	],
		"core-js/stable/number/epsilon": [
		"es.number.epsilon"
	],
		"core-js/stable/number/is-finite": [
		"es.number.is-finite"
	],
		"core-js/stable/number/is-integer": [
		"es.number.is-integer"
	],
		"core-js/stable/number/is-nan": [
		"es.number.is-nan"
	],
		"core-js/stable/number/is-safe-integer": [
		"es.number.is-safe-integer"
	],
		"core-js/stable/number/max-safe-integer": [
		"es.number.max-safe-integer"
	],
		"core-js/stable/number/min-safe-integer": [
		"es.number.min-safe-integer"
	],
		"core-js/stable/number/parse-float": [
		"es.number.parse-float"
	],
		"core-js/stable/number/parse-int": [
		"es.number.parse-int"
	],
		"core-js/stable/number/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/stable/number/to-precision": [
		"es.number.to-precision"
	],
		"core-js/stable/number/virtual": [
		"es.number.to-fixed",
		"es.number.to-precision"
	],
		"core-js/stable/number/virtual/to-fixed": [
		"es.number.to-fixed"
	],
		"core-js/stable/number/virtual/to-precision": [
		"es.number.to-precision"
	],
		"core-js/stable/object": [
		"es.symbol",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.assign",
		"es.object.create",
		"es.object.define-getter",
		"es.object.define-properties",
		"es.object.define-property",
		"es.object.define-setter",
		"es.object.entries",
		"es.object.freeze",
		"es.object.from-entries",
		"es.object.get-own-property-descriptor",
		"es.object.get-own-property-descriptors",
		"es.object.get-own-property-names",
		"es.object.get-prototype-of",
		"es.object.has-own",
		"es.object.is",
		"es.object.is-extensible",
		"es.object.is-frozen",
		"es.object.is-sealed",
		"es.object.keys",
		"es.object.lookup-getter",
		"es.object.lookup-setter",
		"es.object.prevent-extensions",
		"es.object.seal",
		"es.object.set-prototype-of",
		"es.object.to-string",
		"es.object.values",
		"es.reflect.to-string-tag",
		"web.dom-collections.iterator"
	],
		"core-js/stable/object/assign": [
		"es.object.assign"
	],
		"core-js/stable/object/create": [
		"es.object.create"
	],
		"core-js/stable/object/define-getter": [
		"es.object.define-getter"
	],
		"core-js/stable/object/define-properties": [
		"es.object.define-properties"
	],
		"core-js/stable/object/define-property": [
		"es.object.define-property"
	],
		"core-js/stable/object/define-setter": [
		"es.object.define-setter"
	],
		"core-js/stable/object/entries": [
		"es.object.entries"
	],
		"core-js/stable/object/freeze": [
		"es.object.freeze"
	],
		"core-js/stable/object/from-entries": [
		"es.array.iterator",
		"es.object.from-entries",
		"web.dom-collections.iterator"
	],
		"core-js/stable/object/get-own-property-descriptor": [
		"es.object.get-own-property-descriptor"
	],
		"core-js/stable/object/get-own-property-descriptors": [
		"es.object.get-own-property-descriptors"
	],
		"core-js/stable/object/get-own-property-names": [
		"es.object.get-own-property-names"
	],
		"core-js/stable/object/get-own-property-symbols": [
		"es.symbol"
	],
		"core-js/stable/object/get-prototype-of": [
		"es.object.get-prototype-of"
	],
		"core-js/stable/object/has-own": [
		"es.object.has-own"
	],
		"core-js/stable/object/is": [
		"es.object.is"
	],
		"core-js/stable/object/is-extensible": [
		"es.object.is-extensible"
	],
		"core-js/stable/object/is-frozen": [
		"es.object.is-frozen"
	],
		"core-js/stable/object/is-sealed": [
		"es.object.is-sealed"
	],
		"core-js/stable/object/keys": [
		"es.object.keys"
	],
		"core-js/stable/object/lookup-getter": [
		"es.object.lookup-setter"
	],
		"core-js/stable/object/lookup-setter": [
		"es.object.lookup-setter"
	],
		"core-js/stable/object/prevent-extensions": [
		"es.object.prevent-extensions"
	],
		"core-js/stable/object/seal": [
		"es.object.seal"
	],
		"core-js/stable/object/set-prototype-of": [
		"es.object.set-prototype-of"
	],
		"core-js/stable/object/to-string": [
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/stable/object/values": [
		"es.object.values"
	],
		"core-js/stable/parse-float": [
		"es.parse-float"
	],
		"core-js/stable/parse-int": [
		"es.parse-int"
	],
		"core-js/stable/promise": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.promise.any",
		"es.promise.finally",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/promise/all-settled": [
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.all-settled",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/promise/any": [
		"es.aggregate-error",
		"es.array.iterator",
		"es.object.to-string",
		"es.promise",
		"es.promise.any",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/promise/finally": [
		"es.object.to-string",
		"es.promise",
		"es.promise.finally"
	],
		"core-js/stable/queue-microtask": [
		"web.queue-microtask"
	],
		"core-js/stable/reflect": [
		"es.object.to-string",
		"es.reflect.apply",
		"es.reflect.construct",
		"es.reflect.define-property",
		"es.reflect.delete-property",
		"es.reflect.get",
		"es.reflect.get-own-property-descriptor",
		"es.reflect.get-prototype-of",
		"es.reflect.has",
		"es.reflect.is-extensible",
		"es.reflect.own-keys",
		"es.reflect.prevent-extensions",
		"es.reflect.set",
		"es.reflect.set-prototype-of",
		"es.reflect.to-string-tag"
	],
		"core-js/stable/reflect/apply": [
		"es.reflect.apply"
	],
		"core-js/stable/reflect/construct": [
		"es.reflect.construct"
	],
		"core-js/stable/reflect/define-property": [
		"es.reflect.define-property"
	],
		"core-js/stable/reflect/delete-property": [
		"es.reflect.delete-property"
	],
		"core-js/stable/reflect/get": [
		"es.reflect.get"
	],
		"core-js/stable/reflect/get-own-property-descriptor": [
		"es.reflect.get-own-property-descriptor"
	],
		"core-js/stable/reflect/get-prototype-of": [
		"es.reflect.get-prototype-of"
	],
		"core-js/stable/reflect/has": [
		"es.reflect.has"
	],
		"core-js/stable/reflect/is-extensible": [
		"es.reflect.is-extensible"
	],
		"core-js/stable/reflect/own-keys": [
		"es.reflect.own-keys"
	],
		"core-js/stable/reflect/prevent-extensions": [
		"es.reflect.prevent-extensions"
	],
		"core-js/stable/reflect/set": [
		"es.reflect.set"
	],
		"core-js/stable/reflect/set-prototype-of": [
		"es.reflect.set-prototype-of"
	],
		"core-js/stable/reflect/to-string-tag": [
		"es.reflect.to-string-tag"
	],
		"core-js/stable/regexp": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.flags",
		"es.regexp.sticky",
		"es.regexp.test",
		"es.regexp.to-string",
		"es.string.match",
		"es.string.replace",
		"es.string.search",
		"es.string.split"
	],
		"core-js/stable/regexp/constructor": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/stable/regexp/dot-all": [
		"es.regexp.constructor",
		"es.regexp.dot-all",
		"es.regexp.exec"
	],
		"core-js/stable/regexp/flags": [
		"es.regexp.flags"
	],
		"core-js/stable/regexp/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/stable/regexp/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/stable/regexp/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/stable/regexp/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/stable/regexp/sticky": [
		"es.regexp.constructor",
		"es.regexp.exec",
		"es.regexp.sticky"
	],
		"core-js/stable/regexp/test": [
		"es.regexp.exec",
		"es.regexp.test"
	],
		"core-js/stable/regexp/to-string": [
		"es.regexp.to-string"
	],
		"core-js/stable/set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.set",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/set-immediate": [
		"web.immediate"
	],
		"core-js/stable/set-interval": [
		"web.timers"
	],
		"core-js/stable/set-timeout": [
		"web.timers"
	],
		"core-js/stable/string": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.from-code-point",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.raw",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup"
	],
		"core-js/stable/string/anchor": [
		"es.string.anchor"
	],
		"core-js/stable/string/at": [
		"es.string.at-alternative"
	],
		"core-js/stable/string/big": [
		"es.string.big"
	],
		"core-js/stable/string/blink": [
		"es.string.blink"
	],
		"core-js/stable/string/bold": [
		"es.string.bold"
	],
		"core-js/stable/string/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/stable/string/ends-with": [
		"es.string.ends-with"
	],
		"core-js/stable/string/fixed": [
		"es.string.fixed"
	],
		"core-js/stable/string/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/stable/string/fontsize": [
		"es.string.fontsize"
	],
		"core-js/stable/string/from-code-point": [
		"es.string.from-code-point"
	],
		"core-js/stable/string/includes": [
		"es.string.includes"
	],
		"core-js/stable/string/italics": [
		"es.string.italics"
	],
		"core-js/stable/string/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/stable/string/link": [
		"es.string.link"
	],
		"core-js/stable/string/match": [
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/stable/string/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/stable/string/pad-end": [
		"es.string.pad-end"
	],
		"core-js/stable/string/pad-start": [
		"es.string.pad-start"
	],
		"core-js/stable/string/raw": [
		"es.string.raw"
	],
		"core-js/stable/string/repeat": [
		"es.string.repeat"
	],
		"core-js/stable/string/replace": [
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/stable/string/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/stable/string/search": [
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/stable/string/small": [
		"es.string.small"
	],
		"core-js/stable/string/split": [
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/stable/string/starts-with": [
		"es.string.starts-with"
	],
		"core-js/stable/string/strike": [
		"es.string.strike"
	],
		"core-js/stable/string/sub": [
		"es.string.sub"
	],
		"core-js/stable/string/substr": [
		"es.string.substr"
	],
		"core-js/stable/string/sup": [
		"es.string.sup"
	],
		"core-js/stable/string/trim": [
		"es.string.trim"
	],
		"core-js/stable/string/trim-end": [
		"es.string.trim-end"
	],
		"core-js/stable/string/trim-left": [
		"es.string.trim-start"
	],
		"core-js/stable/string/trim-right": [
		"es.string.trim-end"
	],
		"core-js/stable/string/trim-start": [
		"es.string.trim-start"
	],
		"core-js/stable/string/virtual": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.at-alternative",
		"es.string.code-point-at",
		"es.string.ends-with",
		"es.string.includes",
		"es.string.iterator",
		"es.string.match",
		"es.string.match-all",
		"es.string.pad-end",
		"es.string.pad-start",
		"es.string.repeat",
		"es.string.replace",
		"es.string.replace-all",
		"es.string.search",
		"es.string.split",
		"es.string.starts-with",
		"es.string.substr",
		"es.string.trim",
		"es.string.trim-end",
		"es.string.trim-start",
		"es.string.anchor",
		"es.string.big",
		"es.string.blink",
		"es.string.bold",
		"es.string.fixed",
		"es.string.fontcolor",
		"es.string.fontsize",
		"es.string.italics",
		"es.string.link",
		"es.string.small",
		"es.string.strike",
		"es.string.sub",
		"es.string.sup"
	],
		"core-js/stable/string/virtual/anchor": [
		"es.string.anchor"
	],
		"core-js/stable/string/virtual/at": [
		"es.string.at-alternative"
	],
		"core-js/stable/string/virtual/big": [
		"es.string.big"
	],
		"core-js/stable/string/virtual/blink": [
		"es.string.blink"
	],
		"core-js/stable/string/virtual/bold": [
		"es.string.bold"
	],
		"core-js/stable/string/virtual/code-point-at": [
		"es.string.code-point-at"
	],
		"core-js/stable/string/virtual/ends-with": [
		"es.string.ends-with"
	],
		"core-js/stable/string/virtual/fixed": [
		"es.string.fixed"
	],
		"core-js/stable/string/virtual/fontcolor": [
		"es.string.fontcolor"
	],
		"core-js/stable/string/virtual/fontsize": [
		"es.string.fontsize"
	],
		"core-js/stable/string/virtual/includes": [
		"es.string.includes"
	],
		"core-js/stable/string/virtual/italics": [
		"es.string.italics"
	],
		"core-js/stable/string/virtual/iterator": [
		"es.object.to-string",
		"es.string.iterator"
	],
		"core-js/stable/string/virtual/link": [
		"es.string.link"
	],
		"core-js/stable/string/virtual/match-all": [
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/stable/string/virtual/pad-end": [
		"es.string.pad-end"
	],
		"core-js/stable/string/virtual/pad-start": [
		"es.string.pad-start"
	],
		"core-js/stable/string/virtual/repeat": [
		"es.string.repeat"
	],
		"core-js/stable/string/virtual/replace-all": [
		"es.regexp.exec",
		"es.string.replace",
		"es.string.replace-all"
	],
		"core-js/stable/string/virtual/small": [
		"es.string.small"
	],
		"core-js/stable/string/virtual/starts-with": [
		"es.string.starts-with"
	],
		"core-js/stable/string/virtual/strike": [
		"es.string.strike"
	],
		"core-js/stable/string/virtual/sub": [
		"es.string.sub"
	],
		"core-js/stable/string/virtual/substr": [
		"es.string.substr"
	],
		"core-js/stable/string/virtual/sup": [
		"es.string.sup"
	],
		"core-js/stable/string/virtual/trim": [
		"es.string.trim"
	],
		"core-js/stable/string/virtual/trim-end": [
		"es.string.trim-end"
	],
		"core-js/stable/string/virtual/trim-left": [
		"es.string.trim-start"
	],
		"core-js/stable/string/virtual/trim-right": [
		"es.string.trim-end"
	],
		"core-js/stable/string/virtual/trim-start": [
		"es.string.trim-start"
	],
		"core-js/stable/symbol": [
		"es.symbol",
		"es.symbol.description",
		"es.symbol.async-iterator",
		"es.symbol.has-instance",
		"es.symbol.is-concat-spreadable",
		"es.symbol.iterator",
		"es.symbol.match",
		"es.symbol.match-all",
		"es.symbol.replace",
		"es.symbol.search",
		"es.symbol.species",
		"es.symbol.split",
		"es.symbol.to-primitive",
		"es.symbol.to-string-tag",
		"es.symbol.unscopables",
		"es.array.concat",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag",
		"web.dom-collections.iterator"
	],
		"core-js/stable/symbol/async-iterator": [
		"es.symbol.async-iterator"
	],
		"core-js/stable/symbol/description": [
		"es.symbol.description"
	],
		"core-js/stable/symbol/for": [
		"es.symbol"
	],
		"core-js/stable/symbol/has-instance": [
		"es.symbol.has-instance",
		"es.function.has-instance"
	],
		"core-js/stable/symbol/is-concat-spreadable": [
		"es.symbol.is-concat-spreadable",
		"es.array.concat"
	],
		"core-js/stable/symbol/iterator": [
		"es.symbol.iterator",
		"es.array.iterator",
		"es.object.to-string",
		"es.string.iterator",
		"web.dom-collections.iterator"
	],
		"core-js/stable/symbol/key-for": [
		"es.symbol"
	],
		"core-js/stable/symbol/match": [
		"es.symbol.match",
		"es.regexp.exec",
		"es.string.match"
	],
		"core-js/stable/symbol/match-all": [
		"es.symbol.match-all",
		"es.object.to-string",
		"es.regexp.exec",
		"es.string.match-all"
	],
		"core-js/stable/symbol/replace": [
		"es.symbol.replace",
		"es.regexp.exec",
		"es.string.replace"
	],
		"core-js/stable/symbol/search": [
		"es.symbol.search",
		"es.regexp.exec",
		"es.string.search"
	],
		"core-js/stable/symbol/species": [
		"es.symbol.species"
	],
		"core-js/stable/symbol/split": [
		"es.symbol.split",
		"es.regexp.exec",
		"es.string.split"
	],
		"core-js/stable/symbol/to-primitive": [
		"es.symbol.to-primitive",
		"es.date.to-primitive"
	],
		"core-js/stable/symbol/to-string-tag": [
		"es.symbol.to-string-tag",
		"es.json.to-string-tag",
		"es.math.to-string-tag",
		"es.object.to-string",
		"es.reflect.to-string-tag"
	],
		"core-js/stable/symbol/unscopables": [
		"es.symbol.unscopables"
	],
		"core-js/stable/typed-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.float64-array",
		"es.typed-array.int8-array",
		"es.typed-array.int16-array",
		"es.typed-array.int32-array",
		"es.typed-array.uint8-array",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.uint16-array",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/at": [
		"es.typed-array.at"
	],
		"core-js/stable/typed-array/copy-within": [
		"es.typed-array.copy-within"
	],
		"core-js/stable/typed-array/entries": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/stable/typed-array/every": [
		"es.typed-array.every"
	],
		"core-js/stable/typed-array/fill": [
		"es.typed-array.fill"
	],
		"core-js/stable/typed-array/filter": [
		"es.typed-array.filter"
	],
		"core-js/stable/typed-array/find": [
		"es.typed-array.find"
	],
		"core-js/stable/typed-array/find-index": [
		"es.typed-array.find-index"
	],
		"core-js/stable/typed-array/float32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/float64-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.float64-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/for-each": [
		"es.typed-array.for-each"
	],
		"core-js/stable/typed-array/from": [
		"es.typed-array.from"
	],
		"core-js/stable/typed-array/includes": [
		"es.typed-array.includes"
	],
		"core-js/stable/typed-array/index-of": [
		"es.typed-array.index-of"
	],
		"core-js/stable/typed-array/int16-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/int32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/int8-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.int8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/iterator": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/stable/typed-array/join": [
		"es.typed-array.join"
	],
		"core-js/stable/typed-array/keys": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/stable/typed-array/last-index-of": [
		"es.typed-array.last-index-of"
	],
		"core-js/stable/typed-array/map": [
		"es.typed-array.map"
	],
		"core-js/stable/typed-array/methods": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/of": [
		"es.typed-array.of"
	],
		"core-js/stable/typed-array/reduce": [
		"es.typed-array.reduce"
	],
		"core-js/stable/typed-array/reduce-right": [
		"es.typed-array.reduce-right"
	],
		"core-js/stable/typed-array/reverse": [
		"es.typed-array.reverse"
	],
		"core-js/stable/typed-array/set": [
		"es.typed-array.set"
	],
		"core-js/stable/typed-array/slice": [
		"es.typed-array.slice"
	],
		"core-js/stable/typed-array/some": [
		"es.typed-array.some"
	],
		"core-js/stable/typed-array/sort": [
		"es.typed-array.sort"
	],
		"core-js/stable/typed-array/subarray": [
		"es.typed-array.subarray"
	],
		"core-js/stable/typed-array/to-locale-string": [
		"es.typed-array.to-locale-string"
	],
		"core-js/stable/typed-array/to-string": [
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/uint16-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint16-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/uint32-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint32-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/uint8-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint8-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/uint8-clamped-array": [
		"es.object.to-string",
		"es.string.iterator",
		"es.typed-array.uint8-clamped-array",
		"es.typed-array.at",
		"es.typed-array.copy-within",
		"es.typed-array.every",
		"es.typed-array.fill",
		"es.typed-array.filter",
		"es.typed-array.find",
		"es.typed-array.find-index",
		"es.typed-array.for-each",
		"es.typed-array.from",
		"es.typed-array.includes",
		"es.typed-array.index-of",
		"es.typed-array.iterator",
		"es.typed-array.join",
		"es.typed-array.last-index-of",
		"es.typed-array.map",
		"es.typed-array.of",
		"es.typed-array.reduce",
		"es.typed-array.reduce-right",
		"es.typed-array.reverse",
		"es.typed-array.set",
		"es.typed-array.slice",
		"es.typed-array.some",
		"es.typed-array.sort",
		"es.typed-array.subarray",
		"es.typed-array.to-locale-string",
		"es.typed-array.to-string"
	],
		"core-js/stable/typed-array/values": [
		"es.object.to-string",
		"es.typed-array.iterator"
	],
		"core-js/stable/unescape": [
		"es.unescape"
	],
		"core-js/stable/url": [
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/stable/url-search-params": [
		"web.dom-collections.iterator",
		"web.url-search-params"
	],
		"core-js/stable/url/to-json": [
		"web.url.to-json"
	],
		"core-js/stable/weak-map": [
		"es.array.iterator",
		"es.object.to-string",
		"es.weak-map",
		"web.dom-collections.iterator"
	],
		"core-js/stable/weak-set": [
		"es.array.iterator",
		"es.object.to-string",
		"es.weak-set",
		"web.dom-collections.iterator"
	],
		"core-js/stage": [
		"es.map",
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/stage/0": [
		"es.map",
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/stage/1": [
		"es.map",
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of"
	],
		"core-js/stage/2": [
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.at",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.is-template-object",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.emplace",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.object.has-own",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.set.difference",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.metadata",
		"esnext.symbol.replace-all",
		"esnext.typed-array.at",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert"
	],
		"core-js/stage/3": [
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.at",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.global-this",
		"esnext.object.has-own",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.replace-all",
		"esnext.typed-array.at",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index"
	],
		"core-js/stage/4": [
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.at",
		"esnext.global-this",
		"esnext.object.has-own",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.replace-all",
		"esnext.typed-array.at"
	],
		"core-js/stage/pre": [
		"es.map",
		"es.string.at-alternative",
		"esnext.aggregate-error",
		"esnext.array.from-async",
		"esnext.array.at",
		"esnext.array.filter-out",
		"esnext.array.filter-reject",
		"esnext.array.find-last",
		"esnext.array.find-last-index",
		"esnext.array.group-by",
		"esnext.array.is-template-object",
		"esnext.array.last-index",
		"esnext.array.last-item",
		"esnext.array.unique-by",
		"esnext.async-iterator.constructor",
		"esnext.async-iterator.as-indexed-pairs",
		"esnext.async-iterator.drop",
		"esnext.async-iterator.every",
		"esnext.async-iterator.filter",
		"esnext.async-iterator.find",
		"esnext.async-iterator.flat-map",
		"esnext.async-iterator.for-each",
		"esnext.async-iterator.from",
		"esnext.async-iterator.map",
		"esnext.async-iterator.reduce",
		"esnext.async-iterator.some",
		"esnext.async-iterator.take",
		"esnext.async-iterator.to-array",
		"esnext.bigint.range",
		"esnext.composite-key",
		"esnext.composite-symbol",
		"esnext.global-this",
		"esnext.iterator.constructor",
		"esnext.iterator.as-indexed-pairs",
		"esnext.iterator.drop",
		"esnext.iterator.every",
		"esnext.iterator.filter",
		"esnext.iterator.find",
		"esnext.iterator.flat-map",
		"esnext.iterator.for-each",
		"esnext.iterator.from",
		"esnext.iterator.map",
		"esnext.iterator.reduce",
		"esnext.iterator.some",
		"esnext.iterator.take",
		"esnext.iterator.to-array",
		"esnext.map.delete-all",
		"esnext.map.emplace",
		"esnext.map.every",
		"esnext.map.filter",
		"esnext.map.find",
		"esnext.map.find-key",
		"esnext.map.from",
		"esnext.map.group-by",
		"esnext.map.includes",
		"esnext.map.key-by",
		"esnext.map.key-of",
		"esnext.map.map-keys",
		"esnext.map.map-values",
		"esnext.map.merge",
		"esnext.map.of",
		"esnext.map.reduce",
		"esnext.map.some",
		"esnext.map.update",
		"esnext.map.update-or-insert",
		"esnext.map.upsert",
		"esnext.math.clamp",
		"esnext.math.deg-per-rad",
		"esnext.math.degrees",
		"esnext.math.fscale",
		"esnext.math.iaddh",
		"esnext.math.imulh",
		"esnext.math.isubh",
		"esnext.math.rad-per-deg",
		"esnext.math.radians",
		"esnext.math.scale",
		"esnext.math.seeded-prng",
		"esnext.math.signbit",
		"esnext.math.umulh",
		"esnext.number.from-string",
		"esnext.number.range",
		"esnext.object.has-own",
		"esnext.object.iterate-entries",
		"esnext.object.iterate-keys",
		"esnext.object.iterate-values",
		"esnext.observable",
		"esnext.promise.all-settled",
		"esnext.promise.any",
		"esnext.promise.try",
		"esnext.reflect.define-metadata",
		"esnext.reflect.delete-metadata",
		"esnext.reflect.get-metadata",
		"esnext.reflect.get-metadata-keys",
		"esnext.reflect.get-own-metadata",
		"esnext.reflect.get-own-metadata-keys",
		"esnext.reflect.has-metadata",
		"esnext.reflect.has-own-metadata",
		"esnext.reflect.metadata",
		"esnext.set.add-all",
		"esnext.set.delete-all",
		"esnext.set.difference",
		"esnext.set.every",
		"esnext.set.filter",
		"esnext.set.find",
		"esnext.set.from",
		"esnext.set.intersection",
		"esnext.set.is-disjoint-from",
		"esnext.set.is-subset-of",
		"esnext.set.is-superset-of",
		"esnext.set.join",
		"esnext.set.map",
		"esnext.set.of",
		"esnext.set.reduce",
		"esnext.set.some",
		"esnext.set.symmetric-difference",
		"esnext.set.union",
		"esnext.string.at",
		"esnext.string.code-points",
		"esnext.string.match-all",
		"esnext.string.replace-all",
		"esnext.symbol.async-dispose",
		"esnext.symbol.dispose",
		"esnext.symbol.matcher",
		"esnext.symbol.metadata",
		"esnext.symbol.observable",
		"esnext.symbol.pattern-match",
		"esnext.symbol.replace-all",
		"esnext.typed-array.from-async",
		"esnext.typed-array.at",
		"esnext.typed-array.filter-out",
		"esnext.typed-array.filter-reject",
		"esnext.typed-array.find-last",
		"esnext.typed-array.find-last-index",
		"esnext.typed-array.group-by",
		"esnext.typed-array.unique-by",
		"esnext.weak-map.delete-all",
		"esnext.weak-map.from",
		"esnext.weak-map.of",
		"esnext.weak-map.emplace",
		"esnext.weak-map.upsert",
		"esnext.weak-set.add-all",
		"esnext.weak-set.delete-all",
		"esnext.weak-set.from",
		"esnext.weak-set.of",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/web": [
		"web.dom-collections.for-each",
		"web.dom-collections.iterator",
		"web.immediate",
		"web.queue-microtask",
		"web.timers",
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/web/dom-collections": [
		"web.dom-collections.for-each",
		"web.dom-collections.iterator"
	],
		"core-js/web/immediate": [
		"web.immediate"
	],
		"core-js/web/queue-microtask": [
		"web.queue-microtask"
	],
		"core-js/web/timers": [
		"web.timers"
	],
		"core-js/web/url": [
		"web.url",
		"web.url.to-json",
		"web.url-search-params"
	],
		"core-js/web/url-search-params": [
		"web.url-search-params"
	]
	};

	var entries$1 = require$$0$2;

	var corejs3ShippedProposalsList$1 = new Set([]);
	var polyfillsOrder$1 = {};
	Object.keys(data$1).forEach(function (name, index) {
	  polyfillsOrder$1[name] = index;
	});

	var define$2 = function define(pure, global, name, exclude) {
	  if (name === void 0) {
	    name = global[0];
	  }

	  return {
	    name: name,
	    pure: pure,
	    global: global.sort(function (a, b) {
	      return polyfillsOrder$1[a] - polyfillsOrder$1[b];
	    }),
	    exclude: exclude
	  };
	};

	var typed$1 = function typed(name) {
	  return define$2(null, [name].concat(TypedArrayDependencies$1));
	};

	var ArrayNatureIterators$2 = ["es.array.iterator", "web.dom-collections.iterator"];
	var CommonIterators$2 = ["es.string.iterator"].concat(ArrayNatureIterators$2);
	var ArrayNatureIteratorsWithTag$1 = ["es.object.to-string"].concat(ArrayNatureIterators$2);
	var CommonIteratorsWithTag$1 = ["es.object.to-string"].concat(_toConsumableArray(CommonIterators$2));
	var TypedArrayDependencies$1 = ["es.typed-array.at", "es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice", "esnext.typed-array.filter-reject", "esnext.typed-array.find-last", "esnext.typed-array.find-last-index", "esnext.typed-array.group-by", "esnext.typed-array.unique-by"];
	var PromiseDependencies$2 = ["es.promise", "es.object.to-string"];
	var PromiseDependenciesWithIterators$1 = [].concat(PromiseDependencies$2, _toConsumableArray(CommonIterators$2));
	var SymbolDependencies$1 = ["es.symbol", "es.symbol.description", "es.object.to-string"];
	var MapDependencies$1 = ["es.map", "esnext.map.delete-all", "esnext.map.emplace", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
	var SetDependencies$1 = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
	var WeakMapDependencies$1 = ["es.weak-map", "esnext.weak-map.delete-all", "esnext.weak-map.emplace"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
	var WeakSetDependencies$1 = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
	var URLSearchParamsDependencies$1 = ["web.url-search-params"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
	var AsyncIteratorDependencies$1 = ["esnext.async-iterator.constructor"].concat(PromiseDependencies$2);
	var IteratorDependencies$1 = ["esnext.iterator.constructor", "es.object.to-string"];
	var TypedArrayStaticMethods$1 = {
	  from: define$2(null, ["es.typed-array.from"]),
	  fromAsync: define$2(null, ["esnext.typed-array.from-async"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
	  of: define$2(null, ["es.typed-array.of"])
	};
	var BuiltIns$2 = {
	  AsyncIterator: define$2("async-iterator/index", AsyncIteratorDependencies$1),
	  AggregateError: define$2("aggregate-error", ["es.aggregate-error"].concat(_toConsumableArray(CommonIterators$2))),
	  ArrayBuffer: define$2(null, ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"]),
	  DataView: define$2(null, ["es.data-view", "es.array-buffer.slice", "es.object.to-string"]),
	  Date: define$2(null, ["es.date.to-string"]),
	  Float32Array: typed$1("es.typed-array.float32-array"),
	  Float64Array: typed$1("es.typed-array.float64-array"),
	  Int8Array: typed$1("es.typed-array.int8-array"),
	  Int16Array: typed$1("es.typed-array.int16-array"),
	  Int32Array: typed$1("es.typed-array.int32-array"),
	  Iterator: define$2("iterator/index", IteratorDependencies$1),
	  Uint8Array: typed$1("es.typed-array.uint8-array"),
	  Uint8ClampedArray: typed$1("es.typed-array.uint8-clamped-array"),
	  Uint16Array: typed$1("es.typed-array.uint16-array"),
	  Uint32Array: typed$1("es.typed-array.uint32-array"),
	  Map: define$2("map/index", MapDependencies$1),
	  Number: define$2(null, ["es.number.constructor"]),
	  Observable: define$2("observable/index", ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(_toConsumableArray(CommonIteratorsWithTag$1))),
	  Promise: define$2("promise/index", PromiseDependencies$2),
	  Reflect: define$2(null, ["es.reflect.to-string-tag", "es.object.to-string"]),
	  RegExp: define$2(null, ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec", "es.regexp.sticky", "es.regexp.to-string"]),
	  Set: define$2("set/index", SetDependencies$1),
	  Symbol: define$2("symbol/index", SymbolDependencies$1),
	  URL: define$2("url/index", ["web.url"].concat(_toConsumableArray(URLSearchParamsDependencies$1))),
	  URLSearchParams: define$2("url-search-params/index", URLSearchParamsDependencies$1),
	  WeakMap: define$2("weak-map/index", WeakMapDependencies$1),
	  WeakSet: define$2("weak-set/index", WeakSetDependencies$1),
	  clearImmediate: define$2("clear-immediate", ["web.immediate"]),
	  compositeKey: define$2("composite-key", ["esnext.composite-key"]),
	  compositeSymbol: define$2("composite-symbol", ["esnext.composite-symbol"]),
	  escape: define$2("escape", ["es.escape"]),
	  fetch: define$2(null, PromiseDependencies$2),
	  globalThis: define$2("global-this", ["es.global-this"]),
	  parseFloat: define$2("parse-float", ["es.parse-float"]),
	  parseInt: define$2("parse-int", ["es.parse-int"]),
	  queueMicrotask: define$2("queue-microtask", ["web.queue-microtask"]),
	  setImmediate: define$2("set-immediate", ["web.immediate"]),
	  setInterval: define$2("set-interval", ["web.timers"]),
	  setTimeout: define$2("set-timeout", ["web.timers"]),
	  unescape: define$2("unescape", ["es.unescape"])
	};
	var StaticProperties$2 = {
	  AsyncIterator: {
	    from: define$2("async-iterator/from", ["esnext.async-iterator.from"].concat(_toConsumableArray(AsyncIteratorDependencies$1), _toConsumableArray(CommonIterators$2)))
	  },
	  Array: {
	    from: define$2("array/from", ["es.array.from", "es.string.iterator"]),
	    fromAsync: define$2("array/from-async", ["esnext.array.from-async"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
	    isArray: define$2("array/is-array", ["es.array.is-array"]),
	    isTemplateObject: define$2("array/is-template-object", ["esnext.array.is-template-object"]),
	    of: define$2("array/of", ["es.array.of"])
	  },
	  ArrayBuffer: {
	    isView: define$2(null, ["es.array-buffer.is-view"])
	  },
	  BigInt: {
	    range: define$2("bigint/range", ["esnext.bigint.range", "es.object.to-string"])
	  },
	  Date: {
	    now: define$2("date/now", ["es.date.now"])
	  },
	  Iterator: {
	    from: define$2("iterator/from", ["esnext.iterator.from"].concat(IteratorDependencies$1, _toConsumableArray(CommonIterators$2)))
	  },
	  JSON: {
	    stringify: define$2("json/stringify", ["es.json.stringify"], "es.symbol")
	  },
	  Math: {
	    DEG_PER_RAD: define$2("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
	    RAD_PER_DEG: define$2("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
	    acosh: define$2("math/acosh", ["es.math.acosh"]),
	    asinh: define$2("math/asinh", ["es.math.asinh"]),
	    atanh: define$2("math/atanh", ["es.math.atanh"]),
	    cbrt: define$2("math/cbrt", ["es.math.cbrt"]),
	    clamp: define$2("math/clamp", ["esnext.math.clamp"]),
	    clz32: define$2("math/clz32", ["es.math.clz32"]),
	    cosh: define$2("math/cosh", ["es.math.cosh"]),
	    degrees: define$2("math/degrees", ["esnext.math.degrees"]),
	    expm1: define$2("math/expm1", ["es.math.expm1"]),
	    fround: define$2("math/fround", ["es.math.fround"]),
	    fscale: define$2("math/fscale", ["esnext.math.fscale"]),
	    hypot: define$2("math/hypot", ["es.math.hypot"]),
	    iaddh: define$2("math/iaddh", ["esnext.math.iaddh"]),
	    imul: define$2("math/imul", ["es.math.imul"]),
	    imulh: define$2("math/imulh", ["esnext.math.imulh"]),
	    isubh: define$2("math/isubh", ["esnext.math.isubh"]),
	    log10: define$2("math/log10", ["es.math.log10"]),
	    log1p: define$2("math/log1p", ["es.math.log1p"]),
	    log2: define$2("math/log2", ["es.math.log2"]),
	    radians: define$2("math/radians", ["esnext.math.radians"]),
	    scale: define$2("math/scale", ["esnext.math.scale"]),
	    seededPRNG: define$2("math/seeded-prng", ["esnext.math.seeded-prng"]),
	    sign: define$2("math/sign", ["es.math.sign"]),
	    signbit: define$2("math/signbit", ["esnext.math.signbit"]),
	    sinh: define$2("math/sinh", ["es.math.sinh"]),
	    tanh: define$2("math/tanh", ["es.math.tanh"]),
	    trunc: define$2("math/trunc", ["es.math.trunc"]),
	    umulh: define$2("math/umulh", ["esnext.math.umulh"])
	  },
	  Map: {
	    from: define$2(null, ["esnext.map.from"].concat(_toConsumableArray(MapDependencies$1))),
	    groupBy: define$2(null, ["esnext.map.group-by"].concat(_toConsumableArray(MapDependencies$1))),
	    keyBy: define$2(null, ["esnext.map.key-by"].concat(_toConsumableArray(MapDependencies$1))),
	    of: define$2(null, ["esnext.map.of"].concat(_toConsumableArray(MapDependencies$1)))
	  },
	  Number: {
	    EPSILON: define$2("number/epsilon", ["es.number.epsilon"]),
	    MAX_SAFE_INTEGER: define$2("number/max-safe-integer", ["es.number.max-safe-integer"]),
	    MIN_SAFE_INTEGER: define$2("number/min-safe-integer", ["es.number.min-safe-integer"]),
	    fromString: define$2("number/from-string", ["esnext.number.from-string"]),
	    isFinite: define$2("number/is-finite", ["es.number.is-finite"]),
	    isInteger: define$2("number/is-integer", ["es.number.is-integer"]),
	    isNaN: define$2("number/is-nan", ["es.number.is-nan"]),
	    isSafeInteger: define$2("number/is-safe-integer", ["es.number.is-safe-integer"]),
	    parseFloat: define$2("number/parse-float", ["es.number.parse-float"]),
	    parseInt: define$2("number/parse-int", ["es.number.parse-int"]),
	    range: define$2("number/range", ["esnext.number.range", "es.object.to-string"])
	  },
	  Object: {
	    assign: define$2("object/assign", ["es.object.assign"]),
	    create: define$2("object/create", ["es.object.create"]),
	    defineProperties: define$2("object/define-properties", ["es.object.define-properties"]),
	    defineProperty: define$2("object/define-property", ["es.object.define-property"]),
	    entries: define$2("object/entries", ["es.object.entries"]),
	    freeze: define$2("object/freeze", ["es.object.freeze"]),
	    fromEntries: define$2("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
	    getOwnPropertyDescriptor: define$2("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: define$2("object/get-own-property-descriptors", ["es.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: define$2("object/get-own-property-names", ["es.object.get-own-property-names"]),
	    getOwnPropertySymbols: define$2("object/get-own-property-symbols", ["es.symbol"]),
	    getPrototypeOf: define$2("object/get-prototype-of", ["es.object.get-prototype-of"]),
	    hasOwn: define$2("object/has-own", ["es.object.has-own"]),
	    is: define$2("object/is", ["es.object.is"]),
	    isExtensible: define$2("object/is-extensible", ["es.object.is-extensible"]),
	    isFrozen: define$2("object/is-frozen", ["es.object.is-frozen"]),
	    isSealed: define$2("object/is-sealed", ["es.object.is-sealed"]),
	    keys: define$2("object/keys", ["es.object.keys"]),
	    preventExtensions: define$2("object/prevent-extensions", ["es.object.prevent-extensions"]),
	    seal: define$2("object/seal", ["es.object.seal"]),
	    setPrototypeOf: define$2("object/set-prototype-of", ["es.object.set-prototype-of"]),
	    values: define$2("object/values", ["es.object.values"])
	  },
	  Promise: {
	    all: define$2(null, PromiseDependenciesWithIterators$1),
	    allSettled: define$2(null, ["es.promise.all-settled"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
	    any: define$2(null, ["es.promise.any", "es.aggregate-error"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
	    race: define$2(null, PromiseDependenciesWithIterators$1),
	    "try": define$2(null, ["esnext.promise.try"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1)))
	  },
	  Reflect: {
	    apply: define$2("reflect/apply", ["es.reflect.apply"]),
	    construct: define$2("reflect/construct", ["es.reflect.construct"]),
	    defineMetadata: define$2("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
	    defineProperty: define$2("reflect/define-property", ["es.reflect.define-property"]),
	    deleteMetadata: define$2("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
	    deleteProperty: define$2("reflect/delete-property", ["es.reflect.delete-property"]),
	    get: define$2("reflect/get", ["es.reflect.get"]),
	    getMetadata: define$2("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
	    getMetadataKeys: define$2("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
	    getOwnMetadata: define$2("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
	    getOwnMetadataKeys: define$2("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
	    getOwnPropertyDescriptor: define$2("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: define$2("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
	    has: define$2("reflect/has", ["es.reflect.has"]),
	    hasMetadata: define$2("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
	    hasOwnMetadata: define$2("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
	    isExtensible: define$2("reflect/is-extensible", ["es.reflect.is-extensible"]),
	    metadata: define$2("reflect/metadata", ["esnext.reflect.metadata"]),
	    ownKeys: define$2("reflect/own-keys", ["es.reflect.own-keys"]),
	    preventExtensions: define$2("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
	    set: define$2("reflect/set", ["es.reflect.set"]),
	    setPrototypeOf: define$2("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
	  },
	  Set: {
	    from: define$2(null, ["esnext.set.from"].concat(_toConsumableArray(SetDependencies$1))),
	    of: define$2(null, ["esnext.set.of"].concat(_toConsumableArray(SetDependencies$1)))
	  },
	  String: {
	    fromCodePoint: define$2("string/from-code-point", ["es.string.from-code-point"]),
	    raw: define$2("string/raw", ["es.string.raw"])
	  },
	  Symbol: {
	    asyncDispose: define$2("symbol/async-dispose", ["esnext.symbol.async-dispose"]),
	    asyncIterator: define$2("symbol/async-iterator", ["es.symbol.async-iterator"]),
	    dispose: define$2("symbol/dispose", ["esnext.symbol.dispose"]),
	    "for": define$2("symbol/for", [], "es.symbol"),
	    hasInstance: define$2("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
	    isConcatSpreadable: define$2("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
	    iterator: define$2("symbol/iterator", ["es.symbol.iterator"].concat(_toConsumableArray(CommonIteratorsWithTag$1))),
	    keyFor: define$2("symbol/key-for", [], "es.symbol"),
	    match: define$2("symbol/match", ["es.symbol.match", "es.string.match"]),
	    matcher: define$2("symbol/matcher", ["esnext.symbol.matcher"]),
	    matchAll: define$2("symbol/match-all", ["es.symbol.match-all", "es.string.match-all"]),
	    metadata: define$2("symbol/metadata", ["esnext.symbol.metadata"]),
	    observable: define$2("symbol/observable", ["esnext.symbol.observable"]),
	    patternMatch: define$2("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
	    replace: define$2("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
	    search: define$2("symbol/search", ["es.symbol.search", "es.string.search"]),
	    species: define$2("symbol/species", ["es.symbol.species", "es.array.species"]),
	    split: define$2("symbol/split", ["es.symbol.split", "es.string.split"]),
	    toPrimitive: define$2("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
	    toStringTag: define$2("symbol/to-string-tag", ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"]),
	    unscopables: define$2("symbol/unscopables", ["es.symbol.unscopables"])
	  },
	  WeakMap: {
	    from: define$2(null, ["esnext.weak-map.from"].concat(_toConsumableArray(WeakMapDependencies$1))),
	    of: define$2(null, ["esnext.weak-map.of"].concat(_toConsumableArray(WeakMapDependencies$1)))
	  },
	  WeakSet: {
	    from: define$2(null, ["esnext.weak-set.from"].concat(_toConsumableArray(WeakSetDependencies$1))),
	    of: define$2(null, ["esnext.weak-set.of"].concat(_toConsumableArray(WeakSetDependencies$1)))
	  },
	  Int8Array: TypedArrayStaticMethods$1,
	  Uint8Array: TypedArrayStaticMethods$1,
	  Uint8ClampedArray: TypedArrayStaticMethods$1,
	  Int16Array: TypedArrayStaticMethods$1,
	  Uint16Array: TypedArrayStaticMethods$1,
	  Int32Array: TypedArrayStaticMethods$1,
	  Uint32Array: TypedArrayStaticMethods$1,
	  Float32Array: TypedArrayStaticMethods$1,
	  Float64Array: TypedArrayStaticMethods$1
	};
	var InstanceProperties$2 = {
	  asIndexedPairs: define$2("instance/asIndexedPairs", ["esnext.async-iterator.as-indexed-pairs"].concat(_toConsumableArray(AsyncIteratorDependencies$1), ["esnext.iterator.as-indexed-pairs"], IteratorDependencies$1)),
	  at: define$2("instance/at", ["esnext.string.at", "es.string.at-alternative", "es.array.at"]),
	  anchor: define$2(null, ["es.string.anchor"]),
	  big: define$2(null, ["es.string.big"]),
	  bind: define$2("instance/bind", ["es.function.bind"]),
	  blink: define$2(null, ["es.string.blink"]),
	  bold: define$2(null, ["es.string.bold"]),
	  codePointAt: define$2("instance/code-point-at", ["es.string.code-point-at"]),
	  codePoints: define$2("instance/code-points", ["esnext.string.code-points"]),
	  concat: define$2("instance/concat", ["es.array.concat"], undefined, ["String"]),
	  copyWithin: define$2("instance/copy-within", ["es.array.copy-within"]),
	  description: define$2(null, ["es.symbol", "es.symbol.description"]),
	  dotAll: define$2("instance/dot-all", ["es.regexp.dot-all"]),
	  drop: define$2("instance/drop", ["esnext.async-iterator.drop"].concat(_toConsumableArray(AsyncIteratorDependencies$1), ["esnext.iterator.drop"], IteratorDependencies$1)),
	  emplace: define$2("instance/emplace", ["esnext.map.emplace", "esnext.weak-map.emplace"]),
	  endsWith: define$2("instance/ends-with", ["es.string.ends-with"]),
	  entries: define$2("instance/entries", ArrayNatureIteratorsWithTag$1),
	  every: define$2("instance/every", ["es.array.every", "esnext.async-iterator.every", "esnext.iterator.every"].concat(IteratorDependencies$1)),
	  exec: define$2(null, ["es.regexp.exec"]),
	  fill: define$2("instance/fill", ["es.array.fill"]),
	  filter: define$2("instance/filter", ["es.array.filter", "esnext.async-iterator.filter", "esnext.iterator.filter"].concat(IteratorDependencies$1)),
	  filterReject: define$2("instance/filterReject", ["esnext.array.filter-reject"]),
	  "finally": define$2(null, ["es.promise.finally"].concat(PromiseDependencies$2)),
	  find: define$2("instance/find", ["es.array.find", "esnext.async-iterator.find", "esnext.iterator.find"].concat(IteratorDependencies$1)),
	  findIndex: define$2("instance/find-index", ["es.array.find-index"]),
	  findLast: define$2("instance/find-last", ["esnext.array.find-last"]),
	  findLastIndex: define$2("instance/find-last-index", ["esnext.array.find-last-index"]),
	  fixed: define$2(null, ["es.string.fixed"]),
	  flags: define$2("instance/flags", ["es.regexp.flags"]),
	  flatMap: define$2("instance/flat-map", ["es.array.flat-map", "es.array.unscopables.flat-map", "esnext.async-iterator.flat-map", "esnext.iterator.flat-map"].concat(IteratorDependencies$1)),
	  flat: define$2("instance/flat", ["es.array.flat", "es.array.unscopables.flat"]),
	  getYear: define$2(null, ["es.date.get-year"]),
	  groupBy: define$2("instance/group-by", ["esnext.array.group-by"]),
	  fontcolor: define$2(null, ["es.string.fontcolor"]),
	  fontsize: define$2(null, ["es.string.fontsize"]),
	  forEach: define$2("instance/for-each", ["es.array.for-each", "esnext.async-iterator.for-each", "esnext.iterator.for-each"].concat(IteratorDependencies$1, ["web.dom-collections.for-each"])),
	  includes: define$2("instance/includes", ["es.array.includes", "es.string.includes"]),
	  indexOf: define$2("instance/index-of", ["es.array.index-of"]),
	  italic: define$2(null, ["es.string.italics"]),
	  join: define$2(null, ["es.array.join"]),
	  keys: define$2("instance/keys", ArrayNatureIteratorsWithTag$1),
	  lastIndex: define$2(null, ["esnext.array.last-index"]),
	  lastIndexOf: define$2("instance/last-index-of", ["es.array.last-index-of"]),
	  lastItem: define$2(null, ["esnext.array.last-item"]),
	  link: define$2(null, ["es.string.link"]),
	  map: define$2("instance/map", ["es.array.map", "esnext.async-iterator.map", "esnext.iterator.map"]),
	  match: define$2(null, ["es.string.match", "es.regexp.exec"]),
	  matchAll: define$2("instance/match-all", ["es.string.match-all", "es.regexp.exec"]),
	  name: define$2(null, ["es.function.name"]),
	  padEnd: define$2("instance/pad-end", ["es.string.pad-end"]),
	  padStart: define$2("instance/pad-start", ["es.string.pad-start"]),
	  reduce: define$2("instance/reduce", ["es.array.reduce", "esnext.async-iterator.reduce", "esnext.iterator.reduce"].concat(IteratorDependencies$1)),
	  reduceRight: define$2("instance/reduce-right", ["es.array.reduce-right"]),
	  repeat: define$2("instance/repeat", ["es.string.repeat"]),
	  replace: define$2(null, ["es.string.replace", "es.regexp.exec"]),
	  replaceAll: define$2("instance/replace-all", ["es.string.replace-all", "es.string.replace", "es.regexp.exec"]),
	  reverse: define$2("instance/reverse", ["es.array.reverse"]),
	  search: define$2(null, ["es.string.search", "es.regexp.exec"]),
	  setYear: define$2(null, ["es.date.set-year"]),
	  slice: define$2("instance/slice", ["es.array.slice"]),
	  small: define$2(null, ["es.string.small"]),
	  some: define$2("instance/some", ["es.array.some", "esnext.async-iterator.some", "esnext.iterator.some"].concat(IteratorDependencies$1)),
	  sort: define$2("instance/sort", ["es.array.sort"]),
	  splice: define$2("instance/splice", ["es.array.splice"]),
	  split: define$2(null, ["es.string.split", "es.regexp.exec"]),
	  startsWith: define$2("instance/starts-with", ["es.string.starts-with"]),
	  sticky: define$2("instance/sticky", ["es.regexp.sticky"]),
	  strike: define$2(null, ["es.string.strike"]),
	  sub: define$2(null, ["es.string.sub"]),
	  substr: define$2(null, ["es.string.substr"]),
	  sup: define$2(null, ["es.string.sup"]),
	  take: define$2("instance/take", ["esnext.async-iterator.take"].concat(_toConsumableArray(AsyncIteratorDependencies$1), ["esnext.iterator.take"], IteratorDependencies$1)),
	  test: define$2("instance/test", ["es.regexp.test", "es.regexp.exec"]),
	  toArray: define$2("instance/to-array", ["esnext.async-iterator.to-array"].concat(_toConsumableArray(AsyncIteratorDependencies$1), ["esnext.iterator.to-array"], IteratorDependencies$1)),
	  toFixed: define$2(null, ["es.number.to-fixed"]),
	  toGMTString: define$2(null, ["es.date.to-gmt-string"]),
	  toISOString: define$2(null, ["es.date.to-iso-string"]),
	  toJSON: define$2(null, ["es.date.to-json", "web.url.to-json"]),
	  toPrecision: define$2(null, ["es.number.to-precision"]),
	  toString: define$2(null, ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"]),
	  trim: define$2("instance/trim", ["es.string.trim"]),
	  trimEnd: define$2("instance/trim-end", ["es.string.trim-end"]),
	  trimLeft: define$2("instance/trim-left", ["es.string.trim-start"]),
	  trimRight: define$2("instance/trim-right", ["es.string.trim-end"]),
	  trimStart: define$2("instance/trim-start", ["es.string.trim-start"]),
	  uniqueBy: define$2("instance/unique-by", ["esnext.array.unique-by", "es.map"]),
	  values: define$2("instance/values", ArrayNatureIteratorsWithTag$1),
	  __defineGetter__: define$2(null, ["es.object.define-getter"]),
	  __defineSetter__: define$2(null, ["es.object.define-setter"]),
	  __lookupGetter__: define$2(null, ["es.object.lookup-getter"]),
	  __lookupSetter__: define$2(null, ["es.object.lookup-setter"])
	};
	var CommonInstanceDependencies$1 = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);

	var _ref$3 = undefined || babel,
	    t$1$2 = _ref$3.types;

	function callMethod$1(path, id) {
	  var object = path.node.object;
	  var context1, context2;

	  if (t$1$2.isIdentifier(object)) {
	    context1 = object;
	    context2 = t$1$2.cloneNode(object);
	  } else {
	    context1 = path.scope.generateDeclaredUidIdentifier("context");
	    context2 = t$1$2.assignmentExpression("=", t$1$2.cloneNode(context1), object);
	  }

	  path.replaceWith(t$1$2.memberExpression(t$1$2.callExpression(id, [context2]), t$1$2.identifier("call")));
	  path.parentPath.unshiftContainer("arguments", context1);
	}

	function isCoreJSSource$1(source) {
	  if (typeof source === "string") {
	    source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
	  }

	  return hasOwnProperty.call(entries$1, source) && entries$1[source];
	}

	function coreJSModule$1(name) {
	  return "core-js/modules/" + name + ".js";
	}

	function coreJSPureHelper$1(name, useBabelRuntime, ext) {
	  return useBabelRuntime ? useBabelRuntime + "/core-js/" + name + ext : "core-js-pure/features/" + name + ".js";
	}

	var _ref2$1 = undefined || babel,
	    t$4 = _ref2$1.types;

	var runtimeCompat$4 = "#__secret_key__@babel/runtime__compatibility";

	var esnextFallback$1 = function esnextFallback(name, cb) {
	  if (cb(name)) return true;
	  if (!name.startsWith("es.")) return false;
	  var fallback = "esnext." + name.slice(3);
	  if (!data$1[fallback]) return false;
	  return cb(fallback);
	};

	var index$4 = definePolyfillProvider$1(function (_ref3, _ref4) {
	  var getUtils = _ref3.getUtils,
	      method = _ref3.method,
	      shouldInjectPolyfill = _ref3.shouldInjectPolyfill,
	      createMetaResolver = _ref3.createMetaResolver,
	      debug = _ref3.debug,
	      babel = _ref3.babel;
	  var _ref4$version = _ref4.version,
	      version = _ref4$version === void 0 ? 3 : _ref4$version,
	      proposals = _ref4.proposals,
	      shippedProposals = _ref4.shippedProposals,
	      _ref4$runtimeCompat = _ref4[runtimeCompat$4];
	  _ref4$runtimeCompat = _ref4$runtimeCompat === void 0 ? {} : _ref4$runtimeCompat;
	  var useBabelRuntime = _ref4$runtimeCompat.useBabelRuntime,
	      _ref4$runtimeCompat$e = _ref4$runtimeCompat.ext,
	      ext = _ref4$runtimeCompat$e === void 0 ? ".js" : _ref4$runtimeCompat$e;
	  var isWebpack = babel.caller(function (caller) {
	    return (caller == null ? void 0 : caller.name) === "babel-loader";
	  });
	  var resolve = createMetaResolver({
	    global: BuiltIns$2,
	    "static": StaticProperties$2,
	    instance: InstanceProperties$2
	  });
	  var available = new Set(getModulesListForTargetVersion$1(version));

	  function getCoreJSPureBase(useProposalBase) {
	    return useBabelRuntime ? useProposalBase ? useBabelRuntime + "/core-js" : useBabelRuntime + "/core-js-stable" : useProposalBase ? "core-js-pure/features" : "core-js-pure/stable";
	  }

	  function maybeInjectGlobalImpl(name, utils) {
	    if (shouldInjectPolyfill(name)) {
	      debug(name);
	      utils.injectGlobalImport(coreJSModule$1(name));
	      return true;
	    }

	    return false;
	  }

	  function maybeInjectGlobal(names, utils, fallback) {
	    if (fallback === void 0) {
	      fallback = true;
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose(names), _step; !(_step = _iterator()).done;) {
	      var name = _step.value;

	      if (fallback) {
	        esnextFallback$1(name, function (name) {
	          return maybeInjectGlobalImpl(name, utils);
	        });
	      } else {
	        maybeInjectGlobalImpl(name, utils);
	      }
	    }
	  }

	  function maybeInjectPure(desc, hint, utils, object) {
	    if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback$1(desc.name, shouldInjectPolyfill)) {
	      var name = desc.name;
	      var useProposalBase = false;

	      if (proposals || shippedProposals && name.startsWith("esnext.")) {
	        useProposalBase = true;
	      } else if (name.startsWith("es.") && !available.has(name)) {
	        useProposalBase = true;
	      }

	      var coreJSPureBase = getCoreJSPureBase(useProposalBase);
	      return utils.injectDefaultImport(coreJSPureBase + "/" + desc.pure + ext, hint);
	    }
	  }

	  function isFeatureStable(name) {
	    if (name.startsWith("esnext.")) {
	      var esName = "es." + name.slice(7);
	      return esName in data$1;
	    }

	    return true;
	  }

	  return {
	    name: "corejs3",
	    polyfills: data$1,
	    filterPolyfills: function filterPolyfills(name) {
	      if (!available.has(name)) return false;
	      if (proposals || method === "entry-global") return true;

	      if (shippedProposals && corejs3ShippedProposalsList$1.has(name)) {
	        return true;
	      }

	      return isFeatureStable(name);
	    },
	    entryGlobal: function entryGlobal(meta, utils, path) {
	      if (meta.kind !== "import") return;
	      var modules = isCoreJSSource$1(meta.source);
	      if (!modules) return;

	      if (modules.length === 1 && meta.source === coreJSModule$1(modules[0]) && shouldInjectPolyfill(modules[0])) {
	        debug(null);
	        return;
	      }

	      maybeInjectGlobal(modules, utils, false);
	      path.remove();
	    },
	    usageGlobal: function usageGlobal(meta, utils) {
	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var deps = resolved.desc.global;

	      if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
	        var low = meta.object.toLowerCase();
	        deps = deps.filter(function (m) {
	          return m.includes(low) || CommonInstanceDependencies$1.has(m);
	        });
	      }

	      maybeInjectGlobal(deps, utils);
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("is-iterable", useBabelRuntime, ext), "isIterable"), [path.node.right]));
	        }

	        return;
	      }

	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;
	      var isCall;

	      if (meta.kind === "property") {
	        if (!path.isMemberExpression()) return;
	        if (!path.isReferenced()) return;
	        isCall = path.parentPath.isCallExpression({
	          callee: path.node
	        });

	        if (meta.key === "Symbol.iterator") {
	          if (!shouldInjectPolyfill("es.symbol.iterator")) return;

	          if (isCall) {
	            if (path.parent.arguments.length === 0) {
	              path.parentPath.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("get-iterator", useBabelRuntime, ext), "getIterator"), [path.node.object]));
	              path.skip();
	            } else {
	              callMethod$1(path, utils.injectDefaultImport(coreJSPureHelper$1("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"));
	            }
	          } else {
	            path.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [path.node.object]));
	          }

	          return;
	        }
	      }

	      var resolved = resolve(meta);
	      if (!resolved) return;

	      if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index") {
	        resolved = Object.assign(Object.assign({}, resolved), {}, {
	          desc: Object.assign(Object.assign({}, resolved.desc), {}, {
	            pure: resolved.desc.pure.slice(0, -6)
	          })
	        });
	      }

	      if (resolved.kind === "global") {
	        var id = maybeInjectPure(resolved.desc, resolved.name, utils);
	        if (id) path.replaceWith(id);
	      } else if (resolved.kind === "static") {
	        var _id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);

	        if (_id) path.replaceWith(_id);
	      } else if (resolved.kind === "instance") {
	        var _id2 = maybeInjectPure(resolved.desc, resolved.name + "InstanceProperty", utils, meta.object);

	        if (!_id2) return;

	        if (isCall) {
	          callMethod$1(path, _id2);
	        } else {
	          path.replaceWith(t$4.callExpression(_id2, [path.node.object]));
	        }
	      }
	    },
	    visitor: method === "usage-global" && {
	      CallExpression: function CallExpression(path) {
	        if (path.get("callee").isImport()) {
	          var utils = getUtils(path);

	          if (isWebpack) {
	            maybeInjectGlobal(PromiseDependenciesWithIterators$1, utils);
	          } else {
	            maybeInjectGlobal(PromiseDependencies$2, utils);
	          }
	        }
	      },
	      Function: function Function(path) {
	        if (path.node.async) {
	          maybeInjectGlobal(PromiseDependencies$2, getUtils(path));
	        }
	      },
	      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
	        maybeInjectGlobal(CommonIterators$2, getUtils(path));
	      },
	      SpreadElement: function SpreadElement(path) {
	        if (!path.parentPath.isObjectExpression()) {
	          maybeInjectGlobal(CommonIterators$2, getUtils(path));
	        }
	      },
	      YieldExpression: function YieldExpression(path) {
	        if (path.node.delegate) {
	          maybeInjectGlobal(CommonIterators$2, getUtils(path));
	        }
	      }
	    }
	  };
	});

	var runtimeCompat$3 = "#__secret_key__@babel/runtime__compatibility";
	var index$3 = definePolyfillProvider$1(function (_ref, options) {
	  var debug = _ref.debug;
	  var _options$runtimeCompa = options[runtimeCompat$3];
	  _options$runtimeCompa = _options$runtimeCompa === void 0 ? {} : _options$runtimeCompa;
	  var useBabelRuntime = _options$runtimeCompa.useBabelRuntime;
	  var pureName = useBabelRuntime ? useBabelRuntime + "/regenerator" : "regenerator-runtime";
	  return {
	    name: "regenerator",
	    polyfills: ["regenerator-runtime"],
	    usageGlobal: function usageGlobal(meta, utils) {
	      if (isRegenerator$1(meta)) {
	        debug("regenerator-runtime");
	        utils.injectGlobalImport("regenerator-runtime/runtime.js");
	      }
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (isRegenerator$1(meta)) {
	        path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
	      }
	    }
	  };
	});

	var isRegenerator$1 = function isRegenerator(meta) {
	  return meta.kind === "global" && meta.name === "regeneratorRuntime";
	};

	var pluginCorejs2 = index$5["default"] || index$5;
	var pluginCorejs3 = index$4["default"] || index$4;
	var pluginRegenerator$1 = index$3["default"] || index$3;
	var pluginsCompat = "#__secret_key__@babel/runtime__compatibility";

	function supportsStaticESM$1(caller) {
	  return !!(caller != null && caller.supportsStaticESM);
	}

	var transformRuntime = declare(function (api, options, dirname) {
	  var _createCorejsPlgin, _createRegeneratorPlu, _createCorejsPlgin2, _createRegeneratorPlu2, _createRegeneratorPlu3;

	  api.assertVersion(7);
	  var corejs = options.corejs,
	      _options$helpers = options.helpers,
	      useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
	      _options$regenerator = options.regenerator,
	      useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
	      _options$useESModules = options.useESModules,
	      useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
	      _options$version = options.version,
	      runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
	      _options$absoluteRunt = options.absoluteRuntime,
	      absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
	  var proposals = false;
	  var rawVersion;

	  if (typeof corejs === "object" && corejs !== null) {
	    rawVersion = corejs.version;
	    proposals = Boolean(corejs.proposals);
	  } else {
	    rawVersion = corejs;
	  }

	  var corejsVersion = rawVersion ? Number(rawVersion) : false;

	  if (![false, 2, 3].includes(corejsVersion)) {
	    throw new Error("The `core-js` version must be false, 2 or 3, but got " + JSON.stringify(rawVersion) + ".");
	  }

	  if (proposals && (!corejsVersion || corejsVersion < 3)) {
	    throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
	  }

	  if (typeof useRuntimeRegenerator !== "boolean") {
	    throw new Error("The 'regenerator' option must be undefined, or a boolean.");
	  }

	  if (typeof useRuntimeHelpers !== "boolean") {
	    throw new Error("The 'helpers' option must be undefined, or a boolean.");
	  }

	  if (typeof useESModules !== "boolean" && useESModules !== "auto") {
	    throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
	  }

	  if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
	    throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
	  }

	  if (typeof runtimeVersion !== "string") {
	    throw new Error("The 'version' option must be a version string.");
	  }

	  var DUAL_MODE_RUNTIME = "7.13.0";
	  var supportsCJSDefault = hasMinVersion$2(DUAL_MODE_RUNTIME, runtimeVersion);

	  function has(obj, key) {
	    return Object.prototype.hasOwnProperty.call(obj, key);
	  }

	  if (has(options, "useBuiltIns")) {
	    if (options.useBuiltIns) {
	      throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
	    } else {
	      throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
	    }
	  }

	  if (has(options, "polyfill")) {
	    if (options.polyfill === false) {
	      throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
	    } else {
	      throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
	    }
	  }

	  if (has(options, "moduleName")) {
	    throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
	  }

	  var esModules = useESModules === "auto" ? api.caller(supportsStaticESM$1) : useESModules;
	  var injectCoreJS2 = corejsVersion === 2;
	  var injectCoreJS3 = corejsVersion === 3;
	  var moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
	  var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
	  var modulePath = getRuntimePath(moduleName, dirname, absoluteRuntime);

	  function createCorejsPlgin(plugin, options, regeneratorPlugin) {
	    return function (api, _, filename) {
	      return Object.assign({}, plugin(api, options, filename), {
	        inherits: regeneratorPlugin
	      });
	    };
	  }

	  function createRegeneratorPlugin(options) {
	    if (!useRuntimeRegenerator) return undefined;
	    return function (api, _, filename) {
	      return pluginRegenerator$1(api, options, filename);
	    };
	  }

	  return {
	    name: "transform-runtime",
	    inherits: injectCoreJS2 ? createCorejsPlgin(pluginCorejs2, (_createCorejsPlgin = {
	      method: "usage-pure",
	      absoluteImports: absoluteRuntime ? modulePath : false
	    }, _createCorejsPlgin[pluginsCompat] = {
	      runtimeVersion: runtimeVersion,
	      useBabelRuntime: modulePath,
	      ext: ""
	    }, _createCorejsPlgin), createRegeneratorPlugin((_createRegeneratorPlu = {
	      method: "usage-pure",
	      absoluteImports: absoluteRuntime ? modulePath : false
	    }, _createRegeneratorPlu[pluginsCompat] = {
	      useBabelRuntime: modulePath
	    }, _createRegeneratorPlu))) : injectCoreJS3 ? createCorejsPlgin(pluginCorejs3, (_createCorejsPlgin2 = {
	      method: "usage-pure",
	      version: 3,
	      proposals: proposals,
	      absoluteImports: absoluteRuntime ? modulePath : false
	    }, _createCorejsPlgin2[pluginsCompat] = {
	      useBabelRuntime: modulePath,
	      ext: ""
	    }, _createCorejsPlgin2), createRegeneratorPlugin((_createRegeneratorPlu2 = {
	      method: "usage-pure",
	      absoluteImports: absoluteRuntime ? modulePath : false
	    }, _createRegeneratorPlu2[pluginsCompat] = {
	      useBabelRuntime: modulePath
	    }, _createRegeneratorPlu2))) : createRegeneratorPlugin((_createRegeneratorPlu3 = {
	      method: "usage-pure",
	      absoluteImports: absoluteRuntime ? modulePath : false
	    }, _createRegeneratorPlu3[pluginsCompat] = {
	      useBabelRuntime: modulePath
	    }, _createRegeneratorPlu3)),
	    pre: function pre(file) {
	      if (!useRuntimeHelpers) return;
	      file.set("helperGenerator", function (name) {
	        if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
	          return;
	        }

	        var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
	        var blockHoist = isInteropHelper && !isModule(file.path) ? 4 : undefined;
	        var helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
	        var helperPath = modulePath + "/" + helpersDir + "/" + name;
	        if (absoluteRuntime) helperPath = resolveFSPath();
	        return addDefaultImport(helperPath, name, blockHoist, true);
	      });
	      var cache = new Map();

	      function addDefaultImport(source, nameHint, blockHoist, isHelper) {
	        if (isHelper === void 0) {
	          isHelper = false;
	        }

	        var cacheKey = isModule(file.path);
	        var key = source + ":" + nameHint + ":" + (cacheKey || "");
	        var cached = cache.get(key);

	        if (cached) {
	          cached = cloneNode$i(cached);
	        } else {
	          cached = addDefault(file.path, source, {
	            importedInterop: isHelper && supportsCJSDefault ? "compiled" : "uncompiled",
	            nameHint: nameHint,
	            blockHoist: blockHoist
	          });
	          cache.set(key, cached);
	        }

	        return cached;
	      }
	    }
	  };
	});

	var _transformShorthandProperties = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-shorthand-properties",
	    visitor: {
	      ObjectMethod: function ObjectMethod(path) {
	        var node = path.node;

	        if (node.kind === "method") {
	          var func = functionExpression$3(null, node.params, node.body, node.generator, node.async);
	          func.returnType = node.returnType;
	          var computedKey = toComputedKey$3(node);

	          if (isStringLiteral$7(computedKey, {
	            value: "__proto__"
	          })) {
	            path.replaceWith(objectProperty$2(computedKey, func, true));
	          } else {
	            path.replaceWith(objectProperty$2(node.key, func, node.computed));
	          }
	        }
	      },
	      ObjectProperty: function ObjectProperty(path) {
	        var node = path.node;

	        if (node.shorthand) {
	          var computedKey = toComputedKey$3(node);

	          if (isStringLiteral$7(computedKey, {
	            value: "__proto__"
	          })) {
	            path.replaceWith(objectProperty$2(computedKey, node.value, true));
	          } else {
	            node.shorthand = false;
	          }
	        }
	      }
	    }
	  };
	});

	var _transformSpread = declare(function (api, options) {
	  var _api$assumption, _options$allowArrayLi;

	  api.assertVersion(7);
	  var iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
	  var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");

	  function getSpreadLiteral(spread, scope) {
	    if (iterableIsArray && !isIdentifier$g(spread.argument, {
	      name: "arguments"
	    })) {
	      return spread.argument;
	    } else {
	      return scope.toArray(spread.argument, true, arrayLikeIsIterable);
	    }
	  }

	  function hasHole(spread) {
	    return spread.elements.some(function (el) {
	      return el === null;
	    });
	  }

	  function hasSpread(nodes) {
	    for (var i = 0; i < nodes.length; i++) {
	      if (isSpreadElement$1(nodes[i])) {
	        return true;
	      }
	    }

	    return false;
	  }

	  function push(_props, nodes) {
	    if (!_props.length) return _props;
	    nodes.push(arrayExpression$2(_props));
	    return [];
	  }

	  function build(props, scope, file) {
	    var nodes = [];
	    var _props = [];

	    for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
	      var prop = _step.value;

	      if (isSpreadElement$1(prop)) {
	        _props = push(_props, nodes);
	        var spreadLiteral = getSpreadLiteral(prop, scope);

	        if (isArrayExpression$2(spreadLiteral) && hasHole(spreadLiteral)) {
	          spreadLiteral = callExpression$e(file.addHelper("arrayWithoutHoles"), [spreadLiteral]);
	        }

	        nodes.push(spreadLiteral);
	      } else {
	        _props.push(prop);
	      }
	    }

	    push(_props, nodes);
	    return nodes;
	  }

	  return {
	    name: "transform-spread",
	    visitor: {
	      ArrayExpression: function (_ArrayExpression) {
	        function ArrayExpression(_x) {
	          return _ArrayExpression.apply(this, arguments);
	        }

	        ArrayExpression.toString = function () {
	          return _ArrayExpression.toString();
	        };

	        return ArrayExpression;
	      }(function (path) {
	        var node = path.node,
	            scope = path.scope;
	        var elements = node.elements;
	        if (!hasSpread(elements)) return;
	        var nodes = build(elements, scope, this);
	        var first = nodes[0];

	        if (nodes.length === 1 && first !== elements[0].argument) {
	          path.replaceWith(first);
	          return;
	        }

	        if (!isArrayExpression$2(first)) {
	          first = arrayExpression$2([]);
	        } else {
	          nodes.shift();
	        }

	        path.replaceWith(callExpression$e(memberExpression$b(first, identifier$j("concat")), nodes));
	      }),
	      CallExpression: function (_CallExpression) {
	        function CallExpression(_x2) {
	          return _CallExpression.apply(this, arguments);
	        }

	        CallExpression.toString = function () {
	          return _CallExpression.toString();
	        };

	        return CallExpression;
	      }(function (path) {
	        var node = path.node,
	            scope = path.scope;
	        var args = node.arguments;
	        if (!hasSpread(args)) return;
	        var calleePath = skipTransparentExprWrappers(path.get("callee"));

	        if (calleePath.isSuper()) {
	          throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
	        }

	        var contextLiteral = scope.buildUndefinedNode();
	        node.arguments = [];
	        var nodes;

	        if (args.length === 1 && isIdentifier$g(args[0].argument, {
	          name: "arguments"
	        })) {
	          nodes = [args[0].argument];
	        } else {
	          nodes = build(args, scope, this);
	        }

	        var first = nodes.shift();

	        if (nodes.length) {
	          node.arguments.push(callExpression$e(memberExpression$b(first, identifier$j("concat")), nodes));
	        } else {
	          node.arguments.push(first);
	        }

	        var callee = calleePath.node;

	        if (isMemberExpression$8(callee)) {
	          var temp = scope.maybeGenerateMemoised(callee.object);

	          if (temp) {
	            callee.object = assignmentExpression$c("=", temp, callee.object);
	            contextLiteral = temp;
	          } else {
	            contextLiteral = cloneNode$i(callee.object);
	          }
	        }

	        node.callee = memberExpression$b(node.callee, identifier$j("apply"));

	        if (isSuper$2(contextLiteral)) {
	          contextLiteral = thisExpression$3();
	        }

	        node.arguments.unshift(cloneNode$i(contextLiteral));
	      }),
	      NewExpression: function (_NewExpression) {
	        function NewExpression(_x3) {
	          return _NewExpression.apply(this, arguments);
	        }

	        NewExpression.toString = function () {
	          return _NewExpression.toString();
	        };

	        return NewExpression;
	      }(function (path) {
	        var node = path.node,
	            scope = path.scope;
	        if (!hasSpread(node.arguments)) return;
	        var nodes = build(node.arguments, scope, this);
	        var first = nodes.shift();
	        var args;

	        if (nodes.length) {
	          args = callExpression$e(memberExpression$b(first, identifier$j("concat")), nodes);
	        } else {
	          args = first;
	        }

	        path.replaceWith(callExpression$e(path.hub.addHelper("construct"), [node.callee, args]));
	      })
	    }
	  };
	});

	var _transformStickyRegex = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-sticky-regex",
	    visitor: {
	      RegExpLiteral: function RegExpLiteral(path) {
	        var node = path.node;
	        if (!node.flags.includes("y")) return;
	        path.replaceWith(newExpression(identifier$j("RegExp"), [stringLiteral$8(node.pattern), stringLiteral$8(node.flags)]));
	      }
	    }
	  };
	});

	var transformStrictMode = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-strict-mode",
	    visitor: {
	      Program: function Program(path) {
	        var node = path.node;

	        for (var _iterator = _createForOfIteratorHelperLoose(node.directives), _step; !(_step = _iterator()).done;) {
	          var directive = _step.value;
	          if (directive.value.value === "use strict") return;
	        }

	        path.unshiftContainer("directives", directive$1(directiveLiteral$1("use strict")));
	      }
	    }
	  };
	});

	var _templateObject$4;
	var _transformTemplateLiterals = declare(function (api, options) {
	  var _api$assumption, _api$assumption2;

	  api.assertVersion(7);
	  var ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
	  var mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
	  var helperName = "taggedTemplateLiteral";
	  if (mutableTemplateObject) helperName += "Loose";

	  function buildConcatCallExpressions(items) {
	    var avail = true;
	    return items.reduce(function (left, right) {
	      var canBeInserted = isLiteral$7(right);

	      if (!canBeInserted && avail) {
	        canBeInserted = true;
	        avail = false;
	      }

	      if (canBeInserted && isCallExpression$6(left)) {
	        left.arguments.push(right);
	        return left;
	      }

	      return callExpression$e(memberExpression$b(left, identifier$j("concat")), [right]);
	    });
	  }

	  return {
	    name: "transform-template-literals",
	    visitor: {
	      TaggedTemplateExpression: function TaggedTemplateExpression(path) {
	        var node = path.node;
	        var quasi = node.quasi;
	        var strings = [];
	        var raws = [];
	        var isStringsRawEqual = true;

	        for (var _iterator = _createForOfIteratorHelperLoose(quasi.quasis), _step; !(_step = _iterator()).done;) {
	          var elem = _step.value;
	          var _elem$value = elem.value,
	              raw = _elem$value.raw,
	              cooked = _elem$value.cooked;
	          var value = cooked == null ? path.scope.buildUndefinedNode() : stringLiteral$8(cooked);
	          strings.push(value);
	          raws.push(stringLiteral$8(raw));

	          if (raw !== cooked) {
	            isStringsRawEqual = false;
	          }
	        }

	        var helperArgs = [arrayExpression$2(strings)];

	        if (!isStringsRawEqual) {
	          helperArgs.push(arrayExpression$2(raws));
	        }

	        var tmp = path.scope.generateUidIdentifier("templateObject");
	        path.scope.getProgramParent().push({
	          id: cloneNode$i(tmp)
	        });
	        path.replaceWith(callExpression$e(node.tag, [template$2.expression.ast(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose(["\n              ", " || (\n                ", " = ", "(", ")\n              )\n            "])), cloneNode$i(tmp), tmp, this.addHelper(helperName), helperArgs)].concat(_toConsumableArray(quasi.expressions))));
	      },
	      TemplateLiteral: function TemplateLiteral(path) {
	        var nodes = [];
	        var expressions = path.get("expressions");
	        var index = 0;

	        for (var _iterator2 = _createForOfIteratorHelperLoose(path.node.quasis), _step2; !(_step2 = _iterator2()).done;) {
	          var elem = _step2.value;

	          if (elem.value.cooked) {
	            nodes.push(stringLiteral$8(elem.value.cooked));
	          }

	          if (index < expressions.length) {
	            var expr = expressions[index++];
	            var node = expr.node;

	            if (!isStringLiteral$7(node, {
	              value: ""
	            })) {
	              nodes.push(node);
	            }
	          }
	        }

	        if (!isStringLiteral$7(nodes[0]) && !(ignoreToPrimitiveHint && isStringLiteral$7(nodes[1]))) {
	          nodes.unshift(stringLiteral$8(""));
	        }

	        var root = nodes[0];

	        if (ignoreToPrimitiveHint) {
	          for (var i = 1; i < nodes.length; i++) {
	            root = binaryExpression$4("+", root, nodes[i]);
	          }
	        } else if (nodes.length > 1) {
	          root = buildConcatCallExpressions(nodes);
	        }

	        path.replaceWith(root);
	      }
	    }
	  };
	});

	var _transformTypeofSymbol = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-typeof-symbol",
	    visitor: {
	      Scope: function Scope(_ref) {
	        var scope = _ref.scope;

	        if (!scope.getBinding("Symbol")) {
	          return;
	        }

	        scope.rename("Symbol");
	      },
	      UnaryExpression: function UnaryExpression(path) {
	        var node = path.node,
	            parent = path.parent;
	        if (node.operator !== "typeof") return;

	        if (path.parentPath.isBinaryExpression() && EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
	          var opposite = path.getOpposite();

	          if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
	            return;
	          }
	        }

	        var isUnderHelper = path.findParent(function (path) {
	          if (path.isFunction()) {
	            var _path$get;

	            return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
	          }
	        });
	        if (isUnderHelper) return;
	        var helper = this.addHelper("typeof");
	        isUnderHelper = path.findParent(function (path) {
	          return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
	        });

	        if (isUnderHelper) {
	          return;
	        }

	        var call = callExpression$e(helper, [node.argument]);
	        var arg = path.get("argument");

	        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
	          var unary = unaryExpression$7("typeof", cloneNode$i(node.argument));
	          path.replaceWith(conditionalExpression$3(binaryExpression$4("===", unary, stringLiteral$8("undefined")), stringLiteral$8("undefined"), call));
	        } else {
	          path.replaceWith(call);
	        }
	      }
	    }
	  };
	});

	function transpileEnum(path, t) {
	  var node = path.node;

	  if (node.declare) {
	    path.remove();
	    return;
	  }

	  var name = node.id.name;
	  var fill = enumFill(path, t, node.id);

	  switch (path.parent.type) {
	    case "BlockStatement":
	    case "ExportNamedDeclaration":
	    case "Program":
	      {
	        path.insertAfter(fill);

	        if (seen(path.parentPath)) {
	          path.remove();
	        } else {
	          var isGlobal = t.isProgram(path.parent);
	          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"))[0]);
	        }

	        break;
	      }

	    default:
	      throw new Error("Unexpected enum parent '" + path.parent.type);
	  }

	  function seen(parentPath) {
	    if (parentPath.isExportDeclaration()) {
	      return seen(parentPath.parentPath);
	    }

	    if (parentPath.getData(name)) {
	      return true;
	    } else {
	      parentPath.setData(name, true);
	      return false;
	    }
	  }
	}

	function makeVar(id, t, kind) {
	  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
	}

	var buildEnumWrapper = template$2("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");
	var buildStringAssignment = template$2("\n  ENUM[\"NAME\"] = VALUE;\n");
	var buildNumericAssignment = template$2("\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n");

	var buildEnumMember = function buildEnumMember(isString, options) {
	  return (isString ? buildStringAssignment : buildNumericAssignment)(options);
	};

	function enumFill(path, t, id) {
	  var x = translateEnumValues(path, t);
	  var assignments = x.map(function (_ref) {
	    var _ref2 = _slicedToArray$1(_ref, 2),
	        memberName = _ref2[0],
	        memberValue = _ref2[1];

	    return buildEnumMember(t.isStringLiteral(memberValue), {
	      ENUM: t.cloneNode(id),
	      NAME: memberName,
	      VALUE: memberValue
	    });
	  });
	  return buildEnumWrapper({
	    ID: t.cloneNode(id),
	    ASSIGNMENTS: assignments
	  });
	}

	function translateEnumValues(path, t) {
	  var seen = new Map();
	  var constValue = -1;
	  var lastName;
	  return path.node.members.map(function (member) {
	    var name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
	    var initializer = member.initializer;
	    var value;

	    if (initializer) {
	      constValue = evaluate(initializer, seen);

	      if (constValue !== undefined) {
	        seen.set(name, constValue);

	        if (typeof constValue === "number") {
	          value = t.numericLiteral(constValue);
	        } else {
	          assert_1(typeof constValue === "string");
	          value = t.stringLiteral(constValue);
	        }
	      } else {
	        value = initializer;
	      }
	    } else if (typeof constValue === "number") {
	      constValue += 1;
	      value = t.numericLiteral(constValue);
	      seen.set(name, constValue);
	    } else if (typeof constValue === "string") {
	      throw path.buildCodeFrameError("Enum member must have initializer.");
	    } else {
	      var lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);
	      value = t.binaryExpression("+", t.numericLiteral(1), lastRef);
	    }

	    lastName = name;
	    return [name, value];
	  });
	}

	function evaluate(expr, seen) {
	  return evalConstant(expr);

	  function evalConstant(expr) {
	    switch (expr.type) {
	      case "StringLiteral":
	        return expr.value;

	      case "UnaryExpression":
	        return evalUnaryExpression(expr);

	      case "BinaryExpression":
	        return evalBinaryExpression(expr);

	      case "NumericLiteral":
	        return expr.value;

	      case "ParenthesizedExpression":
	        return evalConstant(expr.expression);

	      case "Identifier":
	        return seen.get(expr.name);

	      case "TemplateLiteral":
	        if (expr.quasis.length === 1) {
	          return expr.quasis[0].value.cooked;
	        }

	      default:
	        return undefined;
	    }
	  }

	  function evalUnaryExpression(_ref3) {
	    var argument = _ref3.argument,
	        operator = _ref3.operator;
	    var value = evalConstant(argument);

	    if (value === undefined) {
	      return undefined;
	    }

	    switch (operator) {
	      case "+":
	        return value;

	      case "-":
	        return -value;

	      case "~":
	        return ~value;

	      default:
	        return undefined;
	    }
	  }

	  function evalBinaryExpression(expr) {
	    var left = evalConstant(expr.left);

	    if (left === undefined) {
	      return undefined;
	    }

	    var right = evalConstant(expr.right);

	    if (right === undefined) {
	      return undefined;
	    }

	    switch (expr.operator) {
	      case "|":
	        return left | right;

	      case "&":
	        return left & right;

	      case ">>":
	        return left >> right;

	      case ">>>":
	        return left >>> right;

	      case "<<":
	        return left << right;

	      case "^":
	        return left ^ right;

	      case "*":
	        return left * right;

	      case "/":
	        return left / right;

	      case "+":
	        return left + right;

	      case "-":
	        return left - right;

	      case "%":
	        return left % right;

	      default:
	        return undefined;
	    }
	  }
	}

	function transpileConstEnum(path, t) {
	  var name = path.node.id.name;
	  var parentIsExport = path.parentPath.isExportNamedDeclaration();
	  var isExported = parentIsExport;

	  if (!isExported && t.isProgram(path.parent)) {
	    isExported = path.parent.body.some(function (stmt) {
	      return t.isExportNamedDeclaration(stmt) && !stmt.source && stmt.specifiers.some(function (spec) {
	        return t.isExportSpecifier(spec) && spec.local.name === name;
	      });
	    });
	  }

	  var entries = translateEnumValues(path, t);

	  if (isExported) {
	    var obj = t.objectExpression(entries.map(function (_ref) {
	      var _ref2 = _slicedToArray$1(_ref, 2),
	          name = _ref2[0],
	          value = _ref2[1];

	      return t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value);
	    }));

	    if (path.scope.hasOwnBinding(name)) {
	      (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path.node.id, obj])));
	    } else {
	      path.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path.node.id, obj)]));
	      path.scope.registerDeclaration(path);
	    }

	    return;
	  }

	  var entriesMap = new Map(entries);
	  path.scope.path.traverse({
	    Scope: function Scope(path) {
	      if (path.scope.hasOwnBinding(name)) path.skip();
	    },
	    MemberExpression: function MemberExpression(path) {
	      if (!t.isIdentifier(path.node.object, {
	        name: name
	      })) return;
	      var key;

	      if (path.node.computed) {
	        if (t.isStringLiteral(path.node.property)) {
	          key = path.node.property.value;
	        } else {
	          return;
	        }
	      } else if (t.isIdentifier(path.node.property)) {
	        key = path.node.property.name;
	      } else {
	        return;
	      }

	      if (!entriesMap.has(key)) return;
	      path.replaceWith(t.cloneNode(entriesMap.get(key)));
	    }
	  });
	  path.remove();
	}

	var _templateObject$3, _templateObject2$2;
	function transpileNamespace(path, t, allowNamespaces) {
	  if (path.node.declare || path.node.id.type === "StringLiteral") {
	    path.remove();
	    return;
	  }

	  if (!allowNamespaces) {
	    throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
	  }

	  var name = path.node.id.name;
	  var value = handleNested(path, t, t.cloneDeep(path.node));
	  var bound = path.scope.hasOwnBinding(name);

	  if (path.parent.type === "ExportNamedDeclaration") {
	    if (!bound) {
	      path.parentPath.insertAfter(value);
	      path.replaceWith(getDeclaration(t, name));
	      path.scope.registerDeclaration(path.parentPath);
	    } else {
	      path.parentPath.replaceWith(value);
	    }
	  } else if (bound) {
	    path.replaceWith(value);
	  } else {
	    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
	  }
	}

	function getDeclaration(t, name) {
	  return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
	}

	function getMemberExpression(t, name, itemName) {
	  return t.memberExpression(t.identifier(name), t.identifier(itemName));
	}

	function handleVariableDeclaration(node, name, hub) {
	  if (node.kind !== "const") {
	    throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
	  }

	  var declarations = node.declarations;

	  if (declarations.every(function (declarator) {
	    return isIdentifier$g(declarator.id);
	  })) {
	    for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
	      var declarator = _step.value;
	      declarator.init = assignmentExpression$c("=", getMemberExpression(t$f, name, declarator.id.name), declarator.init);
	    }

	    return [node];
	  }

	  var bindingIdentifiers = getBindingIdentifiers$2(node);
	  var assignments = [];

	  for (var idName in bindingIdentifiers) {
	    assignments.push(assignmentExpression$c("=", getMemberExpression(t$f, name, idName), cloneNode$i(bindingIdentifiers[idName])));
	  }

	  return [node, expressionStatement$a(sequenceExpression$7(assignments))];
	}

	function buildNestedAmbiendModuleError(path, node) {
	  throw path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
	}

	function handleNested(path, t, node, parentExport) {
	  var names = new Set();
	  var realName = node.id;
	  t.assertIdentifier(realName);
	  var name = path.scope.generateUid(realName.name);
	  var namespaceTopLevel = t.isTSModuleBlock(node.body) ? node.body.body : [t.exportNamedDeclaration(node.body)];

	  for (var i = 0; i < namespaceTopLevel.length; i++) {
	    var subNode = namespaceTopLevel[i];

	    switch (subNode.type) {
	      case "TSModuleDeclaration":
	        {
	          if (!t.isIdentifier(subNode.id)) {
	            throw buildNestedAmbiendModuleError(path, subNode);
	          }

	          var transformed = handleNested(path, t, subNode);
	          var moduleName = subNode.id.name;

	          if (names.has(moduleName)) {
	            namespaceTopLevel[i] = transformed;
	          } else {
	            names.add(moduleName);
	            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
	          }

	          continue;
	        }

	      case "TSEnumDeclaration":
	      case "FunctionDeclaration":
	      case "ClassDeclaration":
	        names.add(subNode.id.name);
	        continue;

	      case "VariableDeclaration":
	        {
	          for (var _name in t.getBindingIdentifiers(subNode)) {
	            names.add(_name);
	          }

	          continue;
	        }

	      default:
	        continue;

	      case "ExportNamedDeclaration":
	    }

	    switch (subNode.declaration.type) {
	      case "TSEnumDeclaration":
	      case "FunctionDeclaration":
	      case "ClassDeclaration":
	        {
	          var itemName = subNode.declaration.id.name;
	          names.add(itemName);
	          namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
	          break;
	        }

	      case "VariableDeclaration":
	        {
	          var nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
	          namespaceTopLevel.splice.apply(namespaceTopLevel, [i, nodes.length].concat(_toConsumableArray(nodes)));
	          i += nodes.length - 1;
	          break;
	        }

	      case "TSModuleDeclaration":
	        {
	          if (!t.isIdentifier(subNode.declaration.id)) {
	            throw buildNestedAmbiendModuleError(path, subNode.declaration);
	          }

	          var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

	          var _moduleName = subNode.declaration.id.name;

	          if (names.has(_moduleName)) {
	            namespaceTopLevel[i] = _transformed;
	          } else {
	            names.add(_moduleName);
	            namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
	          }
	        }
	    }
	  }

	  var fallthroughValue = t.objectExpression([]);

	  if (parentExport) {
	    var memberExpr = t.memberExpression(parentExport, realName);
	    fallthroughValue = template$2.expression.ast(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose(["\n      ", " ||\n        (", " = ", ")\n    "])), t.cloneNode(memberExpr), t.cloneNode(memberExpr), fallthroughValue);
	  }

	  return template$2.statement.ast(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "])), t.identifier(name), namespaceTopLevel, realName, t.cloneNode(realName), fallthroughValue);
	}

	var _templateObject$2;

	function isInType(path) {
	  switch (path.parent.type) {
	    case "TSTypeReference":
	    case "TSQualifiedName":
	    case "TSExpressionWithTypeArguments":
	    case "TSTypeQuery":
	      return true;

	    case "ExportSpecifier":
	      return path.parentPath.parent.exportKind === "type";

	    default:
	      return false;
	  }
	}

	var GLOBAL_TYPES = new WeakMap();
	var NEEDS_EXPLICIT_ESM = new WeakMap();
	var PARSED_PARAMS = new WeakSet();

	function isGlobalType(path, name) {
	  var program = path.find(function (path) {
	    return path.isProgram();
	  }).node;
	  if (path.scope.hasOwnBinding(name)) return false;
	  if (GLOBAL_TYPES.get(program).has(name)) return true;
	  console.warn("The exported identifier \"" + name + "\" is not declared in Babel's scope tracker\n" + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + ("\"" + name + "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
	  return false;
	}

	function registerGlobalType(programNode, name) {
	  GLOBAL_TYPES.get(programNode).add(name);
	}

	var transformTypeScript = declare(function (api, opts) {
	  api.assertVersion(7);
	  var JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
	  var _opts$allowNamespaces = opts.allowNamespaces,
	      allowNamespaces = _opts$allowNamespaces === void 0 ? true : _opts$allowNamespaces,
	      _opts$jsxPragma = opts.jsxPragma,
	      jsxPragma = _opts$jsxPragma === void 0 ? "React.createElement" : _opts$jsxPragma,
	      _opts$jsxPragmaFrag = opts.jsxPragmaFrag,
	      jsxPragmaFrag = _opts$jsxPragmaFrag === void 0 ? "React.Fragment" : _opts$jsxPragmaFrag,
	      _opts$onlyRemoveTypeI = opts.onlyRemoveTypeImports,
	      onlyRemoveTypeImports = _opts$onlyRemoveTypeI === void 0 ? false : _opts$onlyRemoveTypeI,
	      _opts$optimizeConstEn = opts.optimizeConstEnums,
	      optimizeConstEnums = _opts$optimizeConstEn === void 0 ? false : _opts$optimizeConstEn;
	  {
	    var _opts$allowDeclareFie = opts.allowDeclareFields,
	        allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
	  }
	  var classMemberVisitors = {
	    field: function field(path) {
	      var node = path.node;
	      {
	        if (!allowDeclareFields && node.declare) {
	          throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
	        }
	      }

	      if (node.declare) {
	        if (node.value) {
	          throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
	        }

	        if (!node.decorators) {
	          path.remove();
	        }
	      } else if (node.definite) {
	        if (node.value) {
	          throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
	        }

	        {
	          if (!allowDeclareFields && !node.decorators) {
	            path.remove();
	          }
	        }
	      } else {
	        if (!allowDeclareFields && !node.value && !node.decorators && !isClassPrivateProperty(node)) {
	          path.remove();
	        }
	      }

	      if (node.accessibility) node.accessibility = null;
	      if (node["abstract"]) node["abstract"] = null;
	      if (node.readonly) node.readonly = null;
	      if (node.optional) node.optional = null;
	      if (node.typeAnnotation) node.typeAnnotation = null;
	      if (node.definite) node.definite = null;
	      if (node.declare) node.declare = null;
	      if (node.override) node.override = null;
	    },
	    method: function method(_ref) {
	      var node = _ref.node;
	      if (node.accessibility) node.accessibility = null;
	      if (node["abstract"]) node["abstract"] = null;
	      if (node.optional) node.optional = null;
	      if (node.override) node.override = null;
	    },
	    constructor: function constructor(path, classPath) {
	      if (path.node.accessibility) path.node.accessibility = null;
	      var parameterProperties = [];

	      for (var _iterator = _createForOfIteratorHelperLoose(path.node.params), _step; !(_step = _iterator()).done;) {
	        var param = _step.value;

	        if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
	          PARSED_PARAMS.add(param.parameter);
	          parameterProperties.push(param.parameter);
	        }
	      }

	      if (parameterProperties.length) {
	        var assigns = parameterProperties.map(function (p) {
	          var id;

	          if (isIdentifier$g(p)) {
	            id = p;
	          } else if (isAssignmentPattern$4(p) && isIdentifier$g(p.left)) {
	            id = p.left;
	          } else {
	            throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
	          }

	          return template$2.statement.ast(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["\n              this.", " = ", ""])), cloneNode$i(id), cloneNode$i(id));
	        });
	        injectInitialization(classPath, path, assigns);
	      }
	    }
	  };
	  return {
	    name: "transform-typescript",
	    inherits: syntaxTypescript,
	    visitor: {
	      Pattern: visitPattern,
	      Identifier: visitPattern,
	      RestElement: visitPattern,
	      Program: {
	        enter: function enter(path, state) {
	          var file = state.file;
	          var fileJsxPragma = null;
	          var fileJsxPragmaFrag = null;
	          var programNode = path.node;

	          if (!GLOBAL_TYPES.has(programNode)) {
	            GLOBAL_TYPES.set(programNode, new Set());
	          }

	          if (file.ast.comments) {
	            for (var _iterator2 = _createForOfIteratorHelperLoose(file.ast.comments), _step2; !(_step2 = _iterator2()).done;) {
	              var comment = _step2.value;
	              var jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);

	              if (jsxMatches) {
	                if (jsxMatches[1]) {
	                  fileJsxPragmaFrag = jsxMatches[2];
	                } else {
	                  fileJsxPragma = jsxMatches[2];
	                }
	              }
	            }
	          }

	          var pragmaImportName = fileJsxPragma || jsxPragma;

	          if (pragmaImportName) {
	            var _pragmaImportName$spl = pragmaImportName.split(".");

	            var _pragmaImportName$spl2 = _slicedToArray$1(_pragmaImportName$spl, 1);

	            pragmaImportName = _pragmaImportName$spl2[0];
	          }

	          var pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;

	          if (pragmaFragImportName) {
	            var _pragmaFragImportName = pragmaFragImportName.split(".");

	            var _pragmaFragImportName2 = _slicedToArray$1(_pragmaFragImportName, 1);

	            pragmaFragImportName = _pragmaFragImportName2[0];
	          }

	          for (var _iterator3 = _createForOfIteratorHelperLoose(path.get("body")), _step3; !(_step3 = _iterator3()).done;) {
	            var stmt = _step3.value;

	            if (stmt.isImportDeclaration()) {
	              var _ret = function () {
	                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
	                  NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
	                }

	                if (stmt.node.importKind === "type") {
	                  for (var _iterator4 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step4; !(_step4 = _iterator4()).done;) {
	                    var specifier = _step4.value;
	                    registerGlobalType(programNode, specifier.local.name);
	                  }

	                  stmt.remove();
	                  return "continue";
	                }

	                var importsToRemove = new Set();
	                var specifiersLength = stmt.node.specifiers.length;

	                var isAllSpecifiersElided = function isAllSpecifiersElided() {
	                  return specifiersLength > 0 && specifiersLength === importsToRemove.size;
	                };

	                for (var _iterator5 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step5; !(_step5 = _iterator5()).done;) {
	                  var _specifier2 = _step5.value;

	                  if (_specifier2.type === "ImportSpecifier" && _specifier2.importKind === "type") {
	                    registerGlobalType(programNode, _specifier2.local.name);

	                    var _binding = stmt.scope.getBinding(_specifier2.local.name);

	                    if (_binding) {
	                      importsToRemove.add(_binding.path);
	                    }
	                  }
	                }

	                if (onlyRemoveTypeImports) {
	                  NEEDS_EXPLICIT_ESM.set(path.node, false);
	                } else {
	                  if (stmt.node.specifiers.length === 0) {
	                    NEEDS_EXPLICIT_ESM.set(path.node, false);
	                    return "continue";
	                  }

	                  for (var _iterator6 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step6; !(_step6 = _iterator6()).done;) {
	                    var _specifier = _step6.value;
	                    var binding = stmt.scope.getBinding(_specifier.local.name);

	                    if (binding && !importsToRemove.has(binding.path)) {
	                      if (isImportTypeOnly({
	                        binding: binding,
	                        programPath: path,
	                        pragmaImportName: pragmaImportName,
	                        pragmaFragImportName: pragmaFragImportName
	                      })) {
	                        importsToRemove.add(binding.path);
	                      } else {
	                        NEEDS_EXPLICIT_ESM.set(path.node, false);
	                      }
	                    }
	                  }
	                }

	                if (isAllSpecifiersElided()) {
	                  stmt.remove();
	                } else {
	                  for (var _iterator7 = _createForOfIteratorHelperLoose(importsToRemove), _step7; !(_step7 = _iterator7()).done;) {
	                    var importPath = _step7.value;
	                    importPath.remove();
	                  }
	                }

	                return "continue";
	              }();

	              if (_ret === "continue") continue;
	            }

	            if (stmt.isExportDeclaration()) {
	              stmt = stmt.get("declaration");
	            }

	            if (stmt.isVariableDeclaration({
	              declare: true
	            })) {
	              for (var _i = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
	                var name = _Object$keys[_i];
	                registerGlobalType(programNode, name);
	              }
	            } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
	              declare: true
	            }) || stmt.isTSEnumDeclaration({
	              declare: true
	            }) || stmt.isTSModuleDeclaration({
	              declare: true
	            }) && stmt.get("id").isIdentifier()) {
	              registerGlobalType(programNode, stmt.node.id.name);
	            }
	          }
	        },
	        exit: function exit(path) {
	          if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
	            path.pushContainer("body", exportNamedDeclaration$2());
	          }
	        }
	      },
	      ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {
	        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
	          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
	        }

	        if (path.node.exportKind === "type") {
	          path.remove();
	          return;
	        }

	        if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (specifier) {
	          return specifier.type === "ExportSpecifier" && specifier.exportKind === "type";
	        })) {
	          path.remove();
	          return;
	        }

	        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (specifier) {
	          return isExportSpecifier(specifier) && isGlobalType(path, specifier.local.name);
	        })) {
	          path.remove();
	          return;
	        }

	        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
	      },
	      ExportSpecifier: function ExportSpecifier(path) {
	        var parent = path.parent;

	        if (!parent.source && isGlobalType(path, path.node.local.name) || path.node.exportKind === "type") {
	          path.remove();
	        }
	      },
	      ExportDefaultDeclaration: function ExportDefaultDeclaration(path, state) {
	        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
	          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
	        }

	        if (isIdentifier$g(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
	          path.remove();
	          return;
	        }

	        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
	      },
	      TSDeclareFunction: function TSDeclareFunction(path) {
	        path.remove();
	      },
	      TSDeclareMethod: function TSDeclareMethod(path) {
	        path.remove();
	      },
	      VariableDeclaration: function VariableDeclaration(path) {
	        if (path.node.declare) {
	          path.remove();
	        }
	      },
	      VariableDeclarator: function VariableDeclarator(_ref2) {
	        var node = _ref2.node;
	        if (node.definite) node.definite = null;
	      },
	      TSIndexSignature: function TSIndexSignature(path) {
	        path.remove();
	      },
	      ClassDeclaration: function ClassDeclaration(path) {
	        var node = path.node;

	        if (node.declare) {
	          path.remove();
	          return;
	        }
	      },
	      Class: function Class(path) {
	        var node = path.node;
	        if (node.typeParameters) node.typeParameters = null;
	        if (node.superTypeParameters) node.superTypeParameters = null;
	        if (node["implements"]) node["implements"] = null;
	        if (node["abstract"]) node["abstract"] = null;
	        path.get("body.body").forEach(function (child) {
	          if (child.isClassMethod() || child.isClassPrivateMethod()) {
	            if (child.node.kind === "constructor") {
	              classMemberVisitors.constructor(child, path);
	            } else {
	              classMemberVisitors.method(child);
	            }
	          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
	            classMemberVisitors.field(child);
	          }
	        });
	      },
	      Function: function Function(path) {
	        var node = path.node,
	            scope = path.scope;
	        if (node.typeParameters) node.typeParameters = null;
	        if (node.returnType) node.returnType = null;
	        var params = node.params;

	        if (params.length > 0 && isIdentifier$g(params[0], {
	          name: "this"
	        })) {
	          params.shift();
	        }

	        var paramsPath = path.get("params");

	        for (var _iterator8 = _createForOfIteratorHelperLoose(paramsPath), _step8; !(_step8 = _iterator8()).done;) {
	          var p = _step8.value;

	          if (p.type === "TSParameterProperty") {
	            p.replaceWith(p.get("parameter"));
	            scope.registerBinding("param", p);
	          }
	        }
	      },
	      TSModuleDeclaration: function TSModuleDeclaration(path) {
	        transpileNamespace(path, t$f, allowNamespaces);
	      },
	      TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
	        path.remove();
	      },
	      TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
	        path.remove();
	      },
	      TSEnumDeclaration: function TSEnumDeclaration(path) {
	        if (optimizeConstEnums && path.node["const"]) {
	          transpileConstEnum(path, t$f);
	        } else {
	          transpileEnum(path, t$f);
	        }
	      },
	      TSImportEqualsDeclaration: function (_TSImportEqualsDeclaration) {
	        function TSImportEqualsDeclaration(_x) {
	          return _TSImportEqualsDeclaration.apply(this, arguments);
	        }

	        TSImportEqualsDeclaration.toString = function () {
	          return _TSImportEqualsDeclaration.toString();
	        };

	        return TSImportEqualsDeclaration;
	      }(function (path) {
	        if (isTSExternalModuleReference(path.node.moduleReference)) {
	          throw path.buildCodeFrameError("`import " + path.node.id.name + " = require('" + path.node.moduleReference.expression.value + "')` " + "is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + ("`import " + path.node.id.name + " from '" + path.node.moduleReference.expression.value + "';` alongside ") + "Typescript's --allowSyntheticDefaultImports option.");
	        }

	        path.replaceWith(variableDeclaration$8("var", [variableDeclarator$8(path.node.id, entityNameToExpr(path.node.moduleReference))]));
	      }),
	      TSExportAssignment: function TSExportAssignment(path) {
	        throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
	      },
	      TSTypeAssertion: function TSTypeAssertion(path) {
	        path.replaceWith(path.node.expression);
	      },
	      TSAsExpression: function TSAsExpression(path) {
	        var node = path.node;

	        do {
	          node = node.expression;
	        } while (isTSAsExpression$2(node));

	        path.replaceWith(node);
	      },
	      TSNonNullExpression: function TSNonNullExpression(path) {
	        path.replaceWith(path.node.expression);
	      },
	      CallExpression: function CallExpression(path) {
	        path.node.typeParameters = null;
	      },
	      OptionalCallExpression: function OptionalCallExpression(path) {
	        path.node.typeParameters = null;
	      },
	      NewExpression: function NewExpression(path) {
	        path.node.typeParameters = null;
	      },
	      JSXOpeningElement: function JSXOpeningElement(path) {
	        path.node.typeParameters = null;
	      },
	      TaggedTemplateExpression: function TaggedTemplateExpression(path) {
	        path.node.typeParameters = null;
	      }
	    }
	  };

	  function entityNameToExpr(node) {
	    if (isTSQualifiedName(node)) {
	      return memberExpression$b(entityNameToExpr(node.left), node.right);
	    }

	    return node;
	  }

	  function visitPattern(_ref3) {
	    var node = _ref3.node;
	    if (node.typeAnnotation) node.typeAnnotation = null;
	    if (isIdentifier$g(node) && node.optional) node.optional = null;
	  }

	  function isImportTypeOnly(_ref4) {
	    var binding = _ref4.binding,
	        programPath = _ref4.programPath,
	        pragmaImportName = _ref4.pragmaImportName,
	        pragmaFragImportName = _ref4.pragmaFragImportName;

	    for (var _iterator9 = _createForOfIteratorHelperLoose(binding.referencePaths), _step9; !(_step9 = _iterator9()).done;) {
	      var path = _step9.value;

	      if (!isInType(path)) {
	        return false;
	      }
	    }

	    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
	      return true;
	    }

	    var sourceFileHasJsx = false;
	    programPath.traverse({
	      "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
	        sourceFileHasJsx = true;
	        path.stop();
	      }
	    });
	    return !sourceFileHasJsx;
	  }
	});

	var _transformUnicodeEscapes = declare(function (api) {
	  api.assertVersion(7);
	  var surrogate = /[\ud800-\udfff]/g;
	  var unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;

	  function escape(code) {
	    var str = code.toString(16);

	    while (str.length < 4) {
	      str = "0" + str;
	    }

	    return "\\u" + str;
	  }

	  function replacer(match, backslashes, code) {
	    if (backslashes.length % 2 === 0) {
	      return match;
	    }

	    var _char = String.fromCodePoint(parseInt(code, 16));

	    var escaped = backslashes.slice(0, -1) + escape(_char.charCodeAt(0));
	    return _char.length === 1 ? escaped : escaped + escape(_char.charCodeAt(1));
	  }

	  function replaceUnicodeEscapes(str) {
	    return str.replace(unicodeEscape, replacer);
	  }

	  function getUnicodeEscape(str) {
	    var match;

	    while (match = unicodeEscape.exec(str)) {
	      if (match[1].length % 2 === 0) continue;
	      unicodeEscape.lastIndex = 0;
	      return match[0];
	    }

	    return null;
	  }

	  return {
	    name: "transform-unicode-escapes",
	    manipulateOptions: function manipulateOptions(_ref) {
	      var _generatorOpts$jsescO, _generatorOpts$jsescO2;

	      var generatorOpts = _ref.generatorOpts;

	      if (!generatorOpts.jsescOption) {
	        generatorOpts.jsescOption = {};
	      }

	      (_generatorOpts$jsescO2 = (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal) != null ? _generatorOpts$jsescO2 : _generatorOpts$jsescO.minimal = false;
	    },
	    visitor: {
	      Identifier: function Identifier(path) {
	        var node = path.node,
	            key = path.key;
	        var name = node.name;
	        var replaced = name.replace(surrogate, function (c) {
	          return "_u" + c.charCodeAt(0).toString(16);
	        });
	        if (name === replaced) return;
	        var str = inherits$1(stringLiteral$8(name), node);

	        if (key === "key") {
	          path.replaceWith(str);
	          return;
	        }

	        var parentPath = path.parentPath,
	            scope = path.scope;

	        if (parentPath.isMemberExpression({
	          property: node
	        }) || parentPath.isOptionalMemberExpression({
	          property: node
	        })) {
	          parentPath.node.computed = true;
	          path.replaceWith(str);
	          return;
	        }

	        var binding = scope.getBinding(name);

	        if (binding) {
	          scope.rename(name, scope.generateUid(replaced));
	          return;
	        }

	        throw path.buildCodeFrameError("Can't reference '" + name + "' as a bare identifier");
	      },
	      "StringLiteral|DirectiveLiteral": function StringLiteralDirectiveLiteral(path) {
	        var node = path.node;
	        var extra = node.extra;
	        if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
	      },
	      TemplateElement: function TemplateElement(path) {
	        var node = path.node,
	            parentPath = path.parentPath;
	        var value = node.value;
	        var firstEscape = getUnicodeEscape(value.raw);
	        if (!firstEscape) return;
	        var grandParent = parentPath.parentPath;

	        if (grandParent.isTaggedTemplateExpression()) {
	          throw path.buildCodeFrameError("Can't replace Unicode escape '" + firstEscape + "' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.");
	        }

	        value.raw = replaceUnicodeEscapes(value.raw);
	      }
	    }
	  };
	});

	var _transformUnicodeRegex = declare(function (api) {
	  api.assertVersion(7);
	  return createRegExpFeaturePlugin({
	    name: "transform-unicode-regex",
	    feature: "unicodeFlag"
	  });
	});

	var all = {
	  "external-helpers": externalHelpers,
	  "syntax-async-generators": lib$x,
	  "syntax-class-properties": lib$w,
	  "syntax-class-static-block": lib$v,
	  "syntax-decimal": syntaxDecimal,
	  "syntax-decorators": syntaxDecorators,
	  "syntax-do-expressions": syntaxDoExpressions,
	  "syntax-export-default-from": syntaxExportDefaultFrom,
	  "syntax-flow": syntaxFlow,
	  "syntax-function-bind": syntaxFunctionBind,
	  "syntax-function-sent": syntaxFunctionSent,
	  "syntax-module-blocks": syntaxModuleBlocks,
	  "syntax-import-meta": lib$u,
	  "syntax-jsx": syntaxJsx,
	  "syntax-import-assertions": syntaxImportAssertions,
	  "syntax-object-rest-spread": lib$t,
	  "syntax-optional-catch-binding": lib$s,
	  "syntax-pipeline-operator": syntaxPipelineOperator,
	  "syntax-record-and-tuple": syntaxRecordAndTuple,
	  "syntax-top-level-await": lib$r,
	  "syntax-typescript": syntaxTypescript,
	  "proposal-async-generator-functions": _proposalAsyncGeneratorFunctions,
	  "proposal-class-properties": _proposalClassProperties,
	  "proposal-class-static-block": _proposalClassStaticBlock,
	  "proposal-decorators": proposalDecorators,
	  "proposal-do-expressions": proposalDoExpressions,
	  "proposal-dynamic-import": _proposalDynamicImport,
	  "proposal-export-default-from": proposalExportDefaultFrom,
	  "proposal-export-namespace-from": _proposalExportNamespaceFrom,
	  "proposal-function-bind": proposalFunctionBind,
	  "proposal-function-sent": proposalFunctionSent,
	  "proposal-json-strings": _proposalJsonStrings,
	  "proposal-logical-assignment-operators": _proposalLogicalAssignmentOperators,
	  "proposal-nullish-coalescing-operator": _proposalNullishCoalescingOperator,
	  "proposal-numeric-separator": _proposalNumericSeparator,
	  "proposal-object-rest-spread": _proposalObjectRestSpread,
	  "proposal-optional-catch-binding": _proposalOptionalCatchBinding,
	  "proposal-optional-chaining": _proposalOptionalChaining,
	  "proposal-pipeline-operator": proposalPipelineOperator,
	  "proposal-private-methods": _proposalPrivateMethods,
	  "proposal-private-property-in-object": _proposalPrivatePropertyInObject,
	  "proposal-throw-expressions": proposalThrowExpressions,
	  "proposal-unicode-property-regex": _proposalUnicodePropertyRegex,
	  "transform-async-to-generator": _transformAsyncToGenerator,
	  "transform-arrow-functions": _transformArrowFunctions,
	  "transform-block-scoped-functions": _transformBlockScopedFunctions,
	  "transform-block-scoping": _transformBlockScoping,
	  "transform-classes": _transformClasses,
	  "transform-computed-properties": _transformComputedProperties,
	  "transform-destructuring": _transformDestructuring,
	  "transform-dotall-regex": _transformDotallRegex,
	  "transform-duplicate-keys": _transformDuplicateKeys,
	  "transform-exponentiation-operator": transformExponentialOperator,
	  "transform-flow-comments": transformFlowComments,
	  "transform-flow-strip-types": transformFlowStripTypes,
	  "transform-for-of": _transformForOf,
	  "transform-function-name": _transformFunctionName,
	  "transform-instanceof": transformInstanceof,
	  "transform-jscript": transformJscript,
	  "transform-literals": _transformLiterals,
	  "transform-member-expression-literals": _transformMemberExpressionLiterals,
	  "transform-modules-amd": _transformModulesAmd,
	  "transform-modules-commonjs": _transformModulesCommonjs,
	  "transform-modules-systemjs": _transformModulesSystemjs,
	  "transform-modules-umd": _transformModulesUmd,
	  "transform-named-capturing-groups-regex": _transformNamedCapturingGroupsRegex,
	  "transform-new-target": _transformNewTarget,
	  "transform-object-assign": transformObjectAssign,
	  "transform-object-super": _transformObjectSuper,
	  "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
	  "transform-parameters": _transformParameters,
	  "transform-property-literals": _transformPropertyLiterals,
	  "transform-property-mutators": transformPropertyMutators,
	  "transform-proto-to-assign": transformProtoToAssign,
	  "transform-react-constant-elements": transformReactConstantElements,
	  "transform-react-display-name": transformReactDisplayName,
	  "transform-react-inline-elements": transformReactInlineElements,
	  "transform-react-jsx": transformReactJSX,
	  "transform-react-jsx-compat": transformReactJsxCompat,
	  "transform-react-jsx-development": transformReactJSXDevelopment,
	  "transform-react-jsx-self": transformReactJsxSelf,
	  "transform-react-jsx-source": transformReactJsxSource,
	  "transform-regenerator": _transformRegenerator,
	  "transform-reserved-words": _transformReservedWords,
	  "transform-runtime": transformRuntime,
	  "transform-shorthand-properties": _transformShorthandProperties,
	  "transform-spread": _transformSpread,
	  "transform-sticky-regex": _transformStickyRegex,
	  "transform-strict-mode": transformStrictMode,
	  "transform-template-literals": _transformTemplateLiterals,
	  "transform-typeof-symbol": _transformTypeofSymbol,
	  "transform-typescript": transformTypeScript,
	  "transform-unicode-escapes": _transformUnicodeEscapes,
	  "transform-unicode-regex": _transformUnicodeRegex
	};

	var preset2015 = (function (_, opts) {
	  var loose = false;
	  var modules = "commonjs";
	  var spec = false;

	  if (opts !== undefined) {
	    if (opts.loose !== undefined) loose = opts.loose;
	    if (opts.modules !== undefined) modules = opts.modules;
	    if (opts.spec !== undefined) spec = opts.spec;
	  }

	  var optsLoose = {
	    loose: loose
	  };
	  return {
	    plugins: [[_transformTemplateLiterals, {
	      loose: loose,
	      spec: spec
	    }], _transformLiterals, _transformFunctionName, [_transformArrowFunctions, {
	      spec: spec
	    }], _transformBlockScopedFunctions, [_transformClasses, optsLoose], _transformObjectSuper, _transformShorthandProperties, _transformDuplicateKeys, [_transformComputedProperties, optsLoose], [_transformForOf, optsLoose], _transformStickyRegex, _transformUnicodeEscapes, _transformUnicodeRegex, [_transformSpread, optsLoose], [_transformParameters, optsLoose], [_transformDestructuring, optsLoose], _transformBlockScoping, _transformTypeofSymbol, transformInstanceof, (modules === "commonjs" || modules === "cjs") && [_transformModulesCommonjs, optsLoose], modules === "systemjs" && [_transformModulesSystemjs, optsLoose], modules === "amd" && [_transformModulesAmd, optsLoose], modules === "umd" && [_transformModulesUmd, optsLoose], [_transformRegenerator, {
	      async: false,
	      asyncGenerators: false
	    }]].filter(Boolean)
	  };
	});

	var presetStage3 = (function (_, _temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      _ref$loose = _ref.loose,
	      loose = _ref$loose === void 0 ? false : _ref$loose;

	  var plugins = [syntaxImportAssertions, _proposalClassStaticBlock];
	  {
	    plugins.push(lib$u, lib$r, _proposalExportNamespaceFrom, _proposalLogicalAssignmentOperators, [_proposalOptionalChaining, {
	      loose: loose
	    }], [_proposalNullishCoalescingOperator, {
	      loose: loose
	    }], [_proposalClassProperties, {
	      loose: loose
	    }], _proposalJsonStrings, _proposalNumericSeparator, [_proposalPrivateMethods, {
	      loose: loose
	    }], _proposalPrivatePropertyInObject);
	  }
	  return {
	    plugins: plugins
	  };
	});

	var presetStage2 = (function (_, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var _opts = opts,
	      _opts$loose = _opts.loose,
	      loose = _opts$loose === void 0 ? false : _opts$loose,
	      _opts$useBuiltIns = _opts.useBuiltIns,
	      useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
	      _opts$decoratorsLegac = _opts.decoratorsLegacy,
	      decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
	      decoratorsBeforeExport = _opts.decoratorsBeforeExport,
	      _opts$pipelineProposa = _opts.pipelineProposal,
	      pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
	      _opts$pipelineTopicTo = _opts.pipelineTopicToken,
	      pipelineTopicToken = _opts$pipelineTopicTo === void 0 ? "%" : _opts$pipelineTopicTo,
	      _opts$recordAndTupleS = _opts.recordAndTupleSyntax,
	      recordAndTupleSyntax = _opts$recordAndTupleS === void 0 ? "hash" : _opts$recordAndTupleS;
	  return {
	    presets: [[presetStage3, {
	      loose: loose,
	      useBuiltIns: useBuiltIns
	    }]],
	    plugins: [[proposalDecorators, {
	      legacy: decoratorsLegacy,
	      decoratorsBeforeExport: decoratorsBeforeExport
	    }], [proposalPipelineOperator, {
	      proposal: pipelineProposal,
	      topicToken: pipelineTopicToken
	    }], proposalFunctionSent, proposalThrowExpressions, [syntaxRecordAndTuple, {
	      syntaxType: recordAndTupleSyntax
	    }], syntaxModuleBlocks]
	  };
	});

	var presetStage1 = (function (_, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var _opts = opts,
	      _opts$loose = _opts.loose,
	      loose = _opts$loose === void 0 ? false : _opts$loose,
	      _opts$useBuiltIns = _opts.useBuiltIns,
	      useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
	      _opts$decoratorsLegac = _opts.decoratorsLegacy,
	      decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
	      decoratorsBeforeExport = _opts.decoratorsBeforeExport,
	      pipelineProposal = _opts.pipelineProposal,
	      pipelineTopicToken = _opts.pipelineTopicToken,
	      recordAndTupleSyntax = _opts.recordAndTupleSyntax;
	  return {
	    presets: [[presetStage2, {
	      loose: loose,
	      useBuiltIns: useBuiltIns,
	      decoratorsLegacy: decoratorsLegacy,
	      decoratorsBeforeExport: decoratorsBeforeExport,
	      pipelineProposal: pipelineProposal,
	      pipelineTopicToken: pipelineTopicToken,
	      recordAndTupleSyntax: recordAndTupleSyntax
	    }]],
	    plugins: [syntaxDecimal, proposalExportDefaultFrom, proposalDoExpressions]
	  };
	});

	var presetStage0 = (function (_, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  var _opts = opts,
	      _opts$loose = _opts.loose,
	      loose = _opts$loose === void 0 ? false : _opts$loose,
	      _opts$useBuiltIns = _opts.useBuiltIns,
	      useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
	      _opts$decoratorsLegac = _opts.decoratorsLegacy,
	      decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
	      decoratorsBeforeExport = _opts.decoratorsBeforeExport,
	      pipelineProposal = _opts.pipelineProposal,
	      pipelineTopicToken = _opts.pipelineTopicToken,
	      _opts$importAssertion = _opts.importAssertionsVersion,
	      importAssertionsVersion = _opts$importAssertion === void 0 ? "september-2020" : _opts$importAssertion;
	  return {
	    presets: [[presetStage1, {
	      loose: loose,
	      useBuiltIns: useBuiltIns,
	      decoratorsLegacy: decoratorsLegacy,
	      decoratorsBeforeExport: decoratorsBeforeExport,
	      pipelineProposal: pipelineProposal,
	      pipelineTopicToken: pipelineTopicToken,
	      importAssertionsVersion: importAssertionsVersion
	    }]],
	    plugins: [proposalFunctionBind]
	  };
	});

	var logPlugin = function logPlugin(item, targetVersions, list) {
	  var filteredList = getInclusionReasons(item, targetVersions, list);
	  var support = list[item];

	  if (!support) {
	    console.log("  " + item);
	    return;
	  }

	  var formattedTargets = "{";
	  var first = true;

	  for (var _i = 0, _Object$keys = Object.keys(filteredList); _i < _Object$keys.length; _i++) {
	    var target = _Object$keys[_i];
	    if (!first) formattedTargets += ",";
	    first = false;
	    formattedTargets += " " + target;
	    if (support[target]) formattedTargets += " < " + support[target];
	  }

	  formattedTargets += " }";
	  console.log("  " + item + " " + formattedTargets);
	};

	var defaultExcludesForLooseMode = ["transform-typeof-symbol"];
	function getOptionSpecificExcludesFor (_ref) {
	  var loose = _ref.loose;
	  return loose ? defaultExcludesForLooseMode : null;
	}

	var lib$d = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-async-generators",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("asyncGenerators");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-async-generators/lib");

	var lib$c = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-class-properties",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-class-properties/lib");

	var lib$b = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-class-static-block",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("classStaticBlock");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-class-static-block/lib");

	var lib$a = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-dynamic-import",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("dynamicImport");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-dynamic-import/lib");

	var lib$9 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-export-namespace-from",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("exportNamespaceFrom");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-export-namespace-from/lib");

	var lib$8 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-json-strings",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("jsonStrings");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-json-strings/lib");

	var lib$7 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-logical-assignment-operators",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("logicalAssignment");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-logical-assignment-operators/lib");

	var lib$6 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-nullish-coalescing-operator",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("nullishCoalescingOperator");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib");

	var lib$5 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-numeric-separator",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("numericSeparator");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-numeric-separator/lib");

	var lib$4 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-object-rest-spread",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("objectRestSpread");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

	var lib$3 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-optional-catch-binding",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("optionalCatchBinding");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

	var lib$2 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-optional-chaining",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("optionalChaining");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-optional-chaining/lib");

	var lib$1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-private-property-in-object",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("privateIn");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-private-property-in-object/lib");

	var lib = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = void 0;

	  var _default = (0, _helperPluginUtils.declare)(function (api) {
	    api.assertVersion(7);
	    return {
	      name: "syntax-top-level-await",
	      manipulateOptions: function manipulateOptions(opts, parserOpts) {
	        parserOpts.plugins.push("topLevelAwait");
	      }
	    };
	  });

	  exports["default"] = _default;
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-top-level-await/lib");

	var transformAsyncArrowsInClass = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = void 0;
	  var OPTS = {
	    allowInsertArrow: false,
	    specCompliant: false
	  };

	  var _default = function _default(_ref) {
	    var t = _ref.types;
	    return {
	      name: "transform-async-arrows-in-class",
	      visitor: {
	        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
	          if (path.node.async && path.findParent(t.isClassMethod)) {
	            path.arrowFunctionToExpression(OPTS);
	          }
	        }
	      }
	    };
	  };

	  exports["default"] = _default;
	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-async-arrows-in-class");

	var transformEdgeDefaultParameters = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = void 0;

	  var _default = function _default(_ref) {
	    var t = _ref.types;

	    var isArrowParent = function isArrowParent(p) {
	      return p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
	    };

	    return {
	      name: "transform-edge-default-parameters",
	      visitor: {
	        AssignmentPattern: function AssignmentPattern(path) {
	          var arrowArgParent = path.find(isArrowParent);

	          if (arrowArgParent && path.parent.shorthand) {
	            path.parent.shorthand = false;
	            (path.parent.extra || {}).shorthand = false;
	            path.scope.rename(path.parent.key.name);
	          }
	        }
	      }
	    };
	  };

	  exports["default"] = _default;
	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-edge-default-parameters");

	var transformEdgeFunctionName = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = void 0;

	  var _default = function _default(_ref) {
	    var t = _ref.types;
	    return {
	      name: "transform-edge-function-name",
	      visitor: {
	        FunctionExpression: {
	          exit: function exit(path) {
	            if (!path.node.id && t.isIdentifier(path.parent.id)) {
	              var id = t.cloneNode(path.parent.id);
	              var binding = path.scope.getBinding(id.name);

	              if (binding == null ? void 0 : binding.constantViolations.length) {
	                path.scope.rename(id.name);
	              }

	              path.node.id = id;
	            }
	          }
	        }
	      }
	    };
	  };

	  exports["default"] = _default;
	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-edge-function-name");

	var transformTaggedTemplateCaching = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = void 0;

	  var _default = function _default(_ref) {
	    var t = _ref.types;
	    return {
	      name: "transform-tagged-template-caching",
	      visitor: {
	        TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
	          var processed = state.get("processed");

	          if (!processed) {
	            processed = new WeakSet();
	            state.set("processed", processed);
	          }

	          if (processed.has(path.node)) return path.skip();
	          var expressions = path.node.quasi.expressions;
	          var identity = state.get("identity");

	          if (!identity) {
	            identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
	            state.set("identity", identity);
	            var binding = path.scope.getBinding(identity.name);
	            binding.path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
	          }

	          var template = t.taggedTemplateExpression(t.cloneNode(identity), t.templateLiteral(path.node.quasi.quasis, expressions.map(function () {
	            return t.numericLiteral(0);
	          })));
	          processed.add(template);
	          var ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
	          path.scope.getBinding(ident.name).path.parent.kind = "let";
	          var inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", t.cloneNode(ident), template));
	          var node = t.callExpression(path.node.tag, [inlineCache].concat(_toConsumableArray(expressions)));
	          path.replaceWith(node);
	        }
	      }
	    };
	  };

	  exports["default"] = _default;
	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-tagged-template-caching");

	var transformSafariBlockShadowing = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = _default;

	  function _default(_ref) {
	    var t = _ref.types;
	    return {
	      name: "transform-safari-block-shadowing",
	      visitor: {
	        VariableDeclarator: function VariableDeclarator(path) {
	          var kind = path.parent.kind;
	          if (kind !== "let" && kind !== "const") return;
	          var block = path.scope.block;
	          if (t.isFunction(block) || t.isProgram(block)) return;
	          var bindings = t.getOuterBindingIdentifiers(path.node.id);

	          for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
	            var name = _Object$keys[_i];
	            var scope = path.scope;
	            if (!scope.hasOwnBinding(name)) continue;

	            while (scope = scope.parent) {
	              if (scope.hasOwnBinding(name)) {
	                path.scope.rename(name);
	                break;
	              }

	              if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
	                break;
	              }
	            }
	          }
	        }
	      }
	    };
	  }

	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-safari-block-shadowing");

	var transformSafariForShadowing = createCommonjsModule(function (module, exports) {

	  exports.__esModule = true;
	  exports["default"] = void 0;

	  function handle(declaration) {
	    if (!declaration.isVariableDeclaration()) return;
	    var fn = declaration.getFunctionParent();
	    var name = declaration.node.declarations[0].id.name;

	    if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
	      declaration.scope.rename(name);
	    }
	  }

	  var _default = function _default() {
	    return {
	      name: "transform-safari-for-shadowing",
	      visitor: {
	        ForXStatement: function ForXStatement(path) {
	          handle(path.get("left"));
	        },
	        ForStatement: function ForStatement(path) {
	          handle(path.get("init"));
	        }
	      }
	    };
	  };

	  exports["default"] = _default;
	  module.exports = exports["default"];
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-safari-for-shadowing");

	function shouldTransform$1(path) {
	  var node = path.node;
	  var functionId = node.id;
	  if (!functionId) return false;
	  var name = functionId.name;
	  var paramNameBinding = path.scope.getOwnBinding(name);

	  if (paramNameBinding === undefined) {
	    return false;
	  }

	  if (paramNameBinding.kind !== "param") {
	    return false;
	  }

	  if (paramNameBinding.identifier === paramNameBinding.path.node) {
	    return false;
	  }

	  return name;
	}

	var bugfixSafariIdDestructuringCollisionInFunctionExpression = declare(function (api) {
	  api.assertVersion("^7.16.0");
	  return {
	    name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
	    visitor: {
	      FunctionExpression: function FunctionExpression(path) {
	        var name = shouldTransform$1(path);

	        if (name) {
	          var scope = path.scope;
	          var newParamName = scope.generateUid(name);
	          scope.rename(name, newParamName);
	        }
	      }
	    }
	  };
	});

	function matchAffectedArguments(argumentNodes) {
	  var spreadIndex = argumentNodes.findIndex(function (node) {
	    return isSpreadElement$1(node);
	  });
	  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
	}

	function shouldTransform(path) {
	  var optionalPath = path;
	  var chains = [];

	  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
	    var _optionalPath = optionalPath,
	        node = _optionalPath.node;
	    chains.push(node);

	    if (optionalPath.isOptionalMemberExpression()) {
	      optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
	    } else if (optionalPath.isOptionalCallExpression()) {
	      optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
	    }
	  }

	  for (var i = 0; i < chains.length; i++) {
	    var _node = chains[i];

	    if (isOptionalCallExpression$3(_node) && matchAffectedArguments(_node.arguments)) {
	      if (_node.optional) {
	        return true;
	      }

	      var callee = chains[i + 1];

	      if (isOptionalMemberExpression$3(callee, {
	        optional: true
	      })) {
	        return true;
	      }
	    }
	  }

	  return false;
	}

	var bugfixV8SpreadParametersInOptionalChaining = declare(function (api) {
	  api.assertVersion(7);
	  var noDocumentAll = api.assumption("noDocumentAll");
	  var pureGetters = api.assumption("pureGetters");
	  return {
	    name: "bugfix-v8-spread-parameters-in-optional-chaining",
	    visitor: {
	      "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
	        if (shouldTransform(path)) {
	          transform$1(path, {
	            noDocumentAll: noDocumentAll,
	            pureGetters: pureGetters
	          });
	        }
	      }
	    }
	  };
	});

	var availablePlugins$1 = {
	  "bugfix/transform-async-arrows-in-class": function bugfixTransformAsyncArrowsInClass() {
	    return transformAsyncArrowsInClass;
	  },
	  "bugfix/transform-edge-default-parameters": function bugfixTransformEdgeDefaultParameters() {
	    return transformEdgeDefaultParameters;
	  },
	  "bugfix/transform-edge-function-name": function bugfixTransformEdgeFunctionName() {
	    return transformEdgeFunctionName;
	  },
	  "bugfix/transform-safari-block-shadowing": function bugfixTransformSafariBlockShadowing() {
	    return transformSafariBlockShadowing;
	  },
	  "bugfix/transform-safari-for-shadowing": function bugfixTransformSafariForShadowing() {
	    return transformSafariForShadowing;
	  },
	  "bugfix/transform-safari-id-destructuring-collision-in-function-expression": function bugfixTransformSafariIdDestructuringCollisionInFunctionExpression() {
	    return bugfixSafariIdDestructuringCollisionInFunctionExpression;
	  },
	  "bugfix/transform-tagged-template-caching": function bugfixTransformTaggedTemplateCaching() {
	    return transformTaggedTemplateCaching;
	  },
	  "bugfix/transform-v8-spread-parameters-in-optional-chaining": function bugfixTransformV8SpreadParametersInOptionalChaining() {
	    return bugfixV8SpreadParametersInOptionalChaining;
	  },
	  "proposal-async-generator-functions": function proposalAsyncGeneratorFunctions() {
	    return _proposalAsyncGeneratorFunctions;
	  },
	  "proposal-class-properties": function proposalClassProperties() {
	    return _proposalClassProperties;
	  },
	  "proposal-class-static-block": function proposalClassStaticBlock() {
	    return _proposalClassStaticBlock;
	  },
	  "proposal-dynamic-import": function proposalDynamicImport() {
	    return _proposalDynamicImport;
	  },
	  "proposal-export-namespace-from": function proposalExportNamespaceFrom() {
	    return _proposalExportNamespaceFrom;
	  },
	  "proposal-json-strings": function proposalJsonStrings() {
	    return _proposalJsonStrings;
	  },
	  "proposal-logical-assignment-operators": function proposalLogicalAssignmentOperators() {
	    return _proposalLogicalAssignmentOperators;
	  },
	  "proposal-nullish-coalescing-operator": function proposalNullishCoalescingOperator() {
	    return _proposalNullishCoalescingOperator;
	  },
	  "proposal-numeric-separator": function proposalNumericSeparator() {
	    return _proposalNumericSeparator;
	  },
	  "proposal-object-rest-spread": function proposalObjectRestSpread() {
	    return _proposalObjectRestSpread;
	  },
	  "proposal-optional-catch-binding": function proposalOptionalCatchBinding() {
	    return _proposalOptionalCatchBinding;
	  },
	  "proposal-optional-chaining": function proposalOptionalChaining() {
	    return _proposalOptionalChaining;
	  },
	  "proposal-private-methods": function proposalPrivateMethods() {
	    return _proposalPrivateMethods;
	  },
	  "proposal-private-property-in-object": function proposalPrivatePropertyInObject() {
	    return _proposalPrivatePropertyInObject;
	  },
	  "proposal-unicode-property-regex": function proposalUnicodePropertyRegex() {
	    return _proposalUnicodePropertyRegex;
	  },
	  "syntax-async-generators": function syntaxAsyncGenerators() {
	    return lib$d;
	  },
	  "syntax-class-properties": function syntaxClassProperties() {
	    return lib$c;
	  },
	  "syntax-class-static-block": function syntaxClassStaticBlock() {
	    return lib$b;
	  },
	  "syntax-dynamic-import": function syntaxDynamicImport() {
	    return lib$a;
	  },
	  "syntax-export-namespace-from": function syntaxExportNamespaceFrom() {
	    return lib$9;
	  },
	  "syntax-json-strings": function syntaxJsonStrings() {
	    return lib$8;
	  },
	  "syntax-logical-assignment-operators": function syntaxLogicalAssignmentOperators() {
	    return lib$7;
	  },
	  "syntax-nullish-coalescing-operator": function syntaxNullishCoalescingOperator() {
	    return lib$6;
	  },
	  "syntax-numeric-separator": function syntaxNumericSeparator() {
	    return lib$5;
	  },
	  "syntax-object-rest-spread": function syntaxObjectRestSpread() {
	    return lib$4;
	  },
	  "syntax-optional-catch-binding": function syntaxOptionalCatchBinding() {
	    return lib$3;
	  },
	  "syntax-optional-chaining": function syntaxOptionalChaining() {
	    return lib$2;
	  },
	  "syntax-private-property-in-object": function syntaxPrivatePropertyInObject() {
	    return lib$1;
	  },
	  "syntax-top-level-await": function syntaxTopLevelAwait() {
	    return lib;
	  },
	  "transform-arrow-functions": function transformArrowFunctions() {
	    return _transformArrowFunctions;
	  },
	  "transform-async-to-generator": function transformAsyncToGenerator() {
	    return _transformAsyncToGenerator;
	  },
	  "transform-block-scoped-functions": function transformBlockScopedFunctions() {
	    return _transformBlockScopedFunctions;
	  },
	  "transform-block-scoping": function transformBlockScoping() {
	    return _transformBlockScoping;
	  },
	  "transform-classes": function transformClasses() {
	    return _transformClasses;
	  },
	  "transform-computed-properties": function transformComputedProperties() {
	    return _transformComputedProperties;
	  },
	  "transform-destructuring": function transformDestructuring() {
	    return _transformDestructuring;
	  },
	  "transform-dotall-regex": function transformDotallRegex() {
	    return _transformDotallRegex;
	  },
	  "transform-duplicate-keys": function transformDuplicateKeys() {
	    return _transformDuplicateKeys;
	  },
	  "transform-exponentiation-operator": function transformExponentiationOperator() {
	    return transformExponentialOperator;
	  },
	  "transform-for-of": function transformForOf() {
	    return _transformForOf;
	  },
	  "transform-function-name": function transformFunctionName() {
	    return _transformFunctionName;
	  },
	  "transform-literals": function transformLiterals() {
	    return _transformLiterals;
	  },
	  "transform-member-expression-literals": function transformMemberExpressionLiterals() {
	    return _transformMemberExpressionLiterals;
	  },
	  "transform-modules-amd": function transformModulesAmd() {
	    return _transformModulesAmd;
	  },
	  "transform-modules-commonjs": function transformModulesCommonjs() {
	    return _transformModulesCommonjs;
	  },
	  "transform-modules-systemjs": function transformModulesSystemjs() {
	    return _transformModulesSystemjs;
	  },
	  "transform-modules-umd": function transformModulesUmd() {
	    return _transformModulesUmd;
	  },
	  "transform-named-capturing-groups-regex": function transformNamedCapturingGroupsRegex() {
	    return _transformNamedCapturingGroupsRegex;
	  },
	  "transform-new-target": function transformNewTarget() {
	    return _transformNewTarget;
	  },
	  "transform-object-super": function transformObjectSuper() {
	    return _transformObjectSuper;
	  },
	  "transform-parameters": function transformParameters() {
	    return _transformParameters;
	  },
	  "transform-property-literals": function transformPropertyLiterals() {
	    return _transformPropertyLiterals;
	  },
	  "transform-regenerator": function transformRegenerator() {
	    return _transformRegenerator;
	  },
	  "transform-reserved-words": function transformReservedWords() {
	    return _transformReservedWords;
	  },
	  "transform-shorthand-properties": function transformShorthandProperties() {
	    return _transformShorthandProperties;
	  },
	  "transform-spread": function transformSpread() {
	    return _transformSpread;
	  },
	  "transform-sticky-regex": function transformStickyRegex() {
	    return _transformStickyRegex;
	  },
	  "transform-template-literals": function transformTemplateLiterals() {
	    return _transformTemplateLiterals;
	  },
	  "transform-typeof-symbol": function transformTypeofSymbol() {
	    return _transformTypeofSymbol;
	  },
	  "transform-unicode-escapes": function transformUnicodeEscapes() {
	    return _transformUnicodeEscapes;
	  },
	  "transform-unicode-regex": function transformUnicodeRegex() {
	    return _transformUnicodeRegex;
	  }
	};
	var minVersions = {
	  "bugfix/transform-safari-id-destructuring-collision-in-function-expression": "7.16.0",
	  "proposal-class-static-block": "7.12.0",
	  "proposal-private-property-in-object": "7.10.0"
	};

	var has$3 = Function.call.bind(Object.hasOwnProperty);
	function removeUnnecessaryItems(items, overlapping) {
	  items.forEach(function (item) {
	    var _overlapping$item;

	    (_overlapping$item = overlapping[item]) == null ? void 0 : _overlapping$item.forEach(function (name) {
	      return items["delete"](name);
	    });
	  });
	}
	function removeUnsupportedItems(items, babelVersion) {
	  items.forEach(function (item) {
	    if (has$3(minVersions, item) && semver$4.lt(babelVersion, minVersions[item])) {
	      items["delete"](item);
	    }
	  });
	}

	var moduleTransformations = {
	  auto: "transform-modules-commonjs",
	  amd: "transform-modules-amd",
	  commonjs: "transform-modules-commonjs",
	  cjs: "transform-modules-commonjs",
	  systemjs: "transform-modules-systemjs",
	  umd: "transform-modules-umd"
	};

	var require$$0$1 = {
		"transform-async-to-generator": {
		chrome: "55",
		opera: "42",
		edge: "15",
		firefox: "52",
		safari: "10.1",
		node: "7.6",
		ios: "10.3",
		samsung: "6",
		electron: "1.6"
	},
		"bugfix/transform-async-arrows-in-class": {
		chrome: "55",
		opera: "42",
		edge: "15",
		firefox: "52",
		safari: "11",
		node: "7.6",
		ios: "11",
		samsung: "6",
		electron: "1.6"
	},
		"transform-parameters": {
		chrome: "49",
		opera: "36",
		edge: "15",
		firefox: "53",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"bugfix/transform-edge-default-parameters": {
		chrome: "49",
		opera: "36",
		edge: "18",
		firefox: "52",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"transform-function-name": {
		chrome: "51",
		opera: "38",
		edge: "14",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"bugfix/transform-edge-function-name": {
		chrome: "51",
		opera: "38",
		edge: "79",
		firefox: "53",
		safari: "10",
		node: "6.5",
		ios: "10",
		samsung: "5",
		electron: "1.2"
	},
		"transform-block-scoping": {
		chrome: "49",
		opera: "36",
		edge: "14",
		firefox: "51",
		safari: "10",
		node: "6",
		ios: "10",
		samsung: "5",
		electron: "0.37"
	},
		"bugfix/transform-safari-block-shadowing": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "44",
		safari: "11",
		node: "6",
		ie: "11",
		ios: "11",
		samsung: "5",
		electron: "0.37"
	},
		"bugfix/transform-safari-for-shadowing": {
		chrome: "49",
		opera: "36",
		edge: "12",
		firefox: "4",
		safari: "11",
		node: "6",
		ie: "11",
		ios: "11",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.37"
	},
		"bugfix/transform-safari-id-destructuring-collision-in-function-expression": {
		chrome: "49",
		opera: "36",
		edge: "14",
		firefox: "2",
		node: "6",
		samsung: "5",
		rhino: "1.7.13",
		electron: "0.37"
	},
		"transform-template-literals": {
		chrome: "41",
		opera: "28",
		edge: "13",
		firefox: "34",
		safari: "9",
		node: "4",
		ios: "9",
		samsung: "3.4",
		electron: "0.21"
	},
		"bugfix/transform-tagged-template-caching": {
		chrome: "41",
		opera: "28",
		edge: "12",
		firefox: "34",
		safari: "13",
		node: "4",
		ios: "13",
		samsung: "3.4",
		electron: "0.21"
	},
		"proposal-optional-chaining": {
		chrome: "80",
		opera: "67",
		edge: "80",
		firefox: "74",
		safari: "13.1",
		node: "14",
		ios: "13.4",
		samsung: "13",
		electron: "8.0"
	},
		"bugfix/transform-v8-spread-parameters-in-optional-chaining": {
		chrome: "91",
		opera: "77",
		edge: "91",
		firefox: "74",
		safari: "13.1",
		node: "16.9",
		ios: "13.4",
		electron: "13.0"
	}
	};

	var pluginBugfixes = require$$0$1;

	var pluginsFiltered = {};
	var bugfixPluginsFiltered = {};

	for (var _i = 0, _Object$keys = Object.keys(plugins); _i < _Object$keys.length; _i++) {
	  var plugin = _Object$keys[_i];

	  if (Object.hasOwnProperty.call(availablePlugins$1, plugin)) {
	    pluginsFiltered[plugin] = plugins[plugin];
	  }
	}

	for (var _i2 = 0, _Object$keys2 = Object.keys(pluginBugfixes); _i2 < _Object$keys2.length; _i2++) {
	  var _plugin = _Object$keys2[_i2];

	  if (Object.hasOwnProperty.call(availablePlugins$1, _plugin)) {
	    bugfixPluginsFiltered[_plugin] = pluginBugfixes[_plugin];
	  }
	}

	pluginsFiltered["proposal-class-properties"] = pluginsFiltered["proposal-private-methods"];

	var TopLevelOptions = {
	  bugfixes: "bugfixes",
	  configPath: "configPath",
	  corejs: "corejs",
	  debug: "debug",
	  exclude: "exclude",
	  forceAllTransforms: "forceAllTransforms",
	  ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
	  include: "include",
	  loose: "loose",
	  modules: "modules",
	  shippedProposals: "shippedProposals",
	  spec: "spec",
	  targets: "targets",
	  useBuiltIns: "useBuiltIns",
	  browserslistEnv: "browserslistEnv"
	};
	var ModulesOption = {
	  "false": false,
	  auto: "auto",
	  amd: "amd",
	  commonjs: "commonjs",
	  cjs: "cjs",
	  systemjs: "systemjs",
	  umd: "umd"
	};
	var UseBuiltInsOption = {
	  "false": false,
	  entry: "entry",
	  usage: "usage"
	};

	var corejs2DefaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
	var v$1 = new OptionValidator("@babel/preset-env");
	var allPluginsList = Object.keys(pluginsFiltered);
	var modulePlugins = ["proposal-dynamic-import"].concat(_toConsumableArray(Object.keys(moduleTransformations).map(function (m) {
	  return moduleTransformations[m];
	})));

	var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
	  return new Set([].concat(_toConsumableArray(allPluginsList), _toConsumableArray(type === "exclude" ? modulePlugins : []), _toConsumableArray(corejs ? corejs == 2 ? [].concat(_toConsumableArray(Object.keys(corejs2BuiltIns)), corejs2DefaultWebIncludes) : Object.keys(require$$0$3) : [])));
	};

	var pluginToRegExp = function pluginToRegExp(plugin) {
	  if (plugin instanceof RegExp) return plugin;

	  try {
	    return new RegExp("^" + normalizePluginName(plugin) + "$");
	  } catch (e) {
	    return null;
	  }
	};

	var selectPlugins = function selectPlugins(regexp, type, corejs) {
	  return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
	    return regexp instanceof RegExp && regexp.test(item);
	  });
	};

	var flatten = function flatten(array) {
	  var _ref;

	  return (_ref = []).concat.apply(_ref, _toConsumableArray(array));
	};

	var expandIncludesAndExcludes = function expandIncludesAndExcludes(plugins, type, corejs) {
	  if (plugins === void 0) {
	    plugins = [];
	  }

	  if (plugins.length === 0) return [];
	  var selectedPlugins = plugins.map(function (plugin) {
	    return selectPlugins(pluginToRegExp(plugin), type, corejs);
	  });
	  var invalidRegExpList = plugins.filter(function (p, i) {
	    return selectedPlugins[i].length === 0;
	  });
	  v$1.invariant(invalidRegExpList.length === 0, "The plugins/built-ins '" + invalidRegExpList.join(", ") + "' passed to the '" + type + "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env");
	  return flatten(selectedPlugins);
	};

	var normalizePluginName = function normalizePluginName(plugin) {
	  return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
	};
	var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(include, exclude) {
	  if (include === void 0) {
	    include = [];
	  }

	  if (exclude === void 0) {
	    exclude = [];
	  }

	  var duplicates = include.filter(function (opt) {
	    return exclude.indexOf(opt) >= 0;
	  });
	  v$1.invariant(duplicates.length === 0, "The plugins/built-ins '" + duplicates.join(", ") + "' were found in both the \"include\" and\n    \"exclude\" options.");
	};

	var normalizeTargets = function normalizeTargets(targets) {
	  if (typeof targets === "string" || Array.isArray(targets)) {
	    return {
	      browsers: targets
	    };
	  }

	  return Object.assign({}, targets);
	};

	var validateModulesOption = function validateModulesOption(modulesOpt) {
	  if (modulesOpt === void 0) {
	    modulesOpt = ModulesOption.auto;
	  }

	  v$1.invariant(ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption["false"], "The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
	  return modulesOpt;
	};
	var validateUseBuiltInsOption = function validateUseBuiltInsOption(builtInsOpt) {
	  if (builtInsOpt === void 0) {
	    builtInsOpt = false;
	  }

	  v$1.invariant(UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === UseBuiltInsOption["false"], "The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
	  return builtInsOpt;
	};
	function normalizeCoreJSOption(corejs, useBuiltIns) {
	  var proposals = false;
	  var rawVersion;

	  if (useBuiltIns && corejs === undefined) {
	    rawVersion = 2;
	    console.warn("\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n\n" + "More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\n" + "More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs");
	  } else if (typeof corejs === "object" && corejs !== null) {
	    rawVersion = corejs.version;
	    proposals = Boolean(corejs.proposals);
	  } else {
	    rawVersion = corejs;
	  }

	  var version = rawVersion ? semver$4.coerce(String(rawVersion)) : false;

	  if (!useBuiltIns && version) {
	    console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
	  }

	  if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
	    throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
	  }

	  return {
	    version: version,
	    proposals: proposals
	  };
	}
	function normalizeOptions$3(opts) {
	  v$1.validateTopLevelOptions(opts, TopLevelOptions);
	  var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
	  var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
	  var include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major);
	  var exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
	  checkDuplicateIncludeExcludes(include, exclude);
	  return {
	    bugfixes: v$1.validateBooleanOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
	    configPath: v$1.validateStringOption(TopLevelOptions.configPath, opts.configPath, browser$4.cwd()),
	    corejs: corejs,
	    debug: v$1.validateBooleanOption(TopLevelOptions.debug, opts.debug, false),
	    include: include,
	    exclude: exclude,
	    forceAllTransforms: v$1.validateBooleanOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
	    ignoreBrowserslistConfig: v$1.validateBooleanOption(TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false),
	    loose: v$1.validateBooleanOption(TopLevelOptions.loose, opts.loose),
	    modules: validateModulesOption(opts.modules),
	    shippedProposals: v$1.validateBooleanOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false),
	    spec: v$1.validateBooleanOption(TopLevelOptions.spec, opts.spec, false),
	    targets: normalizeTargets(opts.targets),
	    useBuiltIns: useBuiltIns,
	    browserslistEnv: v$1.validateStringOption(TopLevelOptions.browserslistEnv, opts.browserslistEnv)
	  };
	}

	var proposalPlugins = new Set();
	var pluginSyntaxObject = {
	  "proposal-async-generator-functions": "syntax-async-generators",
	  "proposal-class-properties": "syntax-class-properties",
	  "proposal-class-static-block": "syntax-class-static-block",
	  "proposal-json-strings": "syntax-json-strings",
	  "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
	  "proposal-numeric-separator": "syntax-numeric-separator",
	  "proposal-object-rest-spread": "syntax-object-rest-spread",
	  "proposal-optional-catch-binding": "syntax-optional-catch-binding",
	  "proposal-optional-chaining": "syntax-optional-chaining",
	  "proposal-private-methods": "syntax-class-properties",
	  "proposal-private-property-in-object": "syntax-private-property-in-object",
	  "proposal-unicode-property-regex": null
	};
	var pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
	  return [key, pluginSyntaxObject[key]];
	});
	var pluginSyntaxMap = new Map(pluginSyntaxEntries);
	var shippedProposals = {
	  pluginSyntaxMap: pluginSyntaxMap,
	  proposalPlugins: proposalPlugins
	};

	var require$$0 = {
		"transform-async-to-generator": [
		"bugfix/transform-async-arrows-in-class"
	],
		"transform-parameters": [
		"bugfix/transform-edge-default-parameters",
		"bugfix/transform-safari-id-destructuring-collision-in-function-expression"
	],
		"transform-function-name": [
		"bugfix/transform-edge-function-name"
	],
		"transform-block-scoping": [
		"bugfix/transform-safari-block-shadowing",
		"bugfix/transform-safari-for-shadowing"
	],
		"transform-template-literals": [
		"bugfix/transform-tagged-template-caching"
	],
		"proposal-optional-chaining": [
		"bugfix/transform-v8-spread-parameters-in-optional-chaining"
	]
	};

	var overlappingPlugins = require$$0;

	var isCallExpression = isCallExpression$6,
	    isExpressionStatement = isExpressionStatement$4,
	    isIdentifier = isIdentifier$g,
	    isStringLiteral = isStringLiteral$7;
	function getImportSource$1(_ref) {
	  var node = _ref.node;
	  if (node.specifiers.length === 0) return node.source.value;
	}
	function getRequireSource$1(_ref2) {
	  var node = _ref2.node;
	  if (!isExpressionStatement(node)) return;
	  var expression = node.expression;

	  if (isCallExpression(expression) && isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && isStringLiteral(expression.arguments[0])) {
	    return expression.arguments[0].value;
	  }
	}
	function isPolyfillSource(source) {
	  return source === "@babel/polyfill" || source === "core-js";
	}

	function isRegeneratorSource(source) {
	  return source === "regenerator-runtime/runtime" || source === "regenerator-runtime/runtime.js";
	}

	function removeRegeneratorEntryPlugin () {
	  var visitor = {
	    ImportDeclaration: function ImportDeclaration(path) {
	      if (isRegeneratorSource(getImportSource$1(path))) {
	        this.regeneratorImportExcluded = true;
	        path.remove();
	      }
	    },
	    Program: function Program(path) {
	      var _this = this;

	      path.get("body").forEach(function (bodyPath) {
	        if (isRegeneratorSource(getRequireSource$1(bodyPath))) {
	          _this.regeneratorImportExcluded = true;
	          bodyPath.remove();
	        }
	      });
	    }
	  };
	  return {
	    name: "preset-env/remove-regenerator",
	    visitor: visitor,
	    pre: function pre() {
	      this.regeneratorImportExcluded = false;
	    },
	    post: function post() {
	      if (this.opts.debug && this.regeneratorImportExcluded) {
	        var filename = this.file.opts.filename;

	        if (browser$4.env.BABEL_ENV === "test") {
	          filename = filename.replace(/\\/g, "/");
	        }

	        console.log("\n[" + filename + "] Based on your targets, regenerator-runtime import excluded.");
	      }
	    }
	  };
	}

	var _templateObject$1, _templateObject2$1, _templateObject3$1, _templateObject4;
	var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
	var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `SPECIFIER` or use `useBuiltIns: 'entry'` instead.";
	function legacyBabelPolyfillPlugin (_ref, _ref2) {
	  var template = _ref.template;
	  var regenerator = _ref2.regenerator,
	      deprecated = _ref2.deprecated,
	      usage = _ref2.usage;
	  return {
	    name: "preset-env/replace-babel-polyfill",
	    visitor: {
	      ImportDeclaration: function (_ImportDeclaration) {
	        function ImportDeclaration(_x) {
	          return _ImportDeclaration.apply(this, arguments);
	        }

	        ImportDeclaration.toString = function () {
	          return _ImportDeclaration.toString();
	        };

	        return ImportDeclaration;
	      }(function (path) {
	        var src = getImportSource$1(path);

	        if (usage && isPolyfillSource(src)) {
	          console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
	          if (!deprecated) path.remove();
	        } else if (src === "@babel/polyfill") {
	          if (deprecated) {
	            console.warn(BABEL_POLYFILL_DEPRECATION);
	          } else if (regenerator) {
	            path.replaceWithMultiple(template.ast(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["\n              import \"core-js\";\n              import \"regenerator-runtime/runtime.js\";\n            "]))));
	          } else {
	            path.replaceWith(template.ast(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["\n              import \"core-js\";\n            "]))));
	          }
	        }
	      }),
	      Program: function (_Program) {
	        function Program(_x2) {
	          return _Program.apply(this, arguments);
	        }

	        Program.toString = function () {
	          return _Program.toString();
	        };

	        return Program;
	      }(function (path) {
	        path.get("body").forEach(function (bodyPath) {
	          var src = getRequireSource$1(bodyPath);

	          if (usage && isPolyfillSource(src)) {
	            console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
	            if (!deprecated) bodyPath.remove();
	          } else if (src === "@babel/polyfill") {
	            if (deprecated) {
	              console.warn(BABEL_POLYFILL_DEPRECATION);
	            } else if (regenerator) {
	              bodyPath.replaceWithMultiple(template.ast(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["\n                require(\"core-js\");\n                require(\"regenerator-runtime/runtime.js\");\n              "]))));
	            } else {
	              bodyPath.replaceWith(template.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["\n                require(\"core-js\");\n              "]))));
	            }
	          }
	        });
	      })
	    }
	  };
	}

	var semver = createCommonjsModule(function (module, exports) {
	  exports = module.exports = SemVer;
	  var debug;

	  if (typeof browser$4 === 'object' && browser$4.env && browser$4.env.NODE_DEBUG && /\bsemver\b/i.test(browser$4.env.NODE_DEBUG)) {
	    debug = function debug() {
	      var args = Array.prototype.slice.call(arguments, 0);
	      args.unshift('SEMVER');
	      console.log.apply(console, args);
	    };
	  } else {
	    debug = function debug() {};
	  }

	  exports.SEMVER_SPEC_VERSION = '2.0.0';
	  var MAX_LENGTH = 256;
	  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	  var MAX_SAFE_COMPONENT_LENGTH = 16;
	  var re = exports.re = [];
	  var src = exports.src = [];
	  var t = exports.tokens = {};
	  var R = 0;

	  function tok(n) {
	    t[n] = R++;
	  }

	  tok('NUMERICIDENTIFIER');
	  src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	  tok('NUMERICIDENTIFIERLOOSE');
	  src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
	  tok('NONNUMERICIDENTIFIER');
	  src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
	  tok('MAINVERSION');
	  src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
	  tok('MAINVERSIONLOOSE');
	  src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
	  tok('PRERELEASEIDENTIFIER');
	  src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASEIDENTIFIERLOOSE');
	  src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
	  tok('PRERELEASE');
	  src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
	  tok('PRERELEASELOOSE');
	  src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
	  tok('BUILDIDENTIFIER');
	  src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
	  tok('BUILD');
	  src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
	  tok('FULL');
	  tok('FULLPLAIN');
	  src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
	  src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
	  tok('LOOSEPLAIN');
	  src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
	  tok('LOOSE');
	  src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
	  tok('GTLT');
	  src[t.GTLT] = '((?:<|>)?=?)';
	  tok('XRANGEIDENTIFIERLOOSE');
	  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	  tok('XRANGEIDENTIFIER');
	  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
	  tok('XRANGEPLAIN');
	  src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGEPLAINLOOSE');
	  src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
	  tok('XRANGE');
	  src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
	  tok('XRANGELOOSE');
	  src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COERCE');
	  src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
	  tok('COERCERTL');
	  re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
	  tok('LONETILDE');
	  src[t.LONETILDE] = '(?:~>?)';
	  tok('TILDETRIM');
	  src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
	  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
	  var tildeTrimReplace = '$1~';
	  tok('TILDE');
	  src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
	  tok('TILDELOOSE');
	  src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('LONECARET');
	  src[t.LONECARET] = '(?:\\^)';
	  tok('CARETTRIM');
	  src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
	  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
	  var caretTrimReplace = '$1^';
	  tok('CARET');
	  src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
	  tok('CARETLOOSE');
	  src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
	  tok('COMPARATORLOOSE');
	  src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
	  tok('COMPARATOR');
	  src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
	  tok('COMPARATORTRIM');
	  src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
	  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
	  var comparatorTrimReplace = '$1$2$3';
	  tok('HYPHENRANGE');
	  src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
	  tok('HYPHENRANGELOOSE');
	  src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
	  tok('STAR');
	  src[t.STAR] = '(<|>)?=?\\s*\\*';

	  for (var i = 0; i < R; i++) {
	    debug(i, src[i]);

	    if (!re[i]) {
	      re[i] = new RegExp(src[i]);
	    }
	  }

	  exports.parse = parse;

	  function parse(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    if (version.length > MAX_LENGTH) {
	      return null;
	    }

	    var r = options.loose ? re[t.LOOSE] : re[t.FULL];

	    if (!r.test(version)) {
	      return null;
	    }

	    try {
	      return new SemVer(version, options);
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.valid = valid;

	  function valid(version, options) {
	    var v = parse(version, options);
	    return v ? v.version : null;
	  }

	  exports.clean = clean;

	  function clean(version, options) {
	    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
	    return s ? s.version : null;
	  }

	  exports.SemVer = SemVer;

	  function SemVer(version, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (version instanceof SemVer) {
	      if (version.loose === options.loose) {
	        return version;
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
	    }

	    if (!(this instanceof SemVer)) {
	      return new SemVer(version, options);
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError('Invalid Version: ' + version);
	    }

	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version');
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version');
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version');
	    }

	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map(function (id) {
	        if (/^[0-9]+$/.test(id)) {
	          var num = +id;

	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num;
	          }
	        }

	        return id;
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  SemVer.prototype.format = function () {
	    this.version = this.major + '.' + this.minor + '.' + this.patch;

	    if (this.prerelease.length) {
	      this.version += '-' + this.prerelease.join('.');
	    }

	    return this.version;
	  };

	  SemVer.prototype.toString = function () {
	    return this.version;
	  };

	  SemVer.prototype.compare = function (other) {
	    debug('SemVer.compare', this.version, this.options, other);

	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return this.compareMain(other) || this.comparePre(other);
	  };

	  SemVer.prototype.compareMain = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
	  };

	  SemVer.prototype.comparePre = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1;
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1;
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0;
	    }

	    var i = 0;

	    do {
	      var a = this.prerelease[i];
	      var b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.compareBuild = function (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    var i = 0;

	    do {
	      var a = this.build[i];
	      var b = other.build[i];
	      debug('prerelease compare', i, a, b);

	      if (a === undefined && b === undefined) {
	        return 0;
	      } else if (b === undefined) {
	        return 1;
	      } else if (a === undefined) {
	        return -1;
	      } else if (a === b) {
	        continue;
	      } else {
	        return compareIdentifiers(a, b);
	      }
	    } while (++i);
	  };

	  SemVer.prototype.inc = function (release, identifier) {
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier);
	        break;

	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier);
	        break;

	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier);
	        this.inc('pre', identifier);
	        break;

	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier);
	        }

	        this.inc('pre', identifier);
	        break;

	      case 'major':
	        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
	          this.major++;
	        }

	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }

	        this.patch = 0;
	        this.prerelease = [];
	        break;

	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }

	        this.prerelease = [];
	        break;

	      case 'pre':
	        if (this.prerelease.length === 0) {
	          this.prerelease = [0];
	        } else {
	          var i = this.prerelease.length;

	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }

	          if (i === -1) {
	            this.prerelease.push(0);
	          }
	        }

	        if (identifier) {
	          if (this.prerelease[0] === identifier) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = [identifier, 0];
	            }
	          } else {
	            this.prerelease = [identifier, 0];
	          }
	        }

	        break;

	      default:
	        throw new Error('invalid increment argument: ' + release);
	    }

	    this.format();
	    this.raw = this.version;
	    return this;
	  };

	  exports.inc = inc;

	  function inc(version, release, loose, identifier) {
	    if (typeof loose === 'string') {
	      identifier = loose;
	      loose = undefined;
	    }

	    try {
	      return new SemVer(version, loose).inc(release, identifier).version;
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.diff = diff;

	  function diff(version1, version2) {
	    if (eq(version1, version2)) {
	      return null;
	    } else {
	      var v1 = parse(version1);
	      var v2 = parse(version2);
	      var prefix = '';

	      if (v1.prerelease.length || v2.prerelease.length) {
	        prefix = 'pre';
	        var defaultResult = 'prerelease';
	      }

	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return prefix + key;
	          }
	        }
	      }

	      return defaultResult;
	    }
	  }

	  exports.compareIdentifiers = compareIdentifiers;
	  var numeric = /^[0-9]+$/;

	  function compareIdentifiers(a, b) {
	    var anum = numeric.test(a);
	    var bnum = numeric.test(b);

	    if (anum && bnum) {
	      a = +a;
	      b = +b;
	    }

	    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
	  }

	  exports.rcompareIdentifiers = rcompareIdentifiers;

	  function rcompareIdentifiers(a, b) {
	    return compareIdentifiers(b, a);
	  }

	  exports.major = major;

	  function major(a, loose) {
	    return new SemVer(a, loose).major;
	  }

	  exports.minor = minor;

	  function minor(a, loose) {
	    return new SemVer(a, loose).minor;
	  }

	  exports.patch = patch;

	  function patch(a, loose) {
	    return new SemVer(a, loose).patch;
	  }

	  exports.compare = compare;

	  function compare(a, b, loose) {
	    return new SemVer(a, loose).compare(new SemVer(b, loose));
	  }

	  exports.compareLoose = compareLoose;

	  function compareLoose(a, b) {
	    return compare(a, b, true);
	  }

	  exports.compareBuild = compareBuild;

	  function compareBuild(a, b, loose) {
	    var versionA = new SemVer(a, loose);
	    var versionB = new SemVer(b, loose);
	    return versionA.compare(versionB) || versionA.compareBuild(versionB);
	  }

	  exports.rcompare = rcompare;

	  function rcompare(a, b, loose) {
	    return compare(b, a, loose);
	  }

	  exports.sort = sort;

	  function sort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(a, b, loose);
	    });
	  }

	  exports.rsort = rsort;

	  function rsort(list, loose) {
	    return list.sort(function (a, b) {
	      return exports.compareBuild(b, a, loose);
	    });
	  }

	  exports.gt = gt;

	  function gt(a, b, loose) {
	    return compare(a, b, loose) > 0;
	  }

	  exports.lt = lt;

	  function lt(a, b, loose) {
	    return compare(a, b, loose) < 0;
	  }

	  exports.eq = eq;

	  function eq(a, b, loose) {
	    return compare(a, b, loose) === 0;
	  }

	  exports.neq = neq;

	  function neq(a, b, loose) {
	    return compare(a, b, loose) !== 0;
	  }

	  exports.gte = gte;

	  function gte(a, b, loose) {
	    return compare(a, b, loose) >= 0;
	  }

	  exports.lte = lte;

	  function lte(a, b, loose) {
	    return compare(a, b, loose) <= 0;
	  }

	  exports.cmp = cmp;

	  function cmp(a, op, b, loose) {
	    switch (op) {
	      case '===':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a === b;

	      case '!==':
	        if (typeof a === 'object') a = a.version;
	        if (typeof b === 'object') b = b.version;
	        return a !== b;

	      case '':
	      case '=':
	      case '==':
	        return eq(a, b, loose);

	      case '!=':
	        return neq(a, b, loose);

	      case '>':
	        return gt(a, b, loose);

	      case '>=':
	        return gte(a, b, loose);

	      case '<':
	        return lt(a, b, loose);

	      case '<=':
	        return lte(a, b, loose);

	      default:
	        throw new TypeError('Invalid operator: ' + op);
	    }
	  }

	  exports.Comparator = Comparator;

	  function Comparator(comp, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp;
	      } else {
	        comp = comp.value;
	      }
	    }

	    if (!(this instanceof Comparator)) {
	      return new Comparator(comp, options);
	    }

	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  var ANY = {};

	  Comparator.prototype.parse = function (comp) {
	    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var m = comp.match(r);

	    if (!m) {
	      throw new TypeError('Invalid comparator: ' + comp);
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';

	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  };

	  Comparator.prototype.toString = function () {
	    return this.value;
	  };

	  Comparator.prototype.test = function (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options);
	  };

	  Comparator.prototype.intersects = function (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required');
	    }

	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    var rangeTmp;

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(comp.value, options);
	      return satisfies(this.value, rangeTmp, options);
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true;
	      }

	      rangeTmp = new Range(this.value, options);
	      return satisfies(comp.semver, rangeTmp, options);
	    }

	    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
	    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
	    var sameSemVer = this.semver.version === comp.semver.version;
	    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
	    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
	    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
	    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
	  };

	  exports.Range = Range;

	  function Range(range, options) {
	    if (!options || typeof options !== 'object') {
	      options = {
	        loose: !!options,
	        includePrerelease: false
	      };
	    }

	    if (range instanceof Range) {
	      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
	        return range;
	      } else {
	        return new Range(range.raw, options);
	      }
	    }

	    if (range instanceof Comparator) {
	      return new Range(range.value, options);
	    }

	    if (!(this instanceof Range)) {
	      return new Range(range, options);
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    this.raw = range;
	    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
	      return this.parseRange(range.trim());
	    }, this).filter(function (c) {
	      return c.length;
	    });

	    if (!this.set.length) {
	      throw new TypeError('Invalid SemVer Range: ' + range);
	    }

	    this.format();
	  }

	  Range.prototype.format = function () {
	    this.range = this.set.map(function (comps) {
	      return comps.join(' ').trim();
	    }).join('||').trim();
	    return this.range;
	  };

	  Range.prototype.toString = function () {
	    return this.range;
	  };

	  Range.prototype.parseRange = function (range) {
	    var loose = this.options.loose;
	    range = range.trim();
	    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace);
	    debug('hyphen replace', range);
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range, re[t.COMPARATORTRIM]);
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    range = range.split(/\s+/).join(' ');
	    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    var set = range.split(' ').map(function (comp) {
	      return parseComparator(comp, this.options);
	    }, this).join(' ').split(/\s+/);

	    if (this.options.loose) {
	      set = set.filter(function (comp) {
	        return !!comp.match(compRe);
	      });
	    }

	    set = set.map(function (comp) {
	      return new Comparator(comp, this.options);
	    }, this);
	    return set;
	  };

	  Range.prototype.intersects = function (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required');
	    }

	    return this.set.some(function (thisComparators) {
	      return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
	        return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
	          return rangeComparators.every(function (rangeComparator) {
	            return thisComparator.intersects(rangeComparator, options);
	          });
	        });
	      });
	    });
	  };

	  function isSatisfiable(comparators, options) {
	    var result = true;
	    var remainingComparators = comparators.slice();
	    var testComparator = remainingComparators.pop();

	    while (result && remainingComparators.length) {
	      result = remainingComparators.every(function (otherComparator) {
	        return testComparator.intersects(otherComparator, options);
	      });
	      testComparator = remainingComparators.pop();
	    }

	    return result;
	  }

	  exports.toComparators = toComparators;

	  function toComparators(range, options) {
	    return new Range(range, options).set.map(function (comp) {
	      return comp.map(function (c) {
	        return c.value;
	      }).join(' ').trim().split(' ');
	    });
	  }

	  function parseComparator(comp, options) {
	    debug('comp', comp, options);
	    comp = replaceCarets(comp, options);
	    debug('caret', comp);
	    comp = replaceTildes(comp, options);
	    debug('tildes', comp);
	    comp = replaceXRanges(comp, options);
	    debug('xrange', comp);
	    comp = replaceStars(comp, options);
	    debug('stars', comp);
	    return comp;
	  }

	  function isX(id) {
	    return !id || id.toLowerCase() === 'x' || id === '*';
	  }

	  function replaceTildes(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceTilde(comp, options);
	    }).join(' ');
	  }

	  function replaceTilde(comp, options) {
	    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('tilde', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      } else if (pr) {
	        debug('replaceTilde pr', pr);
	        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	      } else {
	        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	      }

	      debug('tilde return', ret);
	      return ret;
	    });
	  }

	  function replaceCarets(comp, options) {
	    return comp.trim().split(/\s+/).map(function (comp) {
	      return replaceCaret(comp, options);
	    }).join(' ');
	  }

	  function replaceCaret(comp, options) {
	    debug('caret', comp, options);
	    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	    return comp.replace(r, function (_, M, m, p, pr) {
	      debug('caret', comp, _, M, m, p, pr);
	      var ret;

	      if (isX(M)) {
	        ret = '';
	      } else if (isX(m)) {
	        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	      } else if (isX(p)) {
	        if (M === '0') {
	          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	        } else {
	          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	        }
	      } else if (pr) {
	        debug('replaceCaret pr', pr);

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
	        }
	      } else {
	        debug('no pr');

	        if (M === '0') {
	          if (m === '0') {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
	          } else {
	            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
	          }
	        } else {
	          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
	        }
	      }

	      debug('caret return', ret);
	      return ret;
	    });
	  }

	  function replaceXRanges(comp, options) {
	    debug('replaceXRanges', comp, options);
	    return comp.split(/\s+/).map(function (comp) {
	      return replaceXRange(comp, options);
	    }).join(' ');
	  }

	  function replaceXRange(comp, options) {
	    comp = comp.trim();
	    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
	      debug('xRange', comp, ret, gtlt, M, m, p, pr);
	      var xM = isX(M);
	      var xm = xM || isX(m);
	      var xp = xm || isX(p);
	      var anyX = xp;

	      if (gtlt === '=' && anyX) {
	        gtlt = '';
	      }

	      pr = options.includePrerelease ? '-0' : '';

	      if (xM) {
	        if (gtlt === '>' || gtlt === '<') {
	          ret = '<0.0.0-0';
	        } else {
	          ret = '*';
	        }
	      } else if (gtlt && anyX) {
	        if (xm) {
	          m = 0;
	        }

	        p = 0;

	        if (gtlt === '>') {
	          gtlt = '>=';

	          if (xm) {
	            M = +M + 1;
	            m = 0;
	            p = 0;
	          } else {
	            m = +m + 1;
	            p = 0;
	          }
	        } else if (gtlt === '<=') {
	          gtlt = '<';

	          if (xm) {
	            M = +M + 1;
	          } else {
	            m = +m + 1;
	          }
	        }

	        ret = gtlt + M + '.' + m + '.' + p + pr;
	      } else if (xm) {
	        ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
	      } else if (xp) {
	        ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
	      }

	      debug('xRange return', ret);
	      return ret;
	    });
	  }

	  function replaceStars(comp, options) {
	    debug('replaceStars', comp, options);
	    return comp.trim().replace(re[t.STAR], '');
	  }

	  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
	    if (isX(fM)) {
	      from = '';
	    } else if (isX(fm)) {
	      from = '>=' + fM + '.0.0';
	    } else if (isX(fp)) {
	      from = '>=' + fM + '.' + fm + '.0';
	    } else {
	      from = '>=' + from;
	    }

	    if (isX(tM)) {
	      to = '';
	    } else if (isX(tm)) {
	      to = '<' + (+tM + 1) + '.0.0';
	    } else if (isX(tp)) {
	      to = '<' + tM + '.' + (+tm + 1) + '.0';
	    } else if (tpr) {
	      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	    } else {
	      to = '<=' + to;
	    }

	    return (from + ' ' + to).trim();
	  }

	  Range.prototype.test = function (version) {
	    if (!version) {
	      return false;
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false;
	      }
	    }

	    for (var i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true;
	      }
	    }

	    return false;
	  };

	  function testSet(set, version, options) {
	    for (var i = 0; i < set.length; i++) {
	      if (!set[i].test(version)) {
	        return false;
	      }
	    }

	    if (version.prerelease.length && !options.includePrerelease) {
	      for (i = 0; i < set.length; i++) {
	        debug(set[i].semver);

	        if (set[i].semver === ANY) {
	          continue;
	        }

	        if (set[i].semver.prerelease.length > 0) {
	          var allowed = set[i].semver;

	          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
	            return true;
	          }
	        }
	      }

	      return false;
	    }

	    return true;
	  }

	  exports.satisfies = satisfies;

	  function satisfies(version, range, options) {
	    try {
	      range = new Range(range, options);
	    } catch (er) {
	      return false;
	    }

	    return range.test(version);
	  }

	  exports.maxSatisfying = maxSatisfying;

	  function maxSatisfying(versions, range, options) {
	    var max = null;
	    var maxSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!max || maxSV.compare(v) === -1) {
	          max = v;
	          maxSV = new SemVer(max, options);
	        }
	      }
	    });
	    return max;
	  }

	  exports.minSatisfying = minSatisfying;

	  function minSatisfying(versions, range, options) {
	    var min = null;
	    var minSV = null;

	    try {
	      var rangeObj = new Range(range, options);
	    } catch (er) {
	      return null;
	    }

	    versions.forEach(function (v) {
	      if (rangeObj.test(v)) {
	        if (!min || minSV.compare(v) === 1) {
	          min = v;
	          minSV = new SemVer(min, options);
	        }
	      }
	    });
	    return min;
	  }

	  exports.minVersion = minVersion;

	  function minVersion(range, loose) {
	    range = new Range(range, loose);
	    var minver = new SemVer('0.0.0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = new SemVer('0.0.0-0');

	    if (range.test(minver)) {
	      return minver;
	    }

	    minver = null;

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      comparators.forEach(function (comparator) {
	        var compver = new SemVer(comparator.semver.version);

	        switch (comparator.operator) {
	          case '>':
	            if (compver.prerelease.length === 0) {
	              compver.patch++;
	            } else {
	              compver.prerelease.push(0);
	            }

	            compver.raw = compver.format();

	          case '':
	          case '>=':
	            if (!minver || gt(minver, compver)) {
	              minver = compver;
	            }

	            break;

	          case '<':
	          case '<=':
	            break;

	          default:
	            throw new Error('Unexpected operation: ' + comparator.operator);
	        }
	      });
	    }

	    if (minver && range.test(minver)) {
	      return minver;
	    }

	    return null;
	  }

	  exports.validRange = validRange;

	  function validRange(range, options) {
	    try {
	      return new Range(range, options).range || '*';
	    } catch (er) {
	      return null;
	    }
	  }

	  exports.ltr = ltr;

	  function ltr(version, range, options) {
	    return outside(version, range, '<', options);
	  }

	  exports.gtr = gtr;

	  function gtr(version, range, options) {
	    return outside(version, range, '>', options);
	  }

	  exports.outside = outside;

	  function outside(version, range, hilo, options) {
	    version = new SemVer(version, options);
	    range = new Range(range, options);
	    var gtfn, ltefn, ltfn, comp, ecomp;

	    switch (hilo) {
	      case '>':
	        gtfn = gt;
	        ltefn = lte;
	        ltfn = lt;
	        comp = '>';
	        ecomp = '>=';
	        break;

	      case '<':
	        gtfn = lt;
	        ltefn = gte;
	        ltfn = gt;
	        comp = '<';
	        ecomp = '<=';
	        break;

	      default:
	        throw new TypeError('Must provide a hilo val of "<" or ">"');
	    }

	    if (satisfies(version, range, options)) {
	      return false;
	    }

	    for (var i = 0; i < range.set.length; ++i) {
	      var comparators = range.set[i];
	      var high = null;
	      var low = null;
	      comparators.forEach(function (comparator) {
	        if (comparator.semver === ANY) {
	          comparator = new Comparator('>=0.0.0');
	        }

	        high = high || comparator;
	        low = low || comparator;

	        if (gtfn(comparator.semver, high.semver, options)) {
	          high = comparator;
	        } else if (ltfn(comparator.semver, low.semver, options)) {
	          low = comparator;
	        }
	      });

	      if (high.operator === comp || high.operator === ecomp) {
	        return false;
	      }

	      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
	        return false;
	      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  exports.prerelease = prerelease;

	  function prerelease(version, options) {
	    var parsed = parse(version, options);
	    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	  }

	  exports.intersects = intersects;

	  function intersects(r1, r2, options) {
	    r1 = new Range(r1, options);
	    r2 = new Range(r2, options);
	    return r1.intersects(r2);
	  }

	  exports.coerce = coerce;

	  function coerce(version, options) {
	    if (version instanceof SemVer) {
	      return version;
	    }

	    if (typeof version === 'number') {
	      version = String(version);
	    }

	    if (typeof version !== 'string') {
	      return null;
	    }

	    options = options || {};
	    var match = null;

	    if (!options.rtl) {
	      match = version.match(re[t.COERCE]);
	    } else {
	      var next;

	      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
	        if (!match || next.index + next[0].length !== match.index + match[0].length) {
	          match = next;
	        }

	        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
	      }

	      re[t.COERCERTL].lastIndex = -1;
	    }

	    if (match === null) {
	      return null;
	    }

	    return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
	  }
	}, "/$$rollup_base$$/packages/babel-preset-env/node_modules/babel-plugin-polyfill-corejs2/node_modules/semver");

	var _excluded = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];

	var _templateObject, _templateObject2, _templateObject3;

	var _ref$2 = undefined || babel,
	    t$1$1 = _ref$2.types,
	    template = _ref$2.template;

	function intersection(a, b) {
	  var result = new Set();
	  a.forEach(function (v) {
	    return b.has(v) && result.add(v);
	  });
	  return result;
	}

	function has$1(object, key) {
	  return Object.prototype.hasOwnProperty.call(object, key);
	}

	function getType(target) {
	  return Object.prototype.toString.call(target).slice(8, -1);
	}

	function resolveId(path) {
	  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, true)) {
	    return path.node.name;
	  }

	  var _path$evaluate = path.evaluate(),
	      deopt = _path$evaluate.deopt;

	  if (deopt && deopt.isIdentifier()) {
	    return deopt.node.name;
	  }
	}

	function resolveKey(path, computed) {
	  if (computed === void 0) {
	    computed = false;
	  }

	  var node = path.node,
	      parent = path.parent,
	      scope = path.scope;
	  if (path.isStringLiteral()) return node.value;
	  var name = node.name;
	  var isIdentifier = path.isIdentifier();
	  if (isIdentifier && !(computed || parent.computed)) return name;

	  if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
	    name: "Symbol"
	  }) && !scope.hasBinding("Symbol", true)) {
	    var sym = resolveKey(path.get("property"), path.node.computed);
	    if (sym) return "Symbol." + sym;
	  }

	  if (!isIdentifier || scope.hasBinding(name, true)) {
	    var _path$evaluate2 = path.evaluate(),
	        value = _path$evaluate2.value;

	    if (typeof value === "string") return value;
	  }
	}

	function resolveSource(obj) {
	  if (obj.isMemberExpression() && obj.get("property").isIdentifier({
	    name: "prototype"
	  })) {
	    var _id = resolveId(obj.get("object"));

	    if (_id) {
	      return {
	        id: _id,
	        placement: "prototype"
	      };
	    }

	    return {
	      id: null,
	      placement: null
	    };
	  }

	  var id = resolveId(obj);

	  if (id) {
	    return {
	      id: id,
	      placement: "static"
	    };
	  }

	  var _obj$evaluate = obj.evaluate(),
	      value = _obj$evaluate.value;

	  if (value !== undefined) {
	    return {
	      id: getType(value),
	      placement: "prototype"
	    };
	  } else if (obj.isRegExpLiteral()) {
	    return {
	      id: "RegExp",
	      placement: "prototype"
	    };
	  } else if (obj.isFunction()) {
	    return {
	      id: "Function",
	      placement: "prototype"
	    };
	  }

	  return {
	    id: null,
	    placement: null
	  };
	}

	function getImportSource(_ref2) {
	  var node = _ref2.node;
	  if (node.specifiers.length === 0) return node.source.value;
	}

	function getRequireSource(_ref3) {
	  var node = _ref3.node;
	  if (!t$1$1.isExpressionStatement(node)) return;
	  var expression = node.expression;
	  var isRequire = t$1$1.isCallExpression(expression) && t$1$1.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t$1$1.isStringLiteral(expression.arguments[0]);
	  if (isRequire) return expression.arguments[0].value;
	}

	function hoist(node) {
	  node._blockHoist = 3;
	  return node;
	}

	function createUtilsGetter(cache) {
	  return function (path) {
	    var prog = path.findParent(function (p) {
	      return p.isProgram();
	    });
	    return {
	      injectGlobalImport: function injectGlobalImport(url) {
	        cache.storeAnonymous(prog, url, function (isScript, source) {
	          return isScript ? template.statement.ast(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["require(", ")"])), source) : t$1$1.importDeclaration([], source);
	        });
	      },
	      injectNamedImport: function injectNamedImport(url, name, hint) {
	        if (hint === void 0) {
	          hint = name;
	        }

	        return cache.storeNamed(prog, url, name, function (isScript, source, name) {
	          var id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist(template.statement.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n                  var ", " = require(", ").", "\n                "])), id, source, name)) : t$1$1.importDeclaration([t$1$1.importSpecifier(id, name)], source),
	            name: id.name
	          };
	        });
	      },
	      injectDefaultImport: function injectDefaultImport(url, hint) {
	        if (hint === void 0) {
	          hint = url;
	        }

	        return cache.storeNamed(prog, url, "default", function (isScript, source) {
	          var id = prog.scope.generateUidIdentifier(hint);
	          return {
	            node: isScript ? hoist(template.statement.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["var ", " = require(", ")"])), id, source)) : t$1$1.importDeclaration([t$1$1.importDefaultSpecifier(id)], source),
	            name: id.name
	          };
	        });
	      }
	    };
	  };
	}

	var _ref4 = undefined || babel,
	    t$3 = _ref4.types;

	var ImportsCache = function () {
	  function ImportsCache(resolver) {
	    this._imports = new WeakMap();
	    this._anonymousImports = new WeakMap();
	    this._lastImports = new WeakMap();
	    this._resolver = resolver;
	  }

	  var _proto = ImportsCache.prototype;

	  _proto.storeAnonymous = function storeAnonymous(programPath, url, getVal) {
	    var key = this._normalizeKey(programPath, url);

	    var imports = this._ensure(this._anonymousImports, programPath, Set);

	    if (imports.has(key)) return;
	    var node = getVal(programPath.node.sourceType === "script", t$3.stringLiteral(this._resolver(url)));
	    imports.add(key);

	    this._injectImport(programPath, node);
	  };

	  _proto.storeNamed = function storeNamed(programPath, url, name, getVal) {
	    var key = this._normalizeKey(programPath, url, name);

	    var imports = this._ensure(this._imports, programPath, Map);

	    if (!imports.has(key)) {
	      var _getVal = getVal(programPath.node.sourceType === "script", t$3.stringLiteral(this._resolver(url)), t$3.identifier(name)),
	          node = _getVal.node,
	          id = _getVal.name;

	      imports.set(key, id);

	      this._injectImport(programPath, node);
	    }

	    return t$3.identifier(imports.get(key));
	  };

	  _proto._injectImport = function _injectImport(programPath, node) {
	    var lastImport = this._lastImports.get(programPath);

	    if (lastImport && lastImport.node && lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {
	      lastImport = lastImport.insertAfter(node);
	    } else {
	      lastImport = programPath.unshiftContainer("body", node);
	    }

	    lastImport = lastImport[lastImport.length - 1];

	    this._lastImports.set(programPath, lastImport);
	  };

	  _proto._ensure = function _ensure(map, programPath, Collection) {
	    var collection = map.get(programPath);

	    if (!collection) {
	      collection = new Collection();
	      map.set(programPath, collection);
	    }

	    return collection;
	  };

	  _proto._normalizeKey = function _normalizeKey(programPath, url, name) {
	    if (name === void 0) {
	      name = "";
	    }

	    var sourceType = programPath.node.sourceType;
	    return (name && sourceType) + "::" + url + "::" + name;
	  };

	  return ImportsCache;
	}();

	var presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";

	function stringifyTargetsMultiline(targets) {
	  return JSON.stringify(prettifyTargets(targets), null, 2);
	}

	function patternToRegExp(pattern) {
	  if (pattern instanceof RegExp) return pattern;

	  try {
	    return new RegExp("^" + pattern + "$");
	  } catch (_unused) {
	    return null;
	  }
	}

	function buildUnusedError(label, unused) {
	  if (!unused.length) return "";
	  return "  - The following \"" + label + "\" patterns didn't match any polyfill:\n" + unused.map(function (original) {
	    return "    " + String(original) + "\n";
	  }).join("");
	}

	function buldDuplicatesError(duplicates) {
	  if (!duplicates.size) return "";
	  return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
	    return "    " + name + "\n";
	  }).join("");
	}

	function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
	  var current;

	  var filter = function filter(pattern) {
	    var regexp = patternToRegExp(pattern);
	    if (!regexp) return false;
	    var matched = false;

	    for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
	      var polyfill = _step.value;

	      if (regexp.test(polyfill)) {
	        matched = true;
	        current.add(polyfill);
	      }
	    }

	    return !matched;
	  };

	  var include = current = new Set();
	  var unusedInclude = Array.from(includePatterns).filter(filter);
	  var exclude = current = new Set();
	  var unusedExclude = Array.from(excludePatterns).filter(filter);
	  var duplicates = intersection(include, exclude);

	  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
	    throw new Error("Error while validating the \"" + provider + "\" provider options:\n" + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
	  }

	  return {
	    include: include,
	    exclude: exclude
	  };
	}

	function applyMissingDependenciesDefaults(options, babelApi) {
	  var _options$missingDepen = options.missingDependencies,
	      missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
	  if (missingDependencies === false) return false;
	  var caller = babelApi.caller(function (caller) {
	    return caller == null ? void 0 : caller.name;
	  });
	  var _missingDependencies$ = missingDependencies.log,
	      log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
	      _missingDependencies$2 = missingDependencies.inject,
	      inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
	      _missingDependencies$3 = missingDependencies.all,
	      all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
	  return {
	    log: log,
	    inject: inject,
	    all: all
	  };
	}

	var usage = function usage(callProvider) {
	  function property(object, key, placement, path) {
	    return callProvider({
	      kind: "property",
	      object: object,
	      key: key,
	      placement: placement
	    }, path);
	  }

	  return {
	    ReferencedIdentifier: function ReferencedIdentifier(path) {
	      var name = path.node.name,
	          scope = path.scope;
	      if (scope.getBindingIdentifier(name)) return;
	      callProvider({
	        kind: "global",
	        name: name
	      }, path);
	    },
	    MemberExpression: function MemberExpression(path) {
	      var key = resolveKey(path.get("property"), path.node.computed);
	      if (!key || key === "prototype") return;
	      var object = path.get("object");
	      var binding = object.scope.getBinding(object.node.name);
	      if (binding && binding.path.isImportNamespaceSpecifier()) return;
	      var source = resolveSource(object);
	      return property(source.id, key, source.placement, path);
	    },
	    ObjectPattern: function ObjectPattern(path) {
	      var parentPath = path.parentPath,
	          parent = path.parent;
	      var obj;

	      if (parentPath.isVariableDeclarator()) {
	        obj = parentPath.get("init");
	      } else if (parentPath.isAssignmentExpression()) {
	        obj = parentPath.get("right");
	      } else if (parentPath.isFunction()) {
	        var grand = parentPath.parentPath;

	        if (grand.isCallExpression() || grand.isNewExpression()) {
	          if (grand.node.callee === parent) {
	            obj = grand.get("arguments")[path.key];
	          }
	        }
	      }

	      var id = null;
	      var placement = null;

	      if (obj) {
	        var _resolveSource = resolveSource(obj);

	        id = _resolveSource.id;
	        placement = _resolveSource.placement;
	      }

	      for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
	        var prop = _step2.value;

	        if (prop.isObjectProperty()) {
	          var key = resolveKey(prop.get("key"));
	          if (key) property(id, key, placement, prop);
	        }
	      }
	    },
	    BinaryExpression: function BinaryExpression(path) {
	      if (path.node.operator !== "in") return;
	      var source = resolveSource(path.get("right"));
	      var key = resolveKey(path.get("left"), true);
	      if (!key) return;
	      callProvider({
	        kind: "in",
	        object: source.id,
	        key: key,
	        placement: source.placement
	      }, path);
	    }
	  };
	};

	var entry = function entry(callProvider) {
	  return {
	    ImportDeclaration: function ImportDeclaration(path) {
	      var source = getImportSource(path);
	      if (!source) return;
	      callProvider({
	        kind: "import",
	        source: source
	      }, path);
	    },
	    Program: function Program(path) {
	      path.get("body").forEach(function (bodyPath) {
	        var source = getRequireSource(bodyPath);
	        if (!source) return;
	        callProvider({
	          kind: "import",
	          source: source
	        }, bodyPath);
	      });
	    }
	  };
	};

	function resolve(dirname, moduleName, absoluteImports) {
	  if (absoluteImports === false) return moduleName;
	  throw new Error("\"absoluteImports\" is not supported in bundles prepared for the browser.");
	}

	function has$2(basedir, name) {
	  return true;
	}

	function logMissing(missingDeps) {}

	function laterLogMissing(missingDeps) {}

	var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);

	function createMetaResolver(polyfills) {
	  var staticP = polyfills["static"],
	      instanceP = polyfills.instance,
	      globalP = polyfills.global;
	  return function (meta) {
	    if (meta.kind === "global" && globalP && has$1(globalP, meta.name)) {
	      return {
	        kind: "global",
	        desc: globalP[meta.name],
	        name: meta.name
	      };
	    }

	    if (meta.kind === "property" || meta.kind === "in") {
	      var placement = meta.placement,
	          object = meta.object,
	          key = meta.key;

	      if (object && placement === "static") {
	        if (globalP && PossibleGlobalObjects.has(object) && has$1(globalP, key)) {
	          return {
	            kind: "global",
	            desc: globalP[key],
	            name: key
	          };
	        }

	        if (staticP && has$1(staticP, object) && has$1(staticP[object], key)) {
	          return {
	            kind: "static",
	            desc: staticP[object][key],
	            name: object + "$" + key
	          };
	        }
	      }

	      if (instanceP && has$1(instanceP, key)) {
	        return {
	          kind: "instance",
	          desc: instanceP[key],
	          name: "" + key
	        };
	      }
	    }
	  };
	}

	var getTargets = getTargets$2["default"] || getTargets$2;

	function resolveOptions(options, babelApi) {
	  var method = options.method,
	      targetsOption = options.targets,
	      ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
	      configPath = options.configPath,
	      debug = options.debug,
	      shouldInjectPolyfill = options.shouldInjectPolyfill,
	      absoluteImports = options.absoluteImports,
	      providerOptions = _objectWithoutProperties(options, _excluded);

	  var methodName;
	  if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
	    throw new Error(".method must be a string");
	  } else {
	    throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + (" or \"usage-pure\" (received " + JSON.stringify(method) + ")"));
	  }

	  if (typeof shouldInjectPolyfill === "function") {
	    if (options.include || options.exclude) {
	      throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
	    }
	  } else if (shouldInjectPolyfill != null) {
	    throw new Error(".shouldInjectPolyfill must be a function, or undefined" + (" (received " + JSON.stringify(shouldInjectPolyfill) + ")"));
	  }

	  if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
	    throw new Error(".absoluteImports must be a boolean, a string, or undefined" + (" (received " + JSON.stringify(absoluteImports) + ")"));
	  }

	  var targets;

	  if (targetsOption || configPath || ignoreBrowserslistConfig) {
	    var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
	      browsers: targetsOption
	    } : targetsOption;
	    targets = getTargets(targetsObj, {
	      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
	      configPath: configPath
	    });
	  } else {
	    targets = babelApi.targets();
	  }

	  return {
	    method: method,
	    methodName: methodName,
	    targets: targets,
	    absoluteImports: absoluteImports != null ? absoluteImports : false,
	    shouldInjectPolyfill: shouldInjectPolyfill,
	    debug: !!debug,
	    providerOptions: providerOptions
	  };
	}

	function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
	  var _resolveOptions = resolveOptions(options, babelApi),
	      method = _resolveOptions.method,
	      methodName = _resolveOptions.methodName,
	      targets = _resolveOptions.targets,
	      _debug = _resolveOptions.debug,
	      _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
	      providerOptions = _resolveOptions.providerOptions,
	      absoluteImports = _resolveOptions.absoluteImports;

	  var getUtils = createUtilsGetter(new ImportsCache(function (moduleName) {
	    return resolve(dirname, moduleName, absoluteImports);
	  }));
	  var include, exclude;
	  var polyfillsSupport;
	  var polyfillsNames;
	  var filterPolyfills;
	  var depsCache = new Map();
	  var api = {
	    babel: babelApi,
	    getUtils: getUtils,
	    method: options.method,
	    targets: targets,
	    createMetaResolver: createMetaResolver,
	    shouldInjectPolyfill: function shouldInjectPolyfill(name) {
	      if (polyfillsNames === undefined) {
	        throw new Error("Internal error in the " + factory.name + " provider: " + "shouldInjectPolyfill() can't be called during initialization.");
	      }

	      if (!polyfillsNames.has(name)) {
	        console.warn("Internal error in the " + provider.name + " provider: " + ("unknown polyfill \"" + name + "\"."));
	      }

	      if (filterPolyfills && !filterPolyfills(name)) return false;
	      var shouldInject = isRequired(name, targets, {
	        compatData: polyfillsSupport,
	        includes: include,
	        excludes: exclude
	      });

	      if (_shouldInjectPolyfill) {
	        shouldInject = _shouldInjectPolyfill(name, shouldInject);

	        if (typeof shouldInject !== "boolean") {
	          throw new Error(".shouldInjectPolyfill must return a boolean.");
	        }
	      }

	      return shouldInject;
	    },
	    debug: function debug(name) {
	      debugLog().found = true;
	      if (!_debug || !name) return;
	      if (debugLog().polyfills.has(provider.name)) return;
	      debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);
	    },
	    assertDependency: function assertDependency(name, version) {
	      if (version === void 0) {
	        version = "*";
	      }

	      if (missingDependencies === false) return;

	      if (absoluteImports) {
	        return;
	      }

	      var dep = version === "*" ? name : name + "@^" + version;
	      var found = missingDependencies.all ? false : mapGetOr(depsCache, name + " :: " + dirname, function () {
	        return has$2();
	      });

	      if (!found) {
	        debugLog().missingDeps.add(dep);
	      }
	    }
	  };
	  var provider = factory(api, providerOptions, dirname);

	  if (typeof provider[methodName] !== "function") {
	    throw new Error("The \"" + (provider.name || factory.name) + "\" provider doesn't " + ("support the \"" + method + "\" polyfilling method."));
	  }

	  if (Array.isArray(provider.polyfills)) {
	    polyfillsNames = new Set(provider.polyfills);
	    filterPolyfills = provider.filterPolyfills;
	  } else if (provider.polyfills) {
	    polyfillsNames = new Set(Object.keys(provider.polyfills));
	    polyfillsSupport = provider.polyfills;
	    filterPolyfills = provider.filterPolyfills;
	  } else {
	    polyfillsNames = new Set();
	  }

	  var _validateIncludeExclu = validateIncludeExclude(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);

	  include = _validateIncludeExclu.include;
	  exclude = _validateIncludeExclu.exclude;
	  return {
	    debug: _debug,
	    method: method,
	    targets: targets,
	    provider: provider,
	    callProvider: function callProvider(payload, path) {
	      var utils = getUtils(path);
	      provider[methodName](payload, utils, path);
	    }
	  };
	}

	function definePolyfillProvider(factory) {
	  return declare(function (babelApi, options, dirname) {
	    babelApi.assertVersion(7);
	    var traverse = babelApi.traverse;
	    var debugLog;
	    var missingDependencies = applyMissingDependenciesDefaults(options, babelApi);

	    var _instantiateProvider = instantiateProvider(factory, options, missingDependencies, dirname, function () {
	      return debugLog;
	    }, babelApi),
	        debug = _instantiateProvider.debug,
	        method = _instantiateProvider.method,
	        targets = _instantiateProvider.targets,
	        provider = _instantiateProvider.provider,
	        callProvider = _instantiateProvider.callProvider;

	    var createVisitor = method === "entry-global" ? entry : usage;
	    var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);

	    if (debug && debug !== presetEnvSilentDebugHeader) {
	      console.log(provider.name + ": `DEBUG` option");
	      console.log("\nUsing targets: " + stringifyTargetsMultiline(targets));
	      console.log("\nUsing polyfills with `" + method + "` method:");
	    }

	    return {
	      name: "inject-polyfills",
	      visitor: visitor,
	      pre: function pre() {
	        var _provider$pre;

	        debugLog = {
	          polyfills: new Map(),
	          found: false,
	          providers: new Set(),
	          missingDeps: new Set()
	        };
	        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
	      },
	      post: function post() {
	        var _provider$post;

	        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);

	        if (missingDependencies !== false) {
	          if (missingDependencies.log === "per-file") {
	            logMissing(debugLog.missingDeps);
	          } else {
	            laterLogMissing(debugLog.missingDeps);
	          }
	        }

	        if (!debug) return;
	        if (this.filename) console.log("\n[" + this.filename + "]");

	        if (debugLog.polyfills.size === 0) {
	          console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the " + provider.name + " polyfill did not add any polyfill." : "The entry point for the " + provider.name + " polyfill has not been found." : "Based on your code and targets, the " + provider.name + " polyfill did not add any polyfill.");
	          return;
	        }

	        if (method === "entry-global") {
	          console.log("The " + provider.name + " polyfill entry has been replaced with " + "the following polyfills:");
	        } else {
	          console.log("The " + provider.name + " polyfill added the following polyfills:");
	        }

	        for (var _iterator3 = _createForOfIteratorHelperLoose(debugLog.polyfills), _step3; !(_step3 = _iterator3()).done;) {
	          var _step3$value = _slicedToArray$1(_step3.value, 2),
	              name = _step3$value[0],
	              support = _step3$value[1];

	          if (support) {
	            var filteredTargets = getInclusionReasons(name, targets, support);
	            var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
	            console.log("  " + name + " " + formattedTargets);
	          } else {
	            console.log("  " + name);
	          }
	        }
	      }
	    };
	  });
	}

	function mapGetOr(map, key, getDefault) {
	  var val = map.get(key);

	  if (val === undefined) {
	    val = getDefault();
	    map.set(key, val);
	  }

	  return val;
	}

	var define$1 = function define(name, pure, global, meta) {
	  if (global === void 0) {
	    global = [];
	  }

	  return {
	    name: name,
	    pure: pure,
	    global: global,
	    meta: meta
	  };
	};

	var pureAndGlobal = function pureAndGlobal(pure, global, minRuntimeVersion) {
	  if (minRuntimeVersion === void 0) {
	    minRuntimeVersion = null;
	  }

	  return define$1(global[0], pure, global, {
	    minRuntimeVersion: minRuntimeVersion
	  });
	};

	var globalOnly = function globalOnly(global) {
	  return define$1(global[0], null, global);
	};

	var pureOnly = function pureOnly(pure, name) {
	  return define$1(name, pure, []);
	};

	var ArrayNatureIterators$1 = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
	var CommonIterators$1 = ["es6.string.iterator"].concat(ArrayNatureIterators$1);
	var PromiseDependencies$1 = ["es6.object.to-string", "es6.promise"];
	var BuiltIns$1 = {
	  DataView: globalOnly(["es6.typed.data-view"]),
	  Float32Array: globalOnly(["es6.typed.float32-array"]),
	  Float64Array: globalOnly(["es6.typed.float64-array"]),
	  Int8Array: globalOnly(["es6.typed.int8-array"]),
	  Int16Array: globalOnly(["es6.typed.int16-array"]),
	  Int32Array: globalOnly(["es6.typed.int32-array"]),
	  Map: pureAndGlobal("map", ["es6.map"].concat(_toConsumableArray(CommonIterators$1))),
	  Number: globalOnly(["es6.number.constructor"]),
	  Promise: pureAndGlobal("promise", PromiseDependencies$1),
	  RegExp: globalOnly(["es6.regexp.constructor"]),
	  Set: pureAndGlobal("set", ["es6.set"].concat(_toConsumableArray(CommonIterators$1))),
	  Symbol: pureAndGlobal("symbol", ["es6.symbol"]),
	  Uint8Array: globalOnly(["es6.typed.uint8-array"]),
	  Uint8ClampedArray: globalOnly(["es6.typed.uint8-clamped-array"]),
	  Uint16Array: globalOnly(["es6.typed.uint16-array"]),
	  Uint32Array: globalOnly(["es6.typed.uint32-array"]),
	  WeakMap: pureAndGlobal("weak-map", ["es6.weak-map"].concat(_toConsumableArray(CommonIterators$1))),
	  WeakSet: pureAndGlobal("weak-set", ["es6.weak-set"].concat(_toConsumableArray(CommonIterators$1))),
	  setImmediate: pureOnly("set-immediate", "web.immediate"),
	  clearImmediate: pureOnly("clear-immediate", "web.immediate"),
	  parseFloat: pureOnly("parse-float", "es6.parse-float"),
	  parseInt: pureOnly("parse-int", "es6.parse-int")
	};
	var InstanceProperties$1 = {
	  __defineGetter__: globalOnly(["es7.object.define-getter"]),
	  __defineSetter__: globalOnly(["es7.object.define-setter"]),
	  __lookupGetter__: globalOnly(["es7.object.lookup-getter"]),
	  __lookupSetter__: globalOnly(["es7.object.lookup-setter"]),
	  anchor: globalOnly(["es6.string.anchor"]),
	  big: globalOnly(["es6.string.big"]),
	  bind: globalOnly(["es6.function.bind"]),
	  blink: globalOnly(["es6.string.blink"]),
	  bold: globalOnly(["es6.string.bold"]),
	  codePointAt: globalOnly(["es6.string.code-point-at"]),
	  copyWithin: globalOnly(["es6.array.copy-within"]),
	  endsWith: globalOnly(["es6.string.ends-with"]),
	  entries: globalOnly(ArrayNatureIterators$1),
	  every: globalOnly(["es6.array.every"]),
	  fill: globalOnly(["es6.array.fill"]),
	  filter: globalOnly(["es6.array.filter"]),
	  "finally": globalOnly(["es7.promise.finally"].concat(PromiseDependencies$1)),
	  find: globalOnly(["es6.array.find"]),
	  findIndex: globalOnly(["es6.array.find-index"]),
	  fixed: globalOnly(["es6.string.fixed"]),
	  flags: globalOnly(["es6.regexp.flags"]),
	  flatMap: globalOnly(["es7.array.flat-map"]),
	  fontcolor: globalOnly(["es6.string.fontcolor"]),
	  fontsize: globalOnly(["es6.string.fontsize"]),
	  forEach: globalOnly(["es6.array.for-each"]),
	  includes: globalOnly(["es6.string.includes", "es7.array.includes"]),
	  indexOf: globalOnly(["es6.array.index-of"]),
	  italics: globalOnly(["es6.string.italics"]),
	  keys: globalOnly(ArrayNatureIterators$1),
	  lastIndexOf: globalOnly(["es6.array.last-index-of"]),
	  link: globalOnly(["es6.string.link"]),
	  map: globalOnly(["es6.array.map"]),
	  match: globalOnly(["es6.regexp.match"]),
	  name: globalOnly(["es6.function.name"]),
	  padStart: globalOnly(["es7.string.pad-start"]),
	  padEnd: globalOnly(["es7.string.pad-end"]),
	  reduce: globalOnly(["es6.array.reduce"]),
	  reduceRight: globalOnly(["es6.array.reduce-right"]),
	  repeat: globalOnly(["es6.string.repeat"]),
	  replace: globalOnly(["es6.regexp.replace"]),
	  search: globalOnly(["es6.regexp.search"]),
	  small: globalOnly(["es6.string.small"]),
	  some: globalOnly(["es6.array.some"]),
	  sort: globalOnly(["es6.array.sort"]),
	  split: globalOnly(["es6.regexp.split"]),
	  startsWith: globalOnly(["es6.string.starts-with"]),
	  strike: globalOnly(["es6.string.strike"]),
	  sub: globalOnly(["es6.string.sub"]),
	  sup: globalOnly(["es6.string.sup"]),
	  toISOString: globalOnly(["es6.date.to-iso-string"]),
	  toJSON: globalOnly(["es6.date.to-json"]),
	  toString: globalOnly(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
	  trim: globalOnly(["es6.string.trim"]),
	  trimEnd: globalOnly(["es7.string.trim-right"]),
	  trimLeft: globalOnly(["es7.string.trim-left"]),
	  trimRight: globalOnly(["es7.string.trim-right"]),
	  trimStart: globalOnly(["es7.string.trim-left"]),
	  values: globalOnly(ArrayNatureIterators$1)
	};

	if ("es6.array.slice" in corejs2BuiltIns) {
	  InstanceProperties$1.slice = globalOnly(["es6.array.slice"]);
	}

	var StaticProperties$1 = {
	  Array: {
	    from: pureAndGlobal("array/from", ["es6.symbol", "es6.array.from"].concat(_toConsumableArray(CommonIterators$1))),
	    isArray: pureAndGlobal("array/is-array", ["es6.array.is-array"]),
	    of: pureAndGlobal("array/of", ["es6.array.of"])
	  },
	  Date: {
	    now: pureAndGlobal("date/now", ["es6.date.now"])
	  },
	  JSON: {
	    stringify: pureOnly("json/stringify", "es6.symbol")
	  },
	  Math: {
	    acosh: pureAndGlobal("math/acosh", ["es6.math.acosh"], "7.0.1"),
	    asinh: pureAndGlobal("math/asinh", ["es6.math.asinh"], "7.0.1"),
	    atanh: pureAndGlobal("math/atanh", ["es6.math.atanh"], "7.0.1"),
	    cbrt: pureAndGlobal("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
	    clz32: pureAndGlobal("math/clz32", ["es6.math.clz32"], "7.0.1"),
	    cosh: pureAndGlobal("math/cosh", ["es6.math.cosh"], "7.0.1"),
	    expm1: pureAndGlobal("math/expm1", ["es6.math.expm1"], "7.0.1"),
	    fround: pureAndGlobal("math/fround", ["es6.math.fround"], "7.0.1"),
	    hypot: pureAndGlobal("math/hypot", ["es6.math.hypot"], "7.0.1"),
	    imul: pureAndGlobal("math/imul", ["es6.math.imul"], "7.0.1"),
	    log1p: pureAndGlobal("math/log1p", ["es6.math.log1p"], "7.0.1"),
	    log10: pureAndGlobal("math/log10", ["es6.math.log10"], "7.0.1"),
	    log2: pureAndGlobal("math/log2", ["es6.math.log2"], "7.0.1"),
	    sign: pureAndGlobal("math/sign", ["es6.math.sign"], "7.0.1"),
	    sinh: pureAndGlobal("math/sinh", ["es6.math.sinh"], "7.0.1"),
	    tanh: pureAndGlobal("math/tanh", ["es6.math.tanh"], "7.0.1"),
	    trunc: pureAndGlobal("math/trunc", ["es6.math.trunc"], "7.0.1")
	  },
	  Number: {
	    EPSILON: pureAndGlobal("number/epsilon", ["es6.number.epsilon"]),
	    MIN_SAFE_INTEGER: pureAndGlobal("number/min-safe-integer", ["es6.number.min-safe-integer"]),
	    MAX_SAFE_INTEGER: pureAndGlobal("number/max-safe-integer", ["es6.number.max-safe-integer"]),
	    isFinite: pureAndGlobal("number/is-finite", ["es6.number.is-finite"]),
	    isInteger: pureAndGlobal("number/is-integer", ["es6.number.is-integer"]),
	    isSafeInteger: pureAndGlobal("number/is-safe-integer", ["es6.number.is-safe-integer"]),
	    isNaN: pureAndGlobal("number/is-nan", ["es6.number.is-nan"]),
	    parseFloat: pureAndGlobal("number/parse-float", ["es6.number.parse-float"]),
	    parseInt: pureAndGlobal("number/parse-int", ["es6.number.parse-int"])
	  },
	  Object: {
	    assign: pureAndGlobal("object/assign", ["es6.object.assign"]),
	    create: pureAndGlobal("object/create", ["es6.object.create"]),
	    defineProperties: pureAndGlobal("object/define-properties", ["es6.object.define-properties"]),
	    defineProperty: pureAndGlobal("object/define-property", ["es6.object.define-property"]),
	    entries: pureAndGlobal("object/entries", ["es7.object.entries"]),
	    freeze: pureAndGlobal("object/freeze", ["es6.object.freeze"]),
	    getOwnPropertyDescriptor: pureAndGlobal("object/get-own-property-descriptor", ["es6.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: pureAndGlobal("object/get-own-property-descriptors", ["es7.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: pureAndGlobal("object/get-own-property-names", ["es6.object.get-own-property-names"]),
	    getOwnPropertySymbols: pureAndGlobal("object/get-own-property-symbols", ["es6.symbol"]),
	    getPrototypeOf: pureAndGlobal("object/get-prototype-of", ["es6.object.get-prototype-of"]),
	    is: pureAndGlobal("object/is", ["es6.object.is"]),
	    isExtensible: pureAndGlobal("object/is-extensible", ["es6.object.is-extensible"]),
	    isFrozen: pureAndGlobal("object/is-frozen", ["es6.object.is-frozen"]),
	    isSealed: pureAndGlobal("object/is-sealed", ["es6.object.is-sealed"]),
	    keys: pureAndGlobal("object/keys", ["es6.object.keys"]),
	    preventExtensions: pureAndGlobal("object/prevent-extensions", ["es6.object.prevent-extensions"]),
	    seal: pureAndGlobal("object/seal", ["es6.object.seal"]),
	    setPrototypeOf: pureAndGlobal("object/set-prototype-of", ["es6.object.set-prototype-of"]),
	    values: pureAndGlobal("object/values", ["es7.object.values"])
	  },
	  Promise: {
	    all: globalOnly(CommonIterators$1),
	    race: globalOnly(CommonIterators$1)
	  },
	  Reflect: {
	    apply: pureAndGlobal("reflect/apply", ["es6.reflect.apply"]),
	    construct: pureAndGlobal("reflect/construct", ["es6.reflect.construct"]),
	    defineProperty: pureAndGlobal("reflect/define-property", ["es6.reflect.define-property"]),
	    deleteProperty: pureAndGlobal("reflect/delete-property", ["es6.reflect.delete-property"]),
	    get: pureAndGlobal("reflect/get", ["es6.reflect.get"]),
	    getOwnPropertyDescriptor: pureAndGlobal("reflect/get-own-property-descriptor", ["es6.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: pureAndGlobal("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
	    has: pureAndGlobal("reflect/has", ["es6.reflect.has"]),
	    isExtensible: pureAndGlobal("reflect/is-extensible", ["es6.reflect.is-extensible"]),
	    ownKeys: pureAndGlobal("reflect/own-keys", ["es6.reflect.own-keys"]),
	    preventExtensions: pureAndGlobal("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
	    set: pureAndGlobal("reflect/set", ["es6.reflect.set"]),
	    setPrototypeOf: pureAndGlobal("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
	  },
	  String: {
	    at: pureOnly("string/at", "es7.string.at"),
	    fromCodePoint: pureAndGlobal("string/from-code-point", ["es6.string.from-code-point"]),
	    raw: pureAndGlobal("string/raw", ["es6.string.raw"])
	  },
	  Symbol: {
	    asyncIterator: globalOnly(["es6.symbol", "es7.symbol.async-iterator"]),
	    "for": pureOnly("symbol/for", "es6.symbol"),
	    hasInstance: pureOnly("symbol/has-instance", "es6.symbol"),
	    isConcatSpreadable: pureOnly("symbol/is-concat-spreadable", "es6.symbol"),
	    iterator: define$1("es6.symbol", "symbol/iterator", CommonIterators$1),
	    keyFor: pureOnly("symbol/key-for", "es6.symbol"),
	    match: pureAndGlobal("symbol/match", ["es6.regexp.match"]),
	    replace: pureOnly("symbol/replace", "es6.symbol"),
	    search: pureOnly("symbol/search", "es6.symbol"),
	    species: pureOnly("symbol/species", "es6.symbol"),
	    split: pureOnly("symbol/split", "es6.symbol"),
	    toPrimitive: pureOnly("symbol/to-primitive", "es6.symbol"),
	    toStringTag: pureOnly("symbol/to-string-tag", "es6.symbol"),
	    unscopables: pureOnly("symbol/unscopables", "es6.symbol")
	  }
	};
	var webPolyfills = {
	  "web.timers": {},
	  "web.immediate": {},
	  "web.dom.iterable": {}
	};
	var purePolyfills = {
	  "es6.parse-float": {},
	  "es6.parse-int": {},
	  "es7.string.at": {}
	};

	function addPlatformSpecificPolyfills(targets, method, polyfills) {
	  var targetNames = Object.keys(targets);
	  var isAnyTarget = !targetNames.length;
	  var isWebTarget = targetNames.some(function (name) {
	    return name !== "node";
	  });
	  return Object.assign(Object.assign(Object.assign({}, polyfills), method === "usage-pure" ? purePolyfills : null), isAnyTarget || isWebTarget ? webPolyfills : null);
	}

	function hasMinVersion(minVersion, runtimeVersion) {
	  if (!runtimeVersion || !minVersion) return true;
	  if (semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
	  return !semver.intersects("<" + minVersion, runtimeVersion) && !semver.intersects(">=8.0.0", runtimeVersion);
	}

	var _ref$1 = undefined || babel,
	    t$2 = _ref$1.types;

	var presetEnvCompat = "#__secret_key__@babel/preset-env__compatibility";
	var runtimeCompat$2 = "#__secret_key__@babel/runtime__compatibility";
	var has = Function.call.bind(Object.hasOwnProperty);
	var index$2 = definePolyfillProvider(function (api, _ref2) {
	  var _ref2$presetEnvCompat = _ref2[presetEnvCompat];
	  _ref2$presetEnvCompat = _ref2$presetEnvCompat === void 0 ? {} : _ref2$presetEnvCompat;
	  var entryInjectRegenerator = _ref2$presetEnvCompat.entryInjectRegenerator,
	      _ref2$runtimeCompat = _ref2[runtimeCompat$2];
	  _ref2$runtimeCompat = _ref2$runtimeCompat === void 0 ? {} : _ref2$runtimeCompat;
	  var useBabelRuntime = _ref2$runtimeCompat.useBabelRuntime,
	      runtimeVersion = _ref2$runtimeCompat.runtimeVersion,
	      _ref2$runtimeCompat$e = _ref2$runtimeCompat.ext,
	      ext = _ref2$runtimeCompat$e === void 0 ? ".js" : _ref2$runtimeCompat$e;
	  var resolve = api.createMetaResolver({
	    global: BuiltIns$1,
	    "static": StaticProperties$1,
	    instance: InstanceProperties$1
	  });
	  var debug = api.debug,
	      shouldInjectPolyfill = api.shouldInjectPolyfill,
	      method = api.method;
	  var polyfills = addPlatformSpecificPolyfills(api.targets, method, corejs2BuiltIns);
	  var coreJSBase = useBabelRuntime ? useBabelRuntime + "/core-js" : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";

	  function inject(name, utils) {
	    if (typeof name === "string") {
	      if (has(polyfills, name) && shouldInjectPolyfill(name)) {
	        debug(name);
	        utils.injectGlobalImport(coreJSBase + "/" + name + ".js");
	      }

	      return;
	    }

	    name.forEach(function (name) {
	      return inject(name, utils);
	    });
	  }

	  function maybeInjectPure(desc, hint, utils) {
	    var pure = desc.pure,
	        meta = desc.meta,
	        name = desc.name;
	    if (!pure || !shouldInjectPolyfill(name)) return;

	    if (runtimeVersion && meta && meta.minRuntimeVersion && !hasMinVersion(meta && meta.minRuntimeVersion, runtimeVersion)) {
	      return;
	    }

	    return utils.injectDefaultImport(coreJSBase + "/" + pure + ext, hint);
	  }

	  return {
	    name: "corejs2",
	    polyfills: polyfills,
	    entryGlobal: function entryGlobal(meta, utils, path) {
	      if (meta.kind === "import" && meta.source === "core-js") {
	        debug(null);
	        inject(Object.keys(polyfills), utils);

	        if (entryInjectRegenerator) {
	          utils.injectGlobalImport("regenerator-runtime/runtime.js");
	        }

	        path.remove();
	      }
	    },
	    usageGlobal: function usageGlobal(meta, utils) {
	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var deps = resolved.desc.global;

	      if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
	        var low = meta.object.toLowerCase();
	        deps = deps.filter(function (m) {
	          return m.includes(low);
	        });
	      }

	      inject(deps, utils);
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t$2.callExpression(utils.injectDefaultImport(coreJSBase + "/is-iterable" + ext, "isIterable"), [path.node.right]));
	        }

	        return;
	      }

	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;

	      if (meta.kind === "property") {
	        if (!path.isMemberExpression()) return;
	        if (!path.isReferenced()) return;

	        if (meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
	          callee: path.node
	        }) && path.parent.arguments.length === 0) {
	          path.parentPath.replaceWith(t$2.callExpression(utils.injectDefaultImport(coreJSBase + "/get-iterator" + ext, "getIterator"), [path.node.object]));
	          path.skip();
	          return;
	        }
	      }

	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var id = maybeInjectPure(resolved.desc, resolved.name, utils);
	      if (id) path.replaceWith(id);
	    },
	    visitor: method === "usage-global" && {
	      YieldExpression: function YieldExpression(path) {
	        if (path.node.delegate) {
	          inject("web.dom.iterable", api.getUtils(path));
	        }
	      },
	      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
	        CommonIterators$1.forEach(function (name) {
	          return inject(name, api.getUtils(path));
	        });
	      }
	    }
	  };
	});

	var data = require$$0$3;

	var getModulesListForTargetVersion = getModulesListForTargetVersion$2;

	var entries = require$$0$2;

	var corejs3ShippedProposalsList = new Set([]);
	var polyfillsOrder = {};
	Object.keys(data).forEach(function (name, index) {
	  polyfillsOrder[name] = index;
	});

	var define = function define(pure, global, name, exclude) {
	  if (name === void 0) {
	    name = global[0];
	  }

	  return {
	    name: name,
	    pure: pure,
	    global: global.sort(function (a, b) {
	      return polyfillsOrder[a] - polyfillsOrder[b];
	    }),
	    exclude: exclude
	  };
	};

	var typed = function typed(name) {
	  return define(null, [name].concat(TypedArrayDependencies));
	};

	var ArrayNatureIterators = ["es.array.iterator", "web.dom-collections.iterator"];
	var CommonIterators = ["es.string.iterator"].concat(ArrayNatureIterators);
	var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators);
	var CommonIteratorsWithTag = ["es.object.to-string"].concat(_toConsumableArray(CommonIterators));
	var TypedArrayDependencies = ["es.typed-array.at", "es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice", "esnext.typed-array.filter-reject", "esnext.typed-array.find-last", "esnext.typed-array.find-last-index", "esnext.typed-array.group-by", "esnext.typed-array.unique-by"];
	var PromiseDependencies = ["es.promise", "es.object.to-string"];
	var PromiseDependenciesWithIterators = [].concat(PromiseDependencies, _toConsumableArray(CommonIterators));
	var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
	var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.emplace", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(_toConsumableArray(CommonIteratorsWithTag));
	var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(_toConsumableArray(CommonIteratorsWithTag));
	var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all", "esnext.weak-map.emplace"].concat(_toConsumableArray(CommonIteratorsWithTag));
	var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag));
	var URLSearchParamsDependencies = ["web.url-search-params"].concat(_toConsumableArray(CommonIteratorsWithTag));
	var AsyncIteratorDependencies = ["esnext.async-iterator.constructor"].concat(PromiseDependencies);
	var IteratorDependencies = ["esnext.iterator.constructor", "es.object.to-string"];
	var TypedArrayStaticMethods = {
	  from: define(null, ["es.typed-array.from"]),
	  fromAsync: define(null, ["esnext.typed-array.from-async"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
	  of: define(null, ["es.typed-array.of"])
	};
	var BuiltIns = {
	  AsyncIterator: define("async-iterator/index", AsyncIteratorDependencies),
	  AggregateError: define("aggregate-error", ["es.aggregate-error"].concat(_toConsumableArray(CommonIterators))),
	  ArrayBuffer: define(null, ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"]),
	  DataView: define(null, ["es.data-view", "es.array-buffer.slice", "es.object.to-string"]),
	  Date: define(null, ["es.date.to-string"]),
	  Float32Array: typed("es.typed-array.float32-array"),
	  Float64Array: typed("es.typed-array.float64-array"),
	  Int8Array: typed("es.typed-array.int8-array"),
	  Int16Array: typed("es.typed-array.int16-array"),
	  Int32Array: typed("es.typed-array.int32-array"),
	  Iterator: define("iterator/index", IteratorDependencies),
	  Uint8Array: typed("es.typed-array.uint8-array"),
	  Uint8ClampedArray: typed("es.typed-array.uint8-clamped-array"),
	  Uint16Array: typed("es.typed-array.uint16-array"),
	  Uint32Array: typed("es.typed-array.uint32-array"),
	  Map: define("map/index", MapDependencies),
	  Number: define(null, ["es.number.constructor"]),
	  Observable: define("observable/index", ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(_toConsumableArray(CommonIteratorsWithTag))),
	  Promise: define("promise/index", PromiseDependencies),
	  Reflect: define(null, ["es.reflect.to-string-tag", "es.object.to-string"]),
	  RegExp: define(null, ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec", "es.regexp.sticky", "es.regexp.to-string"]),
	  Set: define("set/index", SetDependencies),
	  Symbol: define("symbol/index", SymbolDependencies),
	  URL: define("url/index", ["web.url"].concat(_toConsumableArray(URLSearchParamsDependencies))),
	  URLSearchParams: define("url-search-params/index", URLSearchParamsDependencies),
	  WeakMap: define("weak-map/index", WeakMapDependencies),
	  WeakSet: define("weak-set/index", WeakSetDependencies),
	  clearImmediate: define("clear-immediate", ["web.immediate"]),
	  compositeKey: define("composite-key", ["esnext.composite-key"]),
	  compositeSymbol: define("composite-symbol", ["esnext.composite-symbol"]),
	  escape: define("escape", ["es.escape"]),
	  fetch: define(null, PromiseDependencies),
	  globalThis: define("global-this", ["es.global-this"]),
	  parseFloat: define("parse-float", ["es.parse-float"]),
	  parseInt: define("parse-int", ["es.parse-int"]),
	  queueMicrotask: define("queue-microtask", ["web.queue-microtask"]),
	  setImmediate: define("set-immediate", ["web.immediate"]),
	  setInterval: define("set-interval", ["web.timers"]),
	  setTimeout: define("set-timeout", ["web.timers"]),
	  unescape: define("unescape", ["es.unescape"])
	};
	var StaticProperties = {
	  AsyncIterator: {
	    from: define("async-iterator/from", ["esnext.async-iterator.from"].concat(_toConsumableArray(AsyncIteratorDependencies), _toConsumableArray(CommonIterators)))
	  },
	  Array: {
	    from: define("array/from", ["es.array.from", "es.string.iterator"]),
	    fromAsync: define("array/from-async", ["esnext.array.from-async"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
	    isArray: define("array/is-array", ["es.array.is-array"]),
	    isTemplateObject: define("array/is-template-object", ["esnext.array.is-template-object"]),
	    of: define("array/of", ["es.array.of"])
	  },
	  ArrayBuffer: {
	    isView: define(null, ["es.array-buffer.is-view"])
	  },
	  BigInt: {
	    range: define("bigint/range", ["esnext.bigint.range", "es.object.to-string"])
	  },
	  Date: {
	    now: define("date/now", ["es.date.now"])
	  },
	  Iterator: {
	    from: define("iterator/from", ["esnext.iterator.from"].concat(IteratorDependencies, _toConsumableArray(CommonIterators)))
	  },
	  JSON: {
	    stringify: define("json/stringify", ["es.json.stringify"], "es.symbol")
	  },
	  Math: {
	    DEG_PER_RAD: define("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
	    RAD_PER_DEG: define("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
	    acosh: define("math/acosh", ["es.math.acosh"]),
	    asinh: define("math/asinh", ["es.math.asinh"]),
	    atanh: define("math/atanh", ["es.math.atanh"]),
	    cbrt: define("math/cbrt", ["es.math.cbrt"]),
	    clamp: define("math/clamp", ["esnext.math.clamp"]),
	    clz32: define("math/clz32", ["es.math.clz32"]),
	    cosh: define("math/cosh", ["es.math.cosh"]),
	    degrees: define("math/degrees", ["esnext.math.degrees"]),
	    expm1: define("math/expm1", ["es.math.expm1"]),
	    fround: define("math/fround", ["es.math.fround"]),
	    fscale: define("math/fscale", ["esnext.math.fscale"]),
	    hypot: define("math/hypot", ["es.math.hypot"]),
	    iaddh: define("math/iaddh", ["esnext.math.iaddh"]),
	    imul: define("math/imul", ["es.math.imul"]),
	    imulh: define("math/imulh", ["esnext.math.imulh"]),
	    isubh: define("math/isubh", ["esnext.math.isubh"]),
	    log10: define("math/log10", ["es.math.log10"]),
	    log1p: define("math/log1p", ["es.math.log1p"]),
	    log2: define("math/log2", ["es.math.log2"]),
	    radians: define("math/radians", ["esnext.math.radians"]),
	    scale: define("math/scale", ["esnext.math.scale"]),
	    seededPRNG: define("math/seeded-prng", ["esnext.math.seeded-prng"]),
	    sign: define("math/sign", ["es.math.sign"]),
	    signbit: define("math/signbit", ["esnext.math.signbit"]),
	    sinh: define("math/sinh", ["es.math.sinh"]),
	    tanh: define("math/tanh", ["es.math.tanh"]),
	    trunc: define("math/trunc", ["es.math.trunc"]),
	    umulh: define("math/umulh", ["esnext.math.umulh"])
	  },
	  Map: {
	    from: define(null, ["esnext.map.from"].concat(_toConsumableArray(MapDependencies))),
	    groupBy: define(null, ["esnext.map.group-by"].concat(_toConsumableArray(MapDependencies))),
	    keyBy: define(null, ["esnext.map.key-by"].concat(_toConsumableArray(MapDependencies))),
	    of: define(null, ["esnext.map.of"].concat(_toConsumableArray(MapDependencies)))
	  },
	  Number: {
	    EPSILON: define("number/epsilon", ["es.number.epsilon"]),
	    MAX_SAFE_INTEGER: define("number/max-safe-integer", ["es.number.max-safe-integer"]),
	    MIN_SAFE_INTEGER: define("number/min-safe-integer", ["es.number.min-safe-integer"]),
	    fromString: define("number/from-string", ["esnext.number.from-string"]),
	    isFinite: define("number/is-finite", ["es.number.is-finite"]),
	    isInteger: define("number/is-integer", ["es.number.is-integer"]),
	    isNaN: define("number/is-nan", ["es.number.is-nan"]),
	    isSafeInteger: define("number/is-safe-integer", ["es.number.is-safe-integer"]),
	    parseFloat: define("number/parse-float", ["es.number.parse-float"]),
	    parseInt: define("number/parse-int", ["es.number.parse-int"]),
	    range: define("number/range", ["esnext.number.range", "es.object.to-string"])
	  },
	  Object: {
	    assign: define("object/assign", ["es.object.assign"]),
	    create: define("object/create", ["es.object.create"]),
	    defineProperties: define("object/define-properties", ["es.object.define-properties"]),
	    defineProperty: define("object/define-property", ["es.object.define-property"]),
	    entries: define("object/entries", ["es.object.entries"]),
	    freeze: define("object/freeze", ["es.object.freeze"]),
	    fromEntries: define("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
	    getOwnPropertyDescriptor: define("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
	    getOwnPropertyDescriptors: define("object/get-own-property-descriptors", ["es.object.get-own-property-descriptors"]),
	    getOwnPropertyNames: define("object/get-own-property-names", ["es.object.get-own-property-names"]),
	    getOwnPropertySymbols: define("object/get-own-property-symbols", ["es.symbol"]),
	    getPrototypeOf: define("object/get-prototype-of", ["es.object.get-prototype-of"]),
	    hasOwn: define("object/has-own", ["es.object.has-own"]),
	    is: define("object/is", ["es.object.is"]),
	    isExtensible: define("object/is-extensible", ["es.object.is-extensible"]),
	    isFrozen: define("object/is-frozen", ["es.object.is-frozen"]),
	    isSealed: define("object/is-sealed", ["es.object.is-sealed"]),
	    keys: define("object/keys", ["es.object.keys"]),
	    preventExtensions: define("object/prevent-extensions", ["es.object.prevent-extensions"]),
	    seal: define("object/seal", ["es.object.seal"]),
	    setPrototypeOf: define("object/set-prototype-of", ["es.object.set-prototype-of"]),
	    values: define("object/values", ["es.object.values"])
	  },
	  Promise: {
	    all: define(null, PromiseDependenciesWithIterators),
	    allSettled: define(null, ["es.promise.all-settled"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
	    any: define(null, ["es.promise.any", "es.aggregate-error"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
	    race: define(null, PromiseDependenciesWithIterators),
	    "try": define(null, ["esnext.promise.try"].concat(_toConsumableArray(PromiseDependenciesWithIterators)))
	  },
	  Reflect: {
	    apply: define("reflect/apply", ["es.reflect.apply"]),
	    construct: define("reflect/construct", ["es.reflect.construct"]),
	    defineMetadata: define("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
	    defineProperty: define("reflect/define-property", ["es.reflect.define-property"]),
	    deleteMetadata: define("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
	    deleteProperty: define("reflect/delete-property", ["es.reflect.delete-property"]),
	    get: define("reflect/get", ["es.reflect.get"]),
	    getMetadata: define("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
	    getMetadataKeys: define("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
	    getOwnMetadata: define("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
	    getOwnMetadataKeys: define("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
	    getOwnPropertyDescriptor: define("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
	    getPrototypeOf: define("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
	    has: define("reflect/has", ["es.reflect.has"]),
	    hasMetadata: define("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
	    hasOwnMetadata: define("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
	    isExtensible: define("reflect/is-extensible", ["es.reflect.is-extensible"]),
	    metadata: define("reflect/metadata", ["esnext.reflect.metadata"]),
	    ownKeys: define("reflect/own-keys", ["es.reflect.own-keys"]),
	    preventExtensions: define("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
	    set: define("reflect/set", ["es.reflect.set"]),
	    setPrototypeOf: define("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
	  },
	  Set: {
	    from: define(null, ["esnext.set.from"].concat(_toConsumableArray(SetDependencies))),
	    of: define(null, ["esnext.set.of"].concat(_toConsumableArray(SetDependencies)))
	  },
	  String: {
	    fromCodePoint: define("string/from-code-point", ["es.string.from-code-point"]),
	    raw: define("string/raw", ["es.string.raw"])
	  },
	  Symbol: {
	    asyncDispose: define("symbol/async-dispose", ["esnext.symbol.async-dispose"]),
	    asyncIterator: define("symbol/async-iterator", ["es.symbol.async-iterator"]),
	    dispose: define("symbol/dispose", ["esnext.symbol.dispose"]),
	    "for": define("symbol/for", [], "es.symbol"),
	    hasInstance: define("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
	    isConcatSpreadable: define("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
	    iterator: define("symbol/iterator", ["es.symbol.iterator"].concat(_toConsumableArray(CommonIteratorsWithTag))),
	    keyFor: define("symbol/key-for", [], "es.symbol"),
	    match: define("symbol/match", ["es.symbol.match", "es.string.match"]),
	    matcher: define("symbol/matcher", ["esnext.symbol.matcher"]),
	    matchAll: define("symbol/match-all", ["es.symbol.match-all", "es.string.match-all"]),
	    metadata: define("symbol/metadata", ["esnext.symbol.metadata"]),
	    observable: define("symbol/observable", ["esnext.symbol.observable"]),
	    patternMatch: define("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
	    replace: define("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
	    search: define("symbol/search", ["es.symbol.search", "es.string.search"]),
	    species: define("symbol/species", ["es.symbol.species", "es.array.species"]),
	    split: define("symbol/split", ["es.symbol.split", "es.string.split"]),
	    toPrimitive: define("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
	    toStringTag: define("symbol/to-string-tag", ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"]),
	    unscopables: define("symbol/unscopables", ["es.symbol.unscopables"])
	  },
	  WeakMap: {
	    from: define(null, ["esnext.weak-map.from"].concat(_toConsumableArray(WeakMapDependencies))),
	    of: define(null, ["esnext.weak-map.of"].concat(_toConsumableArray(WeakMapDependencies)))
	  },
	  WeakSet: {
	    from: define(null, ["esnext.weak-set.from"].concat(_toConsumableArray(WeakSetDependencies))),
	    of: define(null, ["esnext.weak-set.of"].concat(_toConsumableArray(WeakSetDependencies)))
	  },
	  Int8Array: TypedArrayStaticMethods,
	  Uint8Array: TypedArrayStaticMethods,
	  Uint8ClampedArray: TypedArrayStaticMethods,
	  Int16Array: TypedArrayStaticMethods,
	  Uint16Array: TypedArrayStaticMethods,
	  Int32Array: TypedArrayStaticMethods,
	  Uint32Array: TypedArrayStaticMethods,
	  Float32Array: TypedArrayStaticMethods,
	  Float64Array: TypedArrayStaticMethods
	};
	var InstanceProperties = {
	  asIndexedPairs: define("instance/asIndexedPairs", ["esnext.async-iterator.as-indexed-pairs"].concat(_toConsumableArray(AsyncIteratorDependencies), ["esnext.iterator.as-indexed-pairs"], IteratorDependencies)),
	  at: define("instance/at", ["esnext.string.at", "es.string.at-alternative", "es.array.at"]),
	  anchor: define(null, ["es.string.anchor"]),
	  big: define(null, ["es.string.big"]),
	  bind: define("instance/bind", ["es.function.bind"]),
	  blink: define(null, ["es.string.blink"]),
	  bold: define(null, ["es.string.bold"]),
	  codePointAt: define("instance/code-point-at", ["es.string.code-point-at"]),
	  codePoints: define("instance/code-points", ["esnext.string.code-points"]),
	  concat: define("instance/concat", ["es.array.concat"], undefined, ["String"]),
	  copyWithin: define("instance/copy-within", ["es.array.copy-within"]),
	  description: define(null, ["es.symbol", "es.symbol.description"]),
	  dotAll: define("instance/dot-all", ["es.regexp.dot-all"]),
	  drop: define("instance/drop", ["esnext.async-iterator.drop"].concat(_toConsumableArray(AsyncIteratorDependencies), ["esnext.iterator.drop"], IteratorDependencies)),
	  emplace: define("instance/emplace", ["esnext.map.emplace", "esnext.weak-map.emplace"]),
	  endsWith: define("instance/ends-with", ["es.string.ends-with"]),
	  entries: define("instance/entries", ArrayNatureIteratorsWithTag),
	  every: define("instance/every", ["es.array.every", "esnext.async-iterator.every", "esnext.iterator.every"].concat(IteratorDependencies)),
	  exec: define(null, ["es.regexp.exec"]),
	  fill: define("instance/fill", ["es.array.fill"]),
	  filter: define("instance/filter", ["es.array.filter", "esnext.async-iterator.filter", "esnext.iterator.filter"].concat(IteratorDependencies)),
	  filterReject: define("instance/filterReject", ["esnext.array.filter-reject"]),
	  "finally": define(null, ["es.promise.finally"].concat(PromiseDependencies)),
	  find: define("instance/find", ["es.array.find", "esnext.async-iterator.find", "esnext.iterator.find"].concat(IteratorDependencies)),
	  findIndex: define("instance/find-index", ["es.array.find-index"]),
	  findLast: define("instance/find-last", ["esnext.array.find-last"]),
	  findLastIndex: define("instance/find-last-index", ["esnext.array.find-last-index"]),
	  fixed: define(null, ["es.string.fixed"]),
	  flags: define("instance/flags", ["es.regexp.flags"]),
	  flatMap: define("instance/flat-map", ["es.array.flat-map", "es.array.unscopables.flat-map", "esnext.async-iterator.flat-map", "esnext.iterator.flat-map"].concat(IteratorDependencies)),
	  flat: define("instance/flat", ["es.array.flat", "es.array.unscopables.flat"]),
	  getYear: define(null, ["es.date.get-year"]),
	  groupBy: define("instance/group-by", ["esnext.array.group-by"]),
	  fontcolor: define(null, ["es.string.fontcolor"]),
	  fontsize: define(null, ["es.string.fontsize"]),
	  forEach: define("instance/for-each", ["es.array.for-each", "esnext.async-iterator.for-each", "esnext.iterator.for-each"].concat(IteratorDependencies, ["web.dom-collections.for-each"])),
	  includes: define("instance/includes", ["es.array.includes", "es.string.includes"]),
	  indexOf: define("instance/index-of", ["es.array.index-of"]),
	  italic: define(null, ["es.string.italics"]),
	  join: define(null, ["es.array.join"]),
	  keys: define("instance/keys", ArrayNatureIteratorsWithTag),
	  lastIndex: define(null, ["esnext.array.last-index"]),
	  lastIndexOf: define("instance/last-index-of", ["es.array.last-index-of"]),
	  lastItem: define(null, ["esnext.array.last-item"]),
	  link: define(null, ["es.string.link"]),
	  map: define("instance/map", ["es.array.map", "esnext.async-iterator.map", "esnext.iterator.map"]),
	  match: define(null, ["es.string.match", "es.regexp.exec"]),
	  matchAll: define("instance/match-all", ["es.string.match-all", "es.regexp.exec"]),
	  name: define(null, ["es.function.name"]),
	  padEnd: define("instance/pad-end", ["es.string.pad-end"]),
	  padStart: define("instance/pad-start", ["es.string.pad-start"]),
	  reduce: define("instance/reduce", ["es.array.reduce", "esnext.async-iterator.reduce", "esnext.iterator.reduce"].concat(IteratorDependencies)),
	  reduceRight: define("instance/reduce-right", ["es.array.reduce-right"]),
	  repeat: define("instance/repeat", ["es.string.repeat"]),
	  replace: define(null, ["es.string.replace", "es.regexp.exec"]),
	  replaceAll: define("instance/replace-all", ["es.string.replace-all", "es.string.replace", "es.regexp.exec"]),
	  reverse: define("instance/reverse", ["es.array.reverse"]),
	  search: define(null, ["es.string.search", "es.regexp.exec"]),
	  setYear: define(null, ["es.date.set-year"]),
	  slice: define("instance/slice", ["es.array.slice"]),
	  small: define(null, ["es.string.small"]),
	  some: define("instance/some", ["es.array.some", "esnext.async-iterator.some", "esnext.iterator.some"].concat(IteratorDependencies)),
	  sort: define("instance/sort", ["es.array.sort"]),
	  splice: define("instance/splice", ["es.array.splice"]),
	  split: define(null, ["es.string.split", "es.regexp.exec"]),
	  startsWith: define("instance/starts-with", ["es.string.starts-with"]),
	  sticky: define("instance/sticky", ["es.regexp.sticky"]),
	  strike: define(null, ["es.string.strike"]),
	  sub: define(null, ["es.string.sub"]),
	  substr: define(null, ["es.string.substr"]),
	  sup: define(null, ["es.string.sup"]),
	  take: define("instance/take", ["esnext.async-iterator.take"].concat(_toConsumableArray(AsyncIteratorDependencies), ["esnext.iterator.take"], IteratorDependencies)),
	  test: define("instance/test", ["es.regexp.test", "es.regexp.exec"]),
	  toArray: define("instance/to-array", ["esnext.async-iterator.to-array"].concat(_toConsumableArray(AsyncIteratorDependencies), ["esnext.iterator.to-array"], IteratorDependencies)),
	  toFixed: define(null, ["es.number.to-fixed"]),
	  toGMTString: define(null, ["es.date.to-gmt-string"]),
	  toISOString: define(null, ["es.date.to-iso-string"]),
	  toJSON: define(null, ["es.date.to-json", "web.url.to-json"]),
	  toPrecision: define(null, ["es.number.to-precision"]),
	  toString: define(null, ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"]),
	  trim: define("instance/trim", ["es.string.trim"]),
	  trimEnd: define("instance/trim-end", ["es.string.trim-end"]),
	  trimLeft: define("instance/trim-left", ["es.string.trim-start"]),
	  trimRight: define("instance/trim-right", ["es.string.trim-end"]),
	  trimStart: define("instance/trim-start", ["es.string.trim-start"]),
	  uniqueBy: define("instance/unique-by", ["esnext.array.unique-by", "es.map"]),
	  values: define("instance/values", ArrayNatureIteratorsWithTag),
	  __defineGetter__: define(null, ["es.object.define-getter"]),
	  __defineSetter__: define(null, ["es.object.define-setter"]),
	  __lookupGetter__: define(null, ["es.object.lookup-getter"]),
	  __lookupSetter__: define(null, ["es.object.lookup-setter"])
	};
	var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);

	var _ref = undefined || babel,
	    t$1 = _ref.types;

	function callMethod(path, id) {
	  var object = path.node.object;
	  var context1, context2;

	  if (t$1.isIdentifier(object)) {
	    context1 = object;
	    context2 = t$1.cloneNode(object);
	  } else {
	    context1 = path.scope.generateDeclaredUidIdentifier("context");
	    context2 = t$1.assignmentExpression("=", t$1.cloneNode(context1), object);
	  }

	  path.replaceWith(t$1.memberExpression(t$1.callExpression(id, [context2]), t$1.identifier("call")));
	  path.parentPath.unshiftContainer("arguments", context1);
	}

	function isCoreJSSource(source) {
	  if (typeof source === "string") {
	    source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
	  }

	  return hasOwnProperty.call(entries, source) && entries[source];
	}

	function coreJSModule(name) {
	  return "core-js/modules/" + name + ".js";
	}

	function coreJSPureHelper(name, useBabelRuntime, ext) {
	  return useBabelRuntime ? useBabelRuntime + "/core-js/" + name + ext : "core-js-pure/features/" + name + ".js";
	}

	var _ref2 = undefined || babel,
	    t = _ref2.types;

	var runtimeCompat$1 = "#__secret_key__@babel/runtime__compatibility";

	var esnextFallback = function esnextFallback(name, cb) {
	  if (cb(name)) return true;
	  if (!name.startsWith("es.")) return false;
	  var fallback = "esnext." + name.slice(3);
	  if (!data[fallback]) return false;
	  return cb(fallback);
	};

	var index$1 = definePolyfillProvider(function (_ref3, _ref4) {
	  var getUtils = _ref3.getUtils,
	      method = _ref3.method,
	      shouldInjectPolyfill = _ref3.shouldInjectPolyfill,
	      createMetaResolver = _ref3.createMetaResolver,
	      debug = _ref3.debug,
	      babel = _ref3.babel;
	  var _ref4$version = _ref4.version,
	      version = _ref4$version === void 0 ? 3 : _ref4$version,
	      proposals = _ref4.proposals,
	      shippedProposals = _ref4.shippedProposals,
	      _ref4$runtimeCompat = _ref4[runtimeCompat$1];
	  _ref4$runtimeCompat = _ref4$runtimeCompat === void 0 ? {} : _ref4$runtimeCompat;
	  var useBabelRuntime = _ref4$runtimeCompat.useBabelRuntime,
	      _ref4$runtimeCompat$e = _ref4$runtimeCompat.ext,
	      ext = _ref4$runtimeCompat$e === void 0 ? ".js" : _ref4$runtimeCompat$e;
	  var isWebpack = babel.caller(function (caller) {
	    return (caller == null ? void 0 : caller.name) === "babel-loader";
	  });
	  var resolve = createMetaResolver({
	    global: BuiltIns,
	    "static": StaticProperties,
	    instance: InstanceProperties
	  });
	  var available = new Set(getModulesListForTargetVersion(version));

	  function getCoreJSPureBase(useProposalBase) {
	    return useBabelRuntime ? useProposalBase ? useBabelRuntime + "/core-js" : useBabelRuntime + "/core-js-stable" : useProposalBase ? "core-js-pure/features" : "core-js-pure/stable";
	  }

	  function maybeInjectGlobalImpl(name, utils) {
	    if (shouldInjectPolyfill(name)) {
	      debug(name);
	      utils.injectGlobalImport(coreJSModule(name));
	      return true;
	    }

	    return false;
	  }

	  function maybeInjectGlobal(names, utils, fallback) {
	    if (fallback === void 0) {
	      fallback = true;
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose(names), _step; !(_step = _iterator()).done;) {
	      var name = _step.value;

	      if (fallback) {
	        esnextFallback(name, function (name) {
	          return maybeInjectGlobalImpl(name, utils);
	        });
	      } else {
	        maybeInjectGlobalImpl(name, utils);
	      }
	    }
	  }

	  function maybeInjectPure(desc, hint, utils, object) {
	    if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback(desc.name, shouldInjectPolyfill)) {
	      var name = desc.name;
	      var useProposalBase = false;

	      if (proposals || shippedProposals && name.startsWith("esnext.")) {
	        useProposalBase = true;
	      } else if (name.startsWith("es.") && !available.has(name)) {
	        useProposalBase = true;
	      }

	      var coreJSPureBase = getCoreJSPureBase(useProposalBase);
	      return utils.injectDefaultImport(coreJSPureBase + "/" + desc.pure + ext, hint);
	    }
	  }

	  function isFeatureStable(name) {
	    if (name.startsWith("esnext.")) {
	      var esName = "es." + name.slice(7);
	      return esName in data;
	    }

	    return true;
	  }

	  return {
	    name: "corejs3",
	    polyfills: data,
	    filterPolyfills: function filterPolyfills(name) {
	      if (!available.has(name)) return false;
	      if (proposals || method === "entry-global") return true;

	      if (shippedProposals && corejs3ShippedProposalsList.has(name)) {
	        return true;
	      }

	      return isFeatureStable(name);
	    },
	    entryGlobal: function entryGlobal(meta, utils, path) {
	      if (meta.kind !== "import") return;
	      var modules = isCoreJSSource(meta.source);
	      if (!modules) return;

	      if (modules.length === 1 && meta.source === coreJSModule(modules[0]) && shouldInjectPolyfill(modules[0])) {
	        debug(null);
	        return;
	      }

	      maybeInjectGlobal(modules, utils, false);
	      path.remove();
	    },
	    usageGlobal: function usageGlobal(meta, utils) {
	      var resolved = resolve(meta);
	      if (!resolved) return;
	      var deps = resolved.desc.global;

	      if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
	        var low = meta.object.toLowerCase();
	        deps = deps.filter(function (m) {
	          return m.includes(low) || CommonInstanceDependencies.has(m);
	        });
	      }

	      maybeInjectGlobal(deps, utils);
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (meta.kind === "in") {
	        if (meta.key === "Symbol.iterator") {
	          path.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("is-iterable", useBabelRuntime, ext), "isIterable"), [path.node.right]));
	        }

	        return;
	      }

	      if (path.parentPath.isUnaryExpression({
	        operator: "delete"
	      })) return;
	      var isCall;

	      if (meta.kind === "property") {
	        if (!path.isMemberExpression()) return;
	        if (!path.isReferenced()) return;
	        isCall = path.parentPath.isCallExpression({
	          callee: path.node
	        });

	        if (meta.key === "Symbol.iterator") {
	          if (!shouldInjectPolyfill("es.symbol.iterator")) return;

	          if (isCall) {
	            if (path.parent.arguments.length === 0) {
	              path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("get-iterator", useBabelRuntime, ext), "getIterator"), [path.node.object]));
	              path.skip();
	            } else {
	              callMethod(path, utils.injectDefaultImport(coreJSPureHelper("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"));
	            }
	          } else {
	            path.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [path.node.object]));
	          }

	          return;
	        }
	      }

	      var resolved = resolve(meta);
	      if (!resolved) return;

	      if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index") {
	        resolved = Object.assign(Object.assign({}, resolved), {}, {
	          desc: Object.assign(Object.assign({}, resolved.desc), {}, {
	            pure: resolved.desc.pure.slice(0, -6)
	          })
	        });
	      }

	      if (resolved.kind === "global") {
	        var id = maybeInjectPure(resolved.desc, resolved.name, utils);
	        if (id) path.replaceWith(id);
	      } else if (resolved.kind === "static") {
	        var _id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);

	        if (_id) path.replaceWith(_id);
	      } else if (resolved.kind === "instance") {
	        var _id2 = maybeInjectPure(resolved.desc, resolved.name + "InstanceProperty", utils, meta.object);

	        if (!_id2) return;

	        if (isCall) {
	          callMethod(path, _id2);
	        } else {
	          path.replaceWith(t.callExpression(_id2, [path.node.object]));
	        }
	      }
	    },
	    visitor: method === "usage-global" && {
	      CallExpression: function CallExpression(path) {
	        if (path.get("callee").isImport()) {
	          var utils = getUtils(path);

	          if (isWebpack) {
	            maybeInjectGlobal(PromiseDependenciesWithIterators, utils);
	          } else {
	            maybeInjectGlobal(PromiseDependencies, utils);
	          }
	        }
	      },
	      Function: function Function(path) {
	        if (path.node.async) {
	          maybeInjectGlobal(PromiseDependencies, getUtils(path));
	        }
	      },
	      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
	        maybeInjectGlobal(CommonIterators, getUtils(path));
	      },
	      SpreadElement: function SpreadElement(path) {
	        if (!path.parentPath.isObjectExpression()) {
	          maybeInjectGlobal(CommonIterators, getUtils(path));
	        }
	      },
	      YieldExpression: function YieldExpression(path) {
	        if (path.node.delegate) {
	          maybeInjectGlobal(CommonIterators, getUtils(path));
	        }
	      }
	    }
	  };
	});

	var runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
	var index = definePolyfillProvider(function (_ref, options) {
	  var debug = _ref.debug;
	  var _options$runtimeCompa = options[runtimeCompat];
	  _options$runtimeCompa = _options$runtimeCompa === void 0 ? {} : _options$runtimeCompa;
	  var useBabelRuntime = _options$runtimeCompa.useBabelRuntime;
	  var pureName = useBabelRuntime ? useBabelRuntime + "/regenerator" : "regenerator-runtime";
	  return {
	    name: "regenerator",
	    polyfills: ["regenerator-runtime"],
	    usageGlobal: function usageGlobal(meta, utils) {
	      if (isRegenerator(meta)) {
	        debug("regenerator-runtime");
	        utils.injectGlobalImport("regenerator-runtime/runtime.js");
	      }
	    },
	    usagePure: function usagePure(meta, utils, path) {
	      if (isRegenerator(meta)) {
	        path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
	      }
	    }
	  };
	});

	var isRegenerator = function isRegenerator(meta) {
	  return meta.kind === "global" && meta.name === "regeneratorRuntime";
	};

	var pluginCoreJS2 = index$2["default"] || index$2;
	var pluginCoreJS3 = index$1["default"] || index$1;
	var pluginRegenerator = index["default"] || index;

	function filterStageFromList(list, stageList) {
	  return Object.keys(list).reduce(function (result, item) {
	    if (!stageList.has(item)) {
	      result[item] = list[item];
	    }

	    return result;
	  }, {});
	}

	var pluginLists = {
	  withProposals: {
	    withoutBugfixes: pluginsFiltered,
	    withBugfixes: Object.assign({}, pluginsFiltered, bugfixPluginsFiltered)
	  },
	  withoutProposals: {
	    withoutBugfixes: filterStageFromList(pluginsFiltered, shippedProposals.proposalPlugins),
	    withBugfixes: filterStageFromList(Object.assign({}, pluginsFiltered, bugfixPluginsFiltered), shippedProposals.proposalPlugins)
	  }
	};

	function getPluginList(proposals, bugfixes) {
	  if (proposals) {
	    if (bugfixes) return pluginLists.withProposals.withBugfixes;else return pluginLists.withProposals.withoutBugfixes;
	  } else {
	    if (bugfixes) return pluginLists.withoutProposals.withBugfixes;else return pluginLists.withoutProposals.withoutBugfixes;
	  }
	}

	var getPlugin = function getPlugin(pluginName) {
	  var plugin = availablePlugins$1[pluginName]();

	  if (!plugin) {
	    throw new Error("Could not find plugin \"" + pluginName + "\". Ensure there is an entry in ./available-plugins.js for it.");
	  }

	  return plugin;
	};

	var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
	  return opts.reduce(function (result, opt) {
	    var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
	    result[target].add(opt);
	    return result;
	  }, {
	    all: opts,
	    plugins: new Set(),
	    builtIns: new Set()
	  });
	};
	var getModulesPluginNames = function getModulesPluginNames(_ref) {
	  var modules = _ref.modules,
	      transformations = _ref.transformations,
	      shouldTransformESM = _ref.shouldTransformESM,
	      shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
	      shouldTransformExportNamespaceFrom = _ref.shouldTransformExportNamespaceFrom,
	      shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
	  var modulesPluginNames = [];

	  if (modules !== false && transformations[modules]) {
	    if (shouldTransformESM) {
	      modulesPluginNames.push(transformations[modules]);
	    }

	    if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
	      modulesPluginNames.push("proposal-dynamic-import");
	    } else {
	      if (shouldTransformDynamicImport) {
	        console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
	      }

	      modulesPluginNames.push("syntax-dynamic-import");
	    }
	  } else {
	    modulesPluginNames.push("syntax-dynamic-import");
	  }

	  if (shouldTransformExportNamespaceFrom) {
	    modulesPluginNames.push("proposal-export-namespace-from");
	  } else {
	    modulesPluginNames.push("syntax-export-namespace-from");
	  }

	  if (shouldParseTopLevelAwait) {
	    modulesPluginNames.push("syntax-top-level-await");
	  }

	  return modulesPluginNames;
	};
	var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
	  var useBuiltIns = _ref2.useBuiltIns,
	      corejs = _ref2.corejs,
	      polyfillTargets = _ref2.polyfillTargets,
	      include = _ref2.include,
	      exclude = _ref2.exclude,
	      proposals = _ref2.proposals,
	      shippedProposals = _ref2.shippedProposals,
	      regenerator = _ref2.regenerator,
	      debug = _ref2.debug;
	  var polyfillPlugins = [];

	  if (useBuiltIns === "usage" || useBuiltIns === "entry") {
	    var pluginOptions = {
	      method: useBuiltIns + "-global",
	      version: corejs ? corejs.toString() : undefined,
	      targets: polyfillTargets,
	      include: include,
	      exclude: exclude,
	      proposals: proposals,
	      shippedProposals: shippedProposals,
	      debug: debug
	    };

	    if (corejs) {
	      if (useBuiltIns === "usage") {
	        if (corejs.major === 2) {
	          polyfillPlugins.push([pluginCoreJS2, pluginOptions], [legacyBabelPolyfillPlugin, {
	            usage: true
	          }]);
	        } else {
	          polyfillPlugins.push([pluginCoreJS3, pluginOptions], [legacyBabelPolyfillPlugin, {
	            usage: true,
	            deprecated: true
	          }]);
	        }

	        if (regenerator) {
	          polyfillPlugins.push([pluginRegenerator, {
	            method: "usage-global",
	            debug: debug
	          }]);
	        }
	      } else {
	        if (corejs.major === 2) {
	          polyfillPlugins.push([legacyBabelPolyfillPlugin, {
	            regenerator: regenerator
	          }], [pluginCoreJS2, pluginOptions]);
	        } else {
	          polyfillPlugins.push([pluginCoreJS3, pluginOptions], [legacyBabelPolyfillPlugin, {
	            deprecated: true
	          }]);

	          if (!regenerator) {
	            polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
	          }
	        }
	      }
	    }
	  }

	  return polyfillPlugins;
	};

	function getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv) {
	  if (optionsTargets != null && optionsTargets.esmodules && optionsTargets.browsers) {
	    console.warn("\n@babel/preset-env: esmodules and browsers targets have been specified together.\n`browsers` target, `" + optionsTargets.browsers.toString() + "` will be ignored.\n");
	  }

	  return getTargets$2(optionsTargets, {
	    ignoreBrowserslistConfig: ignoreBrowserslistConfig,
	    configPath: configPath,
	    browserslistEnv: browserslistEnv
	  });
	}

	function supportsStaticESM(caller) {
	  return !!(caller != null && caller.supportsStaticESM);
	}

	function supportsDynamicImport(caller) {
	  return !!(caller != null && caller.supportsDynamicImport);
	}

	function supportsExportNamespaceFrom(caller) {
	  return !!(caller != null && caller.supportsExportNamespaceFrom);
	}

	function supportsTopLevelAwait(caller) {
	  return !!(caller != null && caller.supportsTopLevelAwait);
	}

	var presetEnv = declare(function (api, opts) {
	  api.assertVersion(7);
	  var babelTargets = api.targets();

	  var _normalizeOptions = normalizeOptions$3(opts),
	      bugfixes = _normalizeOptions.bugfixes,
	      configPath = _normalizeOptions.configPath,
	      debug = _normalizeOptions.debug,
	      optionsExclude = _normalizeOptions.exclude,
	      forceAllTransforms = _normalizeOptions.forceAllTransforms,
	      ignoreBrowserslistConfig = _normalizeOptions.ignoreBrowserslistConfig,
	      optionsInclude = _normalizeOptions.include,
	      loose = _normalizeOptions.loose,
	      modules = _normalizeOptions.modules,
	      shippedProposals$1 = _normalizeOptions.shippedProposals,
	      spec = _normalizeOptions.spec,
	      optionsTargets = _normalizeOptions.targets,
	      useBuiltIns = _normalizeOptions.useBuiltIns,
	      _normalizeOptions$cor = _normalizeOptions.corejs,
	      corejs = _normalizeOptions$cor.version,
	      proposals = _normalizeOptions$cor.proposals,
	      browserslistEnv = _normalizeOptions.browserslistEnv;

	  var targets = babelTargets;

	  if (semver$4.lt(api.version, "7.13.0") || opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig) {
	    {
	      var hasUglifyTarget = false;

	      if (optionsTargets != null && optionsTargets.uglify) {
	        hasUglifyTarget = true;
	        delete optionsTargets.uglify;
	        console.warn("\nThe uglify target has been deprecated. Set the top level\noption `forceAllTransforms: true` instead.\n");
	      }
	    }
	    targets = getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv);
	  }

	  var transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
	  var include = transformIncludesAndExcludes(optionsInclude);
	  var exclude = transformIncludesAndExcludes(optionsExclude);
	  var compatData = getPluginList(shippedProposals$1, bugfixes);
	  var shouldSkipExportNamespaceFrom = modules === "auto" && (api.caller == null ? void 0 : api.caller(supportsExportNamespaceFrom)) || modules === false && !isRequired("proposal-export-namespace-from", transformTargets, {
	    compatData: compatData,
	    includes: include.plugins,
	    excludes: exclude.plugins
	  });
	  var modulesPluginNames = getModulesPluginNames({
	    modules: modules,
	    transformations: moduleTransformations,
	    shouldTransformESM: modules !== "auto" || !(api.caller != null && api.caller(supportsStaticESM)),
	    shouldTransformDynamicImport: modules !== "auto" || !(api.caller != null && api.caller(supportsDynamicImport)),
	    shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom,
	    shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
	  });
	  var pluginNames = filterItems(compatData, include.plugins, exclude.plugins, transformTargets, modulesPluginNames, getOptionSpecificExcludesFor({
	    loose: loose
	  }), shippedProposals.pluginSyntaxMap);
	  removeUnnecessaryItems(pluginNames, overlappingPlugins);
	  removeUnsupportedItems(pluginNames, api.version);
	  var polyfillPlugins = getPolyfillPlugins({
	    useBuiltIns: useBuiltIns,
	    corejs: corejs,
	    polyfillTargets: targets,
	    include: include.builtIns,
	    exclude: exclude.builtIns,
	    proposals: proposals,
	    shippedProposals: shippedProposals$1,
	    regenerator: pluginNames.has("transform-regenerator"),
	    debug: debug
	  });
	  var pluginUseBuiltIns = useBuiltIns !== false;
	  var plugins = Array.from(pluginNames).map(function (pluginName) {
	    if (pluginName === "proposal-class-properties" || pluginName === "proposal-private-methods" || pluginName === "proposal-private-property-in-object") {
	      return [getPlugin(pluginName), {
	        loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
	      }];
	    }

	    return [getPlugin(pluginName), {
	      spec: spec,
	      loose: loose,
	      useBuiltIns: pluginUseBuiltIns
	    }];
	  }).concat(polyfillPlugins);

	  if (debug) {
	    console.log("@babel/preset-env: `DEBUG` option");
	    console.log("\nUsing targets:");
	    console.log(JSON.stringify(prettifyTargets(targets), null, 2));
	    console.log("\nUsing modules transform: " + modules.toString());
	    console.log("\nUsing plugins:");
	    pluginNames.forEach(function (pluginName) {
	      logPlugin(pluginName, targets, compatData);
	    });

	    if (!useBuiltIns) {
	      console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
	    }
	  }

	  return {
	    plugins: plugins
	  };
	});

	new OptionValidator("@babel/preset-flow");
	function normalizeOptions$2(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      all = _options.all;
	  var _options2 = options,
	      allowDeclareFields = _options2.allowDeclareFields;
	  {
	    return {
	      all: all,
	      allowDeclareFields: allowDeclareFields
	    };
	  }
	}

	var presetFlow = declare(function (api, opts) {
	  api.assertVersion(7);

	  var _normalizeOptions = normalizeOptions$2(opts),
	      all = _normalizeOptions.all,
	      allowDeclareFields = _normalizeOptions.allowDeclareFields;

	  return {
	    plugins: [[transformFlowStripTypes, {
	      all: all,
	      allowDeclareFields: allowDeclareFields
	    }]]
	  };
	});

	var PURE_CALLS = new Map([["react", ["cloneElement", "createContext", "createElement", "createFactory", "createRef", "forwardRef", "isValidElement", "memo", "lazy"]], ["react-dom", ["createPortal"]]]);
	var transformReactPure = declare(function (api) {
	  api.assertVersion(7);
	  return {
	    name: "transform-react-pure-annotations",
	    visitor: {
	      CallExpression: function CallExpression(path) {
	        if (isReactCall(path)) {
	          annotateAsPure(path);
	        }
	      }
	    }
	  };
	});

	function isReactCall(path) {
	  if (!isMemberExpression$8(path.node.callee)) {
	    var callee = path.get("callee");

	    for (var _iterator = _createForOfIteratorHelperLoose(PURE_CALLS), _step; !(_step = _iterator()).done;) {
	      var _step$value = _slicedToArray$1(_step.value, 2),
	          module = _step$value[0],
	          methods = _step$value[1];

	      for (var _iterator2 = _createForOfIteratorHelperLoose(methods), _step2; !(_step2 = _iterator2()).done;) {
	        var method = _step2.value;

	        if (callee.referencesImport(module, method)) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  for (var _iterator3 = _createForOfIteratorHelperLoose(PURE_CALLS), _step3; !(_step3 = _iterator3()).done;) {
	    var _step3$value = _slicedToArray$1(_step3.value, 2),
	        _module = _step3$value[0],
	        _methods = _step3$value[1];

	    var object = path.get("callee.object");

	    if (object.referencesImport(_module, "default") || object.referencesImport(_module, "*")) {
	      for (var _iterator4 = _createForOfIteratorHelperLoose(_methods), _step4; !(_step4 = _iterator4()).done;) {
	        var _method = _step4.value;

	        if (isIdentifier$g(path.node.callee.property, {
	          name: _method
	        })) {
	          return true;
	        }
	      }

	      return false;
	    }
	  }

	  return false;
	}

	new OptionValidator("@babel/preset-react");
	function normalizeOptions$1(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  {
	    var _options = options,
	        pragma = _options.pragma,
	        pragmaFrag = _options.pragmaFrag;
	    var _options2 = options,
	        pure = _options2.pure,
	        _options2$throwIfName = _options2.throwIfNamespace,
	        throwIfNamespace = _options2$throwIfName === void 0 ? true : _options2$throwIfName,
	        _options2$runtime = _options2.runtime,
	        runtime = _options2$runtime === void 0 ? "classic" : _options2$runtime,
	        importSource = _options2.importSource,
	        useBuiltIns = _options2.useBuiltIns,
	        useSpread = _options2.useSpread;

	    if (runtime === "classic") {
	      pragma = pragma || "React.createElement";
	      pragmaFrag = pragmaFrag || "React.Fragment";
	    }

	    var development = !!options.development;
	    return {
	      development: development,
	      importSource: importSource,
	      pragma: pragma,
	      pragmaFrag: pragmaFrag,
	      pure: pure,
	      runtime: runtime,
	      throwIfNamespace: throwIfNamespace,
	      useBuiltIns: useBuiltIns,
	      useSpread: useSpread
	    };
	  }
	}

	var presetReact = declare(function (api, opts) {
	  api.assertVersion(7);

	  var _normalizeOptions = normalizeOptions$1(opts),
	      development = _normalizeOptions.development,
	      importSource = _normalizeOptions.importSource,
	      pragma = _normalizeOptions.pragma,
	      pragmaFrag = _normalizeOptions.pragmaFrag,
	      pure = _normalizeOptions.pure,
	      runtime = _normalizeOptions.runtime,
	      throwIfNamespace = _normalizeOptions.throwIfNamespace;

	  return {
	    plugins: [[development ? transformReactJSXDevelopment : transformReactJSX, {
	      importSource: importSource,
	      pragma: pragma,
	      pragmaFrag: pragmaFrag,
	      runtime: runtime,
	      throwIfNamespace: throwIfNamespace,
	      pure: pure,
	      useBuiltIns: !!opts.useBuiltIns,
	      useSpread: opts.useSpread
	    }], transformReactDisplayName, pure !== false && transformReactPure].filter(Boolean)
	  };
	});

	var v = new OptionValidator("@babel/preset-typescript");
	function normalizeOptions(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      _options$allowNamespa = _options.allowNamespaces,
	      allowNamespaces = _options$allowNamespa === void 0 ? true : _options$allowNamespa,
	      jsxPragma = _options.jsxPragma,
	      onlyRemoveTypeImports = _options.onlyRemoveTypeImports;
	  var TopLevelOptions = {
	    allExtensions: "allExtensions",
	    allowNamespaces: "allowNamespaces",
	    disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
	    isTSX: "isTSX",
	    jsxPragma: "jsxPragma",
	    jsxPragmaFrag: "jsxPragmaFrag",
	    onlyRemoveTypeImports: "onlyRemoveTypeImports",
	    optimizeConstEnums: "optimizeConstEnums"
	  };
	  var jsxPragmaFrag = v.validateStringOption(TopLevelOptions.jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");
	  var allExtensions = v.validateBooleanOption(TopLevelOptions.allExtensions, options.allExtensions, false);
	  var isTSX = v.validateBooleanOption(TopLevelOptions.isTSX, options.isTSX, false);

	  if (isTSX) {
	    v.invariant(allExtensions, "isTSX:true requires allExtensions:true");
	  }

	  var disallowAmbiguousJSXLike = v.validateBooleanOption(TopLevelOptions.disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, false);

	  if (disallowAmbiguousJSXLike) {
	    v.invariant(allExtensions, "disallowAmbiguousJSXLike:true requires allExtensions:true");
	  }

	  var optimizeConstEnums = v.validateBooleanOption(TopLevelOptions.optimizeConstEnums, options.optimizeConstEnums, false);
	  return {
	    allExtensions: allExtensions,
	    allowNamespaces: allowNamespaces,
	    disallowAmbiguousJSXLike: disallowAmbiguousJSXLike,
	    isTSX: isTSX,
	    jsxPragma: jsxPragma,
	    jsxPragmaFrag: jsxPragmaFrag,
	    onlyRemoveTypeImports: onlyRemoveTypeImports,
	    optimizeConstEnums: optimizeConstEnums
	  };
	}

	var presetTypescript = declare(function (api, opts) {
	  api.assertVersion(7);

	  var _normalizeOptions = normalizeOptions(opts),
	      allExtensions = _normalizeOptions.allExtensions,
	      allowNamespaces = _normalizeOptions.allowNamespaces,
	      disallowAmbiguousJSXLike = _normalizeOptions.disallowAmbiguousJSXLike,
	      isTSX = _normalizeOptions.isTSX,
	      jsxPragma = _normalizeOptions.jsxPragma,
	      jsxPragmaFrag = _normalizeOptions.jsxPragmaFrag,
	      onlyRemoveTypeImports = _normalizeOptions.onlyRemoveTypeImports,
	      optimizeConstEnums = _normalizeOptions.optimizeConstEnums;

	  var pluginOptions = function pluginOptions(isTSX, disallowAmbiguousJSXLike) {
	    return {
	      allowDeclareFields: opts.allowDeclareFields,
	      allowNamespaces: allowNamespaces,
	      disallowAmbiguousJSXLike: disallowAmbiguousJSXLike,
	      isTSX: isTSX,
	      jsxPragma: jsxPragma,
	      jsxPragmaFrag: jsxPragmaFrag,
	      onlyRemoveTypeImports: onlyRemoveTypeImports,
	      optimizeConstEnums: optimizeConstEnums
	    };
	  };

	  return {
	    overrides: allExtensions ? [{
	      plugins: [[transformTypeScript, pluginOptions(isTSX, disallowAmbiguousJSXLike)]]
	    }] : [{
	      test: /\.ts$/,
	      plugins: [[transformTypeScript, pluginOptions(false, false)]]
	    }, {
	      test: /\.mts$/,
	      sourceType: "module",
	      plugins: [[transformTypeScript, pluginOptions(false, true)]]
	    }, {
	      test: /\.cts$/,
	      sourceType: "script",
	      plugins: [[transformTypeScript, pluginOptions(false, true)]]
	    }, {
	      test: /\.tsx$/,
	      plugins: [[transformTypeScript, pluginOptions(true, false)]]
	    }]
	  };
	});

	var scriptTypes = ["text/jsx", "text/babel"];
	var headEl;
	var inlineScriptCount = 0;

	function transformCode(transformFn, script) {
	  var source;

	  if (script.url != null) {
	    source = script.url;
	  } else {
	    source = "Inline Babel script";
	    inlineScriptCount++;

	    if (inlineScriptCount > 1) {
	      source += " (" + inlineScriptCount + ")";
	    }
	  }

	  return transformFn(script.content, buildBabelOptions(script, source)).code;
	}

	function buildBabelOptions(script, filename) {
	  var presets = script.presets;

	  if (!presets) {
	    if (script.type === "module") {
	      presets = ["react", ["env", {
	        targets: {
	          esmodules: true
	        },
	        modules: false
	      }]];
	    } else {
	      presets = ["react", "env"];
	    }
	  }

	  return {
	    filename: filename,
	    presets: presets,
	    plugins: script.plugins || ["proposal-class-properties", "proposal-object-rest-spread", "transform-flow-strip-types"],
	    sourceMaps: "inline",
	    sourceFileName: filename
	  };
	}

	function run(transformFn, script) {
	  var scriptEl = document.createElement("script");

	  if (script.type) {
	    scriptEl.setAttribute("type", script.type);
	  }

	  scriptEl.text = transformCode(transformFn, script);
	  headEl.appendChild(scriptEl);
	}

	function load(url, successCallback, errorCallback) {
	  var xhr = new XMLHttpRequest();
	  xhr.open("GET", url, true);

	  if ("overrideMimeType" in xhr) {
	    xhr.overrideMimeType("text/plain");
	  }

	  xhr.onreadystatechange = function () {
	    if (xhr.readyState === 4) {
	      if (xhr.status === 0 || xhr.status === 200) {
	        successCallback(xhr.responseText);
	      } else {
	        errorCallback();
	        throw new Error("Could not load " + url);
	      }
	    }
	  };

	  return xhr.send(null);
	}

	function getPluginsOrPresetsFromScript(script, attributeName) {
	  var rawValue = script.getAttribute(attributeName);

	  if (rawValue === "") {
	    return [];
	  }

	  if (!rawValue) {
	    return null;
	  }

	  return rawValue.split(",").map(function (item) {
	    return item.trim();
	  });
	}

	function loadScripts(transformFn, scripts) {
	  var result = [];
	  var count = scripts.length;

	  function check() {
	    var script, i;

	    for (i = 0; i < count; i++) {
	      script = result[i];

	      if (script.loaded && !script.executed) {
	        script.executed = true;
	        run(transformFn, script);
	      } else if (!script.loaded && !script.error && !script.async) {
	        break;
	      }
	    }
	  }

	  scripts.forEach(function (script, i) {
	    var scriptData = {
	      async: script.hasAttribute("async"),
	      type: script.getAttribute("data-type"),
	      error: false,
	      executed: false,
	      plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
	      presets: getPluginsOrPresetsFromScript(script, "data-presets")
	    };

	    if (script.src) {
	      result[i] = Object.assign({}, scriptData, {
	        content: null,
	        loaded: false,
	        url: script.src
	      });
	      load(script.src, function (content) {
	        result[i].loaded = true;
	        result[i].content = content;
	        check();
	      }, function () {
	        result[i].error = true;
	        check();
	      });
	    } else {
	      result[i] = Object.assign({}, scriptData, {
	        content: script.innerHTML,
	        loaded: true,
	        url: script.getAttribute("data-module") || null
	      });
	    }
	  });
	  check();
	}

	function runScripts(transformFn, scripts) {
	  headEl = document.getElementsByTagName("head")[0];

	  if (!scripts) {
	    scripts = document.getElementsByTagName("script");
	  }

	  var jsxScripts = [];

	  for (var i = 0; i < scripts.length; i++) {
	    var script = scripts.item(i);
	    var type = script.type.split(";")[0];

	    if (scriptTypes.indexOf(type) !== -1) {
	      jsxScripts.push(script);
	    }
	  }

	  if (jsxScripts.length === 0) {
	    return;
	  }

	  console.warn("You are using the in-browser Babel transformer. Be sure to precompile " + "your scripts for production - https://babeljs.io/docs/setup/");
	  loadScripts(transformFn, jsxScripts);
	}

	var _window;

	var isArray = Array.isArray || function (arg) {
	  return Object.prototype.toString.call(arg) === "[object Array]";
	};

	function loadBuiltin(builtinTable, name) {
	  if (isArray(name) && typeof name[0] === "string") {
	    if (Object.prototype.hasOwnProperty.call(builtinTable, name[0])) {
	      return [builtinTable[name[0]]].concat(name.slice(1));
	    }

	    return;
	  } else if (typeof name === "string") {
	    return builtinTable[name];
	  }

	  return name;
	}

	function processOptions(options) {
	  var presets = (options.presets || []).map(function (presetName) {
	    var preset = loadBuiltin(availablePresets, presetName);

	    if (preset) {
	      if (isArray(preset) && typeof preset[0] === "object" && Object.prototype.hasOwnProperty.call(preset[0], "buildPreset")) {
	        preset[0] = Object.assign({}, preset[0], {
	          buildPreset: preset[0].buildPreset
	        });
	      }
	    } else {
	      throw new Error("Invalid preset specified in Babel options: \"" + presetName + "\"");
	    }

	    return preset;
	  });
	  var plugins = (options.plugins || []).map(function (pluginName) {
	    var plugin = loadBuiltin(availablePlugins, pluginName);

	    if (!plugin) {
	      throw new Error("Invalid plugin specified in Babel options: \"" + pluginName + "\"");
	    }

	    return plugin;
	  });
	  return Object.assign({
	    babelrc: false
	  }, options, {
	    presets: presets,
	    plugins: plugins
	  });
	}

	function transform(code, options) {
	  return transform$2(code, processOptions(options));
	}
	function transformFromAst(ast, code, options) {
	  return transformFromAst$1(ast, code, processOptions(options));
	}
	var availablePlugins = {};
	var availablePresets = {};
	var buildExternalHelpers = babelBuildExternalHelpers;
	function registerPlugin(name, plugin) {
	  if (Object.prototype.hasOwnProperty.call(availablePlugins, name)) {
	    console.warn("A plugin named \"" + name + "\" is already registered, it will be overridden");
	  }

	  availablePlugins[name] = plugin;
	}
	function registerPlugins(newPlugins) {
	  Object.keys(newPlugins).forEach(function (name) {
	    return registerPlugin(name, newPlugins[name]);
	  });
	}
	function registerPreset(name, preset) {
	  if (Object.prototype.hasOwnProperty.call(availablePresets, name)) {
	    if (name === "env") {
	      console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone");
	    } else {
	      console.warn("A preset named \"" + name + "\" is already registered, it will be overridden");
	    }
	  }

	  availablePresets[name] = preset;
	}
	function registerPresets(newPresets) {
	  Object.keys(newPresets).forEach(function (name) {
	    return registerPreset(name, newPresets[name]);
	  });
	}
	registerPlugins(all);
	registerPresets({
	  env: presetEnv,
	  es2015: preset2015,
	  es2016: function es2016() {
	    return {
	      plugins: [availablePlugins["transform-exponentiation-operator"]]
	    };
	  },
	  es2017: function es2017() {
	    return {
	      plugins: [availablePlugins["transform-async-to-generator"]]
	    };
	  },
	  react: presetReact,
	  "stage-0": presetStage0,
	  "stage-1": presetStage1,
	  "stage-2": presetStage2,
	  "stage-3": presetStage3,
	  "es2015-loose": {
	    presets: [[preset2015, {
	      loose: true
	    }]]
	  },
	  "es2015-no-commonjs": {
	    presets: [[preset2015, {
	      modules: false
	    }]]
	  },
	  typescript: presetTypescript,
	  flow: presetFlow
	});
	var version = "7.16.6";

	function onDOMContentLoaded() {
	  transformScriptTags();
	}

	if (typeof window !== "undefined" && (_window = window) != null && _window.addEventListener) {
	  window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
	}

	function transformScriptTags(scriptTags) {
	  runScripts(transform, scriptTags);
	}
	function disableScriptTags() {
	  window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
	}

	exports.availablePlugins = availablePlugins;
	exports.availablePresets = availablePresets;
	exports.buildExternalHelpers = buildExternalHelpers;
	exports.disableScriptTags = disableScriptTags;
	exports.registerPlugin = registerPlugin;
	exports.registerPlugins = registerPlugins;
	exports.registerPreset = registerPreset;
	exports.registerPresets = registerPresets;
	exports.transform = transform;
	exports.transformFromAst = transformFromAst;
	exports.transformScriptTags = transformScriptTags;
	exports.version = version;
	exports.babel = babel;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
